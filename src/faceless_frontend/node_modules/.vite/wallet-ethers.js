import {
  buffer_exports,
  crypto_exports,
  init_buffer,
  init_crypto,
  require_eventemitter3,
  require_nacl_fast
} from "./chunk-H7S37BHS.js";
import {
  require_sha256
} from "./chunk-DLBXY3OZ.js";
import {
  require_buffer
} from "./chunk-SLKB6ZVF.js";
import {
  require_base64_js,
  require_ieee754
} from "./chunk-QM6BGJQ6.js";
import {
  require_events
} from "./chunk-H4H4PZ46.js";
import {
  __commonJS,
  __esm,
  __export,
  __markAsModule,
  __objRest,
  __reExport,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-7T45EBAY.js";

// node_modules/eosjs/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/trees.js"(exports, module) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s6, w6) => {
      s6.pending_buf[s6.pending++] = w6 & 255;
      s6.pending_buf[s6.pending++] = w6 >>> 8 & 255;
    };
    var send_bits = (s6, value, length) => {
      if (s6.bi_valid > Buf_size - length) {
        s6.bi_buf |= value << s6.bi_valid & 65535;
        put_short(s6, s6.bi_buf);
        s6.bi_buf = value >> Buf_size - s6.bi_valid;
        s6.bi_valid += length - Buf_size;
      } else {
        s6.bi_buf |= value << s6.bi_valid & 65535;
        s6.bi_valid += length;
      }
    };
    var send_code = (s6, c5, tree) => {
      send_bits(s6, tree[c5 * 2], tree[c5 * 2 + 1]);
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s6) => {
      if (s6.bi_valid === 16) {
        put_short(s6, s6.bi_buf);
        s6.bi_buf = 0;
        s6.bi_valid = 0;
      } else if (s6.bi_valid >= 8) {
        s6.pending_buf[s6.pending++] = s6.bi_buf & 255;
        s6.bi_buf >>= 8;
        s6.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s6, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base2 = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h5;
      let n3, m5;
      let bits;
      let xbits;
      let f7;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s6.bl_count[bits] = 0;
      }
      tree[s6.heap[s6.heap_max] * 2 + 1] = 0;
      for (h5 = s6.heap_max + 1; h5 < HEAP_SIZE; h5++) {
        n3 = s6.heap[h5];
        bits = tree[tree[n3 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n3 * 2 + 1] = bits;
        if (n3 > max_code) {
          continue;
        }
        s6.bl_count[bits]++;
        xbits = 0;
        if (n3 >= base2) {
          xbits = extra[n3 - base2];
        }
        f7 = tree[n3 * 2];
        s6.opt_len += f7 * (bits + xbits);
        if (has_stree) {
          s6.static_len += f7 * (stree[n3 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s6.bl_count[bits] === 0) {
          bits--;
        }
        s6.bl_count[bits]--;
        s6.bl_count[bits + 1] += 2;
        s6.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n3 = s6.bl_count[bits];
        while (n3 !== 0) {
          m5 = s6.heap[--h5];
          if (m5 > max_code) {
            continue;
          }
          if (tree[m5 * 2 + 1] !== bits) {
            s6.opt_len += (bits - tree[m5 * 2 + 1]) * tree[m5 * 2];
            tree[m5 * 2 + 1] = bits;
          }
          n3--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n3;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n3 = 0; n3 <= max_code; n3++) {
        let len = tree[n3 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n3 * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n3;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n3 = 0; n3 < 1 << extra_lbits[code]; n3++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n3 = 0; n3 < 1 << extra_dbits[code]; n3++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n3 = 0; n3 < 1 << extra_dbits[code] - 7; n3++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n3 = 0;
      while (n3 <= 143) {
        static_ltree[n3 * 2 + 1] = 8;
        n3++;
        bl_count[8]++;
      }
      while (n3 <= 255) {
        static_ltree[n3 * 2 + 1] = 9;
        n3++;
        bl_count[9]++;
      }
      while (n3 <= 279) {
        static_ltree[n3 * 2 + 1] = 7;
        n3++;
        bl_count[7]++;
      }
      while (n3 <= 287) {
        static_ltree[n3 * 2 + 1] = 8;
        n3++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n3 = 0; n3 < D_CODES; n3++) {
        static_dtree[n3 * 2 + 1] = 5;
        static_dtree[n3 * 2] = bi_reverse(n3, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s6) => {
      let n3;
      for (n3 = 0; n3 < L_CODES; n3++) {
        s6.dyn_ltree[n3 * 2] = 0;
      }
      for (n3 = 0; n3 < D_CODES; n3++) {
        s6.dyn_dtree[n3 * 2] = 0;
      }
      for (n3 = 0; n3 < BL_CODES; n3++) {
        s6.bl_tree[n3 * 2] = 0;
      }
      s6.dyn_ltree[END_BLOCK * 2] = 1;
      s6.opt_len = s6.static_len = 0;
      s6.last_lit = s6.matches = 0;
    };
    var bi_windup = (s6) => {
      if (s6.bi_valid > 8) {
        put_short(s6, s6.bi_buf);
      } else if (s6.bi_valid > 0) {
        s6.pending_buf[s6.pending++] = s6.bi_buf;
      }
      s6.bi_buf = 0;
      s6.bi_valid = 0;
    };
    var copy_block = (s6, buf, len, header) => {
      bi_windup(s6);
      if (header) {
        put_short(s6, len);
        put_short(s6, ~len);
      }
      s6.pending_buf.set(s6.window.subarray(buf, buf + len), s6.pending);
      s6.pending += len;
    };
    var smaller = (tree, n3, m5, depth) => {
      const _n2 = n3 * 2;
      const _m2 = m5 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n3] <= depth[m5];
    };
    var pqdownheap = (s6, tree, k5) => {
      const v8 = s6.heap[k5];
      let j5 = k5 << 1;
      while (j5 <= s6.heap_len) {
        if (j5 < s6.heap_len && smaller(tree, s6.heap[j5 + 1], s6.heap[j5], s6.depth)) {
          j5++;
        }
        if (smaller(tree, v8, s6.heap[j5], s6.depth)) {
          break;
        }
        s6.heap[k5] = s6.heap[j5];
        k5 = j5;
        j5 <<= 1;
      }
      s6.heap[k5] = v8;
    };
    var compress_block = (s6, ltree, dtree) => {
      let dist;
      let lc;
      let lx = 0;
      let code;
      let extra;
      if (s6.last_lit !== 0) {
        do {
          dist = s6.pending_buf[s6.d_buf + lx * 2] << 8 | s6.pending_buf[s6.d_buf + lx * 2 + 1];
          lc = s6.pending_buf[s6.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s6, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s6, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s6, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s6, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s6, dist, extra);
            }
          }
        } while (lx < s6.last_lit);
      }
      send_code(s6, END_BLOCK, ltree);
    };
    var build_tree = (s6, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n3, m5;
      let max_code = -1;
      let node;
      s6.heap_len = 0;
      s6.heap_max = HEAP_SIZE;
      for (n3 = 0; n3 < elems; n3++) {
        if (tree[n3 * 2] !== 0) {
          s6.heap[++s6.heap_len] = max_code = n3;
          s6.depth[n3] = 0;
        } else {
          tree[n3 * 2 + 1] = 0;
        }
      }
      while (s6.heap_len < 2) {
        node = s6.heap[++s6.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s6.depth[node] = 0;
        s6.opt_len--;
        if (has_stree) {
          s6.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n3 = s6.heap_len >> 1; n3 >= 1; n3--) {
        pqdownheap(s6, tree, n3);
      }
      node = elems;
      do {
        n3 = s6.heap[1];
        s6.heap[1] = s6.heap[s6.heap_len--];
        pqdownheap(s6, tree, 1);
        m5 = s6.heap[1];
        s6.heap[--s6.heap_max] = n3;
        s6.heap[--s6.heap_max] = m5;
        tree[node * 2] = tree[n3 * 2] + tree[m5 * 2];
        s6.depth[node] = (s6.depth[n3] >= s6.depth[m5] ? s6.depth[n3] : s6.depth[m5]) + 1;
        tree[n3 * 2 + 1] = tree[m5 * 2 + 1] = node;
        s6.heap[1] = node++;
        pqdownheap(s6, tree, 1);
      } while (s6.heap_len >= 2);
      s6.heap[--s6.heap_max] = s6.heap[1];
      gen_bitlen(s6, desc);
      gen_codes(tree, max_code, s6.bl_count);
    };
    var scan_tree = (s6, tree, max_code) => {
      let n3;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n3 = 0; n3 <= max_code; n3++) {
        curlen = nextlen;
        nextlen = tree[(n3 + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          s6.bl_tree[curlen * 2] += count2;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s6.bl_tree[curlen * 2]++;
          }
          s6.bl_tree[REP_3_6 * 2]++;
        } else if (count2 <= 10) {
          s6.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s6.bl_tree[REPZ_11_138 * 2]++;
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s6, tree, max_code) => {
      let n3;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n3 = 0; n3 <= max_code; n3++) {
        curlen = nextlen;
        nextlen = tree[(n3 + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          do {
            send_code(s6, curlen, s6.bl_tree);
          } while (--count2 !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s6, curlen, s6.bl_tree);
            count2--;
          }
          send_code(s6, REP_3_6, s6.bl_tree);
          send_bits(s6, count2 - 3, 2);
        } else if (count2 <= 10) {
          send_code(s6, REPZ_3_10, s6.bl_tree);
          send_bits(s6, count2 - 3, 3);
        } else {
          send_code(s6, REPZ_11_138, s6.bl_tree);
          send_bits(s6, count2 - 11, 7);
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s6) => {
      let max_blindex;
      scan_tree(s6, s6.dyn_ltree, s6.l_desc.max_code);
      scan_tree(s6, s6.dyn_dtree, s6.d_desc.max_code);
      build_tree(s6, s6.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s6.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s6.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s6, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s6, lcodes - 257, 5);
      send_bits(s6, dcodes - 1, 5);
      send_bits(s6, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s6, s6.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s6, s6.dyn_ltree, lcodes - 1);
      send_tree(s6, s6.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s6) => {
      let black_mask = 4093624447;
      let n3;
      for (n3 = 0; n3 <= 31; n3++, black_mask >>>= 1) {
        if (black_mask & 1 && s6.dyn_ltree[n3 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s6.dyn_ltree[9 * 2] !== 0 || s6.dyn_ltree[10 * 2] !== 0 || s6.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n3 = 32; n3 < LITERALS; n3++) {
        if (s6.dyn_ltree[n3 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s6) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s6.l_desc = new TreeDesc(s6.dyn_ltree, static_l_desc);
      s6.d_desc = new TreeDesc(s6.dyn_dtree, static_d_desc);
      s6.bl_desc = new TreeDesc(s6.bl_tree, static_bl_desc);
      s6.bi_buf = 0;
      s6.bi_valid = 0;
      init_block(s6);
    };
    var _tr_stored_block = (s6, buf, stored_len, last2) => {
      send_bits(s6, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
      copy_block(s6, buf, stored_len, true);
    };
    var _tr_align = (s6) => {
      send_bits(s6, STATIC_TREES << 1, 3);
      send_code(s6, END_BLOCK, static_ltree);
      bi_flush(s6);
    };
    var _tr_flush_block = (s6, buf, stored_len, last2) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s6.level > 0) {
        if (s6.strm.data_type === Z_UNKNOWN) {
          s6.strm.data_type = detect_data_type(s6);
        }
        build_tree(s6, s6.l_desc);
        build_tree(s6, s6.d_desc);
        max_blindex = build_bl_tree(s6);
        opt_lenb = s6.opt_len + 3 + 7 >>> 3;
        static_lenb = s6.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s6, buf, stored_len, last2);
      } else if (s6.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s6, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
        compress_block(s6, static_ltree, static_dtree);
      } else {
        send_bits(s6, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
        send_all_trees(s6, s6.l_desc.max_code + 1, s6.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s6, s6.dyn_ltree, s6.dyn_dtree);
      }
      init_block(s6);
      if (last2) {
        bi_windup(s6);
      }
    };
    var _tr_tally = (s6, dist, lc) => {
      s6.pending_buf[s6.d_buf + s6.last_lit * 2] = dist >>> 8 & 255;
      s6.pending_buf[s6.d_buf + s6.last_lit * 2 + 1] = dist & 255;
      s6.pending_buf[s6.l_buf + s6.last_lit] = lc & 255;
      s6.last_lit++;
      if (dist === 0) {
        s6.dyn_ltree[lc * 2]++;
      } else {
        s6.matches++;
        dist--;
        s6.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s6.dyn_dtree[d_code(dist) * 2]++;
      }
      return s6.last_lit === s6.lit_bufsize - 1;
    };
    module.exports._tr_init = _tr_init;
    module.exports._tr_stored_block = _tr_stored_block;
    module.exports._tr_flush_block = _tr_flush_block;
    module.exports._tr_tally = _tr_tally;
    module.exports._tr_align = _tr_align;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n3 = 0;
      while (len !== 0) {
        n3 = len > 2e3 ? 2e3 : len;
        len -= n3;
        do {
          s1 = s1 + buf[pos++] | 0;
          s22 = s22 + s1 | 0;
        } while (--n3);
        s1 %= 65521;
        s22 %= 65521;
      }
      return s1 | s22 << 16 | 0;
    };
    module.exports = adler32;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var makeTable = () => {
      let c5, table = [];
      for (var n3 = 0; n3 < 256; n3++) {
        c5 = n3;
        for (var k5 = 0; k5 < 8; k5++) {
          c5 = c5 & 1 ? 3988292384 ^ c5 >>> 1 : c5 >>> 1;
        }
        table[n3] = c5;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t5 = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i5 = pos; i5 < end; i5++) {
        crc = crc >>> 8 ^ t5[(crc ^ buf[i5]) & 255];
      }
      return crc ^ -1;
    };
    module.exports = crc32;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/deflate.js"(exports, module) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f7) => {
      return (f7 << 1) - (f7 > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var HASH_ZLIB = (s6, prev, data) => (prev << s6.hash_shift ^ data) & s6.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s6 = strm.state;
      let len = s6.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s6.pending_buf.subarray(s6.pending_out, s6.pending_out + len), strm.next_out);
      strm.next_out += len;
      s6.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s6.pending -= len;
      if (s6.pending === 0) {
        s6.pending_out = 0;
      }
    };
    var flush_block_only = (s6, last2) => {
      _tr_flush_block(s6, s6.block_start >= 0 ? s6.block_start : -1, s6.strstart - s6.block_start, last2);
      s6.block_start = s6.strstart;
      flush_pending(s6.strm);
    };
    var put_byte = (s6, b4) => {
      s6.pending_buf[s6.pending++] = b4;
    };
    var putShortMSB = (s6, b4) => {
      s6.pending_buf[s6.pending++] = b4 >>> 8 & 255;
      s6.pending_buf[s6.pending++] = b4 & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s6, cur_match) => {
      let chain_length = s6.max_chain_length;
      let scan2 = s6.strstart;
      let match;
      let len;
      let best_len = s6.prev_length;
      let nice_match = s6.nice_match;
      const limit = s6.strstart > s6.w_size - MIN_LOOKAHEAD ? s6.strstart - (s6.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s6.window;
      const wmask = s6.w_mask;
      const prev = s6.prev;
      const strend = s6.strstart + MAX_MATCH;
      let scan_end1 = _win[scan2 + best_len - 1];
      let scan_end = _win[scan2 + best_len];
      if (s6.prev_length >= s6.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s6.lookahead) {
        nice_match = s6.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan2] || _win[++match] !== _win[scan2 + 1]) {
          continue;
        }
        scan2 += 2;
        match++;
        do {
        } while (_win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && scan2 < strend);
        len = MAX_MATCH - (strend - scan2);
        scan2 = strend - MAX_MATCH;
        if (len > best_len) {
          s6.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan2 + best_len - 1];
          scan_end = _win[scan2 + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s6.lookahead) {
        return best_len;
      }
      return s6.lookahead;
    };
    var fill_window = (s6) => {
      const _w_size = s6.w_size;
      let p5, n3, m5, more, str;
      do {
        more = s6.window_size - s6.lookahead - s6.strstart;
        if (s6.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s6.window.set(s6.window.subarray(_w_size, _w_size + _w_size), 0);
          s6.match_start -= _w_size;
          s6.strstart -= _w_size;
          s6.block_start -= _w_size;
          n3 = s6.hash_size;
          p5 = n3;
          do {
            m5 = s6.head[--p5];
            s6.head[p5] = m5 >= _w_size ? m5 - _w_size : 0;
          } while (--n3);
          n3 = _w_size;
          p5 = n3;
          do {
            m5 = s6.prev[--p5];
            s6.prev[p5] = m5 >= _w_size ? m5 - _w_size : 0;
          } while (--n3);
          more += _w_size;
        }
        if (s6.strm.avail_in === 0) {
          break;
        }
        n3 = read_buf(s6.strm, s6.window, s6.strstart + s6.lookahead, more);
        s6.lookahead += n3;
        if (s6.lookahead + s6.insert >= MIN_MATCH) {
          str = s6.strstart - s6.insert;
          s6.ins_h = s6.window[str];
          s6.ins_h = HASH(s6, s6.ins_h, s6.window[str + 1]);
          while (s6.insert) {
            s6.ins_h = HASH(s6, s6.ins_h, s6.window[str + MIN_MATCH - 1]);
            s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
            s6.head[s6.ins_h] = str;
            str++;
            s6.insert--;
            if (s6.lookahead + s6.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s6.lookahead < MIN_LOOKAHEAD && s6.strm.avail_in !== 0);
    };
    var deflate_stored = (s6, flush) => {
      let max_block_size = 65535;
      if (max_block_size > s6.pending_buf_size - 5) {
        max_block_size = s6.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s6.lookahead <= 1) {
          fill_window(s6);
          if (s6.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        s6.strstart += s6.lookahead;
        s6.lookahead = 0;
        const max_start = s6.block_start + max_block_size;
        if (s6.strstart === 0 || s6.strstart >= max_start) {
          s6.lookahead = s6.strstart - max_start;
          s6.strstart = max_start;
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s6.strstart - s6.block_start >= s6.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.strstart > s6.block_start) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    };
    var deflate_fast = (s6, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s6.lookahead < MIN_LOOKAHEAD) {
          fill_window(s6);
          if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s6.lookahead >= MIN_MATCH) {
          s6.ins_h = HASH(s6, s6.ins_h, s6.window[s6.strstart + MIN_MATCH - 1]);
          hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = s6.strstart;
        }
        if (hash_head !== 0 && s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD) {
          s6.match_length = longest_match(s6, hash_head);
        }
        if (s6.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s6, s6.strstart - s6.match_start, s6.match_length - MIN_MATCH);
          s6.lookahead -= s6.match_length;
          if (s6.match_length <= s6.max_lazy_match && s6.lookahead >= MIN_MATCH) {
            s6.match_length--;
            do {
              s6.strstart++;
              s6.ins_h = HASH(s6, s6.ins_h, s6.window[s6.strstart + MIN_MATCH - 1]);
              hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
              s6.head[s6.ins_h] = s6.strstart;
            } while (--s6.match_length !== 0);
            s6.strstart++;
          } else {
            s6.strstart += s6.match_length;
            s6.match_length = 0;
            s6.ins_h = s6.window[s6.strstart];
            s6.ins_h = HASH(s6, s6.ins_h, s6.window[s6.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s6, 0, s6.window[s6.strstart]);
          s6.lookahead--;
          s6.strstart++;
        }
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s6, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s6.lookahead < MIN_LOOKAHEAD) {
          fill_window(s6);
          if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s6.lookahead >= MIN_MATCH) {
          s6.ins_h = HASH(s6, s6.ins_h, s6.window[s6.strstart + MIN_MATCH - 1]);
          hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = s6.strstart;
        }
        s6.prev_length = s6.match_length;
        s6.prev_match = s6.match_start;
        s6.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s6.prev_length < s6.max_lazy_match && s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD) {
          s6.match_length = longest_match(s6, hash_head);
          if (s6.match_length <= 5 && (s6.strategy === Z_FILTERED || s6.match_length === MIN_MATCH && s6.strstart - s6.match_start > 4096)) {
            s6.match_length = MIN_MATCH - 1;
          }
        }
        if (s6.prev_length >= MIN_MATCH && s6.match_length <= s6.prev_length) {
          max_insert = s6.strstart + s6.lookahead - MIN_MATCH;
          bflush = _tr_tally(s6, s6.strstart - 1 - s6.prev_match, s6.prev_length - MIN_MATCH);
          s6.lookahead -= s6.prev_length - 1;
          s6.prev_length -= 2;
          do {
            if (++s6.strstart <= max_insert) {
              s6.ins_h = HASH(s6, s6.ins_h, s6.window[s6.strstart + MIN_MATCH - 1]);
              hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
              s6.head[s6.ins_h] = s6.strstart;
            }
          } while (--s6.prev_length !== 0);
          s6.match_available = 0;
          s6.match_length = MIN_MATCH - 1;
          s6.strstart++;
          if (bflush) {
            flush_block_only(s6, false);
            if (s6.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s6.match_available) {
          bflush = _tr_tally(s6, 0, s6.window[s6.strstart - 1]);
          if (bflush) {
            flush_block_only(s6, false);
          }
          s6.strstart++;
          s6.lookahead--;
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s6.match_available = 1;
          s6.strstart++;
          s6.lookahead--;
        }
      }
      if (s6.match_available) {
        bflush = _tr_tally(s6, 0, s6.window[s6.strstart - 1]);
        s6.match_available = 0;
      }
      s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s6, flush) => {
      let bflush;
      let prev;
      let scan2, strend;
      const _win = s6.window;
      for (; ; ) {
        if (s6.lookahead <= MAX_MATCH) {
          fill_window(s6);
          if (s6.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        s6.match_length = 0;
        if (s6.lookahead >= MIN_MATCH && s6.strstart > 0) {
          scan2 = s6.strstart - 1;
          prev = _win[scan2];
          if (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2]) {
            strend = s6.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && scan2 < strend);
            s6.match_length = MAX_MATCH - (strend - scan2);
            if (s6.match_length > s6.lookahead) {
              s6.match_length = s6.lookahead;
            }
          }
        }
        if (s6.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s6, 1, s6.match_length - MIN_MATCH);
          s6.lookahead -= s6.match_length;
          s6.strstart += s6.match_length;
          s6.match_length = 0;
        } else {
          bflush = _tr_tally(s6, 0, s6.window[s6.strstart]);
          s6.lookahead--;
          s6.strstart++;
        }
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s6, flush) => {
      let bflush;
      for (; ; ) {
        if (s6.lookahead === 0) {
          fill_window(s6);
          if (s6.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s6.match_length = 0;
        bflush = _tr_tally(s6, 0, s6.window[s6.strstart]);
        s6.lookahead--;
        s6.strstart++;
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
    var lm_init = (s6) => {
      s6.window_size = 2 * s6.w_size;
      zero(s6.head);
      s6.max_lazy_match = configuration_table[s6.level].max_lazy;
      s6.good_match = configuration_table[s6.level].good_length;
      s6.nice_match = configuration_table[s6.level].nice_length;
      s6.max_chain_length = configuration_table[s6.level].max_chain;
      s6.strstart = 0;
      s6.block_start = 0;
      s6.lookahead = 0;
      s6.insert = 0;
      s6.match_length = s6.prev_length = MIN_MATCH - 1;
      s6.match_available = 0;
      s6.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s6 = strm.state;
      s6.pending = 0;
      s6.pending_out = 0;
      if (s6.wrap < 0) {
        s6.wrap = -s6.wrap;
      }
      s6.status = s6.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s6.wrap === 2 ? 0 : 1;
      s6.last_flush = Z_NO_FLUSH;
      _tr_init(s6);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s6 = new DeflateState();
      strm.state = s6;
      s6.strm = strm;
      s6.wrap = wrap;
      s6.gzhead = null;
      s6.w_bits = windowBits;
      s6.w_size = 1 << s6.w_bits;
      s6.w_mask = s6.w_size - 1;
      s6.hash_bits = memLevel + 7;
      s6.hash_size = 1 << s6.hash_bits;
      s6.hash_mask = s6.hash_size - 1;
      s6.hash_shift = ~~((s6.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s6.window = new Uint8Array(s6.w_size * 2);
      s6.head = new Uint16Array(s6.hash_size);
      s6.prev = new Uint16Array(s6.w_size);
      s6.lit_bufsize = 1 << memLevel + 6;
      s6.pending_buf_size = s6.lit_bufsize * 4;
      s6.pending_buf = new Uint8Array(s6.pending_buf_size);
      s6.d_buf = 1 * s6.lit_bufsize;
      s6.l_buf = (1 + 2) * s6.lit_bufsize;
      s6.level = level;
      s6.strategy = strategy;
      s6.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      let beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s6 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s6.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s6.strm = strm;
      const old_flush = s6.last_flush;
      s6.last_flush = flush;
      if (s6.status === INIT_STATE) {
        if (s6.wrap === 2) {
          strm.adler = 0;
          put_byte(s6, 31);
          put_byte(s6, 139);
          put_byte(s6, 8);
          if (!s6.gzhead) {
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(s6, s6.level === 9 ? 2 : s6.strategy >= Z_HUFFMAN_ONLY || s6.level < 2 ? 4 : 0);
            put_byte(s6, OS_CODE);
            s6.status = BUSY_STATE;
          } else {
            put_byte(s6, (s6.gzhead.text ? 1 : 0) + (s6.gzhead.hcrc ? 2 : 0) + (!s6.gzhead.extra ? 0 : 4) + (!s6.gzhead.name ? 0 : 8) + (!s6.gzhead.comment ? 0 : 16));
            put_byte(s6, s6.gzhead.time & 255);
            put_byte(s6, s6.gzhead.time >> 8 & 255);
            put_byte(s6, s6.gzhead.time >> 16 & 255);
            put_byte(s6, s6.gzhead.time >> 24 & 255);
            put_byte(s6, s6.level === 9 ? 2 : s6.strategy >= Z_HUFFMAN_ONLY || s6.level < 2 ? 4 : 0);
            put_byte(s6, s6.gzhead.os & 255);
            if (s6.gzhead.extra && s6.gzhead.extra.length) {
              put_byte(s6, s6.gzhead.extra.length & 255);
              put_byte(s6, s6.gzhead.extra.length >> 8 & 255);
            }
            if (s6.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending, 0);
            }
            s6.gzindex = 0;
            s6.status = EXTRA_STATE;
          }
        } else {
          let header = Z_DEFLATED + (s6.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s6.strategy >= Z_HUFFMAN_ONLY || s6.level < 2) {
            level_flags = 0;
          } else if (s6.level < 6) {
            level_flags = 1;
          } else if (s6.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s6.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s6.status = BUSY_STATE;
          putShortMSB(s6, header);
          if (s6.strstart !== 0) {
            putShortMSB(s6, strm.adler >>> 16);
            putShortMSB(s6, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s6.status === EXTRA_STATE) {
        if (s6.gzhead.extra) {
          beg = s6.pending;
          while (s6.gzindex < (s6.gzhead.extra.length & 65535)) {
            if (s6.pending === s6.pending_buf_size) {
              if (s6.gzhead.hcrc && s6.pending > beg) {
                strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s6.pending;
              if (s6.pending === s6.pending_buf_size) {
                break;
              }
            }
            put_byte(s6, s6.gzhead.extra[s6.gzindex] & 255);
            s6.gzindex++;
          }
          if (s6.gzhead.hcrc && s6.pending > beg) {
            strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
          }
          if (s6.gzindex === s6.gzhead.extra.length) {
            s6.gzindex = 0;
            s6.status = NAME_STATE;
          }
        } else {
          s6.status = NAME_STATE;
        }
      }
      if (s6.status === NAME_STATE) {
        if (s6.gzhead.name) {
          beg = s6.pending;
          do {
            if (s6.pending === s6.pending_buf_size) {
              if (s6.gzhead.hcrc && s6.pending > beg) {
                strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s6.pending;
              if (s6.pending === s6.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s6.gzindex < s6.gzhead.name.length) {
              val = s6.gzhead.name.charCodeAt(s6.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s6, val);
          } while (val !== 0);
          if (s6.gzhead.hcrc && s6.pending > beg) {
            strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
          }
          if (val === 0) {
            s6.gzindex = 0;
            s6.status = COMMENT_STATE;
          }
        } else {
          s6.status = COMMENT_STATE;
        }
      }
      if (s6.status === COMMENT_STATE) {
        if (s6.gzhead.comment) {
          beg = s6.pending;
          do {
            if (s6.pending === s6.pending_buf_size) {
              if (s6.gzhead.hcrc && s6.pending > beg) {
                strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s6.pending;
              if (s6.pending === s6.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s6.gzindex < s6.gzhead.comment.length) {
              val = s6.gzhead.comment.charCodeAt(s6.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s6, val);
          } while (val !== 0);
          if (s6.gzhead.hcrc && s6.pending > beg) {
            strm.adler = crc32(strm.adler, s6.pending_buf, s6.pending - beg, beg);
          }
          if (val === 0) {
            s6.status = HCRC_STATE;
          }
        } else {
          s6.status = HCRC_STATE;
        }
      }
      if (s6.status === HCRC_STATE) {
        if (s6.gzhead.hcrc) {
          if (s6.pending + 2 > s6.pending_buf_size) {
            flush_pending(strm);
          }
          if (s6.pending + 2 <= s6.pending_buf_size) {
            put_byte(s6, strm.adler & 255);
            put_byte(s6, strm.adler >> 8 & 255);
            strm.adler = 0;
            s6.status = BUSY_STATE;
          }
        } else {
          s6.status = BUSY_STATE;
        }
      }
      if (s6.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s6.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s6.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s6.lookahead !== 0 || flush !== Z_NO_FLUSH && s6.status !== FINISH_STATE) {
        let bstate = s6.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s6, flush) : s6.strategy === Z_RLE ? deflate_rle(s6, flush) : configuration_table[s6.level].func(s6, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s6.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s6.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s6);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s6, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s6.head);
              if (s6.lookahead === 0) {
                s6.strstart = 0;
                s6.block_start = 0;
                s6.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s6.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s6.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s6.wrap === 2) {
        put_byte(s6, strm.adler & 255);
        put_byte(s6, strm.adler >> 8 & 255);
        put_byte(s6, strm.adler >> 16 & 255);
        put_byte(s6, strm.adler >> 24 & 255);
        put_byte(s6, strm.total_in & 255);
        put_byte(s6, strm.total_in >> 8 & 255);
        put_byte(s6, strm.total_in >> 16 & 255);
        put_byte(s6, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s6, strm.adler >>> 16);
        putShortMSB(s6, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s6.wrap > 0) {
        s6.wrap = -s6.wrap;
      }
      return s6.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const s6 = strm.state;
      const wrap = s6.wrap;
      if (wrap === 2 || wrap === 1 && s6.status !== INIT_STATE || s6.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s6.wrap = 0;
      if (dictLength >= s6.w_size) {
        if (wrap === 0) {
          zero(s6.head);
          s6.strstart = 0;
          s6.block_start = 0;
          s6.insert = 0;
        }
        let tmpDict = new Uint8Array(s6.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s6.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s6.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s6);
      while (s6.lookahead >= MIN_MATCH) {
        let str = s6.strstart;
        let n3 = s6.lookahead - (MIN_MATCH - 1);
        do {
          s6.ins_h = HASH(s6, s6.ins_h, s6.window[str + MIN_MATCH - 1]);
          s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = str;
          str++;
        } while (--n3);
        s6.strstart = str;
        s6.lookahead = MIN_MATCH - 1;
        fill_window(s6);
      }
      s6.strstart += s6.lookahead;
      s6.block_start = s6.strstart;
      s6.insert = s6.lookahead;
      s6.lookahead = 0;
      s6.match_length = s6.prev_length = MIN_MATCH - 1;
      s6.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s6.wrap = wrap;
      return Z_OK;
    };
    module.exports.deflateInit = deflateInit;
    module.exports.deflateInit2 = deflateInit2;
    module.exports.deflateReset = deflateReset;
    module.exports.deflateResetKeep = deflateResetKeep;
    module.exports.deflateSetHeader = deflateSetHeader;
    module.exports.deflate = deflate;
    module.exports.deflateEnd = deflateEnd;
    module.exports.deflateSetDictionary = deflateSetDictionary;
    module.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/eosjs/node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/utils/common.js"(exports, module) {
    "use strict";
    var _has = (obj, key2) => {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    };
    module.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p5 in source) {
          if (_has(source, p5)) {
            obj[p5] = source[p5];
          }
        }
      }
      return obj;
    };
    module.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i5 = 0, l5 = chunks.length; i5 < l5; i5++) {
        len += chunks[i5].length;
      }
      const result = new Uint8Array(len);
      for (let i5 = 0, pos = 0, l5 = chunks.length; i5 < l5; i5++) {
        let chunk = chunks[i5];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/utils/strings.js"(exports, module) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q5 = 0; q5 < 256; q5++) {
      _utf8len[q5] = q5 >= 252 ? 6 : q5 >= 248 ? 5 : q5 >= 240 ? 4 : q5 >= 224 ? 3 : q5 >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module.exports.string2buf = (str) => {
      let buf, c5, c22, m_pos, i5, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c5 = str.charCodeAt(m_pos);
        if ((c5 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c5 = 65536 + (c5 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c5 < 128 ? 1 : c5 < 2048 ? 2 : c5 < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i5 = 0, m_pos = 0; i5 < buf_len; m_pos++) {
        c5 = str.charCodeAt(m_pos);
        if ((c5 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c5 = 65536 + (c5 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c5 < 128) {
          buf[i5++] = c5;
        } else if (c5 < 2048) {
          buf[i5++] = 192 | c5 >>> 6;
          buf[i5++] = 128 | c5 & 63;
        } else if (c5 < 65536) {
          buf[i5++] = 224 | c5 >>> 12;
          buf[i5++] = 128 | c5 >>> 6 & 63;
          buf[i5++] = 128 | c5 & 63;
        } else {
          buf[i5++] = 240 | c5 >>> 18;
          buf[i5++] = 128 | c5 >>> 12 & 63;
          buf[i5++] = 128 | c5 >>> 6 & 63;
          buf[i5++] = 128 | c5 & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i5 = 0; i5 < len; i5++) {
        result += String.fromCharCode(buf[i5]);
      }
      return result;
    };
    module.exports.buf2string = (buf, max2) => {
      let i5, out;
      const len = max2 || buf.length;
      const utf16buf = new Array(len * 2);
      for (out = 0, i5 = 0; i5 < len; ) {
        let c5 = buf[i5++];
        if (c5 < 128) {
          utf16buf[out++] = c5;
          continue;
        }
        let c_len = _utf8len[c5];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i5 += c_len - 1;
          continue;
        }
        c5 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i5 < len) {
          c5 = c5 << 6 | buf[i5++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c5 < 65536) {
          utf16buf[out++] = c5;
        } else {
          c5 -= 65536;
          utf16buf[out++] = 55296 | c5 >> 10 & 1023;
          utf16buf[out++] = 56320 | c5 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module.exports.utf8border = (buf, max2) => {
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      let pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/eosjs/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/deflate.js"(exports, module) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils2 = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString2 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants();
    function Deflate(options) {
      this.options = utils2.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils2.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.constants = require_constants();
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      let _in;
      let last2;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from2;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last2 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from2 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from2 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from2 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from2 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from2++];
                          output[_out++] = from_source[from2++];
                          output[_out++] = from_source[from2++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from2++];
                          if (len > 1) {
                            output[_out++] = from_source[from2++];
                          }
                        }
                      } else {
                        from2 = _out - dist;
                        do {
                          output[_out++] = output[from2++];
                          output[_out++] = output[from2++];
                          output[_out++] = output[from2++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from2++];
                          if (len > 1) {
                            output[_out++] = output[from2++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last2 && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min2 = 0, max2 = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask2;
      let next;
      let base2 = null;
      let base_index = 0;
      let end;
      const count2 = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let extra_index = 0;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count2[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count2[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count2[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count2[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count2[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type2 === CODES || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count2[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type2 === CODES) {
        base2 = extra = work;
        end = 19;
      } else if (type2 === LENS) {
        base2 = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base2 = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask2 = used - 1;
      if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base2[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count2[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask2) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count2[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask2;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module.exports = inflate_table;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/inflate.js"(exports, module) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants();
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q5) => {
      return (q5 >>> 24 & 255) + (q5 >>> 8 & 65280) + ((q5 & 65280) << 8) + ((q5 & 255) << 24);
    };
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.window = null;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from2;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n3;
      const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(input.subarray(next, next + copy), len);
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n3 = here_bits + 2;
                    while (bits < n3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n3 = here_bits + 3;
                    while (bits < n3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n3 = here_bits + 7;
                    while (bits < n3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n3 = state.extra;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n3 = state.extra;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from2 = state.wsize - copy;
                } else {
                  from2 = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from2 = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from2++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module.exports.inflateReset = inflateReset;
    module.exports.inflateReset2 = inflateReset2;
    module.exports.inflateResetKeep = inflateResetKeep;
    module.exports.inflateInit = inflateInit;
    module.exports.inflateInit2 = inflateInit2;
    module.exports.inflate = inflate;
    module.exports.inflateEnd = inflateEnd;
    module.exports.inflateGetHeader = inflateGetHeader;
    module.exports.inflateSetDictionary = inflateSetDictionary;
    module.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/eosjs/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/inflate.js"(exports, module) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils2 = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString2 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants();
    function Inflate(options) {
      this.options = utils2.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = inflate;
    module.exports.constants = require_constants();
  }
});

// node_modules/eosjs/node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/eosjs/node_modules/pako/index.js"(exports, module) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants();
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = ungzip;
    module.exports.constants = constants;
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert5;
    function assert5(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert5.equal = function assertEqual3(l5, r6, msg) {
      if (l5 != r6)
        throw new Error(msg || "Assertion failed: " + l5 + " != " + r6);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert5 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    exports.inherits = inherits2;
    function isSurrogatePair2(msg, i5) {
      if ((msg.charCodeAt(i5) & 64512) !== 55296) {
        return false;
      }
      if (i5 < 0 || i5 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i5 + 1) & 64512) === 56320;
    }
    function toArray3(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p5 = 0;
          for (var i5 = 0; i5 < msg.length; i5++) {
            var c5 = msg.charCodeAt(i5);
            if (c5 < 128) {
              res[p5++] = c5;
            } else if (c5 < 2048) {
              res[p5++] = c5 >> 6 | 192;
              res[p5++] = c5 & 63 | 128;
            } else if (isSurrogatePair2(msg, i5)) {
              c5 = 65536 + ((c5 & 1023) << 10) + (msg.charCodeAt(++i5) & 1023);
              res[p5++] = c5 >> 18 | 240;
              res[p5++] = c5 >> 12 & 63 | 128;
              res[p5++] = c5 >> 6 & 63 | 128;
              res[p5++] = c5 & 63 | 128;
            } else {
              res[p5++] = c5 >> 12 | 224;
              res[p5++] = c5 >> 6 & 63 | 128;
              res[p5++] = c5 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i5 = 0; i5 < msg.length; i5 += 2)
            res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
        }
      } else {
        for (i5 = 0; i5 < msg.length; i5++)
          res[i5] = msg[i5] | 0;
      }
      return res;
    }
    exports.toArray = toArray3;
    function toHex3(msg) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++)
        res += zero22(msg[i5].toString(16));
      return res;
    }
    exports.toHex = toHex3;
    function htonl2(w6) {
      var res = w6 >>> 24 | w6 >>> 8 & 65280 | w6 << 8 & 16711680 | (w6 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl2;
    function toHex322(msg, endian) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++) {
        var w6 = msg[i5];
        if (endian === "little")
          w6 = htonl2(w6);
        res += zero82(w6.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex322;
    function zero22(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero22;
    function zero82(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero82;
    function join322(msg, start, end, endian) {
      var len = end - start;
      assert5(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i5 = 0, k5 = start; i5 < res.length; i5++, k5 += 4) {
        var w6;
        if (endian === "big")
          w6 = msg[k5] << 24 | msg[k5 + 1] << 16 | msg[k5 + 2] << 8 | msg[k5 + 3];
        else
          w6 = msg[k5 + 3] << 24 | msg[k5 + 2] << 16 | msg[k5 + 1] << 8 | msg[k5];
        res[i5] = w6 >>> 0;
      }
      return res;
    }
    exports.join32 = join322;
    function split322(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i5 = 0, k5 = 0; i5 < msg.length; i5++, k5 += 4) {
        var m5 = msg[i5];
        if (endian === "big") {
          res[k5] = m5 >>> 24;
          res[k5 + 1] = m5 >>> 16 & 255;
          res[k5 + 2] = m5 >>> 8 & 255;
          res[k5 + 3] = m5 & 255;
        } else {
          res[k5 + 3] = m5 >>> 24;
          res[k5 + 2] = m5 >>> 16 & 255;
          res[k5 + 1] = m5 >>> 8 & 255;
          res[k5] = m5 & 255;
        }
      }
      return res;
    }
    exports.split32 = split322;
    function rotr322(w6, b4) {
      return w6 >>> b4 | w6 << 32 - b4;
    }
    exports.rotr32 = rotr322;
    function rotl322(w6, b4) {
      return w6 << b4 | w6 >>> 32 - b4;
    }
    exports.rotl32 = rotl322;
    function sum322(a5, b4) {
      return a5 + b4 >>> 0;
    }
    exports.sum32 = sum322;
    function sum32_32(a5, b4, c5) {
      return a5 + b4 + c5 >>> 0;
    }
    exports.sum32_3 = sum32_32;
    function sum32_42(a5, b4, c5, d5) {
      return a5 + b4 + c5 + d5 >>> 0;
    }
    exports.sum32_4 = sum32_42;
    function sum32_52(a5, b4, c5, d5, e5) {
      return a5 + b4 + c5 + d5 + e5 >>> 0;
    }
    exports.sum32_5 = sum32_52;
    function sum642(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum642;
    function sum64_hi2(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi2;
    function sum64_lo2(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo2;
    function sum64_4_hi2(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi2;
    function sum64_4_lo2(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo2;
    function sum64_5_hi2(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi2;
    function sum64_5_lo2(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo2;
    function rotr64_hi2(ah, al, num) {
      var r6 = al << 32 - num | ah >>> num;
      return r6 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi2;
    function rotr64_lo2(ah, al, num) {
      var r6 = ah << 32 - num | al >>> num;
      return r6 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo2;
    function shr64_hi2(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi2;
    function shr64_lo2(ah, al, num) {
      var r6 = ah << 32 - num | al >>> num;
      return r6 >>> 0;
    }
    exports.shr64_lo = shr64_lo2;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils2 = require_utils();
    var assert5 = require_minimalistic_assert();
    function BlockHash2() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash2;
    BlockHash2.prototype.update = function update5(msg, enc) {
      msg = utils2.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r6 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r6, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils2.join32(msg, 0, msg.length - r6, this.endian);
        for (var i5 = 0; i5 < msg.length; i5 += this._delta32)
          this._update(msg, i5, i5 + this._delta32);
      }
      return this;
    };
    BlockHash2.prototype.digest = function digest9(enc) {
      this.update(this._pad());
      assert5(this.pending === null);
      return this._digest(enc);
    };
    BlockHash2.prototype._pad = function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k5 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k5 + this.padLength);
      res[0] = 128;
      for (var i5 = 1; i5 < k5; i5++)
        res[i5] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t5 = 8; t5 < this.padLength; t5++)
          res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = len >>> 24 & 255;
        res[i5++] = len >>> 16 & 255;
        res[i5++] = len >>> 8 & 255;
        res[i5++] = len & 255;
      } else {
        res[i5++] = len & 255;
        res[i5++] = len >>> 8 & 255;
        res[i5++] = len >>> 16 & 255;
        res[i5++] = len >>> 24 & 255;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        for (t5 = 8; t5 < this.padLength; t5++)
          res[i5++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils2 = require_utils();
    var rotr322 = utils2.rotr32;
    function ft_12(s6, x5, y5, z4) {
      if (s6 === 0)
        return ch322(x5, y5, z4);
      if (s6 === 1 || s6 === 3)
        return p322(x5, y5, z4);
      if (s6 === 2)
        return maj322(x5, y5, z4);
    }
    exports.ft_1 = ft_12;
    function ch322(x5, y5, z4) {
      return x5 & y5 ^ ~x5 & z4;
    }
    exports.ch32 = ch322;
    function maj322(x5, y5, z4) {
      return x5 & y5 ^ x5 & z4 ^ y5 & z4;
    }
    exports.maj32 = maj322;
    function p322(x5, y5, z4) {
      return x5 ^ y5 ^ z4;
    }
    exports.p32 = p322;
    function s0_2562(x5) {
      return rotr322(x5, 2) ^ rotr322(x5, 13) ^ rotr322(x5, 22);
    }
    exports.s0_256 = s0_2562;
    function s1_2562(x5) {
      return rotr322(x5, 6) ^ rotr322(x5, 11) ^ rotr322(x5, 25);
    }
    exports.s1_256 = s1_2562;
    function g0_2562(x5) {
      return rotr322(x5, 7) ^ rotr322(x5, 18) ^ x5 >>> 3;
    }
    exports.g0_256 = g0_2562;
    function g1_2562(x5) {
      return rotr322(x5, 17) ^ rotr322(x5, 19) ^ x5 >>> 10;
    }
    exports.g1_256 = g1_2562;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    var common2 = require_common2();
    var shaCommon2 = require_common3();
    var rotl322 = utils2.rotl32;
    var sum322 = utils2.sum32;
    var sum32_52 = utils2.sum32_5;
    var ft_12 = shaCommon2.ft_1;
    var BlockHash2 = common2.BlockHash;
    var sha1_K2 = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA12() {
      if (!(this instanceof SHA12))
        return new SHA12();
      BlockHash2.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils2.inherits(SHA12, BlockHash2);
    module.exports = SHA12;
    SHA12.blockSize = 512;
    SHA12.outSize = 160;
    SHA12.hmacStrength = 80;
    SHA12.padLength = 64;
    SHA12.prototype._update = function _update4(msg, start) {
      var W2 = this.W;
      for (var i5 = 0; i5 < 16; i5++)
        W2[i5] = msg[start + i5];
      for (; i5 < W2.length; i5++)
        W2[i5] = rotl322(W2[i5 - 3] ^ W2[i5 - 8] ^ W2[i5 - 14] ^ W2[i5 - 16], 1);
      var a5 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d5 = this.h[3];
      var e5 = this.h[4];
      for (i5 = 0; i5 < W2.length; i5++) {
        var s6 = ~~(i5 / 20);
        var t5 = sum32_52(rotl322(a5, 5), ft_12(s6, b4, c5, d5), e5, W2[i5], sha1_K2[s6]);
        e5 = d5;
        d5 = c5;
        c5 = rotl322(b4, 30);
        b4 = a5;
        a5 = t5;
      }
      this.h[0] = sum322(this.h[0], a5);
      this.h[1] = sum322(this.h[1], b4);
      this.h[2] = sum322(this.h[2], c5);
      this.h[3] = sum322(this.h[3], d5);
      this.h[4] = sum322(this.h[4], e5);
    };
    SHA12.prototype._digest = function digest9(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "big");
      else
        return utils2.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    var common2 = require_common2();
    var shaCommon2 = require_common3();
    var assert5 = require_minimalistic_assert();
    var sum322 = utils2.sum32;
    var sum32_42 = utils2.sum32_4;
    var sum32_52 = utils2.sum32_5;
    var ch322 = shaCommon2.ch32;
    var maj322 = shaCommon2.maj32;
    var s0_2562 = shaCommon2.s0_256;
    var s1_2562 = shaCommon2.s1_256;
    var g0_2562 = shaCommon2.g0_256;
    var g1_2562 = shaCommon2.g1_256;
    var BlockHash2 = common2.BlockHash;
    var sha256_K2 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA2562() {
      if (!(this instanceof SHA2562))
        return new SHA2562();
      BlockHash2.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K2;
      this.W = new Array(64);
    }
    utils2.inherits(SHA2562, BlockHash2);
    module.exports = SHA2562;
    SHA2562.blockSize = 512;
    SHA2562.outSize = 256;
    SHA2562.hmacStrength = 192;
    SHA2562.padLength = 64;
    SHA2562.prototype._update = function _update4(msg, start) {
      var W2 = this.W;
      for (var i5 = 0; i5 < 16; i5++)
        W2[i5] = msg[start + i5];
      for (; i5 < W2.length; i5++)
        W2[i5] = sum32_42(g1_2562(W2[i5 - 2]), W2[i5 - 7], g0_2562(W2[i5 - 15]), W2[i5 - 16]);
      var a5 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d5 = this.h[3];
      var e5 = this.h[4];
      var f7 = this.h[5];
      var g5 = this.h[6];
      var h5 = this.h[7];
      assert5(this.k.length === W2.length);
      for (i5 = 0; i5 < W2.length; i5++) {
        var T1 = sum32_52(h5, s1_2562(e5), ch322(e5, f7, g5), this.k[i5], W2[i5]);
        var T22 = sum322(s0_2562(a5), maj322(a5, b4, c5));
        h5 = g5;
        g5 = f7;
        f7 = e5;
        e5 = sum322(d5, T1);
        d5 = c5;
        c5 = b4;
        b4 = a5;
        a5 = sum322(T1, T22);
      }
      this.h[0] = sum322(this.h[0], a5);
      this.h[1] = sum322(this.h[1], b4);
      this.h[2] = sum322(this.h[2], c5);
      this.h[3] = sum322(this.h[3], d5);
      this.h[4] = sum322(this.h[4], e5);
      this.h[5] = sum322(this.h[5], f7);
      this.h[6] = sum322(this.h[6], g5);
      this.h[7] = sum322(this.h[7], h5);
    };
    SHA2562.prototype._digest = function digest9(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "big");
      else
        return utils2.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    var SHA2562 = require__2();
    function SHA2242() {
      if (!(this instanceof SHA2242))
        return new SHA2242();
      SHA2562.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils2.inherits(SHA2242, SHA2562);
    module.exports = SHA2242;
    SHA2242.blockSize = 512;
    SHA2242.outSize = 224;
    SHA2242.hmacStrength = 192;
    SHA2242.padLength = 64;
    SHA2242.prototype._digest = function digest9(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h.slice(0, 7), "big");
      else
        return utils2.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    var common2 = require_common2();
    var assert5 = require_minimalistic_assert();
    var rotr64_hi2 = utils2.rotr64_hi;
    var rotr64_lo2 = utils2.rotr64_lo;
    var shr64_hi2 = utils2.shr64_hi;
    var shr64_lo2 = utils2.shr64_lo;
    var sum642 = utils2.sum64;
    var sum64_hi2 = utils2.sum64_hi;
    var sum64_lo2 = utils2.sum64_lo;
    var sum64_4_hi2 = utils2.sum64_4_hi;
    var sum64_4_lo2 = utils2.sum64_4_lo;
    var sum64_5_hi2 = utils2.sum64_5_hi;
    var sum64_5_lo2 = utils2.sum64_5_lo;
    var BlockHash2 = common2.BlockHash;
    var sha512_K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA5122() {
      if (!(this instanceof SHA5122))
        return new SHA5122();
      BlockHash2.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K2;
      this.W = new Array(160);
    }
    utils2.inherits(SHA5122, BlockHash2);
    module.exports = SHA5122;
    SHA5122.blockSize = 1024;
    SHA5122.outSize = 512;
    SHA5122.hmacStrength = 192;
    SHA5122.padLength = 128;
    SHA5122.prototype._prepareBlock = function _prepareBlock2(msg, start) {
      var W2 = this.W;
      for (var i5 = 0; i5 < 32; i5++)
        W2[i5] = msg[start + i5];
      for (; i5 < W2.length; i5 += 2) {
        var c0_hi = g1_512_hi2(W2[i5 - 4], W2[i5 - 3]);
        var c0_lo = g1_512_lo2(W2[i5 - 4], W2[i5 - 3]);
        var c1_hi = W2[i5 - 14];
        var c1_lo = W2[i5 - 13];
        var c2_hi = g0_512_hi2(W2[i5 - 30], W2[i5 - 29]);
        var c2_lo = g0_512_lo2(W2[i5 - 30], W2[i5 - 29]);
        var c3_hi = W2[i5 - 32];
        var c3_lo = W2[i5 - 31];
        W2[i5] = sum64_4_hi2(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W2[i5 + 1] = sum64_4_lo2(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      }
    };
    SHA5122.prototype._update = function _update4(msg, start) {
      this._prepareBlock(msg, start);
      var W2 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert5(this.k.length === W2.length);
      for (var i5 = 0; i5 < W2.length; i5 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi2(eh, el);
        var c1_lo = s1_512_lo2(eh, el);
        var c2_hi = ch64_hi2(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo2(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i5];
        var c3_lo = this.k[i5 + 1];
        var c4_hi = W2[i5];
        var c4_lo = W2[i5 + 1];
        var T1_hi = sum64_5_hi2(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo2(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi2(ah, al);
        c0_lo = s0_512_lo2(ah, al);
        c1_hi = maj64_hi2(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo2(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi2(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo2(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi2(dh, dl, T1_hi, T1_lo);
        el = sum64_lo2(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi2(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo2(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum642(this.h, 0, ah, al);
      sum642(this.h, 2, bh, bl);
      sum642(this.h, 4, ch, cl);
      sum642(this.h, 6, dh, dl);
      sum642(this.h, 8, eh, el);
      sum642(this.h, 10, fh, fl);
      sum642(this.h, 12, gh, gl);
      sum642(this.h, 14, hh, hl);
    };
    SHA5122.prototype._digest = function digest9(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "big");
      else
        return utils2.split32(this.h, "big");
    };
    function ch64_hi2(xh, xl, yh, yl, zh) {
      var r6 = xh & yh ^ ~xh & zh;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function ch64_lo2(xh, xl, yh, yl, zh, zl) {
      var r6 = xl & yl ^ ~xl & zl;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function maj64_hi2(xh, xl, yh, yl, zh) {
      var r6 = xh & yh ^ xh & zh ^ yh & zh;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function maj64_lo2(xh, xl, yh, yl, zh, zl) {
      var r6 = xl & yl ^ xl & zl ^ yl & zl;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s0_512_hi2(xh, xl) {
      var c0_hi = rotr64_hi2(xh, xl, 28);
      var c1_hi = rotr64_hi2(xl, xh, 2);
      var c2_hi = rotr64_hi2(xl, xh, 7);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s0_512_lo2(xh, xl) {
      var c0_lo = rotr64_lo2(xh, xl, 28);
      var c1_lo = rotr64_lo2(xl, xh, 2);
      var c2_lo = rotr64_lo2(xl, xh, 7);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s1_512_hi2(xh, xl) {
      var c0_hi = rotr64_hi2(xh, xl, 14);
      var c1_hi = rotr64_hi2(xh, xl, 18);
      var c2_hi = rotr64_hi2(xl, xh, 9);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s1_512_lo2(xh, xl) {
      var c0_lo = rotr64_lo2(xh, xl, 14);
      var c1_lo = rotr64_lo2(xh, xl, 18);
      var c2_lo = rotr64_lo2(xl, xh, 9);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g0_512_hi2(xh, xl) {
      var c0_hi = rotr64_hi2(xh, xl, 1);
      var c1_hi = rotr64_hi2(xh, xl, 8);
      var c2_hi = shr64_hi2(xh, xl, 7);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g0_512_lo2(xh, xl) {
      var c0_lo = rotr64_lo2(xh, xl, 1);
      var c1_lo = rotr64_lo2(xh, xl, 8);
      var c2_lo = shr64_lo2(xh, xl, 7);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g1_512_hi2(xh, xl) {
      var c0_hi = rotr64_hi2(xh, xl, 19);
      var c1_hi = rotr64_hi2(xl, xh, 29);
      var c2_hi = shr64_hi2(xh, xl, 6);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g1_512_lo2(xh, xl) {
      var c0_lo = rotr64_lo2(xh, xl, 19);
      var c1_lo = rotr64_lo2(xl, xh, 29);
      var c2_lo = shr64_lo2(xh, xl, 6);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    var SHA5122 = require__4();
    function SHA3842() {
      if (!(this instanceof SHA3842))
        return new SHA3842();
      SHA5122.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils2.inherits(SHA3842, SHA5122);
    module.exports = SHA3842;
    SHA3842.blockSize = 1024;
    SHA3842.outSize = 384;
    SHA3842.hmacStrength = 192;
    SHA3842.padLength = 128;
    SHA3842.prototype._digest = function digest9(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h.slice(0, 12), "big");
      else
        return utils2.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils2 = require_utils();
    var common2 = require_common2();
    var rotl322 = utils2.rotl32;
    var sum322 = utils2.sum32;
    var sum32_32 = utils2.sum32_3;
    var sum32_42 = utils2.sum32_4;
    var BlockHash2 = common2.BlockHash;
    function RIPEMD1602() {
      if (!(this instanceof RIPEMD1602))
        return new RIPEMD1602();
      BlockHash2.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils2.inherits(RIPEMD1602, BlockHash2);
    exports.ripemd160 = RIPEMD1602;
    RIPEMD1602.blockSize = 512;
    RIPEMD1602.outSize = 160;
    RIPEMD1602.hmacStrength = 192;
    RIPEMD1602.padLength = 64;
    RIPEMD1602.prototype._update = function update5(msg, start) {
      var A6 = this.h[0];
      var B3 = this.h[1];
      var C4 = this.h[2];
      var D4 = this.h[3];
      var E4 = this.h[4];
      var Ah = A6;
      var Bh = B3;
      var Ch = C4;
      var Dh = D4;
      var Eh = E4;
      for (var j5 = 0; j5 < 80; j5++) {
        var T6 = sum322(rotl322(sum32_42(A6, f7(j5, B3, C4, D4), msg[r6[j5] + start], K3(j5)), s6[j5]), E4);
        A6 = E4;
        E4 = D4;
        D4 = rotl322(C4, 10);
        C4 = B3;
        B3 = T6;
        T6 = sum322(rotl322(sum32_42(Ah, f7(79 - j5, Bh, Ch, Dh), msg[rh2[j5] + start], Kh2(j5)), sh2[j5]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl322(Ch, 10);
        Ch = Bh;
        Bh = T6;
      }
      T6 = sum32_32(this.h[1], C4, Dh);
      this.h[1] = sum32_32(this.h[2], D4, Eh);
      this.h[2] = sum32_32(this.h[3], E4, Ah);
      this.h[3] = sum32_32(this.h[4], A6, Bh);
      this.h[4] = sum32_32(this.h[0], B3, Ch);
      this.h[0] = T6;
    };
    RIPEMD1602.prototype._digest = function digest9(enc) {
      if (enc === "hex")
        return utils2.toHex32(this.h, "little");
      else
        return utils2.split32(this.h, "little");
    };
    function f7(j5, x5, y5, z4) {
      if (j5 <= 15)
        return x5 ^ y5 ^ z4;
      else if (j5 <= 31)
        return x5 & y5 | ~x5 & z4;
      else if (j5 <= 47)
        return (x5 | ~y5) ^ z4;
      else if (j5 <= 63)
        return x5 & z4 | y5 & ~z4;
      else
        return x5 ^ (y5 | ~z4);
    }
    function K3(j5) {
      if (j5 <= 15)
        return 0;
      else if (j5 <= 31)
        return 1518500249;
      else if (j5 <= 47)
        return 1859775393;
      else if (j5 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh2(j5) {
      if (j5 <= 15)
        return 1352829926;
      else if (j5 <= 31)
        return 1548603684;
      else if (j5 <= 47)
        return 1836072691;
      else if (j5 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r6 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh2 = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s6 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh2 = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    var assert5 = require_minimalistic_assert();
    function Hmac2(hash4, key2, enc) {
      if (!(this instanceof Hmac2))
        return new Hmac2(hash4, key2, enc);
      this.Hash = hash4;
      this.blockSize = hash4.blockSize / 8;
      this.outSize = hash4.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils2.toArray(key2, enc));
    }
    module.exports = Hmac2;
    Hmac2.prototype._init = function init3(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert5(key2.length <= this.blockSize);
      for (var i5 = key2.length; i5 < this.blockSize; i5++)
        key2.push(0);
      for (i5 = 0; i5 < key2.length; i5++)
        key2[i5] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i5 = 0; i5 < key2.length; i5++)
        key2[i5] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac2.prototype.update = function update5(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac2.prototype.digest = function digest9(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash4 = exports;
    hash4.utils = require_utils();
    hash4.common = require_common2();
    hash4.sha = require_sha();
    hash4.ripemd = require_ripemd();
    hash4.hmac = require_hmac();
    hash4.sha1 = hash4.sha.sha1;
    hash4.sha256 = hash4.sha.sha256;
    hash4.sha224 = hash4.sha.sha224;
    hash4.sha384 = hash4.sha.sha384;
    hash4.sha512 = hash4.sha.sha512;
    hash4.ripemd160 = hash4.ripemd.ripemd160;
  }
});

// node_modules/eosjs/dist/ripemd.js
var require_ripemd2 = __commonJS({
  "node_modules/eosjs/dist/ripemd.js"(exports, module) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i5) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i5 && _arr.length === i5)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i5) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i5);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i5 = 0; i5 < props.length; i5++) {
          var descriptor = props[i5];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var RIPEMD1602 = function() {
      function RIPEMD1603() {
        _classCallCheck(this, RIPEMD1603);
      }
      _createClass(RIPEMD1603, null, [{
        key: "get_n_pad_bytes",
        value: function get_n_pad_bytes(message_size) {
          return 64 - (message_size + 8 & 63);
        }
      }, {
        key: "pad",
        value: function pad2(message) {
          var message_size = message.byteLength;
          var n_pad = RIPEMD1603.get_n_pad_bytes(message_size);
          var divmod = function divmod2(dividend, divisor) {
            return [Math.floor(dividend / divisor), dividend % divisor];
          };
          var _divmod$map = divmod(message_size, 536870912).map(function(x5, index) {
            return index ? x5 * 8 : x5;
          }), _divmod$map2 = _slicedToArray(_divmod$map, 2), msg_bit_size_most = _divmod$map2[0], msg_bit_size_least = _divmod$map2[1];
          var padded = new Uint8Array(message_size + n_pad + 8);
          padded.set(new Uint8Array(message), 0);
          var data_view = new DataView(padded.buffer);
          data_view.setUint8(message_size, 128);
          data_view.setUint32(message_size + n_pad, msg_bit_size_least, true);
          data_view.setUint32(message_size + n_pad + 4, msg_bit_size_most, true);
          return padded.buffer;
        }
      }, {
        key: "f",
        value: function f7(j5, x5, y5, z4) {
          if (0 <= j5 && j5 <= 15) {
            return x5 ^ y5 ^ z4;
          }
          if (16 <= j5 && j5 <= 31) {
            return x5 & y5 | ~x5 & z4;
          }
          if (32 <= j5 && j5 <= 47) {
            return (x5 | ~y5) ^ z4;
          }
          if (48 <= j5 && j5 <= 63) {
            return x5 & z4 | y5 & ~z4;
          }
          if (64 <= j5 && j5 <= 79) {
            return x5 ^ (y5 | ~z4);
          }
        }
      }, {
        key: "K",
        value: function K3(j5) {
          if (0 <= j5 && j5 <= 15) {
            return 0;
          }
          if (16 <= j5 && j5 <= 31) {
            return 1518500249;
          }
          if (32 <= j5 && j5 <= 47) {
            return 1859775393;
          }
          if (48 <= j5 && j5 <= 63) {
            return 2400959708;
          }
          if (64 <= j5 && j5 <= 79) {
            return 2840853838;
          }
        }
      }, {
        key: "KP",
        value: function KP(j5) {
          if (0 <= j5 && j5 <= 15) {
            return 1352829926;
          }
          if (16 <= j5 && j5 <= 31) {
            return 1548603684;
          }
          if (32 <= j5 && j5 <= 47) {
            return 1836072691;
          }
          if (48 <= j5 && j5 <= 63) {
            return 2053994217;
          }
          if (64 <= j5 && j5 <= 79) {
            return 0;
          }
        }
      }, {
        key: "add_modulo32",
        value: function add_modulo32() {
          return Array.from(arguments).reduce(function(a5, b4) {
            return a5 + b4;
          }, 0) | 0;
        }
      }, {
        key: "rol32",
        value: function rol32(value, count2) {
          return value << count2 | value >>> 32 - count2;
        }
      }, {
        key: "hash",
        value: function hash4(message) {
          var padded = RIPEMD1603.pad(message);
          var r6 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
          var rP = [
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ];
          var s6 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
          var sP = [
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ];
          var word_size = 4;
          var block_size = 64;
          var t5 = padded.byteLength / block_size;
          var X2 = new Array(t5).fill(void 0).map(function(_10, i6) {
            return function(j6) {
              return new DataView(padded, i6 * block_size, block_size).getUint32(j6 * word_size, true);
            };
          });
          var h5 = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
          ];
          for (var i5 = 0; i5 < t5; ++i5) {
            var A6 = h5[0], B3 = h5[1], C4 = h5[2], D4 = h5[3], E4 = h5[4];
            var AP = A6, BP = B3, CP = C4, DP = D4, EP = E4;
            for (var j5 = 0; j5 < 80; ++j5) {
              var _T = RIPEMD1603.add_modulo32(RIPEMD1603.rol32(RIPEMD1603.add_modulo32(A6, RIPEMD1603.f(j5, B3, C4, D4), X2[i5](r6[j5]), RIPEMD1603.K(j5)), s6[j5]), E4);
              A6 = E4;
              E4 = D4;
              D4 = RIPEMD1603.rol32(C4, 10);
              C4 = B3;
              B3 = _T;
              _T = RIPEMD1603.add_modulo32(RIPEMD1603.rol32(RIPEMD1603.add_modulo32(AP, RIPEMD1603.f(79 - j5, BP, CP, DP), X2[i5](rP[j5]), RIPEMD1603.KP(j5)), sP[j5]), EP);
              AP = EP;
              EP = DP;
              DP = RIPEMD1603.rol32(CP, 10);
              CP = BP;
              BP = _T;
            }
            var T6 = RIPEMD1603.add_modulo32(h5[1], C4, DP);
            h5[1] = RIPEMD1603.add_modulo32(h5[2], D4, EP);
            h5[2] = RIPEMD1603.add_modulo32(h5[3], E4, AP);
            h5[3] = RIPEMD1603.add_modulo32(h5[4], A6, BP);
            h5[4] = RIPEMD1603.add_modulo32(h5[0], B3, CP);
            h5[0] = T6;
          }
          var result = new ArrayBuffer(20);
          var data_view = new DataView(result);
          h5.forEach(function(h_i, i6) {
            return data_view.setUint32(i6 * 4, h_i, true);
          });
          return result;
        }
      }]);
      return RIPEMD1603;
    }();
    module.exports = {
      RIPEMD160: RIPEMD1602
    };
  }
});

// node_modules/eosjs/dist/eosjs-numeric.js
var require_eosjs_numeric = __commonJS({
  "node_modules/eosjs/dist/eosjs-numeric.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o5, n3) {
      var m5 = typeof Symbol === "function" && o5[Symbol.iterator];
      if (!m5)
        return o5;
      var i5 = m5.call(o5), r6, ar = [], e5;
      try {
        while ((n3 === void 0 || n3-- > 0) && !(r6 = i5.next()).done)
          ar.push(r6.value);
      } catch (error) {
        e5 = { error };
      } finally {
        try {
          if (r6 && !r6.done && (m5 = i5["return"]))
            m5.call(i5);
        } finally {
          if (e5)
            throw e5.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
      for (var i5 = 0, il = from2.length, j5 = to.length; i5 < il; i5++, j5++)
        to[j5] = from2[i5];
      return to;
    };
    var __values = exports && exports.__values || function(o5) {
      var s6 = typeof Symbol === "function" && Symbol.iterator, m5 = s6 && o5[s6], i5 = 0;
      if (m5)
        return m5.call(o5);
      if (o5 && typeof o5.length === "number")
        return {
          next: function() {
            if (o5 && i5 >= o5.length)
              o5 = void 0;
            return { value: o5 && o5[i5++], done: !o5 };
          }
        };
      throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureToString = exports.stringToSignature = exports.privateKeyToString = exports.privateKeyToLegacyString = exports.stringToPrivateKey = exports.convertLegacyPublicKeys = exports.convertLegacyPublicKey = exports.publicKeyToString = exports.publicKeyToLegacyString = exports.stringToPublicKey = exports.signatureDataSize = exports.privateKeyDataSize = exports.publicKeyDataSize = exports.KeyType = exports.base64ToBinary = exports.binaryToBase58 = exports.base58ToBinary = exports.signedBinaryToDecimal = exports.binaryToDecimal = exports.signedDecimalToBinary = exports.decimalToBinary = exports.negate = exports.isNegative = void 0;
    var hash_js_1 = require_hash();
    var ripemd1603 = require_ripemd2().RIPEMD160.hash;
    var base58Chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var create_base58_map = function() {
      var base58M = Array(256).fill(-1);
      for (var i5 = 0; i5 < base58Chars.length; ++i5) {
        base58M[base58Chars.charCodeAt(i5)] = i5;
      }
      return base58M;
    };
    var base58Map = create_base58_map();
    var create_base64_map = function() {
      var base64M = Array(256).fill(-1);
      for (var i5 = 0; i5 < base64Chars.length; ++i5) {
        base64M[base64Chars.charCodeAt(i5)] = i5;
      }
      base64M["=".charCodeAt(0)] = 0;
      return base64M;
    };
    var base64Map = create_base64_map();
    var isNegative = function(bignum) {
      return (bignum[bignum.length - 1] & 128) !== 0;
    };
    exports.isNegative = isNegative;
    var negate = function(bignum) {
      var carry = 1;
      for (var i5 = 0; i5 < bignum.length; ++i5) {
        var x5 = (~bignum[i5] & 255) + carry;
        bignum[i5] = x5;
        carry = x5 >> 8;
      }
    };
    exports.negate = negate;
    var decimalToBinary = function(size, s6) {
      var result = new Uint8Array(size);
      for (var i5 = 0; i5 < s6.length; ++i5) {
        var srcDigit = s6.charCodeAt(i5);
        if (srcDigit < "0".charCodeAt(0) || srcDigit > "9".charCodeAt(0)) {
          throw new Error("invalid number");
        }
        var carry = srcDigit - "0".charCodeAt(0);
        for (var j5 = 0; j5 < size; ++j5) {
          var x5 = result[j5] * 10 + carry;
          result[j5] = x5;
          carry = x5 >> 8;
        }
        if (carry) {
          throw new Error("number is out of range");
        }
      }
      return result;
    };
    exports.decimalToBinary = decimalToBinary;
    var signedDecimalToBinary = function(size, s6) {
      var negative = s6[0] === "-";
      if (negative) {
        s6 = s6.substr(1);
      }
      var result = exports.decimalToBinary(size, s6);
      if (negative) {
        exports.negate(result);
        if (!exports.isNegative(result)) {
          throw new Error("number is out of range");
        }
      } else if (exports.isNegative(result)) {
        throw new Error("number is out of range");
      }
      return result;
    };
    exports.signedDecimalToBinary = signedDecimalToBinary;
    var binaryToDecimal = function(bignum, minDigits) {
      if (minDigits === void 0) {
        minDigits = 1;
      }
      var result = Array(minDigits).fill("0".charCodeAt(0));
      for (var i5 = bignum.length - 1; i5 >= 0; --i5) {
        var carry = bignum[i5];
        for (var j5 = 0; j5 < result.length; ++j5) {
          var x5 = (result[j5] - "0".charCodeAt(0) << 8) + carry;
          result[j5] = "0".charCodeAt(0) + x5 % 10;
          carry = x5 / 10 | 0;
        }
        while (carry) {
          result.push("0".charCodeAt(0) + carry % 10);
          carry = carry / 10 | 0;
        }
      }
      result.reverse();
      return String.fromCharCode.apply(String, __spreadArray([], __read(result)));
    };
    exports.binaryToDecimal = binaryToDecimal;
    var signedBinaryToDecimal = function(bignum, minDigits) {
      if (minDigits === void 0) {
        minDigits = 1;
      }
      if (exports.isNegative(bignum)) {
        var x5 = bignum.slice();
        exports.negate(x5);
        return "-" + exports.binaryToDecimal(x5, minDigits);
      }
      return exports.binaryToDecimal(bignum, minDigits);
    };
    exports.signedBinaryToDecimal = signedBinaryToDecimal;
    var base58ToBinaryVarSize = function(s6) {
      var e_1, _a2;
      var result = [];
      for (var i5 = 0; i5 < s6.length; ++i5) {
        var carry = base58Map[s6.charCodeAt(i5)];
        if (carry < 0) {
          throw new Error("invalid base-58 value");
        }
        for (var j5 = 0; j5 < result.length; ++j5) {
          var x5 = result[j5] * 58 + carry;
          result[j5] = x5 & 255;
          carry = x5 >> 8;
        }
        if (carry) {
          result.push(carry);
        }
      }
      try {
        for (var s_1 = __values(s6), s_1_1 = s_1.next(); !s_1_1.done; s_1_1 = s_1.next()) {
          var ch = s_1_1.value;
          if (ch === "1") {
            result.push(0);
          } else {
            break;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (s_1_1 && !s_1_1.done && (_a2 = s_1.return))
            _a2.call(s_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      result.reverse();
      return new Uint8Array(result);
    };
    var base58ToBinary = function(size, s6) {
      if (!size) {
        return base58ToBinaryVarSize(s6);
      }
      var result = new Uint8Array(size);
      for (var i5 = 0; i5 < s6.length; ++i5) {
        var carry = base58Map[s6.charCodeAt(i5)];
        if (carry < 0) {
          throw new Error("invalid base-58 value");
        }
        for (var j5 = 0; j5 < size; ++j5) {
          var x5 = result[j5] * 58 + carry;
          result[j5] = x5;
          carry = x5 >> 8;
        }
        if (carry) {
          throw new Error("base-58 value is out of range");
        }
      }
      result.reverse();
      return result;
    };
    exports.base58ToBinary = base58ToBinary;
    var binaryToBase58 = function(bignum, minDigits) {
      var e_2, _a2, e_3, _b;
      if (minDigits === void 0) {
        minDigits = 1;
      }
      var result = [];
      try {
        for (var bignum_1 = __values(bignum), bignum_1_1 = bignum_1.next(); !bignum_1_1.done; bignum_1_1 = bignum_1.next()) {
          var byte = bignum_1_1.value;
          var carry = byte;
          for (var j5 = 0; j5 < result.length; ++j5) {
            var x5 = (base58Map[result[j5]] << 8) + carry;
            result[j5] = base58Chars.charCodeAt(x5 % 58);
            carry = x5 / 58 | 0;
          }
          while (carry) {
            result.push(base58Chars.charCodeAt(carry % 58));
            carry = carry / 58 | 0;
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (bignum_1_1 && !bignum_1_1.done && (_a2 = bignum_1.return))
            _a2.call(bignum_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      try {
        for (var bignum_2 = __values(bignum), bignum_2_1 = bignum_2.next(); !bignum_2_1.done; bignum_2_1 = bignum_2.next()) {
          var byte = bignum_2_1.value;
          if (byte) {
            break;
          } else {
            result.push("1".charCodeAt(0));
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (bignum_2_1 && !bignum_2_1.done && (_b = bignum_2.return))
            _b.call(bignum_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      result.reverse();
      return String.fromCharCode.apply(String, __spreadArray([], __read(result)));
    };
    exports.binaryToBase58 = binaryToBase58;
    var base64ToBinary = function(s6) {
      var len = s6.length;
      if ((len & 3) === 1 && s6[len - 1] === "=") {
        len -= 1;
      }
      if ((len & 3) !== 0) {
        throw new Error("base-64 value is not padded correctly");
      }
      var groups = len >> 2;
      var bytes = groups * 3;
      if (len > 0 && s6[len - 1] === "=") {
        if (s6[len - 2] === "=") {
          bytes -= 2;
        } else {
          bytes -= 1;
        }
      }
      var result = new Uint8Array(bytes);
      for (var group = 0; group < groups; ++group) {
        var digit0 = base64Map[s6.charCodeAt(group * 4 + 0)];
        var digit1 = base64Map[s6.charCodeAt(group * 4 + 1)];
        var digit2 = base64Map[s6.charCodeAt(group * 4 + 2)];
        var digit3 = base64Map[s6.charCodeAt(group * 4 + 3)];
        result[group * 3 + 0] = digit0 << 2 | digit1 >> 4;
        if (group * 3 + 1 < bytes) {
          result[group * 3 + 1] = (digit1 & 15) << 4 | digit2 >> 2;
        }
        if (group * 3 + 2 < bytes) {
          result[group * 3 + 2] = (digit2 & 3) << 6 | digit3;
        }
      }
      return result;
    };
    exports.base64ToBinary = base64ToBinary;
    var KeyType;
    (function(KeyType2) {
      KeyType2[KeyType2["k1"] = 0] = "k1";
      KeyType2[KeyType2["r1"] = 1] = "r1";
      KeyType2[KeyType2["wa"] = 2] = "wa";
    })(KeyType = exports.KeyType || (exports.KeyType = {}));
    exports.publicKeyDataSize = 33;
    exports.privateKeyDataSize = 32;
    exports.signatureDataSize = 65;
    var digestSuffixRipemd160 = function(data, suffix) {
      var d5 = new Uint8Array(data.length + suffix.length);
      for (var i5 = 0; i5 < data.length; ++i5) {
        d5[i5] = data[i5];
      }
      for (var i5 = 0; i5 < suffix.length; ++i5) {
        d5[data.length + i5] = suffix.charCodeAt(i5);
      }
      return ripemd1603(d5);
    };
    var stringToKey = function(s6, type2, size, suffix) {
      var whole = exports.base58ToBinary(size ? size + 4 : 0, s6);
      var result = { type: type2, data: new Uint8Array(whole.buffer, 0, whole.length - 4) };
      var digest9 = new Uint8Array(digestSuffixRipemd160(result.data, suffix));
      if (digest9[0] !== whole[whole.length - 4] || digest9[1] !== whole[whole.length - 3] || digest9[2] !== whole[whole.length - 2] || digest9[3] !== whole[whole.length - 1]) {
        throw new Error("checksum doesn't match");
      }
      return result;
    };
    var keyToString = function(key2, suffix, prefix) {
      var digest9 = new Uint8Array(digestSuffixRipemd160(key2.data, suffix));
      var whole = new Uint8Array(key2.data.length + 4);
      for (var i5 = 0; i5 < key2.data.length; ++i5) {
        whole[i5] = key2.data[i5];
      }
      for (var i5 = 0; i5 < 4; ++i5) {
        whole[i5 + key2.data.length] = digest9[i5];
      }
      return prefix + exports.binaryToBase58(whole);
    };
    var stringToPublicKey = function(s6) {
      if (typeof s6 !== "string") {
        throw new Error("expected string containing public key");
      }
      if (s6.substr(0, 3) === "EOS") {
        var whole = exports.base58ToBinary(exports.publicKeyDataSize + 4, s6.substr(3));
        var key2 = { type: KeyType.k1, data: new Uint8Array(exports.publicKeyDataSize) };
        for (var i5 = 0; i5 < exports.publicKeyDataSize; ++i5) {
          key2.data[i5] = whole[i5];
        }
        var digest9 = new Uint8Array(ripemd1603(key2.data));
        if (digest9[0] !== whole[exports.publicKeyDataSize] || digest9[1] !== whole[34] || digest9[2] !== whole[35] || digest9[3] !== whole[36]) {
          throw new Error("checksum doesn't match");
        }
        return key2;
      } else if (s6.substr(0, 7) === "PUB_K1_") {
        return stringToKey(s6.substr(7), KeyType.k1, exports.publicKeyDataSize, "K1");
      } else if (s6.substr(0, 7) === "PUB_R1_") {
        return stringToKey(s6.substr(7), KeyType.r1, exports.publicKeyDataSize, "R1");
      } else if (s6.substr(0, 7) === "PUB_WA_") {
        return stringToKey(s6.substr(7), KeyType.wa, 0, "WA");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.stringToPublicKey = stringToPublicKey;
    var publicKeyToLegacyString = function(key2) {
      if (key2.type === KeyType.k1 && key2.data.length === exports.publicKeyDataSize) {
        return keyToString(key2, "", "EOS");
      } else if (key2.type === KeyType.r1 || key2.type === KeyType.wa) {
        throw new Error("Key format not supported in legacy conversion");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.publicKeyToLegacyString = publicKeyToLegacyString;
    var publicKeyToString = function(key2) {
      if (key2.type === KeyType.k1 && key2.data.length === exports.publicKeyDataSize) {
        return keyToString(key2, "K1", "PUB_K1_");
      } else if (key2.type === KeyType.r1 && key2.data.length === exports.publicKeyDataSize) {
        return keyToString(key2, "R1", "PUB_R1_");
      } else if (key2.type === KeyType.wa) {
        return keyToString(key2, "WA", "PUB_WA_");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.publicKeyToString = publicKeyToString;
    var convertLegacyPublicKey = function(s6) {
      if (s6.substr(0, 3) === "EOS") {
        return exports.publicKeyToString(exports.stringToPublicKey(s6));
      }
      return s6;
    };
    exports.convertLegacyPublicKey = convertLegacyPublicKey;
    var convertLegacyPublicKeys = function(keys) {
      return keys.map(exports.convertLegacyPublicKey);
    };
    exports.convertLegacyPublicKeys = convertLegacyPublicKeys;
    var stringToPrivateKey = function(s6) {
      if (typeof s6 !== "string") {
        throw new Error("expected string containing private key");
      }
      if (s6.substr(0, 7) === "PVT_R1_") {
        return stringToKey(s6.substr(7), KeyType.r1, exports.privateKeyDataSize, "R1");
      } else if (s6.substr(0, 7) === "PVT_K1_") {
        return stringToKey(s6.substr(7), KeyType.k1, exports.privateKeyDataSize, "K1");
      } else {
        var whole = exports.base58ToBinary(exports.privateKeyDataSize + 5, s6);
        var key2 = { type: KeyType.k1, data: new Uint8Array(exports.privateKeyDataSize) };
        if (whole[0] !== 128) {
          throw new Error("unrecognized private key type");
        }
        for (var i5 = 0; i5 < exports.privateKeyDataSize; ++i5) {
          key2.data[i5] = whole[i5 + 1];
        }
        return key2;
      }
    };
    exports.stringToPrivateKey = stringToPrivateKey;
    var privateKeyToLegacyString = function(key2) {
      if (key2.type === KeyType.k1 && key2.data.length === exports.privateKeyDataSize) {
        var whole_1 = [];
        whole_1.push(128);
        key2.data.forEach(function(byte) {
          return whole_1.push(byte);
        });
        var digest9 = new Uint8Array(hash_js_1.sha256().update(hash_js_1.sha256().update(whole_1).digest()).digest());
        var result = new Uint8Array(exports.privateKeyDataSize + 5);
        for (var i5 = 0; i5 < whole_1.length; i5++) {
          result[i5] = whole_1[i5];
        }
        for (var i5 = 0; i5 < 4; i5++) {
          result[i5 + whole_1.length] = digest9[i5];
        }
        return exports.binaryToBase58(result);
      } else if (key2.type === KeyType.r1 || key2.type === KeyType.wa) {
        throw new Error("Key format not supported in legacy conversion");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.privateKeyToLegacyString = privateKeyToLegacyString;
    var privateKeyToString = function(key2) {
      if (key2.type === KeyType.r1) {
        return keyToString(key2, "R1", "PVT_R1_");
      } else if (key2.type === KeyType.k1) {
        return keyToString(key2, "K1", "PVT_K1_");
      } else {
        throw new Error("unrecognized private key format");
      }
    };
    exports.privateKeyToString = privateKeyToString;
    var stringToSignature = function(s6) {
      if (typeof s6 !== "string") {
        throw new Error("expected string containing signature");
      }
      if (s6.substr(0, 7) === "SIG_K1_") {
        return stringToKey(s6.substr(7), KeyType.k1, exports.signatureDataSize, "K1");
      } else if (s6.substr(0, 7) === "SIG_R1_") {
        return stringToKey(s6.substr(7), KeyType.r1, exports.signatureDataSize, "R1");
      } else if (s6.substr(0, 7) === "SIG_WA_") {
        return stringToKey(s6.substr(7), KeyType.wa, 0, "WA");
      } else {
        throw new Error("unrecognized signature format");
      }
    };
    exports.stringToSignature = stringToSignature;
    var signatureToString = function(signature2) {
      if (signature2.type === KeyType.k1) {
        return keyToString(signature2, "K1", "SIG_K1_");
      } else if (signature2.type === KeyType.r1) {
        return keyToString(signature2, "R1", "SIG_R1_");
      } else if (signature2.type === KeyType.wa) {
        return keyToString(signature2, "WA", "SIG_WA_");
      } else {
        throw new Error("unrecognized signature format");
      }
    };
    exports.signatureToString = signatureToString;
  }
});

// node_modules/eosjs/dist/eosjs-serialize.js
var require_eosjs_serialize = __commonJS({
  "node_modules/eosjs/dist/eosjs-serialize.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t5) {
        for (var s6, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
          s6 = arguments[i5];
          for (var p5 in s6)
            if (Object.prototype.hasOwnProperty.call(s6, p5))
              t5[p5] = s6[p5];
        }
        return t5;
      };
      return __assign2.apply(this, arguments);
    };
    var __read = exports && exports.__read || function(o5, n3) {
      var m5 = typeof Symbol === "function" && o5[Symbol.iterator];
      if (!m5)
        return o5;
      var i5 = m5.call(o5), r6, ar = [], e5;
      try {
        while ((n3 === void 0 || n3-- > 0) && !(r6 = i5.next()).done)
          ar.push(r6.value);
      } catch (error) {
        e5 = { error };
      } finally {
        try {
          if (r6 && !r6.done && (m5 = i5["return"]))
            m5.call(i5);
        } finally {
          if (e5)
            throw e5.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
      for (var i5 = 0, il = from2.length, j5 = to.length; i5 < il; i5++, j5++)
        to[j5] = from2[i5];
      return to;
    };
    var __values = exports && exports.__values || function(o5) {
      var s6 = typeof Symbol === "function" && Symbol.iterator, m5 = s6 && o5[s6], i5 = 0;
      if (m5)
        return m5.call(o5);
      if (o5 && typeof o5.length === "number")
        return {
          next: function() {
            if (o5 && i5 >= o5.length)
              o5 = void 0;
            return { value: o5 && o5[i5++], done: !o5 };
          }
        };
      throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeQuery = exports.deserializeAnyArray = exports.serializeAnyArray = exports.deserializeAnyObject = exports.serializeAnyObject = exports.deserializeAnyvarShort = exports.deserializeAnyvar = exports.serializeAnyvar = exports.deserializeAction = exports.deserializeActionData = exports.serializeAction = exports.serializeActionData = exports.transactionHeader = exports.getTypesFromAbi = exports.getType = exports.createTransactionTypes = exports.createTransactionExtensionTypes = exports.createAbiTypes = exports.createInitialTypes = exports.hexToUint8Array = exports.arrayToHex = exports.symbolToString = exports.stringToSymbol = exports.blockTimestampToDate = exports.dateToBlockTimestamp = exports.timePointSecToDate = exports.dateToTimePointSec = exports.timePointToDate = exports.dateToTimePoint = exports.supportedAbiVersion = exports.SerialBuffer = exports.SerializerState = void 0;
    var numeric = require_eosjs_numeric();
    var SerializerState = function() {
      function SerializerState2(options) {
        if (options === void 0) {
          options = {};
        }
        this.skippedBinaryExtension = false;
        this.options = options;
      }
      return SerializerState2;
    }();
    exports.SerializerState = SerializerState;
    var SerialBuffer = function() {
      function SerialBuffer2(_a2) {
        var _b = _a2 === void 0 ? {} : _a2, textEncoder = _b.textEncoder, textDecoder = _b.textDecoder, array2 = _b.array;
        this.readPos = 0;
        this.array = array2 || new Uint8Array(1024);
        this.length = array2 ? array2.length : 0;
        this.textEncoder = textEncoder || new TextEncoder();
        this.textDecoder = textDecoder || new TextDecoder("utf-8", { fatal: true });
      }
      SerialBuffer2.prototype.reserve = function(size) {
        if (this.length + size <= this.array.length) {
          return;
        }
        var l5 = this.array.length;
        while (this.length + size > l5) {
          l5 = Math.ceil(l5 * 1.5);
        }
        var newArray = new Uint8Array(l5);
        newArray.set(this.array);
        this.array = newArray;
      };
      SerialBuffer2.prototype.haveReadData = function() {
        return this.readPos < this.length;
      };
      SerialBuffer2.prototype.restartRead = function() {
        this.readPos = 0;
      };
      SerialBuffer2.prototype.asUint8Array = function() {
        return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
      };
      SerialBuffer2.prototype.pushArray = function(v8) {
        this.reserve(v8.length);
        this.array.set(v8, this.length);
        this.length += v8.length;
      };
      SerialBuffer2.prototype.push = function() {
        var v8 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          v8[_i] = arguments[_i];
        }
        this.pushArray(v8);
      };
      SerialBuffer2.prototype.get = function() {
        if (this.readPos < this.length) {
          return this.array[this.readPos++];
        }
        throw new Error("Read past end of buffer");
      };
      SerialBuffer2.prototype.pushUint8ArrayChecked = function(v8, len) {
        if (v8.length !== len) {
          throw new Error("Binary data has incorrect size");
        }
        this.pushArray(v8);
      };
      SerialBuffer2.prototype.getUint8Array = function(len) {
        if (this.readPos + len > this.length) {
          throw new Error("Read past end of buffer");
        }
        var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
        this.readPos += len;
        return result;
      };
      SerialBuffer2.prototype.skip = function(len) {
        if (this.readPos + len > this.length) {
          throw new Error("Read past end of buffer");
        }
        this.readPos += len;
      };
      SerialBuffer2.prototype.pushUint16 = function(v8) {
        this.push(v8 >> 0 & 255, v8 >> 8 & 255);
      };
      SerialBuffer2.prototype.getUint16 = function() {
        var v8 = 0;
        v8 |= this.get() << 0;
        v8 |= this.get() << 8;
        return v8;
      };
      SerialBuffer2.prototype.pushUint32 = function(v8) {
        this.push(v8 >> 0 & 255, v8 >> 8 & 255, v8 >> 16 & 255, v8 >> 24 & 255);
      };
      SerialBuffer2.prototype.getUint32 = function() {
        var v8 = 0;
        v8 |= this.get() << 0;
        v8 |= this.get() << 8;
        v8 |= this.get() << 16;
        v8 |= this.get() << 24;
        return v8 >>> 0;
      };
      SerialBuffer2.prototype.pushNumberAsUint64 = function(v8) {
        this.pushUint32(v8 >>> 0);
        this.pushUint32(Math.floor(v8 / 4294967296) >>> 0);
      };
      SerialBuffer2.prototype.getUint64AsNumber = function() {
        var low = this.getUint32();
        var high = this.getUint32();
        return (high >>> 0) * 4294967296 + (low >>> 0);
      };
      SerialBuffer2.prototype.pushVaruint32 = function(v8) {
        while (true) {
          if (v8 >>> 7) {
            this.push(128 | v8 & 127);
            v8 = v8 >>> 7;
          } else {
            this.push(v8);
            break;
          }
        }
      };
      SerialBuffer2.prototype.getVaruint32 = function() {
        var v8 = 0;
        var bit = 0;
        while (true) {
          var b4 = this.get();
          v8 |= (b4 & 127) << bit;
          bit += 7;
          if (!(b4 & 128)) {
            break;
          }
        }
        return v8 >>> 0;
      };
      SerialBuffer2.prototype.pushVarint32 = function(v8) {
        this.pushVaruint32(v8 << 1 ^ v8 >> 31);
      };
      SerialBuffer2.prototype.getVarint32 = function() {
        var v8 = this.getVaruint32();
        if (v8 & 1) {
          return ~v8 >> 1 | 2147483648;
        } else {
          return v8 >>> 1;
        }
      };
      SerialBuffer2.prototype.pushFloat32 = function(v8) {
        this.pushArray(new Uint8Array(new Float32Array([v8]).buffer));
      };
      SerialBuffer2.prototype.getFloat32 = function() {
        return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
      };
      SerialBuffer2.prototype.pushFloat64 = function(v8) {
        this.pushArray(new Uint8Array(new Float64Array([v8]).buffer));
      };
      SerialBuffer2.prototype.getFloat64 = function() {
        return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
      };
      SerialBuffer2.prototype.pushName = function(s6) {
        if (typeof s6 !== "string") {
          throw new Error("Expected string containing name");
        }
        var regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
        if (!regex.test(s6)) {
          throw new Error("Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz");
        }
        var charToSymbol = function(c6) {
          if (c6 >= "a".charCodeAt(0) && c6 <= "z".charCodeAt(0)) {
            return c6 - "a".charCodeAt(0) + 6;
          }
          if (c6 >= "1".charCodeAt(0) && c6 <= "5".charCodeAt(0)) {
            return c6 - "1".charCodeAt(0) + 1;
          }
          return 0;
        };
        var a5 = new Uint8Array(8);
        var bit = 63;
        for (var i5 = 0; i5 < s6.length; ++i5) {
          var c5 = charToSymbol(s6.charCodeAt(i5));
          if (bit < 5) {
            c5 = c5 << 1;
          }
          for (var j5 = 4; j5 >= 0; --j5) {
            if (bit >= 0) {
              a5[Math.floor(bit / 8)] |= (c5 >> j5 & 1) << bit % 8;
              --bit;
            }
          }
        }
        this.pushArray(a5);
      };
      SerialBuffer2.prototype.getName = function() {
        var a5 = this.getUint8Array(8);
        var result = "";
        for (var bit = 63; bit >= 0; ) {
          var c5 = 0;
          for (var i5 = 0; i5 < 5; ++i5) {
            if (bit >= 0) {
              c5 = c5 << 1 | a5[Math.floor(bit / 8)] >> bit % 8 & 1;
              --bit;
            }
          }
          if (c5 >= 6) {
            result += String.fromCharCode(c5 + "a".charCodeAt(0) - 6);
          } else if (c5 >= 1) {
            result += String.fromCharCode(c5 + "1".charCodeAt(0) - 1);
          } else {
            result += ".";
          }
        }
        while (result.endsWith(".")) {
          result = result.substr(0, result.length - 1);
        }
        return result;
      };
      SerialBuffer2.prototype.pushBytes = function(v8) {
        this.pushVaruint32(v8.length);
        this.pushArray(v8);
      };
      SerialBuffer2.prototype.getBytes = function() {
        return this.getUint8Array(this.getVaruint32());
      };
      SerialBuffer2.prototype.pushString = function(v8) {
        this.pushBytes(this.textEncoder.encode(v8));
      };
      SerialBuffer2.prototype.getString = function() {
        return this.textDecoder.decode(this.getBytes());
      };
      SerialBuffer2.prototype.pushSymbolCode = function(name2) {
        if (typeof name2 !== "string") {
          throw new Error("Expected string containing symbol_code");
        }
        var a5 = [];
        a5.push.apply(a5, __spreadArray([], __read(this.textEncoder.encode(name2))));
        while (a5.length < 8) {
          a5.push(0);
        }
        this.pushArray(a5.slice(0, 8));
      };
      SerialBuffer2.prototype.getSymbolCode = function() {
        var a5 = this.getUint8Array(8);
        var len;
        for (len = 0; len < a5.length; ++len) {
          if (!a5[len]) {
            break;
          }
        }
        var name2 = this.textDecoder.decode(new Uint8Array(a5.buffer, a5.byteOffset, len));
        return name2;
      };
      SerialBuffer2.prototype.pushSymbol = function(_a2) {
        var name2 = _a2.name, precision = _a2.precision;
        if (!/^[A-Z]{1,7}$/.test(name2)) {
          throw new Error("Expected symbol to be A-Z and between one and seven characters");
        }
        var a5 = [precision & 255];
        a5.push.apply(a5, __spreadArray([], __read(this.textEncoder.encode(name2))));
        while (a5.length < 8) {
          a5.push(0);
        }
        this.pushArray(a5.slice(0, 8));
      };
      SerialBuffer2.prototype.getSymbol = function() {
        var precision = this.get();
        var a5 = this.getUint8Array(7);
        var len;
        for (len = 0; len < a5.length; ++len) {
          if (!a5[len]) {
            break;
          }
        }
        var name2 = this.textDecoder.decode(new Uint8Array(a5.buffer, a5.byteOffset, len));
        return { name: name2, precision };
      };
      SerialBuffer2.prototype.pushAsset = function(s6) {
        if (typeof s6 !== "string") {
          throw new Error("Expected string containing asset");
        }
        s6 = s6.trim();
        var pos = 0;
        var amount = "";
        var precision = 0;
        if (s6[pos] === "-") {
          amount += "-";
          ++pos;
        }
        var foundDigit = false;
        while (pos < s6.length && s6.charCodeAt(pos) >= "0".charCodeAt(0) && s6.charCodeAt(pos) <= "9".charCodeAt(0)) {
          foundDigit = true;
          amount += s6[pos];
          ++pos;
        }
        if (!foundDigit) {
          throw new Error("Asset must begin with a number");
        }
        if (s6[pos] === ".") {
          ++pos;
          while (pos < s6.length && s6.charCodeAt(pos) >= "0".charCodeAt(0) && s6.charCodeAt(pos) <= "9".charCodeAt(0)) {
            amount += s6[pos];
            ++precision;
            ++pos;
          }
        }
        var name2 = s6.substr(pos).trim();
        this.pushArray(numeric.signedDecimalToBinary(8, amount));
        this.pushSymbol({ name: name2, precision });
      };
      SerialBuffer2.prototype.getAsset = function() {
        var amount = this.getUint8Array(8);
        var _a2 = this.getSymbol(), name2 = _a2.name, precision = _a2.precision;
        var s6 = numeric.signedBinaryToDecimal(amount, precision + 1);
        if (precision) {
          s6 = s6.substr(0, s6.length - precision) + "." + s6.substr(s6.length - precision);
        }
        return s6 + " " + name2;
      };
      SerialBuffer2.prototype.pushPublicKey = function(s6) {
        var key2 = numeric.stringToPublicKey(s6);
        this.push(key2.type);
        this.pushArray(key2.data);
      };
      SerialBuffer2.prototype.getPublicKey = function() {
        var type2 = this.get();
        var data;
        if (type2 === numeric.KeyType.wa) {
          var begin = this.readPos;
          this.skip(34);
          this.skip(this.getVaruint32());
          data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
        } else {
          data = this.getUint8Array(numeric.publicKeyDataSize);
        }
        return numeric.publicKeyToString({ type: type2, data });
      };
      SerialBuffer2.prototype.pushPrivateKey = function(s6) {
        var key2 = numeric.stringToPrivateKey(s6);
        this.push(key2.type);
        this.pushArray(key2.data);
      };
      SerialBuffer2.prototype.getPrivateKey = function() {
        var type2 = this.get();
        var data = this.getUint8Array(numeric.privateKeyDataSize);
        return numeric.privateKeyToString({ type: type2, data });
      };
      SerialBuffer2.prototype.pushSignature = function(s6) {
        var key2 = numeric.stringToSignature(s6);
        this.push(key2.type);
        this.pushArray(key2.data);
      };
      SerialBuffer2.prototype.getSignature = function() {
        var type2 = this.get();
        var data;
        if (type2 === numeric.KeyType.wa) {
          var begin = this.readPos;
          this.skip(65);
          this.skip(this.getVaruint32());
          this.skip(this.getVaruint32());
          data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
        } else {
          data = this.getUint8Array(numeric.signatureDataSize);
        }
        return numeric.signatureToString({ type: type2, data });
      };
      return SerialBuffer2;
    }();
    exports.SerialBuffer = SerialBuffer;
    var supportedAbiVersion = function(version29) {
      return version29.startsWith("eosio::abi/1.");
    };
    exports.supportedAbiVersion = supportedAbiVersion;
    var checkDateParse = function(date) {
      var result = Date.parse(date);
      if (Number.isNaN(result)) {
        throw new Error("Invalid time format");
      }
      return result;
    };
    var dateToTimePoint = function(date) {
      return Math.round(checkDateParse(date + "Z") * 1e3);
    };
    exports.dateToTimePoint = dateToTimePoint;
    var timePointToDate = function(us) {
      var s6 = new Date(us / 1e3).toISOString();
      return s6.substr(0, s6.length - 1);
    };
    exports.timePointToDate = timePointToDate;
    var dateToTimePointSec = function(date) {
      return Math.round(checkDateParse(date + "Z") / 1e3);
    };
    exports.dateToTimePointSec = dateToTimePointSec;
    var timePointSecToDate = function(sec) {
      var s6 = new Date(sec * 1e3).toISOString();
      return s6.substr(0, s6.length - 1);
    };
    exports.timePointSecToDate = timePointSecToDate;
    var dateToBlockTimestamp = function(date) {
      return Math.round((checkDateParse(date + "Z") - 9466848e5) / 500);
    };
    exports.dateToBlockTimestamp = dateToBlockTimestamp;
    var blockTimestampToDate = function(slot) {
      var s6 = new Date(slot * 500 + 9466848e5).toISOString();
      return s6.substr(0, s6.length - 1);
    };
    exports.blockTimestampToDate = blockTimestampToDate;
    var stringToSymbol = function(s6) {
      if (typeof s6 !== "string") {
        throw new Error("Expected string containing symbol");
      }
      var m5 = s6.match(/^([0-9]+),([A-Z]+)$/);
      if (!m5) {
        throw new Error("Invalid symbol");
      }
      return { name: m5[2], precision: +m5[1] };
    };
    exports.stringToSymbol = stringToSymbol;
    var symbolToString = function(_a2) {
      var name2 = _a2.name, precision = _a2.precision;
      return precision + "," + name2;
    };
    exports.symbolToString = symbolToString;
    var arrayToHex3 = function(data) {
      var e_1, _a2;
      var result = "";
      try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var x5 = data_1_1.value;
          result += ("00" + x5.toString(16)).slice(-2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
            _a2.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result.toUpperCase();
    };
    exports.arrayToHex = arrayToHex3;
    var hexToUint8Array = function(hex) {
      if (typeof hex !== "string") {
        throw new Error("Expected string containing hex digits");
      }
      if (hex.length % 2) {
        throw new Error("Odd number of hex digits");
      }
      var l5 = hex.length / 2;
      var result = new Uint8Array(l5);
      for (var i5 = 0; i5 < l5; ++i5) {
        var x5 = parseInt(hex.substr(i5 * 2, 2), 16);
        if (Number.isNaN(x5)) {
          throw new Error("Expected hex string");
        }
        result[i5] = x5;
      }
      return result;
    };
    exports.hexToUint8Array = hexToUint8Array;
    function serializeUnknown(buffer2, data) {
      throw new Error("Don't know how to serialize " + this.name);
    }
    function deserializeUnknown(buffer2) {
      throw new Error("Don't know how to deserialize " + this.name);
    }
    function serializeStruct(buffer2, data, state, allowExtensions) {
      var e_2, _a2;
      if (state === void 0) {
        state = new SerializerState();
      }
      if (allowExtensions === void 0) {
        allowExtensions = true;
      }
      if (typeof data !== "object") {
        throw new Error("expected object containing data: " + JSON.stringify(data));
      }
      if (this.base) {
        this.base.serialize(buffer2, data, state, allowExtensions);
      }
      try {
        for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
          var field = _c.value;
          if (field.name in data) {
            if (state.skippedBinaryExtension) {
              throw new Error("unexpected " + this.name + "." + field.name);
            }
            field.type.serialize(buffer2, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
          } else {
            if (allowExtensions && field.type.extensionOf) {
              state.skippedBinaryExtension = true;
            } else {
              throw new Error("missing " + this.name + "." + field.name + " (type=" + field.type.name + ")");
            }
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    function deserializeStruct(buffer2, state, allowExtensions) {
      var e_3, _a2;
      if (state === void 0) {
        state = new SerializerState();
      }
      if (allowExtensions === void 0) {
        allowExtensions = true;
      }
      var result;
      if (this.base) {
        result = this.base.deserialize(buffer2, state, allowExtensions);
      } else {
        result = {};
      }
      try {
        for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
          var field = _c.value;
          if (allowExtensions && field.type.extensionOf && !buffer2.haveReadData()) {
            state.skippedBinaryExtension = true;
          } else {
            result[field.name] = field.type.deserialize(buffer2, state, allowExtensions);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return result;
    }
    function serializeVariant(buffer2, data, state, allowExtensions) {
      if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== "string") {
        throw new Error('expected variant: ["type", value]');
      }
      var i5 = this.fields.findIndex(function(field) {
        return field.name === data[0];
      });
      if (i5 < 0) {
        throw new Error('type "' + data[0] + '" is not valid for variant');
      }
      buffer2.pushVaruint32(i5);
      this.fields[i5].type.serialize(buffer2, data[1], state, allowExtensions);
    }
    function deserializeVariant(buffer2, state, allowExtensions) {
      var i5 = buffer2.getVaruint32();
      if (i5 >= this.fields.length) {
        throw new Error("type index " + i5 + " is not valid for variant");
      }
      var field = this.fields[i5];
      return [field.name, field.type.deserialize(buffer2, state, allowExtensions)];
    }
    function serializeArray(buffer2, data, state, allowExtensions) {
      var e_4, _a2;
      buffer2.pushVaruint32(data.length);
      try {
        for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
          var item = data_2_1.value;
          this.arrayOf.serialize(buffer2, item, state, false);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (data_2_1 && !data_2_1.done && (_a2 = data_2.return))
            _a2.call(data_2);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    }
    function deserializeArray(buffer2, state, allowExtensions) {
      var len = buffer2.getVaruint32();
      var result = [];
      for (var i5 = 0; i5 < len; ++i5) {
        result.push(this.arrayOf.deserialize(buffer2, state, false));
      }
      return result;
    }
    function serializeOptional(buffer2, data, state, allowExtensions) {
      if (data === null || data === void 0) {
        buffer2.push(0);
      } else {
        buffer2.push(1);
        this.optionalOf.serialize(buffer2, data, state, allowExtensions);
      }
    }
    function deserializeOptional(buffer2, state, allowExtensions) {
      if (buffer2.get()) {
        return this.optionalOf.deserialize(buffer2, state, allowExtensions);
      } else {
        return null;
      }
    }
    function serializeExtension(buffer2, data, state, allowExtensions) {
      this.extensionOf.serialize(buffer2, data, state, allowExtensions);
    }
    function deserializeExtension(buffer2, state, allowExtensions) {
      return this.extensionOf.deserialize(buffer2, state, allowExtensions);
    }
    function serializeObject(buffer2, data, state, allowExtensions) {
      var e_5, _a2;
      var entries = Object.entries(data);
      buffer2.pushVaruint32(entries.length);
      try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
          var _b = __read(entries_1_1.value, 2), key2 = _b[0], value = _b[1];
          var keyType = this.fields[0].type;
          var dataType = this.fields[1].type;
          keyType.serialize(buffer2, key2, state, allowExtensions);
          dataType.serialize(buffer2, value, state, allowExtensions);
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (entries_1_1 && !entries_1_1.done && (_a2 = entries_1.return))
            _a2.call(entries_1);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
    }
    function deserializeObject(buffer2, state, allowExtensions) {
      var len = buffer2.getVaruint32();
      var result = {};
      for (var i5 = 0; i5 < len; ++i5) {
        var keyType = this.fields[0].type;
        var dataType = this.fields[1].type;
        var key2 = keyType.deserialize(buffer2, state, allowExtensions);
        result[key2] = dataType.deserialize(buffer2, state, allowExtensions);
      }
      return result;
    }
    function serializePair(buffer2, data, state, allowExtensions) {
      var _this = this;
      buffer2.pushVaruint32(data.length);
      data.forEach(function(item) {
        _this.fields[0].type.serialize(buffer2, item[0], state, allowExtensions);
        _this.fields[1].type.serialize(buffer2, item[1], state, allowExtensions);
      });
    }
    function deserializePair(buffer2, state, allowExtensions) {
      var result = [];
      var len = buffer2.getVaruint32();
      for (var i5 = 0; i5 < len; ++i5) {
        result.push(this.fields[0].type.deserialize(buffer2, state, allowExtensions));
        result.push(this.fields[1].type.deserialize(buffer2, state, allowExtensions));
      }
      return result;
    }
    var createType = function(attrs) {
      return __assign2({ name: "<missing name>", aliasOfName: "", arrayOf: null, optionalOf: null, extensionOf: null, baseName: "", base: null, fields: [], serialize: serializeUnknown, deserialize: deserializeUnknown }, attrs);
    };
    var checkRange = function(orig, converted) {
      if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== "number" && typeof orig !== "string") {
        throw new Error("Expected number");
      }
      if (+orig !== +converted) {
        throw new Error("Number is out of range");
      }
      return +orig;
    };
    var createInitialTypes = function() {
      var result = new Map(Object.entries({
        bool: createType({
          name: "bool",
          serialize: function(buffer2, data) {
            if (!(typeof data === "boolean" || typeof data === "number" && (data === 1 || data === 0))) {
              throw new Error("Expected boolean or number equal to 1 or 0");
            }
            buffer2.push(data ? 1 : 0);
          },
          deserialize: function(buffer2) {
            return !!buffer2.get();
          }
        }),
        uint8: createType({
          name: "uint8",
          serialize: function(buffer2, data) {
            buffer2.push(checkRange(data, data & 255));
          },
          deserialize: function(buffer2) {
            return buffer2.get();
          }
        }),
        int8: createType({
          name: "int8",
          serialize: function(buffer2, data) {
            buffer2.push(checkRange(data, data << 24 >> 24));
          },
          deserialize: function(buffer2) {
            return buffer2.get() << 24 >> 24;
          }
        }),
        uint16: createType({
          name: "uint16",
          serialize: function(buffer2, data) {
            buffer2.pushUint16(checkRange(data, data & 65535));
          },
          deserialize: function(buffer2) {
            return buffer2.getUint16();
          }
        }),
        int16: createType({
          name: "int16",
          serialize: function(buffer2, data) {
            buffer2.pushUint16(checkRange(data, data << 16 >> 16));
          },
          deserialize: function(buffer2) {
            return buffer2.getUint16() << 16 >> 16;
          }
        }),
        uint32: createType({
          name: "uint32",
          serialize: function(buffer2, data) {
            buffer2.pushUint32(checkRange(data, data >>> 0));
          },
          deserialize: function(buffer2) {
            return buffer2.getUint32();
          }
        }),
        uint64: createType({
          name: "uint64",
          serialize: function(buffer2, data) {
            buffer2.pushArray(numeric.decimalToBinary(8, "" + data));
          },
          deserialize: function(buffer2) {
            return numeric.binaryToDecimal(buffer2.getUint8Array(8));
          }
        }),
        int64: createType({
          name: "int64",
          serialize: function(buffer2, data) {
            buffer2.pushArray(numeric.signedDecimalToBinary(8, "" + data));
          },
          deserialize: function(buffer2) {
            return numeric.signedBinaryToDecimal(buffer2.getUint8Array(8));
          }
        }),
        int32: createType({
          name: "int32",
          serialize: function(buffer2, data) {
            buffer2.pushUint32(checkRange(data, data | 0));
          },
          deserialize: function(buffer2) {
            return buffer2.getUint32() | 0;
          }
        }),
        varuint32: createType({
          name: "varuint32",
          serialize: function(buffer2, data) {
            buffer2.pushVaruint32(checkRange(data, data >>> 0));
          },
          deserialize: function(buffer2) {
            return buffer2.getVaruint32();
          }
        }),
        varint32: createType({
          name: "varint32",
          serialize: function(buffer2, data) {
            buffer2.pushVarint32(checkRange(data, data | 0));
          },
          deserialize: function(buffer2) {
            return buffer2.getVarint32();
          }
        }),
        uint128: createType({
          name: "uint128",
          serialize: function(buffer2, data) {
            buffer2.pushArray(numeric.decimalToBinary(16, "" + data));
          },
          deserialize: function(buffer2) {
            return numeric.binaryToDecimal(buffer2.getUint8Array(16));
          }
        }),
        int128: createType({
          name: "int128",
          serialize: function(buffer2, data) {
            buffer2.pushArray(numeric.signedDecimalToBinary(16, "" + data));
          },
          deserialize: function(buffer2) {
            return numeric.signedBinaryToDecimal(buffer2.getUint8Array(16));
          }
        }),
        float32: createType({
          name: "float32",
          serialize: function(buffer2, data) {
            buffer2.pushFloat32(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getFloat32();
          }
        }),
        float64: createType({
          name: "float64",
          serialize: function(buffer2, data) {
            buffer2.pushFloat64(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getFloat64();
          }
        }),
        float128: createType({
          name: "float128",
          serialize: function(buffer2, data) {
            buffer2.pushUint8ArrayChecked(exports.hexToUint8Array(data), 16);
          },
          deserialize: function(buffer2) {
            return exports.arrayToHex(buffer2.getUint8Array(16));
          }
        }),
        bytes: createType({
          name: "bytes",
          serialize: function(buffer2, data) {
            if (data instanceof Uint8Array || Array.isArray(data)) {
              buffer2.pushBytes(data);
            } else {
              buffer2.pushBytes(exports.hexToUint8Array(data));
            }
          },
          deserialize: function(buffer2, state) {
            if (state && state.options.bytesAsUint8Array) {
              return buffer2.getBytes();
            } else {
              return exports.arrayToHex(buffer2.getBytes());
            }
          }
        }),
        string: createType({
          name: "string",
          serialize: function(buffer2, data) {
            buffer2.pushString(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getString();
          }
        }),
        name: createType({
          name: "name",
          serialize: function(buffer2, data) {
            buffer2.pushName(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getName();
          }
        }),
        time_point: createType({
          name: "time_point",
          serialize: function(buffer2, data) {
            buffer2.pushNumberAsUint64(exports.dateToTimePoint(data));
          },
          deserialize: function(buffer2) {
            return exports.timePointToDate(buffer2.getUint64AsNumber());
          }
        }),
        time_point_sec: createType({
          name: "time_point_sec",
          serialize: function(buffer2, data) {
            buffer2.pushUint32(exports.dateToTimePointSec(data));
          },
          deserialize: function(buffer2) {
            return exports.timePointSecToDate(buffer2.getUint32());
          }
        }),
        block_timestamp_type: createType({
          name: "block_timestamp_type",
          serialize: function(buffer2, data) {
            buffer2.pushUint32(exports.dateToBlockTimestamp(data));
          },
          deserialize: function(buffer2) {
            return exports.blockTimestampToDate(buffer2.getUint32());
          }
        }),
        symbol_code: createType({
          name: "symbol_code",
          serialize: function(buffer2, data) {
            buffer2.pushSymbolCode(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getSymbolCode();
          }
        }),
        symbol: createType({
          name: "symbol",
          serialize: function(buffer2, data) {
            buffer2.pushSymbol(exports.stringToSymbol(data));
          },
          deserialize: function(buffer2) {
            return exports.symbolToString(buffer2.getSymbol());
          }
        }),
        asset: createType({
          name: "asset",
          serialize: function(buffer2, data) {
            buffer2.pushAsset(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getAsset();
          }
        }),
        checksum160: createType({
          name: "checksum160",
          serialize: function(buffer2, data) {
            buffer2.pushUint8ArrayChecked(exports.hexToUint8Array(data), 20);
          },
          deserialize: function(buffer2) {
            return exports.arrayToHex(buffer2.getUint8Array(20));
          }
        }),
        checksum256: createType({
          name: "checksum256",
          serialize: function(buffer2, data) {
            buffer2.pushUint8ArrayChecked(exports.hexToUint8Array(data), 32);
          },
          deserialize: function(buffer2) {
            return exports.arrayToHex(buffer2.getUint8Array(32));
          }
        }),
        checksum512: createType({
          name: "checksum512",
          serialize: function(buffer2, data) {
            buffer2.pushUint8ArrayChecked(exports.hexToUint8Array(data), 64);
          },
          deserialize: function(buffer2) {
            return exports.arrayToHex(buffer2.getUint8Array(64));
          }
        }),
        public_key: createType({
          name: "public_key",
          serialize: function(buffer2, data) {
            buffer2.pushPublicKey(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getPublicKey();
          }
        }),
        private_key: createType({
          name: "private_key",
          serialize: function(buffer2, data) {
            buffer2.pushPrivateKey(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getPrivateKey();
          }
        }),
        signature: createType({
          name: "signature",
          serialize: function(buffer2, data) {
            buffer2.pushSignature(data);
          },
          deserialize: function(buffer2) {
            return buffer2.getSignature();
          }
        })
      }));
      result.set("extended_asset", createType({
        name: "extended_asset",
        baseName: "",
        fields: [
          { name: "quantity", typeName: "asset", type: result.get("asset") },
          { name: "contract", typeName: "name", type: result.get("name") }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return result;
    };
    exports.createInitialTypes = createInitialTypes;
    var createAbiTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("extensions_entry", createType({
        name: "extensions_entry",
        baseName: "",
        fields: [
          { name: "tag", typeName: "uint16", type: null },
          { name: "value", typeName: "bytes", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("type_def", createType({
        name: "type_def",
        baseName: "",
        fields: [
          { name: "new_type_name", typeName: "string", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("field_def", createType({
        name: "field_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "string", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("struct_def", createType({
        name: "struct_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "string", type: null },
          { name: "base", typeName: "string", type: null },
          { name: "fields", typeName: "field_def[]", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("action_def", createType({
        name: "action_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "type", typeName: "string", type: null },
          { name: "ricardian_contract", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("table_def", createType({
        name: "table_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "index_type", typeName: "string", type: null },
          { name: "key_names", typeName: "string[]", type: null },
          { name: "key_types", typeName: "string[]", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("clause_pair", createType({
        name: "clause_pair",
        baseName: "",
        fields: [
          { name: "id", typeName: "string", type: null },
          { name: "body", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("error_message", createType({
        name: "error_message",
        baseName: "",
        fields: [
          { name: "error_code", typeName: "uint64", type: null },
          { name: "error_msg", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("variant_def", createType({
        name: "variant_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "string", type: null },
          { name: "types", typeName: "string[]", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("action_result", createType({
        name: "action_result",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "result_type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("primary_key_index_def", createType({
        name: "primary_key_index_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("secondary_index_def", createType({
        name: "secondary_index_def",
        baseName: "",
        fields: [
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("secondary_indices", createType({
        name: "secondary_indices",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "secondary_index_def", typeName: "secondary_index_def", type: null }
        ],
        serialize: serializeObject,
        deserialize: deserializeObject
      }));
      initialTypes.set("kv_table_entry_def", createType({
        name: "kv_table_entry_def",
        baseName: "",
        fields: [
          { name: "type", typeName: "string", type: null },
          { name: "primary_index", typeName: "primary_key_index_def", type: null },
          { name: "secondary_indices", typeName: "secondary_indices", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("kv_table", createType({
        name: "kv_table",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "kv_table_entry_def", typeName: "kv_table_entry_def", type: null }
        ],
        serialize: serializeObject,
        deserialize: deserializeObject
      }));
      initialTypes.set("abi_def", createType({
        name: "abi_def",
        baseName: "",
        fields: [
          { name: "version", typeName: "string", type: null },
          { name: "types", typeName: "type_def[]", type: null },
          { name: "structs", typeName: "struct_def[]", type: null },
          { name: "actions", typeName: "action_def[]", type: null },
          { name: "tables", typeName: "table_def[]", type: null },
          { name: "ricardian_clauses", typeName: "clause_pair[]", type: null },
          { name: "error_messages", typeName: "error_message[]", type: null },
          { name: "abi_extensions", typeName: "extensions_entry[]", type: null },
          { name: "variants", typeName: "variant_def[]$", type: null },
          { name: "action_results", typeName: "action_result[]$", type: null },
          { name: "kv_tables", typeName: "kv_table$", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return initialTypes;
    };
    exports.createAbiTypes = createAbiTypes;
    var createTransactionExtensionTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("resource_payer", createType({
        name: "resource_payer",
        baseName: "",
        fields: [
          { name: "payer", typeName: "name", type: null },
          { name: "max_net_bytes", typeName: "uint64", type: null },
          { name: "max_cpu_us", typeName: "uint64", type: null },
          { name: "max_memory_bytes", typeName: "uint64", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return initialTypes;
    };
    exports.createTransactionExtensionTypes = createTransactionExtensionTypes;
    var createTransactionTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("permission_level", createType({
        name: "permission_level",
        baseName: "",
        fields: [
          { name: "actor", typeName: "name", type: null },
          { name: "permission", typeName: "name", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("action", createType({
        name: "action",
        baseName: "",
        fields: [
          { name: "account", typeName: "name", type: null },
          { name: "name", typeName: "name", type: null },
          { name: "authorization", typeName: "permission_level[]", type: null },
          { name: "data", typeName: "bytes", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("extension", createType({
        name: "extension",
        baseName: "",
        fields: [
          { name: "type", typeName: "uint16", type: null },
          { name: "data", typeName: "bytes", type: null }
        ],
        serialize: serializePair,
        deserialize: deserializePair
      }));
      initialTypes.set("transaction_header", createType({
        name: "transaction_header",
        baseName: "",
        fields: [
          { name: "expiration", typeName: "time_point_sec", type: null },
          { name: "ref_block_num", typeName: "uint16", type: null },
          { name: "ref_block_prefix", typeName: "uint32", type: null },
          { name: "max_net_usage_words", typeName: "varuint32", type: null },
          { name: "max_cpu_usage_ms", typeName: "uint8", type: null },
          { name: "delay_sec", typeName: "varuint32", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("transaction", createType({
        name: "transaction",
        baseName: "transaction_header",
        fields: [
          { name: "context_free_actions", typeName: "action[]", type: null },
          { name: "actions", typeName: "action[]", type: null },
          { name: "transaction_extensions", typeName: "extension", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return initialTypes;
    };
    exports.createTransactionTypes = createTransactionTypes;
    var getType2 = function(types, name2) {
      var type2 = types.get(name2);
      if (type2 && type2.aliasOfName) {
        return exports.getType(types, type2.aliasOfName);
      }
      if (type2) {
        return type2;
      }
      if (name2.endsWith("[]")) {
        return createType({
          name: name2,
          arrayOf: exports.getType(types, name2.substr(0, name2.length - 2)),
          serialize: serializeArray,
          deserialize: deserializeArray
        });
      }
      if (name2.endsWith("?")) {
        return createType({
          name: name2,
          optionalOf: exports.getType(types, name2.substr(0, name2.length - 1)),
          serialize: serializeOptional,
          deserialize: deserializeOptional
        });
      }
      if (name2.endsWith("$")) {
        return createType({
          name: name2,
          extensionOf: exports.getType(types, name2.substr(0, name2.length - 1)),
          serialize: serializeExtension,
          deserialize: deserializeExtension
        });
      }
      throw new Error("Unknown type: " + name2);
    };
    exports.getType = getType2;
    var getTypesFromAbi = function(initialTypes, abi) {
      var e_6, _a2, e_7, _b, e_8, _c, e_9, _d, e_10, _e;
      var types = new Map(initialTypes);
      if (abi && abi.types) {
        try {
          for (var _f = __values(abi.types), _g = _f.next(); !_g.done; _g = _f.next()) {
            var _h = _g.value, new_type_name = _h.new_type_name, type2 = _h.type;
            types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type2 }));
          }
        } catch (e_6_1) {
          e_6 = { error: e_6_1 };
        } finally {
          try {
            if (_g && !_g.done && (_a2 = _f.return))
              _a2.call(_f);
          } finally {
            if (e_6)
              throw e_6.error;
          }
        }
      }
      if (abi && abi.structs) {
        try {
          for (var _j = __values(abi.structs), _k = _j.next(); !_k.done; _k = _j.next()) {
            var _l = _k.value, name_1 = _l.name, base2 = _l.base, fields = _l.fields;
            types.set(name_1, createType({
              name: name_1,
              baseName: base2,
              fields: fields.map(function(_a3) {
                var n3 = _a3.name, type3 = _a3.type;
                return { name: n3, typeName: type3, type: null };
              }),
              serialize: serializeStruct,
              deserialize: deserializeStruct
            }));
          }
        } catch (e_7_1) {
          e_7 = { error: e_7_1 };
        } finally {
          try {
            if (_k && !_k.done && (_b = _j.return))
              _b.call(_j);
          } finally {
            if (e_7)
              throw e_7.error;
          }
        }
      }
      if (abi && abi.variants) {
        try {
          for (var _m = __values(abi.variants), _o = _m.next(); !_o.done; _o = _m.next()) {
            var _p = _o.value, name_2 = _p.name, t5 = _p.types;
            types.set(name_2, createType({
              name: name_2,
              fields: t5.map(function(s6) {
                return { name: s6, typeName: s6, type: null };
              }),
              serialize: serializeVariant,
              deserialize: deserializeVariant
            }));
          }
        } catch (e_8_1) {
          e_8 = { error: e_8_1 };
        } finally {
          try {
            if (_o && !_o.done && (_c = _m.return))
              _c.call(_m);
          } finally {
            if (e_8)
              throw e_8.error;
          }
        }
      }
      try {
        for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
          var _q = __read(types_1_1.value, 2), name_3 = _q[0], type2 = _q[1];
          if (type2.baseName) {
            type2.base = exports.getType(types, type2.baseName);
          }
          try {
            for (var _r = (e_10 = void 0, __values(type2.fields)), _s = _r.next(); !_s.done; _s = _r.next()) {
              var field = _s.value;
              field.type = exports.getType(types, field.typeName);
            }
          } catch (e_10_1) {
            e_10 = { error: e_10_1 };
          } finally {
            try {
              if (_s && !_s.done && (_e = _r.return))
                _e.call(_r);
            } finally {
              if (e_10)
                throw e_10.error;
            }
          }
        }
      } catch (e_9_1) {
        e_9 = { error: e_9_1 };
      } finally {
        try {
          if (types_1_1 && !types_1_1.done && (_d = types_1.return))
            _d.call(types_1);
        } finally {
          if (e_9)
            throw e_9.error;
        }
      }
      return types;
    };
    exports.getTypesFromAbi = getTypesFromAbi;
    var reverseHex = function(h5) {
      return h5.substr(6, 2) + h5.substr(4, 2) + h5.substr(2, 2) + h5.substr(0, 2);
    };
    var transactionHeader = function(refBlock, expireSeconds) {
      var timestamp2 = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;
      var prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);
      return {
        expiration: exports.timePointSecToDate(exports.dateToTimePointSec(timestamp2) + expireSeconds),
        ref_block_num: refBlock.block_num & 65535,
        ref_block_prefix: prefix
      };
    };
    exports.transactionHeader = transactionHeader;
    var serializeActionData = function(contract, account, name2, data, textEncoder, textDecoder) {
      var action = contract.actions.get(name2);
      if (!action) {
        throw new Error("Unknown action " + name2 + " in contract " + account);
      }
      var buffer2 = new SerialBuffer({ textEncoder, textDecoder });
      action.serialize(buffer2, data);
      return exports.arrayToHex(buffer2.asUint8Array());
    };
    exports.serializeActionData = serializeActionData;
    var serializeAction = function(contract, account, name2, authorization, data, textEncoder, textDecoder) {
      return {
        account,
        name: name2,
        authorization,
        data: exports.serializeActionData(contract, account, name2, data, textEncoder, textDecoder)
      };
    };
    exports.serializeAction = serializeAction;
    var deserializeActionData = function(contract, account, name2, data, textEncoder, textDecoder) {
      var action = contract.actions.get(name2);
      if (typeof data === "string") {
        data = exports.hexToUint8Array(data);
      }
      if (!action) {
        throw new Error("Unknown action " + name2 + " in contract " + account);
      }
      var buffer2 = new SerialBuffer({ textDecoder, textEncoder });
      buffer2.pushArray(data);
      return action.deserialize(buffer2);
    };
    exports.deserializeActionData = deserializeActionData;
    var deserializeAction = function(contract, account, name2, authorization, data, textEncoder, textDecoder) {
      return {
        account,
        name: name2,
        authorization,
        data: exports.deserializeActionData(contract, account, name2, data, textEncoder, textDecoder)
      };
    };
    exports.deserializeAction = deserializeAction;
    var serializeAnyvar = function(buffer2, anyvar) {
      var _a2, _b, _c, _d, _e, _f, _g;
      var def;
      var value;
      if (anyvar === null) {
        _a2 = __read([anyvarDefs.null_t, anyvar], 2), def = _a2[0], value = _a2[1];
      } else if (typeof anyvar === "string") {
        _b = __read([anyvarDefs.string, anyvar], 2), def = _b[0], value = _b[1];
      } else if (typeof anyvar === "number") {
        _c = __read([anyvarDefs.int32, anyvar], 2), def = _c[0], value = _c[1];
      } else if (anyvar instanceof Uint8Array) {
        _d = __read([anyvarDefs.bytes, anyvar], 2), def = _d[0], value = _d[1];
      } else if (Array.isArray(anyvar)) {
        _e = __read([anyvarDefs.any_array, anyvar], 2), def = _e[0], value = _e[1];
      } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty("type") && anyvar.hasOwnProperty("value")) {
        _f = __read([anyvarDefs[anyvar.type], anyvar.value], 2), def = _f[0], value = _f[1];
      } else {
        _g = __read([anyvarDefs.any_object, anyvar], 2), def = _g[0], value = _g[1];
      }
      buffer2.pushVaruint32(def.index);
      def.type.serialize(buffer2, value);
    };
    exports.serializeAnyvar = serializeAnyvar;
    var deserializeAnyvar = function(buffer2, state) {
      var defIndex = buffer2.getVaruint32();
      if (defIndex >= anyvarDefsByIndex.length) {
        throw new Error("Tried to deserialize unknown anyvar type");
      }
      var def = anyvarDefsByIndex[defIndex];
      var value = def.type.deserialize(buffer2, state);
      if (state && state.options.useShortForm || def.useShortForm) {
        return value;
      } else {
        return { type: def.type.name, value };
      }
    };
    exports.deserializeAnyvar = deserializeAnyvar;
    var deserializeAnyvarShort = function(buffer2) {
      return exports.deserializeAnyvar(buffer2, new SerializerState({ useShortForm: true }));
    };
    exports.deserializeAnyvarShort = deserializeAnyvarShort;
    var serializeAnyObject = function(buffer2, obj) {
      var e_11, _a2;
      var entries = Object.entries(obj);
      buffer2.pushVaruint32(entries.length);
      try {
        for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {
          var _b = __read(entries_2_1.value, 2), key2 = _b[0], value = _b[1];
          buffer2.pushString(key2);
          exports.serializeAnyvar(buffer2, value);
        }
      } catch (e_11_1) {
        e_11 = { error: e_11_1 };
      } finally {
        try {
          if (entries_2_1 && !entries_2_1.done && (_a2 = entries_2.return))
            _a2.call(entries_2);
        } finally {
          if (e_11)
            throw e_11.error;
        }
      }
    };
    exports.serializeAnyObject = serializeAnyObject;
    var deserializeAnyObject = function(buffer2, state) {
      var len = buffer2.getVaruint32();
      var result = {};
      for (var i5 = 0; i5 < len; ++i5) {
        var key2 = buffer2.getString();
        if (key2 in result) {
          var j5 = 1;
          while (key2 + "_" + j5 in result) {
            ++j5;
          }
          key2 = key2 + "_" + j5;
        }
        result[key2] = exports.deserializeAnyvar(buffer2, state);
      }
      return result;
    };
    exports.deserializeAnyObject = deserializeAnyObject;
    var serializeAnyArray = function(buffer2, arr) {
      var e_12, _a2;
      buffer2.pushVaruint32(arr.length);
      try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
          var x5 = arr_1_1.value;
          exports.serializeAnyvar(buffer2, x5);
        }
      } catch (e_12_1) {
        e_12 = { error: e_12_1 };
      } finally {
        try {
          if (arr_1_1 && !arr_1_1.done && (_a2 = arr_1.return))
            _a2.call(arr_1);
        } finally {
          if (e_12)
            throw e_12.error;
        }
      }
    };
    exports.serializeAnyArray = serializeAnyArray;
    var deserializeAnyArray = function(buffer2, state) {
      var len = buffer2.getVaruint32();
      var result = [];
      for (var i5 = 0; i5 < len; ++i5) {
        result.push(exports.deserializeAnyvar(buffer2, state));
      }
      return result;
    };
    exports.deserializeAnyArray = deserializeAnyArray;
    var addAdditionalTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("null_t", createType({
        name: "null_t",
        serialize: function(buffer2, anyvar) {
        },
        deserialize: function(buffer2, state) {
        }
      }));
      initialTypes.set("any_object", createType({
        name: "any_object",
        serialize: exports.serializeAnyObject,
        deserialize: exports.deserializeAnyObject
      }));
      initialTypes.set("any_array", createType({
        name: "any_array",
        serialize: exports.serializeAnyArray,
        deserialize: exports.deserializeAnyArray
      }));
      return initialTypes;
    };
    var additionalTypes = addAdditionalTypes();
    var anyvarDefs = {
      null_t: { index: 0, useShortForm: true, type: additionalTypes.get("null_t") },
      int64: { index: 1, useShortForm: false, type: additionalTypes.get("int64") },
      uint64: { index: 2, useShortForm: false, type: additionalTypes.get("uint64") },
      int32: { index: 3, useShortForm: true, type: additionalTypes.get("int32") },
      uint32: { index: 4, useShortForm: false, type: additionalTypes.get("uint32") },
      int16: { index: 5, useShortForm: false, type: additionalTypes.get("int16") },
      uint16: { index: 6, useShortForm: false, type: additionalTypes.get("uint16") },
      int8: { index: 7, useShortForm: false, type: additionalTypes.get("int8") },
      uint8: { index: 8, useShortForm: false, type: additionalTypes.get("uint8") },
      time_point: { index: 9, useShortForm: false, type: additionalTypes.get("time_point") },
      checksum256: { index: 10, useShortForm: false, type: additionalTypes.get("checksum256") },
      float64: { index: 11, useShortForm: false, type: additionalTypes.get("float64") },
      string: { index: 12, useShortForm: true, type: additionalTypes.get("string") },
      any_object: { index: 13, useShortForm: true, type: additionalTypes.get("any_object") },
      any_array: { index: 14, useShortForm: true, type: additionalTypes.get("any_array") },
      bytes: { index: 15, useShortForm: false, type: additionalTypes.get("bytes") },
      symbol: { index: 16, useShortForm: false, type: additionalTypes.get("symbol") },
      symbol_code: { index: 17, useShortForm: false, type: additionalTypes.get("symbol_code") },
      asset: { index: 18, useShortForm: false, type: additionalTypes.get("asset") }
    };
    var anyvarDefsByIndex = [
      anyvarDefs.null_t,
      anyvarDefs.int64,
      anyvarDefs.uint64,
      anyvarDefs.int32,
      anyvarDefs.uint32,
      anyvarDefs.int16,
      anyvarDefs.uint16,
      anyvarDefs.int8,
      anyvarDefs.uint8,
      anyvarDefs.time_point,
      anyvarDefs.checksum256,
      anyvarDefs.float64,
      anyvarDefs.string,
      anyvarDefs.any_object,
      anyvarDefs.any_array,
      anyvarDefs.bytes,
      anyvarDefs.symbol,
      anyvarDefs.symbol_code,
      anyvarDefs.asset
    ];
    var serializeQuery = function(buffer2, query) {
      var _a2, _b, _c, e_13, _d;
      var method;
      var arg;
      var filter2;
      if (typeof query === "string") {
        method = query;
      } else if (Array.isArray(query) && query.length === 2) {
        _a2 = __read(query, 2), method = _a2[0], filter2 = _a2[1];
      } else if (Array.isArray(query) && query.length === 3) {
        _b = __read(query, 3), method = _b[0], arg = _b[1], filter2 = _b[2];
      } else {
        _c = __read([query.method, query.arg, query.filter], 3), method = _c[0], arg = _c[1], filter2 = _c[2];
      }
      buffer2.pushString(method);
      if (arg === void 0) {
        buffer2.push(0);
      } else {
        buffer2.push(1);
        exports.serializeAnyvar(buffer2, arg);
      }
      if (filter2 === void 0) {
        buffer2.push(0);
      } else {
        buffer2.pushVaruint32(filter2.length);
        try {
          for (var filter_1 = __values(filter2), filter_1_1 = filter_1.next(); !filter_1_1.done; filter_1_1 = filter_1.next()) {
            var q5 = filter_1_1.value;
            exports.serializeQuery(buffer2, q5);
          }
        } catch (e_13_1) {
          e_13 = { error: e_13_1 };
        } finally {
          try {
            if (filter_1_1 && !filter_1_1.done && (_d = filter_1.return))
              _d.call(filter_1);
          } finally {
            if (e_13)
              throw e_13.error;
          }
        }
      }
    };
    exports.serializeQuery = serializeQuery;
  }
});

// node_modules/eosjs/dist/eosjs-api.js
var require_eosjs_api = __commonJS({
  "node_modules/eosjs/dist/eosjs-api.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t5) {
        for (var s6, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
          s6 = arguments[i5];
          for (var p5 in s6)
            if (Object.prototype.hasOwnProperty.call(s6, p5))
              t5[p5] = s6[p5];
        }
        return t5;
      };
      return __assign2.apply(this, arguments);
    };
    var __awaiter22 = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator5 = exports && exports.__generator || function(thisArg, body) {
      var _10 = { label: 0, sent: function() {
        if (t5[0] & 1)
          throw t5[1];
        return t5[1];
      }, trys: [], ops: [] }, f7, y5, t5, g5;
      return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
        return this;
      }), g5;
      function verb(n3) {
        return function(v8) {
          return step([n3, v8]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_10)
          try {
            if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
              return t5;
            if (y5 = 0, t5)
              op = [op[0] & 2, t5.value];
            switch (op[0]) {
              case 0:
              case 1:
                t5 = op;
                break;
              case 4:
                _10.label++;
                return { value: op[1], done: false };
              case 5:
                _10.label++;
                y5 = op[1];
                op = [0];
                continue;
              case 7:
                op = _10.ops.pop();
                _10.trys.pop();
                continue;
              default:
                if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _10 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                  _10.label = op[1];
                  break;
                }
                if (op[0] === 6 && _10.label < t5[1]) {
                  _10.label = t5[1];
                  t5 = op;
                  break;
                }
                if (t5 && _10.label < t5[2]) {
                  _10.label = t5[2];
                  _10.ops.push(op);
                  break;
                }
                if (t5[2])
                  _10.ops.pop();
                _10.trys.pop();
                continue;
            }
            op = body.call(thisArg, _10);
          } catch (e5) {
            op = [6, e5];
            y5 = 0;
          } finally {
            f7 = t5 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports && exports.__read || function(o5, n3) {
      var m5 = typeof Symbol === "function" && o5[Symbol.iterator];
      if (!m5)
        return o5;
      var i5 = m5.call(o5), r6, ar = [], e5;
      try {
        while ((n3 === void 0 || n3-- > 0) && !(r6 = i5.next()).done)
          ar.push(r6.value);
      } catch (error) {
        e5 = { error };
      } finally {
        try {
          if (r6 && !r6.done && (m5 = i5["return"]))
            m5.call(i5);
        } finally {
          if (e5)
            throw e5.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
      for (var i5 = 0, il = from2.length, j5 = to.length; i5 < il; i5++, j5++)
        to[j5] = from2[i5];
      return to;
    };
    var __values = exports && exports.__values || function(o5) {
      var s6 = typeof Symbol === "function" && Symbol.iterator, m5 = s6 && o5[s6], i5 = 0;
      if (m5)
        return m5.call(o5);
      if (o5 && typeof o5.length === "number")
        return {
          next: function() {
            if (o5 && i5 >= o5.length)
              o5 = void 0;
            return { value: o5 && o5[i5++], done: !o5 };
          }
        };
      throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionBuilder = exports.TransactionBuilder = exports.Api = void 0;
    var pako_1 = require_pako();
    var ser = require_eosjs_serialize();
    var Api = function() {
      function Api2(args) {
        this.contracts = new Map();
        this.cachedAbis = new Map();
        this.transactionExtensions = [
          { id: 1, type: "resource_payer", keys: ["payer", "max_net_bytes", "max_cpu_us", "max_memory_bytes"] }
        ];
        this.rpc = args.rpc;
        this.authorityProvider = args.authorityProvider || args.rpc;
        this.abiProvider = args.abiProvider || args.rpc;
        this.signatureProvider = args.signatureProvider;
        this.chainId = args.chainId;
        this.textEncoder = args.textEncoder;
        this.textDecoder = args.textDecoder;
        this.abiTypes = ser.getTypesFromAbi(ser.createAbiTypes());
        this.transactionTypes = ser.getTypesFromAbi(ser.createTransactionTypes());
      }
      Api2.prototype.rawAbiToJson = function(rawAbi) {
        var buffer2 = new ser.SerialBuffer({
          textEncoder: this.textEncoder,
          textDecoder: this.textDecoder,
          array: rawAbi
        });
        if (!ser.supportedAbiVersion(buffer2.getString())) {
          throw new Error("Unsupported abi version");
        }
        buffer2.restartRead();
        return this.abiTypes.get("abi_def").deserialize(buffer2);
      };
      Api2.prototype.jsonToRawAbi = function(jsonAbi) {
        var buffer2 = new ser.SerialBuffer({
          textEncoder: this.textEncoder,
          textDecoder: this.textDecoder
        });
        this.abiTypes.get("abi_def").serialize(buffer2, jsonAbi);
        if (!ser.supportedAbiVersion(buffer2.getString())) {
          throw new Error("Unsupported abi version");
        }
        return buffer2.asUint8Array();
      };
      Api2.prototype.getCachedAbi = function(accountName, reload) {
        if (reload === void 0) {
          reload = false;
        }
        return __awaiter22(this, void 0, void 0, function() {
          var cachedAbi, rawAbi, abi, e_1;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!reload && this.cachedAbis.get(accountName)) {
                  return [2, this.cachedAbis.get(accountName)];
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.abiProvider.getRawAbi(accountName)];
              case 2:
                rawAbi = _a2.sent().abi;
                abi = this.rawAbiToJson(rawAbi);
                cachedAbi = { rawAbi, abi };
                return [3, 4];
              case 3:
                e_1 = _a2.sent();
                e_1.message = "fetching abi for " + accountName + ": " + e_1.message;
                throw e_1;
              case 4:
                if (!cachedAbi) {
                  throw new Error("Missing abi for " + accountName);
                }
                this.cachedAbis.set(accountName, cachedAbi);
                return [2, cachedAbi];
            }
          });
        });
      };
      Api2.prototype.getAbi = function(accountName, reload) {
        if (reload === void 0) {
          reload = false;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.getCachedAbi(accountName, reload)];
              case 1:
                return [2, _a2.sent().abi];
            }
          });
        });
      };
      Api2.prototype.getTransactionAbis = function(transaction, reload) {
        if (reload === void 0) {
          reload = false;
        }
        return __awaiter22(this, void 0, void 0, function() {
          var actions, accounts, uniqueAccounts, actionPromises;
          var _this = this;
          return __generator5(this, function(_a2) {
            actions = (transaction.context_free_actions || []).concat(transaction.actions);
            accounts = actions.map(function(action) {
              return action.account;
            });
            uniqueAccounts = new Set(accounts);
            actionPromises = __spreadArray([], __read(uniqueAccounts)).map(function(account) {
              return __awaiter22(_this, void 0, void 0, function() {
                var _a3;
                return __generator5(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _a3 = {
                        accountName: account
                      };
                      return [4, this.getCachedAbi(account, reload)];
                    case 1:
                      return [2, (_a3.abi = _b.sent().rawAbi, _a3)];
                  }
                });
              });
            });
            return [2, Promise.all(actionPromises)];
          });
        });
      };
      Api2.prototype.getContract = function(accountName, reload) {
        if (reload === void 0) {
          reload = false;
        }
        return __awaiter22(this, void 0, void 0, function() {
          var abi, types, actions, _a2, _b, _c, name_1, type2, result;
          var e_2, _d;
          return __generator5(this, function(_e) {
            switch (_e.label) {
              case 0:
                if (!reload && this.contracts.get(accountName)) {
                  return [2, this.contracts.get(accountName)];
                }
                return [4, this.getAbi(accountName, reload)];
              case 1:
                abi = _e.sent();
                types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);
                actions = new Map();
                try {
                  for (_a2 = __values(abi.actions), _b = _a2.next(); !_b.done; _b = _a2.next()) {
                    _c = _b.value, name_1 = _c.name, type2 = _c.type;
                    actions.set(name_1, ser.getType(types, type2));
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (_b && !_b.done && (_d = _a2.return))
                      _d.call(_a2);
                  } finally {
                    if (e_2)
                      throw e_2.error;
                  }
                }
                result = { types, actions };
                this.contracts.set(accountName, result);
                return [2, result];
            }
          });
        });
      };
      Api2.prototype.serialize = function(buffer2, type2, value) {
        this.transactionTypes.get(type2).serialize(buffer2, value);
      };
      Api2.prototype.deserialize = function(buffer2, type2) {
        return this.transactionTypes.get(type2).deserialize(buffer2);
      };
      Api2.prototype.serializeTransaction = function(transaction) {
        var buffer2 = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
        this.serialize(buffer2, "transaction", __assign2({ max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0, context_free_actions: [], actions: [], transaction_extensions: [] }, transaction));
        return buffer2.asUint8Array();
      };
      Api2.prototype.serializeContextFreeData = function(contextFreeData) {
        var e_3, _a2;
        if (!contextFreeData || !contextFreeData.length) {
          return null;
        }
        var buffer2 = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
        buffer2.pushVaruint32(contextFreeData.length);
        try {
          for (var contextFreeData_1 = __values(contextFreeData), contextFreeData_1_1 = contextFreeData_1.next(); !contextFreeData_1_1.done; contextFreeData_1_1 = contextFreeData_1.next()) {
            var data = contextFreeData_1_1.value;
            buffer2.pushBytes(data);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (contextFreeData_1_1 && !contextFreeData_1_1.done && (_a2 = contextFreeData_1.return))
              _a2.call(contextFreeData_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return buffer2.asUint8Array();
      };
      Api2.prototype.deserializeTransaction = function(transaction) {
        var buffer2 = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
        buffer2.pushArray(transaction);
        return this.deserialize(buffer2, "transaction");
      };
      Api2.prototype.serializeTransactionExtensions = function(transaction) {
        var transaction_extensions = [];
        if (transaction.resource_payer) {
          var extensionBuffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          var types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());
          types.get("resource_payer").serialize(extensionBuffer, transaction.resource_payer);
          transaction_extensions = __spreadArray(__spreadArray([], __read(transaction_extensions)), [[1, ser.arrayToHex(extensionBuffer.asUint8Array())]]);
        }
        return transaction_extensions;
      };
      ;
      Api2.prototype.deserializeTransactionExtensions = function(data) {
        var _this = this;
        var transaction = {};
        data.forEach(function(extensionData) {
          var transactionExtension = _this.transactionExtensions.find(function(extension) {
            return extension.id === extensionData[0];
          });
          if (transactionExtension === void 0) {
            throw new Error("Transaction Extension could not be determined: " + extensionData);
          }
          var types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());
          var extensionBuffer = new ser.SerialBuffer({ textEncoder: _this.textEncoder, textDecoder: _this.textDecoder });
          extensionBuffer.pushArray(ser.hexToUint8Array(extensionData[1]));
          var deserializedObj = types.get(transactionExtension.type).deserialize(extensionBuffer);
          if (extensionData[0] === 1) {
            deserializedObj.max_net_bytes = Number(deserializedObj.max_net_bytes);
            deserializedObj.max_cpu_us = Number(deserializedObj.max_cpu_us);
            deserializedObj.max_memory_bytes = Number(deserializedObj.max_memory_bytes);
            transaction.resource_payer = deserializedObj;
          }
        });
        return transaction;
      };
      ;
      Api2.prototype.deleteTransactionExtensionObjects = function(transaction) {
        delete transaction.resource_payer;
        return transaction;
      };
      Api2.prototype.serializeActions = function(actions) {
        return __awaiter22(this, void 0, void 0, function() {
          var _this = this;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, Promise.all(actions.map(function(action) {
                  return __awaiter22(_this, void 0, void 0, function() {
                    var account, name2, authorization, data, contract;
                    return __generator5(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          account = action.account, name2 = action.name, authorization = action.authorization, data = action.data;
                          return [4, this.getContract(account)];
                        case 1:
                          contract = _a3.sent();
                          if (typeof data !== "object") {
                            return [2, action];
                          }
                          return [2, ser.serializeAction(contract, account, name2, authorization, data, this.textEncoder, this.textDecoder)];
                      }
                    });
                  });
                }))];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      Api2.prototype.deserializeActions = function(actions) {
        return __awaiter22(this, void 0, void 0, function() {
          var _this = this;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, Promise.all(actions.map(function(_a3) {
                  var account = _a3.account, name2 = _a3.name, authorization = _a3.authorization, data = _a3.data;
                  return __awaiter22(_this, void 0, void 0, function() {
                    var contract;
                    return __generator5(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          return [4, this.getContract(account)];
                        case 1:
                          contract = _b.sent();
                          return [2, ser.deserializeAction(contract, account, name2, authorization, data, this.textEncoder, this.textDecoder)];
                      }
                    });
                  });
                }))];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      Api2.prototype.deserializeTransactionWithActions = function(transaction) {
        return __awaiter22(this, void 0, void 0, function() {
          var deserializedTransaction, deserializedCFActions, deserializedActions;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (typeof transaction === "string") {
                  transaction = ser.hexToUint8Array(transaction);
                }
                deserializedTransaction = this.deserializeTransaction(transaction);
                return [4, this.deserializeActions(deserializedTransaction.context_free_actions)];
              case 1:
                deserializedCFActions = _a2.sent();
                return [4, this.deserializeActions(deserializedTransaction.actions)];
              case 2:
                deserializedActions = _a2.sent();
                return [2, __assign2(__assign2({}, deserializedTransaction), { context_free_actions: deserializedCFActions, actions: deserializedActions })];
            }
          });
        });
      };
      Api2.prototype.deflateSerializedArray = function(serializedArray) {
        return pako_1.deflate(serializedArray, { level: 9 });
      };
      Api2.prototype.inflateSerializedArray = function(compressedSerializedArray) {
        return pako_1.inflate(compressedSerializedArray);
      };
      Api2.prototype.transact = function(transaction, _a2) {
        var _b = _a2 === void 0 ? {} : _a2, _c = _b.broadcast, broadcast = _c === void 0 ? true : _c, _d = _b.sign, sign3 = _d === void 0 ? true : _d, readOnlyTrx = _b.readOnlyTrx, returnFailureTraces = _b.returnFailureTraces, requiredKeys = _b.requiredKeys, compression = _b.compression, blocksBehind = _b.blocksBehind, useLastIrreversible = _b.useLastIrreversible, expireSeconds = _b.expireSeconds;
        return __awaiter22(this, void 0, void 0, function() {
          var info, abis, _e, serializedTransaction, serializedContextFreeData, pushTransactionArgs, availableKeys;
          var _f;
          return __generator5(this, function(_g) {
            switch (_g.label) {
              case 0:
                if (typeof blocksBehind === "number" && useLastIrreversible) {
                  throw new Error("Use either blocksBehind or useLastIrreversible");
                }
                if (!!this.chainId)
                  return [3, 2];
                return [4, this.rpc.get_info()];
              case 1:
                info = _g.sent();
                this.chainId = info.chain_id;
                _g.label = 2;
              case 2:
                if (!((typeof blocksBehind === "number" || useLastIrreversible) && expireSeconds))
                  return [3, 4];
                return [4, this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds)];
              case 3:
                transaction = _g.sent();
                _g.label = 4;
              case 4:
                if (!this.hasRequiredTaposFields(transaction)) {
                  throw new Error("Required configuration or TAPOS fields are not present");
                }
                return [4, this.getTransactionAbis(transaction)];
              case 5:
                abis = _g.sent();
                _e = [__assign2({}, transaction)];
                _f = {};
                return [4, this.serializeTransactionExtensions(transaction)];
              case 6:
                _f.transaction_extensions = _g.sent();
                return [4, this.serializeActions(transaction.context_free_actions || [])];
              case 7:
                _f.context_free_actions = _g.sent();
                return [4, this.serializeActions(transaction.actions)];
              case 8:
                transaction = __assign2.apply(void 0, _e.concat([(_f.actions = _g.sent(), _f)]));
                transaction = this.deleteTransactionExtensionObjects(transaction);
                serializedTransaction = this.serializeTransaction(transaction);
                serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
                pushTransactionArgs = {
                  serializedTransaction,
                  serializedContextFreeData,
                  signatures: []
                };
                if (!sign3)
                  return [3, 13];
                if (!!requiredKeys)
                  return [3, 11];
                return [4, this.signatureProvider.getAvailableKeys()];
              case 9:
                availableKeys = _g.sent();
                return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
              case 10:
                requiredKeys = _g.sent();
                _g.label = 11;
              case 11:
                return [4, this.signatureProvider.sign({
                  chainId: this.chainId,
                  requiredKeys,
                  serializedTransaction,
                  serializedContextFreeData,
                  abis
                })];
              case 12:
                pushTransactionArgs = _g.sent();
                _g.label = 13;
              case 13:
                if (broadcast) {
                  if (compression) {
                    return [2, this.pushCompressedSignedTransaction(pushTransactionArgs, readOnlyTrx, returnFailureTraces)];
                  }
                  return [2, this.pushSignedTransaction(pushTransactionArgs, readOnlyTrx, returnFailureTraces)];
                }
                return [2, pushTransactionArgs];
            }
          });
        });
      };
      Api2.prototype.query = function(account, short, query, _a2) {
        var sign3 = _a2.sign, requiredKeys = _a2.requiredKeys, _b = _a2.authorization, authorization = _b === void 0 ? [] : _b;
        return __awaiter22(this, void 0, void 0, function() {
          var info, refBlock, queryBuffer, transaction, serializedTransaction, signatures, abis, availableKeys, signResponse, response, returnBuffer;
          return __generator5(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, this.rpc.get_info()];
              case 1:
                info = _c.sent();
                return [4, this.tryRefBlockFromGetInfo(info)];
              case 2:
                refBlock = _c.sent();
                queryBuffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
                ser.serializeQuery(queryBuffer, query);
                transaction = __assign2(__assign2({}, ser.transactionHeader(refBlock, 60 * 30)), { context_free_actions: [], actions: [{
                  account,
                  name: "queryit",
                  authorization,
                  data: ser.arrayToHex(queryBuffer.asUint8Array())
                }] });
                serializedTransaction = this.serializeTransaction(transaction);
                signatures = [];
                if (!sign3)
                  return [3, 8];
                return [4, this.getTransactionAbis(transaction)];
              case 3:
                abis = _c.sent();
                if (!!requiredKeys)
                  return [3, 6];
                return [4, this.signatureProvider.getAvailableKeys()];
              case 4:
                availableKeys = _c.sent();
                return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
              case 5:
                requiredKeys = _c.sent();
                _c.label = 6;
              case 6:
                return [4, this.signatureProvider.sign({
                  chainId: this.chainId,
                  requiredKeys,
                  serializedTransaction,
                  serializedContextFreeData: null,
                  abis
                })];
              case 7:
                signResponse = _c.sent();
                signatures = signResponse.signatures;
                _c.label = 8;
              case 8:
                return [4, this.rpc.send_transaction({
                  signatures,
                  compression: 0,
                  serializedTransaction
                })];
              case 9:
                response = _c.sent();
                returnBuffer = new ser.SerialBuffer({
                  textEncoder: this.textEncoder,
                  textDecoder: this.textDecoder,
                  array: ser.hexToUint8Array(response.processed.action_traces[0][1].return_value)
                });
                if (short) {
                  return [2, ser.deserializeAnyvarShort(returnBuffer)];
                } else {
                  return [2, ser.deserializeAnyvar(returnBuffer)];
                }
                return [2];
            }
          });
        });
      };
      Api2.prototype.pushSignedTransaction = function(_a2, readOnlyTrx, returnFailureTraces) {
        var signatures = _a2.signatures, serializedTransaction = _a2.serializedTransaction, serializedContextFreeData = _a2.serializedContextFreeData;
        if (readOnlyTrx === void 0) {
          readOnlyTrx = false;
        }
        if (returnFailureTraces === void 0) {
          returnFailureTraces = false;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_b) {
            if (readOnlyTrx) {
              return [2, this.rpc.push_ro_transaction({
                signatures,
                serializedTransaction,
                serializedContextFreeData
              }, returnFailureTraces)];
            }
            return [2, this.rpc.push_transaction({
              signatures,
              serializedTransaction,
              serializedContextFreeData
            })];
          });
        });
      };
      Api2.prototype.pushCompressedSignedTransaction = function(_a2, readOnlyTrx, returnFailureTraces) {
        var signatures = _a2.signatures, serializedTransaction = _a2.serializedTransaction, serializedContextFreeData = _a2.serializedContextFreeData;
        if (readOnlyTrx === void 0) {
          readOnlyTrx = false;
        }
        if (returnFailureTraces === void 0) {
          returnFailureTraces = false;
        }
        return __awaiter22(this, void 0, void 0, function() {
          var compressedSerializedTransaction, compressedSerializedContextFreeData;
          return __generator5(this, function(_b) {
            compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);
            compressedSerializedContextFreeData = this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));
            if (readOnlyTrx) {
              return [2, this.rpc.push_ro_transaction({
                signatures,
                compression: 1,
                serializedTransaction: compressedSerializedTransaction,
                serializedContextFreeData: compressedSerializedContextFreeData
              }, returnFailureTraces)];
            }
            return [2, this.rpc.push_transaction({
              signatures,
              compression: 1,
              serializedTransaction: compressedSerializedTransaction,
              serializedContextFreeData: compressedSerializedContextFreeData
            })];
          });
        });
      };
      Api2.prototype.generateTapos = function(info, transaction, blocksBehind, useLastIrreversible, expireSeconds) {
        return __awaiter22(this, void 0, void 0, function() {
          var block, taposBlockNumber, refBlock, _a2;
          return __generator5(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!!info)
                  return [3, 2];
                return [4, this.rpc.get_info()];
              case 1:
                info = _b.sent();
                _b.label = 2;
              case 2:
                if (!useLastIrreversible)
                  return [3, 4];
                return [4, this.tryRefBlockFromGetInfo(info)];
              case 3:
                block = _b.sent();
                return [2, __assign2(__assign2({}, ser.transactionHeader(block, expireSeconds)), transaction)];
              case 4:
                taposBlockNumber = info.head_block_num - blocksBehind;
                if (!(taposBlockNumber <= info.last_irreversible_block_num))
                  return [3, 6];
                return [4, this.tryGetBlockInfo(taposBlockNumber)];
              case 5:
                _a2 = _b.sent();
                return [3, 8];
              case 6:
                return [4, this.tryGetBlockHeaderState(taposBlockNumber)];
              case 7:
                _a2 = _b.sent();
                _b.label = 8;
              case 8:
                refBlock = _a2;
                return [2, __assign2(__assign2({}, ser.transactionHeader(refBlock, expireSeconds)), transaction)];
            }
          });
        });
      };
      Api2.prototype.hasRequiredTaposFields = function(_a2) {
        var expiration = _a2.expiration, ref_block_num = _a2.ref_block_num, ref_block_prefix = _a2.ref_block_prefix;
        return !!(expiration && typeof ref_block_num === "number" && typeof ref_block_prefix === "number");
      };
      Api2.prototype.tryGetBlockHeaderState = function(taposBlockNumber) {
        return __awaiter22(this, void 0, void 0, function() {
          var error_1;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 4]);
                return [4, this.rpc.get_block_header_state(taposBlockNumber)];
              case 1:
                return [2, _a2.sent()];
              case 2:
                error_1 = _a2.sent();
                return [4, this.tryGetBlockInfo(taposBlockNumber)];
              case 3:
                return [2, _a2.sent()];
              case 4:
                return [2];
            }
          });
        });
      };
      Api2.prototype.tryGetBlockInfo = function(blockNumber) {
        return __awaiter22(this, void 0, void 0, function() {
          var error_2;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 4]);
                return [4, this.rpc.get_block_info(blockNumber)];
              case 1:
                return [2, _a2.sent()];
              case 2:
                error_2 = _a2.sent();
                return [4, this.rpc.get_block(blockNumber)];
              case 3:
                return [2, _a2.sent()];
              case 4:
                return [2];
            }
          });
        });
      };
      Api2.prototype.tryRefBlockFromGetInfo = function(info) {
        return __awaiter22(this, void 0, void 0, function() {
          var block;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!(info.hasOwnProperty("last_irreversible_block_id") && info.hasOwnProperty("last_irreversible_block_num") && info.hasOwnProperty("last_irreversible_block_time")))
                  return [3, 1];
                return [2, {
                  block_num: info.last_irreversible_block_num,
                  id: info.last_irreversible_block_id,
                  timestamp: info.last_irreversible_block_time
                }];
              case 1:
                return [4, this.tryGetBlockInfo(info.last_irreversible_block_num)];
              case 2:
                block = _a2.sent();
                return [2, {
                  block_num: block.block_num,
                  id: block.id,
                  timestamp: block.timestamp
                }];
            }
          });
        });
      };
      Api2.prototype.with = function(accountName) {
        return new ActionBuilder(this, accountName);
      };
      Api2.prototype.buildTransaction = function(cb) {
        var tx = new TransactionBuilder(this);
        if (cb) {
          return cb(tx);
        }
        return tx;
      };
      return Api2;
    }();
    exports.Api = Api;
    var TransactionBuilder = function() {
      function TransactionBuilder2(api) {
        this.actions = [];
        this.contextFreeGroups = [];
        this.api = api;
      }
      TransactionBuilder2.prototype.with = function(accountName) {
        var actionBuilder = new ActionBuilder(this.api, accountName);
        this.actions.push(actionBuilder);
        return actionBuilder;
      };
      TransactionBuilder2.prototype.associateContextFree = function(contextFreeGroup) {
        this.contextFreeGroups.push(contextFreeGroup);
        return this;
      };
      TransactionBuilder2.prototype.send = function(config2) {
        return __awaiter22(this, void 0, void 0, function() {
          var contextFreeDataSet, contextFreeActions, actions;
          var _this = this;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                contextFreeDataSet = [];
                contextFreeActions = [];
                actions = this.actions.map(function(actionBuilder) {
                  return actionBuilder.serializedData;
                });
                return [4, Promise.all(this.contextFreeGroups.map(function(contextFreeCallback) {
                  return __awaiter22(_this, void 0, void 0, function() {
                    var _a3, action, contextFreeAction, contextFreeData;
                    return __generator5(this, function(_b) {
                      _a3 = contextFreeCallback({
                        cfd: contextFreeDataSet.length,
                        cfa: contextFreeActions.length
                      }), action = _a3.action, contextFreeAction = _a3.contextFreeAction, contextFreeData = _a3.contextFreeData;
                      if (action) {
                        actions.push(action);
                      }
                      if (contextFreeAction) {
                        contextFreeActions.push(contextFreeAction);
                      }
                      if (contextFreeData) {
                        contextFreeDataSet.push(contextFreeData);
                      }
                      return [2];
                    });
                  });
                }))];
              case 1:
                _a2.sent();
                this.contextFreeGroups = [];
                this.actions = [];
                return [4, this.api.transact({
                  context_free_data: contextFreeDataSet,
                  context_free_actions: contextFreeActions,
                  actions
                }, config2)];
              case 2:
                return [2, _a2.sent()];
            }
          });
        });
      };
      return TransactionBuilder2;
    }();
    exports.TransactionBuilder = TransactionBuilder;
    var ActionBuilder = function() {
      function ActionBuilder2(api, accountName) {
        this.api = api;
        this.accountName = accountName;
      }
      ActionBuilder2.prototype.as = function(actorName) {
        if (actorName === void 0) {
          actorName = [];
        }
        var authorization = [];
        if (actorName && typeof actorName === "string") {
          authorization = [{ actor: actorName, permission: "active" }];
        } else {
          authorization = actorName;
        }
        return new ActionSerializer(this, this.api, this.accountName, authorization);
      };
      return ActionBuilder2;
    }();
    exports.ActionBuilder = ActionBuilder;
    var ActionSerializer = function() {
      function ActionSerializer2(parent, api, accountName, authorization) {
        var e_4, _a2;
        var _this = this;
        var jsonAbi = api.cachedAbis.get(accountName);
        if (!jsonAbi) {
          throw new Error("ABI must be cached before using ActionBuilder, run api.getAbi()");
        }
        var types = ser.getTypesFromAbi(ser.createInitialTypes(), jsonAbi.abi);
        var actions = new Map();
        try {
          for (var _b = __values(jsonAbi.abi.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = _c.value, name_2 = _d.name, type2 = _d.type;
            actions.set(name_2, ser.getType(types, type2));
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return))
              _a2.call(_b);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        actions.forEach(function(type3, name2) {
          var _a3;
          Object.assign(_this, (_a3 = {}, _a3[name2] = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var data = {};
            args.forEach(function(arg, index) {
              var field = type3.fields[index];
              data[field.name] = arg;
            });
            var serializedData = ser.serializeAction({ types, actions }, accountName, name2, authorization, data, api.textEncoder, api.textDecoder);
            parent.serializedData = serializedData;
            return serializedData;
          }, _a3));
        });
      }
      return ActionSerializer2;
    }();
  }
});

// node_modules/eosjs/dist/eosjs-api-interfaces.js
var require_eosjs_api_interfaces = __commonJS({
  "node_modules/eosjs/dist/eosjs-api-interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/eosjs/dist/eosjs-rpcerror.js
var require_eosjs_rpcerror = __commonJS({
  "node_modules/eosjs/dist/eosjs-rpcerror.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d5, b4) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
          d6.__proto__ = b5;
        } || function(d6, b5) {
          for (var p5 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p5))
              d6[p5] = b5[p5];
        };
        return extendStatics2(d5, b4);
      };
      return function(d5, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics2(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RpcError = void 0;
    var RpcError = function(_super) {
      __extends2(RpcError2, _super);
      function RpcError2(json) {
        var _this = this;
        if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
          _this = _super.call(this, json.error.details[0].message) || this;
          _this.details = json.error.details;
        } else if (json.processed && json.processed.except && json.processed.except.message) {
          _this = _super.call(this, json.processed.except.message) || this;
          _this.details = json.processed.except;
        } else if (json.result && json.result.except && json.result.except.message) {
          _this = _super.call(this, json.result.except.message) || this;
          _this.details = json.result.except;
        } else {
          _this = _super.call(this, json.message) || this;
        }
        Object.setPrototypeOf(_this, RpcError2.prototype);
        _this.json = json;
        return _this;
      }
      return RpcError2;
    }(Error);
    exports.RpcError = RpcError;
  }
});

// node_modules/eosjs/dist/eosjs-jsonrpc.js
var require_eosjs_jsonrpc = __commonJS({
  "node_modules/eosjs/dist/eosjs-jsonrpc.js"(exports) {
    "use strict";
    var __awaiter22 = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator5 = exports && exports.__generator || function(thisArg, body) {
      var _10 = { label: 0, sent: function() {
        if (t5[0] & 1)
          throw t5[1];
        return t5[1];
      }, trys: [], ops: [] }, f7, y5, t5, g5;
      return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
        return this;
      }), g5;
      function verb(n3) {
        return function(v8) {
          return step([n3, v8]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_10)
          try {
            if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
              return t5;
            if (y5 = 0, t5)
              op = [op[0] & 2, t5.value];
            switch (op[0]) {
              case 0:
              case 1:
                t5 = op;
                break;
              case 4:
                _10.label++;
                return { value: op[1], done: false };
              case 5:
                _10.label++;
                y5 = op[1];
                op = [0];
                continue;
              case 7:
                op = _10.ops.pop();
                _10.trys.pop();
                continue;
              default:
                if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _10 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                  _10.label = op[1];
                  break;
                }
                if (op[0] === 6 && _10.label < t5[1]) {
                  _10.label = t5[1];
                  t5 = op;
                  break;
                }
                if (t5 && _10.label < t5[2]) {
                  _10.label = t5[2];
                  _10.ops.push(op);
                  break;
                }
                if (t5[2])
                  _10.ops.pop();
                _10.trys.pop();
                continue;
            }
            op = body.call(thisArg, _10);
          } catch (e5) {
            op = [6, e5];
            y5 = 0;
          } finally {
            f7 = t5 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __values = exports && exports.__values || function(o5) {
      var s6 = typeof Symbol === "function" && Symbol.iterator, m5 = s6 && o5[s6], i5 = 0;
      if (m5)
        return m5.call(o5);
      if (o5 && typeof o5.length === "number")
        return {
          next: function() {
            if (o5 && i5 >= o5.length)
              o5 = void 0;
            return { value: o5 && o5[i5++], done: !o5 };
          }
        };
      throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpc = void 0;
    var eosjs_numeric_1 = require_eosjs_numeric();
    var eosjs_rpcerror_1 = require_eosjs_rpcerror();
    var arrayToHex3 = function(data) {
      var e_1, _a2;
      var result = "";
      try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var x5 = data_1_1.value;
          result += ("00" + x5.toString(16)).slice(-2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
            _a2.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result;
    };
    var JsonRpc = function() {
      function JsonRpc2(endpoint2, args) {
        if (args === void 0) {
          args = {};
        }
        this.endpoint = endpoint2.replace(/\/$/, "");
        if (args.fetch) {
          this.fetchBuiltin = args.fetch;
        } else {
          this.fetchBuiltin = global.fetch;
        }
      }
      JsonRpc2.prototype.fetch = function(path, body) {
        return __awaiter22(this, void 0, void 0, function() {
          var response, json, f7, e_2;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 3, , 4]);
                f7 = this.fetchBuiltin;
                return [4, f7(this.endpoint + path, {
                  body: JSON.stringify(body),
                  method: "POST"
                })];
              case 1:
                response = _a2.sent();
                return [4, response.json()];
              case 2:
                json = _a2.sent();
                if (json.processed && json.processed.except) {
                  throw new eosjs_rpcerror_1.RpcError(json);
                } else if (json.result && json.result.except) {
                  throw new eosjs_rpcerror_1.RpcError(json);
                }
                return [3, 4];
              case 3:
                e_2 = _a2.sent();
                e_2.isFetchError = true;
                throw e_2;
              case 4:
                if (!response.ok) {
                  throw new eosjs_rpcerror_1.RpcError(json);
                }
                return [2, json];
            }
          });
        });
      };
      JsonRpc2.prototype.abi_bin_to_json = function(code, action, binargs) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/abi_bin_to_json", { code, action, binargs })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.abi_json_to_bin = function(code, action, args) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/abi_json_to_bin", { code, action, args })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_abi = function(accountName) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_abi", { account_name: accountName })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_account = function(accountName) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_account", { account_name: accountName })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_accounts_by_authorizers = function(accounts, keys) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_accounts_by_authorizers", { accounts, keys })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_activated_protocol_features = function(_a2) {
        var _b = _a2.limit, limit = _b === void 0 ? 10 : _b, _c = _a2.search_by_block_num, search_by_block_num = _c === void 0 ? false : _c, _d = _a2.reverse, reverse = _d === void 0 ? false : _d, _e = _a2.lower_bound, lower_bound = _e === void 0 ? null : _e, _f = _a2.upper_bound, upper_bound = _f === void 0 ? null : _f;
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_g) {
            switch (_g.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_activated_protocol_features", { lower_bound, upper_bound, limit, search_by_block_num, reverse })];
              case 1:
                return [2, _g.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_block_header_state = function(blockNumOrId) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_block_header_state", { block_num_or_id: blockNumOrId })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_block_info = function(blockNum) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_block_info", { block_num: blockNum })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_block = function(blockNumOrId) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_block", { block_num_or_id: blockNumOrId })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_code = function(accountName) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_code", {
                  account_name: accountName,
                  code_as_wasm: true
                })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_code_hash = function(accountName) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_code_hash", { account_name: accountName })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_currency_balance = function(code, account, symbol) {
        if (symbol === void 0) {
          symbol = null;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_currency_balance", { code, account, symbol })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_currency_stats = function(code, symbol) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_currency_stats", { code, symbol })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_info = function() {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_info", {})];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_producer_schedule = function() {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_producer_schedule", {})];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_producers = function(json, lowerBound, limit) {
        if (json === void 0) {
          json = true;
        }
        if (lowerBound === void 0) {
          lowerBound = "";
        }
        if (limit === void 0) {
          limit = 50;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_producers", { json, lower_bound: lowerBound, limit })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_raw_code_and_abi = function(accountName) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_raw_code_and_abi", { account_name: accountName })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.getRawAbi = function(accountName) {
        return __awaiter22(this, void 0, void 0, function() {
          var rawAbi, abi;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.get_raw_abi(accountName)];
              case 1:
                rawAbi = _a2.sent();
                abi = eosjs_numeric_1.base64ToBinary(rawAbi.abi);
                return [2, { accountName: rawAbi.account_name, abi }];
            }
          });
        });
      };
      JsonRpc2.prototype.get_raw_abi = function(accountName) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_raw_abi", { account_name: accountName })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_scheduled_transactions = function(json, lowerBound, limit) {
        if (json === void 0) {
          json = true;
        }
        if (lowerBound === void 0) {
          lowerBound = "";
        }
        if (limit === void 0) {
          limit = 50;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_scheduled_transactions", { json, lower_bound: lowerBound, limit })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_table_rows = function(_a2) {
        var _b = _a2.json, json = _b === void 0 ? true : _b, code = _a2.code, scope = _a2.scope, table = _a2.table, _c = _a2.lower_bound, lower_bound = _c === void 0 ? "" : _c, _d = _a2.upper_bound, upper_bound = _d === void 0 ? "" : _d, _e = _a2.index_position, index_position = _e === void 0 ? 1 : _e, _f = _a2.key_type, key_type = _f === void 0 ? "" : _f, _g = _a2.limit, limit = _g === void 0 ? 10 : _g, _h = _a2.reverse, reverse = _h === void 0 ? false : _h, _j = _a2.show_payer, show_payer = _j === void 0 ? false : _j;
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_k) {
            switch (_k.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_table_rows", {
                  json,
                  code,
                  scope,
                  table,
                  lower_bound,
                  upper_bound,
                  index_position,
                  key_type,
                  limit,
                  reverse,
                  show_payer
                })];
              case 1:
                return [2, _k.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_kv_table_rows = function(_a2) {
        var _b = _a2.json, json = _b === void 0 ? true : _b, code = _a2.code, table = _a2.table, index_name = _a2.index_name, _c = _a2.encode_type, encode_type = _c === void 0 ? "bytes" : _c, index_value = _a2.index_value, lower_bound = _a2.lower_bound, upper_bound = _a2.upper_bound, _d = _a2.limit, limit = _d === void 0 ? 10 : _d, _e = _a2.reverse, reverse = _e === void 0 ? false : _e, _f = _a2.show_payer, show_payer = _f === void 0 ? false : _f;
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_g) {
            switch (_g.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_kv_table_rows", {
                  json,
                  code,
                  table,
                  index_name,
                  encode_type,
                  index_value,
                  lower_bound,
                  upper_bound,
                  limit,
                  reverse,
                  show_payer
                })];
              case 1:
                return [2, _g.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.get_table_by_scope = function(_a2) {
        var code = _a2.code, table = _a2.table, _b = _a2.lower_bound, lower_bound = _b === void 0 ? "" : _b, _c = _a2.upper_bound, upper_bound = _c === void 0 ? "" : _c, _d = _a2.limit, limit = _d === void 0 ? 10 : _d;
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_e) {
            switch (_e.label) {
              case 0:
                return [4, this.fetch("/v1/chain/get_table_by_scope", {
                  code,
                  table,
                  lower_bound,
                  upper_bound,
                  limit
                })];
              case 1:
                return [2, _e.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.getRequiredKeys = function(args) {
        return __awaiter22(this, void 0, void 0, function() {
          var _a2;
          return __generator5(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = eosjs_numeric_1.convertLegacyPublicKeys;
                return [4, this.fetch("/v1/chain/get_required_keys", {
                  transaction: args.transaction,
                  available_keys: args.availableKeys
                })];
              case 1:
                return [2, _a2.apply(void 0, [_b.sent().required_keys])];
            }
          });
        });
      };
      JsonRpc2.prototype.push_transaction = function(_a2) {
        var signatures = _a2.signatures, _b = _a2.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a2.serializedTransaction, serializedContextFreeData = _a2.serializedContextFreeData;
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, this.fetch("/v1/chain/push_transaction", {
                  signatures,
                  compression,
                  packed_context_free_data: arrayToHex3(serializedContextFreeData || new Uint8Array(0)),
                  packed_trx: arrayToHex3(serializedTransaction)
                })];
              case 1:
                return [2, _c.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.push_ro_transaction = function(_a2, returnFailureTraces) {
        var signatures = _a2.signatures, _b = _a2.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a2.serializedTransaction;
        if (returnFailureTraces === void 0) {
          returnFailureTraces = false;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, this.fetch("/v1/chain/push_ro_transaction", {
                  transaction: {
                    signatures,
                    compression,
                    packed_context_free_data: arrayToHex3(new Uint8Array(0)),
                    packed_trx: arrayToHex3(serializedTransaction)
                  },
                  return_failure_traces: returnFailureTraces
                })];
              case 1:
                return [2, _c.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.push_transactions = function(transactions) {
        return __awaiter22(this, void 0, void 0, function() {
          var packedTrxs;
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                packedTrxs = transactions.map(function(_a3) {
                  var signatures = _a3.signatures, _b = _a3.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a3.serializedTransaction, serializedContextFreeData = _a3.serializedContextFreeData;
                  return {
                    signatures,
                    compression,
                    packed_context_free_data: arrayToHex3(serializedContextFreeData || new Uint8Array(0)),
                    packed_trx: arrayToHex3(serializedTransaction)
                  };
                });
                return [4, this.fetch("/v1/chain/push_transactions", packedTrxs)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.send_transaction = function(_a2) {
        var signatures = _a2.signatures, _b = _a2.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a2.serializedTransaction, serializedContextFreeData = _a2.serializedContextFreeData;
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, this.fetch("/v1/chain/send_transaction", {
                  signatures,
                  compression,
                  packed_context_free_data: arrayToHex3(serializedContextFreeData || new Uint8Array(0)),
                  packed_trx: arrayToHex3(serializedTransaction)
                })];
              case 1:
                return [2, _c.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.db_size_get = function() {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/db_size/get", {})];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.trace_get_block = function(block_num) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/trace_api/get_block", { block_num })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.history_get_actions = function(accountName, pos, offset2) {
        if (pos === void 0) {
          pos = null;
        }
        if (offset2 === void 0) {
          offset2 = null;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/history/get_actions", { account_name: accountName, pos, offset: offset2 })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.history_get_transaction = function(id2, blockNumHint) {
        if (blockNumHint === void 0) {
          blockNumHint = null;
        }
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/history/get_transaction", { id: id2, block_num_hint: blockNumHint })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.history_get_key_accounts = function(publicKey2) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/history/get_key_accounts", { public_key: publicKey2 })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      JsonRpc2.prototype.history_get_controlled_accounts = function(controllingAccount) {
        return __awaiter22(this, void 0, void 0, function() {
          return __generator5(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.fetch("/v1/history/get_controlled_accounts", { controlling_account: controllingAccount })];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      return JsonRpc2;
    }();
    exports.JsonRpc = JsonRpc;
  }
});

// node_modules/eosjs/dist/eosjs-rpc-interfaces.js
var require_eosjs_rpc_interfaces = __commonJS({
  "node_modules/eosjs/dist/eosjs-rpc-interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/eosjs/dist/index.js
var require_dist = __commonJS({
  "node_modules/eosjs/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serialize = exports.RpcError = exports.RpcInterfaces = exports.Numeric = exports.JsonRpc = exports.ApiInterfaces = exports.Api = void 0;
    var eosjs_api_1 = require_eosjs_api();
    Object.defineProperty(exports, "Api", { enumerable: true, get: function() {
      return eosjs_api_1.Api;
    } });
    var ApiInterfaces = require_eosjs_api_interfaces();
    exports.ApiInterfaces = ApiInterfaces;
    var eosjs_jsonrpc_1 = require_eosjs_jsonrpc();
    Object.defineProperty(exports, "JsonRpc", { enumerable: true, get: function() {
      return eosjs_jsonrpc_1.JsonRpc;
    } });
    var Numeric = require_eosjs_numeric();
    exports.Numeric = Numeric;
    var RpcInterfaces = require_eosjs_rpc_interfaces();
    exports.RpcInterfaces = RpcInterfaces;
    var eosjs_rpcerror_1 = require_eosjs_rpcerror();
    Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
      return eosjs_rpcerror_1.RpcError;
    } });
    var Serialize = require_eosjs_serialize();
    exports.Serialize = Serialize;
  }
});

// node_modules/@waxio/waxjs/dist/WaxEventSource.js
var require_WaxEventSource = __commonJS({
  "node_modules/@waxio/waxjs/dist/WaxEventSource.js"(exports) {
    "use strict";
    var __awaiter22 = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var WaxEventSource = class {
      constructor(waxSigningURL) {
        this.waxSigningURL = waxSigningURL;
        this.timeout = () => __awaiter22(this, void 0, void 0, function* () {
          return new Promise((_10, reject) => setTimeout(() => reject(new Error("Timeout")), 5e3));
        });
        this.openEventSource = this.openEventSource.bind(this);
        this.onceEvent = this.onceEvent.bind(this);
      }
      openPopup(url) {
        return __awaiter22(this, void 0, void 0, function* () {
          const win = yield window.open(url, "WaxPopup", "height=800,width=600");
          if (win) {
            return win;
          }
          throw new Error("Unable to open popup window");
        });
      }
      openEventSource(url, message, win) {
        return __awaiter22(this, void 0, void 0, function* () {
          const openedWindow = win ? win : yield this.openPopup(url);
          if (!openedWindow) {
            throw new Error("Unable to open a popup window");
          }
          if (typeof message === "undefined") {
            return openedWindow;
          }
          const postTransaction = (event) => __awaiter22(this, void 0, void 0, function* () {
            if (event.data.type === "READY") {
              openedWindow.postMessage(message, this.waxSigningURL);
            }
          });
          const eventPromise = this.onceEvent(openedWindow, this.waxSigningURL, postTransaction, "READY");
          yield Promise.race([eventPromise, this.timeout()]).catch((err) => {
            if (err.message !== "Timeout") {
              throw err;
            }
            openedWindow.postMessage(message, this.waxSigningURL);
          });
          return openedWindow;
        });
      }
      onceEvent(source, origin, action, type2) {
        return __awaiter22(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            window.addEventListener("message", function onEvent(event) {
              return __awaiter22(this, void 0, void 0, function* () {
                if (event.origin !== origin) {
                  return;
                }
                if (event.source !== source) {
                  return;
                }
                if (typeof event.data !== "object") {
                  return;
                }
                if (type2 && (!event.data.type || event.data.type !== type2)) {
                  return;
                }
                try {
                  resolve(yield action(event));
                } catch (e5) {
                  reject(e5);
                }
                window.removeEventListener("message", onEvent, false);
              });
            }, false);
          });
        });
      }
    };
    exports.WaxEventSource = WaxEventSource;
  }
});

// node_modules/@waxio/waxjs/dist/WaxSigningApi.js
var require_WaxSigningApi = __commonJS({
  "node_modules/@waxio/waxjs/dist/WaxSigningApi.js"(exports) {
    "use strict";
    var __awaiter22 = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var WaxEventSource_1 = require_WaxEventSource();
    var WaxSigningApi = class {
      constructor(waxSigningURL, waxAutoSigningURL) {
        this.waxSigningURL = waxSigningURL;
        this.waxAutoSigningURL = waxAutoSigningURL;
        this.waxEventSource = new WaxEventSource_1.WaxEventSource(waxSigningURL);
      }
      login() {
        return __awaiter22(this, void 0, void 0, function* () {
          if (!this.user) {
            yield this.loginViaWindow();
          }
          if (this.user) {
            return this.user;
          }
          throw new Error("Login failed");
        });
      }
      tryAutologin() {
        return __awaiter22(this, void 0, void 0, function* () {
          if (this.user) {
            return true;
          }
          try {
            yield this.loginViaEndpoint();
            return true;
          } catch (e5) {
            return false;
          }
        });
      }
      prepareTransaction(transaction) {
        return __awaiter22(this, void 0, void 0, function* () {
          if (!this.canAutoSign(transaction)) {
            this.signingWindow = yield this.waxEventSource.openPopup(`${this.waxSigningURL}/cloud-wallet/signing/`);
          }
        });
      }
      signing(transaction, serializedTransaction, noModify = false) {
        return __awaiter22(this, void 0, void 0, function* () {
          if (this.canAutoSign(transaction)) {
            try {
              return yield this.signViaEndpoint(serializedTransaction, noModify);
            } catch (_a2) {
            }
          }
          return yield this.signViaWindow(serializedTransaction, this.signingWindow, noModify);
        });
      }
      loginViaWindow() {
        return __awaiter22(this, void 0, void 0, function* () {
          const confirmationWindow = yield this.waxEventSource.openEventSource(`${this.waxSigningURL}/cloud-wallet/login/`);
          return this.waxEventSource.onceEvent(confirmationWindow, this.waxSigningURL, this.receiveLogin.bind(this), void 0);
        });
      }
      loginViaEndpoint() {
        return __awaiter22(this, void 0, void 0, function* () {
          const response = yield fetch(`${this.waxAutoSigningURL}login`, {
            credentials: "include",
            method: "get"
          });
          if (!response.ok) {
            throw new Error(`Login Endpoint Error ${response.status} ${response.statusText}`);
          }
          const data = yield response.json();
          if (data.processed && data.processed.except) {
            throw new Error(data);
          }
          return this.receiveLogin({ data });
        });
      }
      signViaEndpoint(serializedTransaction, noModify = false) {
        return __awaiter22(this, void 0, void 0, function* () {
          const controller = new AbortController();
          setTimeout(() => controller.abort(), 5e3);
          const response = yield fetch(`${this.waxAutoSigningURL}signing`, {
            body: JSON.stringify({
              freeBandwidth: !noModify,
              transaction: Object.values(serializedTransaction)
            }),
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            method: "POST",
            signal: controller.signal
          });
          if (!response.ok) {
            this.whitelistedContracts = [];
            throw new Error(`Signing Endpoint Error ${response.status} ${response.statusText}`);
          }
          const data = yield response.json();
          if (data.processed && data.processed.except) {
            this.whitelistedContracts = [];
            throw new Error(`Error returned from signing endpoint: ${JSON.stringify(data)}`);
          }
          return this.receiveSignatures({ data });
        });
      }
      signViaWindow(serializedTransaction, window3, noModify = false) {
        return __awaiter22(this, void 0, void 0, function* () {
          const confirmationWindow = yield this.waxEventSource.openEventSource(`${this.waxSigningURL}/cloud-wallet/signing/`, {
            freeBandwidth: !noModify,
            transaction: serializedTransaction,
            type: "TRANSACTION"
          }, window3);
          return this.waxEventSource.onceEvent(confirmationWindow, this.waxSigningURL, this.receiveSignatures.bind(this), "TX_SIGNED");
        });
      }
      receiveLogin(event) {
        return __awaiter22(this, void 0, void 0, function* () {
          const { verified, userAccount, pubKeys, whitelistedContracts } = event.data;
          if (!verified) {
            throw new Error("User declined to share their user account");
          }
          if (!userAccount || !pubKeys) {
            throw new Error("User does not have a blockchain account");
          }
          this.whitelistedContracts = whitelistedContracts || [];
          this.user = { account: userAccount, keys: pubKeys };
          return true;
        });
      }
      receiveSignatures(event) {
        return __awaiter22(this, void 0, void 0, function* () {
          if (event.data.type === "TX_SIGNED") {
            const { verified, signatures, whitelistedContracts, serializedTransaction } = event.data;
            if (!verified || !signatures) {
              throw new Error("User declined to sign the transaction");
            }
            this.whitelistedContracts = whitelistedContracts || [];
            return { serializedTransaction, signatures };
          }
          throw new Error(`Unexpected response received when attempting signing: ${JSON.stringify(event.data)}`);
        });
      }
      canAutoSign(transaction) {
        const ua = navigator.userAgent.toLowerCase();
        if (ua.search("chrome") === -1 && ua.search("safari") >= 0) {
          return false;
        }
        return !transaction.actions.find((action) => !this.isWhitelisted(action));
      }
      isWhitelisted(action) {
        return !!(this.whitelistedContracts && !!this.whitelistedContracts.find((w6) => {
          if (w6.contract === action.account) {
            if (action.account === "eosio.token" && action.name === "transfer") {
              return w6.recipients.includes(action.data.to);
            }
            return true;
          }
          return false;
        }));
      }
    };
    exports.WaxSigningApi = WaxSigningApi;
  }
});

// node_modules/@waxio/waxjs/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@waxio/waxjs/dist/index.js"(exports) {
    "use strict";
    var __awaiter22 = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var eosjs_1 = require_dist();
    var WaxSigningApi_1 = require_WaxSigningApi();
    var WaxJS2 = class {
      constructor({ rpcEndpoint, tryAutoLogin = true, userAccount, pubKeys, apiSigner, waxSigningURL = "https://all-access.wax.io", waxAutoSigningURL = "https://api-idm.wax.io/v1/accounts/auto-accept/", eosApiArgs = {}, freeBandwidth = true, verifyTx = defaultTxVerifier }) {
        this.signingApi = new WaxSigningApi_1.WaxSigningApi(waxSigningURL, waxAutoSigningURL);
        this.rpc = new eosjs_1.JsonRpc(rpcEndpoint);
        this.waxSigningURL = waxSigningURL;
        this.waxAutoSigningURL = waxAutoSigningURL;
        this.apiSigner = apiSigner;
        this.eosApiArgs = eosApiArgs;
        this.freeBandwidth = freeBandwidth;
        this.verifyTx = verifyTx;
        if (userAccount && Array.isArray(pubKeys)) {
          this.receiveLogin({ account: userAccount, keys: pubKeys });
        } else {
          if (tryAutoLogin) {
            this.signingApi.tryAutologin().then((response) => __awaiter22(this, void 0, void 0, function* () {
              if (response) {
                this.receiveLogin(yield this.signingApi.login());
              }
            }));
          }
        }
      }
      get userAccount() {
        return this.user && this.user.account;
      }
      get pubKeys() {
        return this.user && this.user.keys;
      }
      login() {
        return __awaiter22(this, void 0, void 0, function* () {
          if (!this.user) {
            this.receiveLogin(yield this.signingApi.login());
          }
          return this.user.account;
        });
      }
      isAutoLoginAvailable() {
        return __awaiter22(this, void 0, void 0, function* () {
          if (this.user) {
            return true;
          } else if (yield this.signingApi.tryAutologin()) {
            this.receiveLogin(yield this.signingApi.login());
            return true;
          }
          return false;
        });
      }
      receiveLogin(data) {
        this.user = data;
        const signatureProvider = {
          getAvailableKeys: () => __awaiter22(this, void 0, void 0, function* () {
            return [
              ...this.user.keys,
              ...this.apiSigner && (yield this.apiSigner.getAvailableKeys()) || []
            ];
          }),
          sign: (sigArgs) => __awaiter22(this, void 0, void 0, function* () {
            const originalTx = yield this.api.deserializeTransactionWithActions(sigArgs.serializedTransaction);
            const { serializedTransaction, signatures } = yield this.signingApi.signing(originalTx, sigArgs.serializedTransaction, !this.freeBandwidth);
            const augmentedTx = yield this.api.deserializeTransactionWithActions(serializedTransaction);
            this.verifyTx(this.user, originalTx, augmentedTx);
            sigArgs.serializedTransaction = serializedTransaction;
            return {
              serializedTransaction,
              signatures: [
                ...signatures,
                ...this.apiSigner && (yield this.apiSigner.sign(sigArgs)).signatures || []
              ]
            };
          })
        };
        this.api = new eosjs_1.Api(Object.assign(Object.assign({}, this.eosApiArgs), { rpc: this.rpc, signatureProvider }));
        const transact = this.api.transact.bind(this.api);
        this.api.transact = (transaction, namedParams) => __awaiter22(this, void 0, void 0, function* () {
          yield this.signingApi.prepareTransaction(transaction);
          return yield transact(transaction, namedParams);
        });
      }
    };
    exports.WaxJS = WaxJS2;
    function defaultTxVerifier(user, originalTx, augmentedTx) {
      const { actions: originalActions } = originalTx;
      const { actions: augmentedActions } = augmentedTx;
      if (JSON.stringify(originalActions) !== JSON.stringify(augmentedActions.slice(augmentedActions.length - originalActions.length))) {
        throw new Error(`Augmented transaction actions has modified actions from the original.
Original: ${JSON.stringify(originalActions, void 0, 2)}
Augmented: ${JSON.stringify(augmentedActions, void 0, 2)}`);
      }
      for (const extraAction of augmentedActions.slice(0, augmentedActions.length - originalActions.length)) {
        const userAuthedAction = extraAction.authorization.find((auth) => {
          return auth.actor === user.account;
        });
        if (userAuthedAction) {
          throw new Error(`Augmented transaction actions has an extra action from the original authorizing the user.
Original: ${JSON.stringify(originalActions, void 0, 2)}
Augmented: ${JSON.stringify(augmentedActions, void 0, 2)}`);
        }
      }
    }
  }
});

// node_modules/@solana/web3.js/node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/@solana/web3.js/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e5) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from2(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b4 = fromObject(value);
      if (b4)
        return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding5) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding5 === "string" ? createBuffer(size).fill(fill, encoding5) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding5) {
      return alloc(size, fill, encoding5);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding5) {
      if (typeof encoding5 !== "string" || encoding5 === "") {
        encoding5 = "utf8";
      }
      if (!Buffer3.isEncoding(encoding5)) {
        throw new TypeError("Unknown encoding: " + encoding5);
      }
      const length = byteLength(string2, encoding5) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string2, encoding5);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i5 = 0; i5 < length; i5 += 1) {
        buf[i5] = array2[i5] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer2(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a5, b4) {
      if (isInstance(a5, Uint8Array))
        a5 = Buffer3.from(a5, a5.offset, a5.byteLength);
      if (isInstance(b4, Uint8Array))
        b4 = Buffer3.from(b4, b4.offset, b4.byteLength);
      if (!Buffer3.isBuffer(a5) || !Buffer3.isBuffer(b4)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a5 === b4)
        return 0;
      let x5 = a5.length;
      let y5 = b4.length;
      for (let i5 = 0, len = Math.min(x5, y5); i5 < len; ++i5) {
        if (a5[i5] !== b4[i5]) {
          x5 = a5[i5];
          y5 = b4[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding5) {
      switch (String(encoding5).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat4(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        let buf = list[i5];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string2, encoding5) {
      if (Buffer3.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding5) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding5 = ("" + encoding5).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding5, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding5)
        encoding5 = "utf8";
      while (true) {
        switch (encoding5) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding5);
            encoding5 = (encoding5 + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b4, n3, m5) {
      const i5 = b4[n3];
      b4[n3] = b4[m5];
      b4[m5] = i5;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b4) {
      if (!Buffer3.isBuffer(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer3.compare(this, b4) === 0;
    };
    Buffer3.prototype.inspect = function inspect4() {
      let str = "";
      const max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x5 = thisEnd - thisStart;
      let y5 = end - start;
      const len = Math.min(x5, y5);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x5 = thisCopy[i5];
          y5 = targetCopy[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding5, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding5 = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding5);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding5, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding5, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding5, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding5 !== void 0) {
        encoding5 = String(encoding5).toLowerCase();
        if (encoding5 === "ucs2" || encoding5 === "ucs-2" || encoding5 === "utf16le" || encoding5 === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i6) {
        if (indexSize === 1) {
          return buf[i6];
        } else {
          return buf.readUInt16BE(i6 * indexSize);
        }
      }
      let i5;
      if (dir) {
        let foundIndex = -1;
        for (i5 = byteOffset; i5 < arrLength; i5++) {
          if (read(arr, i5) === read(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i5;
            if (i5 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i5 -= i5 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i5 = byteOffset; i5 >= 0; i5--) {
          let found = true;
          for (let j5 = 0; j5 < valLength; j5++) {
            if (read(arr, i5 + j5) !== read(val, j5)) {
              found = false;
              break;
            }
          }
          if (found)
            return i5;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding5) {
      return this.indexOf(val, byteOffset, encoding5) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding5) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding5, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding5) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding5, false);
    };
    function hexWrite(buf, string2, offset2, length) {
      offset2 = Number(offset2) || 0;
      const remaining = buf.length - offset2;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        const parsed = parseInt(string2.substr(i5 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i5;
        buf[offset2 + i5] = parsed;
      }
      return i5;
    }
    function utf8Write(buf, string2, offset2, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset2), buf, offset2, length);
    }
    function asciiWrite(buf, string2, offset2, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset2, length);
    }
    function base64Write(buf, string2, offset2, length) {
      return blitBuffer(base64ToBytes(string2), buf, offset2, length);
    }
    function ucs2Write(buf, string2, offset2, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
    }
    Buffer3.prototype.write = function write(string2, offset2, length, encoding5) {
      if (offset2 === void 0) {
        encoding5 = "utf8";
        length = this.length;
        offset2 = 0;
      } else if (length === void 0 && typeof offset2 === "string") {
        encoding5 = offset2;
        length = this.length;
        offset2 = 0;
      } else if (isFinite(offset2)) {
        offset2 = offset2 >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding5 === void 0)
            encoding5 = "utf8";
        } else {
          encoding5 = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset2;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding5)
        encoding5 = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding5) {
          case "hex":
            return hexWrite(this, string2, offset2, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset2, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset2, length);
          case "base64":
            return base64Write(this, string2, offset2, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset2, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding5);
            encoding5 = ("" + encoding5).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i5 = start;
      while (i5 < end) {
        const firstByte = buf[i5];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i5 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i5 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              fourthByte = buf[i5 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i5 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i5 = 0;
      while (i5 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i5 = start; i5 < end; ++i5) {
        out += hexSliceLookupTable[buf[i5]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i5 = 0; i5 < bytes.length - 1; i5 += 2) {
        res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset2, ext, length) {
      if (offset2 % 1 !== 0 || offset2 < 0)
        throw new RangeError("offset is not uint");
      if (offset2 + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      let val = this[offset2];
      let mul3 = 1;
      let i5 = 0;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        val += this[offset2 + i5] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset2, byteLength2, this.length);
      }
      let val = this[offset2 + --byteLength2];
      let mul3 = 1;
      while (byteLength2 > 0 && (mul3 *= 256)) {
        val += this[offset2 + --byteLength2] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 1, this.length);
      return this[offset2];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      return this[offset2] | this[offset2 + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      return this[offset2] << 8 | this[offset2 + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first2 = this[offset2];
      const last2 = this[offset2 + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const lo = first2 + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
      const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first2 = this[offset2];
      const last2 = this[offset2 + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
      const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      let val = this[offset2];
      let mul3 = 1;
      let i5 = 0;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        val += this[offset2 + i5] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      let i5 = byteLength2;
      let mul3 = 1;
      let val = this[offset2 + --i5];
      while (i5 > 0 && (mul3 *= 256)) {
        val += this[offset2 + --i5] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 1, this.length);
      if (!(this[offset2] & 128))
        return this[offset2];
      return (255 - this[offset2] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      const val = this[offset2] | this[offset2 + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      const val = this[offset2 + 1] | this[offset2] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first2 = this[offset2];
      const last2 = this[offset2 + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first2 = this[offset2];
      const last2 = this[offset2 + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const val = (first2 << 24) + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, false, 52, 8);
    };
    function checkInt(buf, value, offset2, ext, max2, min2) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset2 + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      let mul3 = 1;
      let i5 = 0;
      this[offset2] = value & 255;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        this[offset2 + i5] = value / mul3 & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      let i5 = byteLength2 - 1;
      let mul3 = 1;
      this[offset2 + i5] = value & 255;
      while (--i5 >= 0 && (mul3 *= 256)) {
        this[offset2 + i5] = value / mul3 & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 1, 255, 0);
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2 + 3] = value >>> 24;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 1] = value >>> 8;
      this[offset2] = value & 255;
      return offset2 + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset2, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset2++] = lo;
      lo = lo >> 8;
      buf[offset2++] = lo;
      lo = lo >> 8;
      buf[offset2++] = lo;
      lo = lo >> 8;
      buf[offset2++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset2++] = hi;
      hi = hi >> 8;
      buf[offset2++] = hi;
      hi = hi >> 8;
      buf[offset2++] = hi;
      hi = hi >> 8;
      buf[offset2++] = hi;
      return offset2;
    }
    function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset2, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset2 + 7] = lo;
      lo = lo >> 8;
      buf[offset2 + 6] = lo;
      lo = lo >> 8;
      buf[offset2 + 5] = lo;
      lo = lo >> 8;
      buf[offset2 + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset2 + 3] = hi;
      hi = hi >> 8;
      buf[offset2 + 2] = hi;
      hi = hi >> 8;
      buf[offset2 + 1] = hi;
      hi = hi >> 8;
      buf[offset2] = hi;
      return offset2 + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
      return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
      return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      let i5 = 0;
      let mul3 = 1;
      let sub = 0;
      this[offset2] = value & 255;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i5] = (value / mul3 >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      let i5 = byteLength2 - 1;
      let mul3 = 1;
      let sub = 0;
      this[offset2 + i5] = value & 255;
      while (--i5 >= 0 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i5] = (value / mul3 >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 3] = value >>> 24;
      return offset2 + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
      return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
      return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset2, ext, max2, min2) {
      if (offset2 + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset2 < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset2, littleEndian, 23, 4);
      return offset2 + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, false, noAssert);
    };
    function writeDouble(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset2, littleEndian, 52, 8);
      return offset2 + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding5) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding5 = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding5 = end;
          end = this.length;
        }
        if (encoding5 !== void 0 && typeof encoding5 !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding5 === "string" && !Buffer3.isEncoding(encoding5)) {
          throw new TypeError("Unknown encoding: " + encoding5);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding5 === "utf8" && code < 128 || encoding5 === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding5);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E4("ERR_OUT_OF_RANGE", function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i5 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i5 >= start + 4; i5 -= 3) {
        res = `_${val.slice(i5 - 3, i5)}${res}`;
      }
      return `${val.slice(0, i5)}${res}`;
    }
    function checkBounds(buf, offset2, byteLength2) {
      validateNumber(offset2, "offset");
      if (buf[offset2] === void 0 || buf[offset2 + byteLength2] === void 0) {
        boundsError(offset2, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min2, max2, buf, offset2, byteLength2) {
      if (value > max2 || value < min2) {
        const n3 = typeof min2 === "bigint" ? "n" : "";
        let range2;
        if (byteLength2 > 3) {
          if (min2 === 0 || min2 === BigInt(0)) {
            range2 = `>= 0${n3} and < 2${n3} ** ${(byteLength2 + 1) * 8}${n3}`;
          } else {
            range2 = `>= -(2${n3} ** ${(byteLength2 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n3}`;
          }
        } else {
          range2 = `>= ${min2}${n3} and <= ${max2}${n3}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset2, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", `>= ${type2 ? 1 : 0} and <= ${length}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i5 = 0; i5 < length; ++i5) {
        codePoint = string2.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        byteArray.push(str.charCodeAt(i5) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c5, hi, lo;
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        if ((units -= 2) < 0)
          break;
        c5 = str.charCodeAt(i5);
        hi = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset2, length) {
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        if (i5 + offset2 >= dst.length || i5 >= src.length)
          break;
        dst[i5 + offset2] = src[i5];
      }
      return i5;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i5 = 0; i5 < 16; ++i5) {
        const i16 = i5 * 16;
        for (let j5 = 0; j5 < 16; ++j5) {
          table[i16 + j5] = alphabet[i5] + alphabet[j5];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number2, base2, endian) {
        if (BN6.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = (init_buffer(), buffer_exports).Buffer;
        }
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert5(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN6.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number2, base2, endian) {
        assert5(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i5 = number2.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number2[i5] | number2[i5 - 1] << 8 | number2[i5 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number2.length; i5 += 3) {
            w6 = number2[i5] | number2[i5 + 1] << 8 | number2[i5 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c5 = string2.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert5(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r6 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r6;
      }
      BN6.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number2.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number2.length; i5 += 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var b4 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            b4 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b4 = c5 - 17 + 10;
          } else {
            b4 = c5;
          }
          assert5(c5 >= 0 && b4 < mul3, "Invalid character");
          r6 += b4;
        }
        return r6;
      }
      BN6.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number2, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i5, number2.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN6.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN6.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN6.prototype.clone = function clone() {
        var r6 = new BN6(null);
        this.copy(r6);
        return r6;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN6.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e5) {
          BN6.prototype.inspect = inspect4;
        }
      } else {
        BN6.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modrn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer3) {
        BN6.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer3, endian, length);
        };
      }
      BN6.prototype.toArray = function toArray3(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN6.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN6.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = num.words[off] >>> wbit & 1;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN6.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this._strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this._strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this._strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN6.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t5 = new Array(N5);
        var l5 = BN6.prototype._countBits(N5) - 1;
        for (var i5 = 0; i5 < N5; i5++) {
          t5[i5] = this.revBin(i5, l5, N5);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N5) {
        if (x5 === 0 || x5 === N5 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i5 = 0; i5 < N5; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s6 = 1; s6 < N5; s6 <<= 1) {
          var l5 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N5; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s6; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s6];
              var io = itws[p5 + j5 + s6];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s6] = re - ro;
              itws[p5 + j5 + s6] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N5 = Math.max(m5, n3) | 1;
        var odd = N5 & 1;
        var i5 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1)
          return;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N5 - i5 - 1];
          rws[N5 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N5 - i5 - 1];
          iws[N5 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N5) * 8192 + Math.round(ws[2 * i5] / N5) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N5; ++i5) {
          rws[i5] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i5 = 0; i5 < N5; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N5 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N5);
        var _10 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x5.words, x5.length, rws, N5);
        this.convert13b(y5.words, y5.length, nrws, N5);
        this.transform(rws, _10, rwst, iwst, N5, rbt);
        this.transform(nrws, _10, nrwst, niwst, N5, rbt);
        for (var i5 = 0; i5 < N5; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _10, N5, rbt);
        this.conjugate(rmws, _10, N5);
        this.normalize13b(rmws, N5);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out._strip();
      };
      BN6.prototype.mul = function mul3(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(typeof num === "number");
        assert5(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s6] = this.words[i5];
          }
          for (i5 = 0; i5 < s6; i5++) {
            this.words[i5] = 0;
          }
          this.length += s6;
        }
        return this._strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s6;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s6; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w6 = this.words[s6];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul3;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert5(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a5._strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert5(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN6.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN6.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B3.isOdd()) {
                A6.iadd(yp);
                B3.isub(xp);
              }
              A6.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g5)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s6; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert5(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert5(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p5) {
        this.name = name2;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert5(a5.negative === 0, "red works only with positives");
        assert5(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert5((a5.negative | b4.negative) === 0, "red works only with positives");
        assert5(a5.red && a5.red === b4.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        move(a5, a5.umod(this.m)._forceRed(this));
        return a5;
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s6 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s6++;
          q5.iushrn(1);
        }
        assert5(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c5 = this.pow(z4, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s6;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert5(i5 < m5);
          var b4 = this.pow(c5, new BN6(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer2 = require_buffer();
    var Buffer3 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding5) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding5 === "string") {
          buf.fill(fill, encoding5);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base2(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j5 = 0; j5 < BASE_MAP.length; j5++) {
        BASE_MAP[j5] = 255;
      }
      for (var i5 = 0; i5 < ALPHABET.length; i5++) {
        var x5 = ALPHABET.charAt(i5);
        var xc = x5.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc] = i5;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode5(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i6 = 0;
          for (var it1 = size - 1; (carry !== 0 || i6 < length) && it1 !== -1; it1--, i6++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i6;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i6 = 0;
          for (var it3 = size - 1; (carry !== 0 || i6 < length) && it3 !== -1; it3--, i6++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i6;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j6 = zeroes;
        while (it4 !== size) {
          vch[j6++] = b256[it4++];
        }
        return vch;
      }
      function decode4(string2) {
        var buffer2 = decodeUnsafe(string2);
        if (buffer2) {
          return buffer2;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode5,
        decodeUnsafe,
        decode: decode4
      };
    }
    module.exports = base2;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/borsh/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/borsh/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number2, base2, endian) {
        if (BN6.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = (init_buffer(), buffer_exports).Buffer;
        }
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert5(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN6.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number2, base2, endian) {
        assert5(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i5 = number2.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number2[i5] | number2[i5 - 1] << 8 | number2[i5 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number2.length; i5 += 3) {
            w6 = number2[i5] | number2[i5 + 1] << 8 | number2[i5 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c5 = string2.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert5(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r6 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r6;
      }
      BN6.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number2.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number2.length; i5 += 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var b4 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            b4 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b4 = c5 - 17 + 10;
          } else {
            b4 = c5;
          }
          assert5(c5 >= 0 && b4 < mul3, "Invalid character");
          r6 += b4;
        }
        return r6;
      }
      BN6.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number2, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i5, number2.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN6.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN6.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN6.prototype.clone = function clone() {
        var r6 = new BN6(null);
        this.copy(r6);
        return r6;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN6.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e5) {
          BN6.prototype.inspect = inspect4;
        }
      } else {
        BN6.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modrn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer3) {
        BN6.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer3, endian, length);
        };
      }
      BN6.prototype.toArray = function toArray3(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN6.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN6.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = num.words[off] >>> wbit & 1;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN6.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this._strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this._strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this._strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN6.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t5 = new Array(N5);
        var l5 = BN6.prototype._countBits(N5) - 1;
        for (var i5 = 0; i5 < N5; i5++) {
          t5[i5] = this.revBin(i5, l5, N5);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N5) {
        if (x5 === 0 || x5 === N5 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i5 = 0; i5 < N5; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s6 = 1; s6 < N5; s6 <<= 1) {
          var l5 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N5; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s6; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s6];
              var io = itws[p5 + j5 + s6];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s6] = re - ro;
              itws[p5 + j5 + s6] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N5 = Math.max(m5, n3) | 1;
        var odd = N5 & 1;
        var i5 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1)
          return;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N5 - i5 - 1];
          rws[N5 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N5 - i5 - 1];
          iws[N5 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N5) * 8192 + Math.round(ws[2 * i5] / N5) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N5; ++i5) {
          rws[i5] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i5 = 0; i5 < N5; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N5 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N5);
        var _10 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x5.words, x5.length, rws, N5);
        this.convert13b(y5.words, y5.length, nrws, N5);
        this.transform(rws, _10, rwst, iwst, N5, rbt);
        this.transform(nrws, _10, nrwst, niwst, N5, rbt);
        for (var i5 = 0; i5 < N5; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _10, N5, rbt);
        this.conjugate(rmws, _10, N5);
        this.normalize13b(rmws, N5);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out._strip();
      };
      BN6.prototype.mul = function mul3(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(typeof num === "number");
        assert5(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s6] = this.words[i5];
          }
          for (i5 = 0; i5 < s6; i5++) {
            this.words[i5] = 0;
          }
          this.length += s6;
        }
        return this._strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s6;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s6; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w6 = this.words[s6];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul3;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert5(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a5._strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert5(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN6.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN6.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B3.isOdd()) {
                A6.iadd(yp);
                B3.isub(xp);
              }
              A6.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g5)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s6; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert5(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert5(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p5) {
        this.name = name2;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert5(a5.negative === 0, "red works only with positives");
        assert5(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert5((a5.negative | b4.negative) === 0, "red works only with positives");
        assert5(a5.red && a5.red === b4.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        move(a5, a5.umod(this.m)._forceRed(this));
        return a5;
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s6 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s6++;
          q5.iushrn(1);
        }
        assert5(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c5 = this.pow(z4, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s6;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert5(i5 < m5);
          var b4 = this.pow(c5, new BN6(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2
});
function inRange(a5, min2, max2) {
  return min2 <= a5 && a5 <= max2;
}
function ToDictionary(o5) {
  if (o5 === void 0)
    return {};
  if (o5 === Object(o5))
    return o5;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string2) {
  var s6 = String(string2);
  var n3 = s6.length;
  var i5 = 0;
  var u5 = [];
  while (i5 < n3) {
    var c5 = s6.charCodeAt(i5);
    if (c5 < 55296 || c5 > 57343) {
      u5.push(c5);
    } else if (56320 <= c5 && c5 <= 57343) {
      u5.push(65533);
    } else if (55296 <= c5 && c5 <= 56319) {
      if (i5 === n3 - 1) {
        u5.push(65533);
      } else {
        var d5 = string2.charCodeAt(i5 + 1);
        if (56320 <= d5 && d5 <= 57343) {
          var a5 = c5 & 1023;
          var b4 = d5 & 1023;
          u5.push(65536 + (a5 << 10) + b4);
          i5 += 1;
        } else {
          u5.push(65533);
        }
      }
    }
    i5 += 1;
  }
  return u5;
}
function codePointsToString(code_points) {
  var s6 = "";
  for (var i5 = 0; i5 < code_points.length; ++i5) {
    var cp = code_points[i5];
    if (cp <= 65535) {
      s6 += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s6 += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
    }
  }
  return s6;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder() {
}
function Encoder() {
}
function TextDecoder2(encoding5, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding5, options);
  }
  encoding5 = encoding5 !== void 0 ? String(encoding5).toLowerCase() : DEFAULT_ENCODING;
  if (encoding5 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder2(encoding5, options) {
  if (!(this instanceof TextEncoder2))
    return new TextEncoder2(encoding5, options);
  encoding5 = encoding5 !== void 0 ? String(encoding5).toLowerCase() : DEFAULT_ENCODING;
  if (encoding5 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count2, offset2;
    if (inRange(code_point, 128, 2047)) {
      count2 = 1;
      offset2 = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count2 = 2;
      offset2 = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count2 = 3;
      offset2 = 240;
    }
    var bytes = [(code_point >> 6 * count2) + offset2];
    while (count2 > 0) {
      var temp = code_point >> 6 * (count2 - 1);
      bytes.push(128 | temp & 63);
      count2 -= 1;
    }
    return bytes;
  };
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({
  "node_modules/text-encoding-utf-8/src/encoding.js"() {
    "use strict";
    end_of_stream = -1;
    Stream.prototype = {
      endOfStream: function() {
        return !this.tokens.length;
      },
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      prepend: function(token) {
        if (Array.isArray(token)) {
          var tokens = token;
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token);
        }
      },
      push: function(token) {
        if (Array.isArray(token)) {
          var tokens = token;
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token);
        }
      }
    };
    finished = -1;
    Decoder.prototype = {
      handler: function(stream, bite) {
      }
    };
    Encoder.prototype = {
      handler: function(stream, code_point) {
      }
    };
    DEFAULT_ENCODING = "utf-8";
    TextDecoder2.prototype = {
      decode: function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(code_points, result);
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(code_points, result);
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    TextEncoder2.prototype = {
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes.push.apply(bytes, result);
          else
            bytes.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(bytes, result);
            else
              bytes.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes);
      }
    };
  }
});

// node_modules/borsh/lib/index.js
var require_lib = __commonJS({
  "node_modules/borsh/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o5, v8) {
      Object.defineProperty(o5, "default", { enumerable: true, value: v8 });
    } : function(o5, v8) {
      o5["default"] = v8;
    });
    var __decorate = exports && exports.__decorate || function(decorators, target, key2, desc) {
      var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d5;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r6 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i5 = decorators.length - 1; i5 >= 0; i5--)
          if (d5 = decorators[i5])
            r6 = (c5 < 3 ? d5(r6) : c5 > 3 ? d5(target, key2, r6) : d5(target, key2)) || r6;
      return c5 > 3 && r6 && Object.defineProperty(target, key2, r6), r6;
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k5 in mod)
          if (k5 !== "default" && Object.hasOwnProperty.call(mod, k5))
            __createBinding(result, mod, k5);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
    var bn_js_1 = __importDefault(require_bn2());
    var bs58_1 = __importDefault(require_bs58());
    var encoding5 = __importStar((init_encoding(), encoding_exports));
    var TextDecoder3 = typeof global.TextDecoder !== "function" ? encoding5.TextDecoder : global.TextDecoder;
    var textDecoder = new TextDecoder3("utf-8", { fatal: true });
    function baseEncode(value) {
      if (typeof value === "string") {
        value = Buffer.from(value, "utf8");
      }
      return bs58_1.default.encode(Buffer.from(value));
    }
    exports.baseEncode = baseEncode;
    function baseDecode(value) {
      return Buffer.from(bs58_1.default.decode(value));
    }
    exports.baseDecode = baseDecode;
    var INITIAL_LENGTH = 1024;
    var BorshError = class extends Error {
      constructor(message) {
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
      }
      addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    };
    exports.BorshError = BorshError;
    var BinaryWriter = class {
      constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
      }
      maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
      }
      writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
      }
      writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
      }
      writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
      }
      writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
      }
      writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
      }
      writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
      }
      writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
      }
      writeBuffer(buffer2) {
        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer2, Buffer.alloc(INITIAL_LENGTH)]);
        this.length += buffer2.length;
      }
      writeString(str) {
        this.maybeResize();
        const b4 = Buffer.from(str, "utf8");
        this.writeU32(b4.length);
        this.writeBuffer(b4);
      }
      writeFixedArray(array2) {
        this.writeBuffer(Buffer.from(array2));
      }
      writeArray(array2, fn) {
        this.maybeResize();
        this.writeU32(array2.length);
        for (const elem of array2) {
          this.maybeResize();
          fn(elem);
        }
      }
      toArray() {
        return this.buf.subarray(0, this.length);
      }
    };
    exports.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
      const originalMethod = propertyDescriptor.value;
      propertyDescriptor.value = function(...args) {
        try {
          return originalMethod.apply(this, args);
        } catch (e5) {
          if (e5 instanceof RangeError) {
            const code = e5.code;
            if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
              throw new BorshError("Reached the end of buffer when deserializing");
            }
          }
          throw e5;
        }
      };
    }
    var BinaryReader = class {
      constructor(buf) {
        this.buf = buf;
        this.offset = 0;
      }
      readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
      }
      readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      }
      readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      }
      readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
      }
      readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
      }
      readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
      }
      readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
      }
      readBuffer(len) {
        if (this.offset + len > this.buf.length) {
          throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
        }
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
      }
      readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
          return textDecoder.decode(buf);
        } catch (e5) {
          throw new BorshError(`Error decoding UTF-8 string: ${e5}`);
        }
      }
      readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
      }
      readArray(fn) {
        const len = this.readU32();
        const result = Array();
        for (let i5 = 0; i5 < len; ++i5) {
          result.push(fn());
        }
        return result;
      }
    };
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU8", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU16", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU32", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU64", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU128", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU256", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU512", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readString", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readFixedArray", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readArray", null);
    exports.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string2) {
      return string2.charAt(0).toUpperCase() + string2.slice(1);
    }
    function serializeField(schema, fieldName, value, fieldType, writer) {
      try {
        if (typeof fieldType === "string") {
          writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        } else if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            if (value.length !== fieldType[0]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
            }
            writer.writeFixedArray(value);
          } else {
            writer.writeArray(value, (item) => {
              serializeField(schema, fieldName, item, fieldType[0], writer);
            });
          }
        } else if (fieldType.kind !== void 0) {
          switch (fieldType.kind) {
            case "option": {
              if (value === null || value === void 0) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(schema, fieldName, value, fieldType.type, writer);
              }
              break;
            }
            default:
              throw new BorshError(`FieldType ${fieldType} unrecognized`);
          }
        } else {
          serializeStruct(schema, value, writer);
        }
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function serializeStruct(schema, obj, writer) {
      const structSchema = schema.get(obj.constructor);
      if (!structSchema) {
        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        });
      } else if (structSchema.kind === "enum") {
        const name2 = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
          const [fieldName, fieldType] = structSchema.values[idx];
          if (fieldName === name2) {
            writer.writeU8(idx);
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
            break;
          }
        }
      } else {
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
      }
    }
    function serialize4(schema, obj) {
      const writer = new BinaryWriter();
      serializeStruct(schema, obj, writer);
      return writer.toArray();
    }
    exports.serialize = serialize4;
    function deserializeField(schema, fieldName, fieldType, reader) {
      try {
        if (typeof fieldType === "string") {
          return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            return reader.readFixedArray(fieldType[0]);
          }
          return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
        }
        if (fieldType.kind === "option") {
          const option = reader.readU8();
          if (option) {
            return deserializeField(schema, fieldName, fieldType.type, reader);
          }
          return void 0;
        }
        return deserializeStruct(schema, fieldType, reader);
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function deserializeStruct(schema, classType, reader) {
      const structSchema = schema.get(classType);
      if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields) {
          result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        }
        return new classType(result);
      }
      if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
          throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType({ [fieldName]: fieldValue });
      }
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    function deserialize2(schema, classType, buffer2) {
      const reader = new BinaryReader(buffer2);
      const result = deserializeStruct(schema, classType, reader);
      if (reader.offset < buffer2.length) {
        throw new BorshError(`Unexpected ${buffer2.length - reader.offset} bytes after deserialized data`);
      }
      return result;
    }
    exports.deserialize = deserialize2;
    function deserializeUnchecked2(schema, classType, buffer2) {
      const reader = new BinaryReader(buffer2);
      return deserializeStruct(schema, classType, reader);
    }
    exports.deserializeUnchecked = deserializeUnchecked2;
  }
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/@solana/buffer-layout/lib/Layout.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d5, b4) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
          d6.__proto__ = b5;
        } || function(d6, b5) {
          for (var p5 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p5))
              d6[p5] = b5[p5];
        };
        return extendStatics2(d5, b4);
      };
      return function(d5, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics2(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    exports.__esModule = true;
    exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
    exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
    var buffer_1 = require_buffer();
    function checkUint8Array(b4) {
      if (!(b4 instanceof Uint8Array)) {
        throw new TypeError("b must be a Uint8Array");
      }
    }
    exports.checkUint8Array = checkUint8Array;
    function uint8ArrayToBuffer(b4) {
      checkUint8Array(b4);
      return buffer_1.Buffer.from(b4.buffer, b4.byteOffset, b4.length);
    }
    exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
    var Layout = function() {
      function Layout2(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      Layout2.prototype.makeDestinationObject = function() {
        return {};
      };
      Layout2.prototype.decode = function(b4, offset2) {
        throw new Error("Layout is abstract");
      };
      Layout2.prototype.encode = function(src, b4, offset2) {
        throw new Error("Layout is abstract");
      };
      Layout2.prototype.getSpan = function(b4, offset2) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      };
      Layout2.prototype.replicate = function(property) {
        var rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      };
      Layout2.prototype.fromArray = function(values) {
        return void 0;
      };
      return Layout2;
    }();
    exports.Layout = Layout;
    function nameWithProperty(name2, lo) {
      if (lo.property) {
        return name2 + "[" + lo.property + "]";
      }
      return name2;
    }
    exports.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if (typeof Class !== "function") {
        throw new TypeError("Class must be constructor");
      }
      if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = function() {
        return new Class();
      };
      Object.defineProperty(Class.prototype, "encode", {
        value: function(b4, offset2) {
          return layout.encode(this, b4, offset2);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value: function(b4, offset2) {
          return layout.decode(b4, offset2);
        },
        writable: true
      });
    }
    exports.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = function(_super) {
      __extends2(ExternalLayout2, _super);
      function ExternalLayout2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ExternalLayout2.prototype.isCount = function() {
        throw new Error("ExternalLayout is abstract");
      };
      return ExternalLayout2;
    }(Layout);
    exports.ExternalLayout = ExternalLayout;
    var GreedyCount = function(_super) {
      __extends2(GreedyCount2, _super);
      function GreedyCount2(elementSpan, property) {
        var _this = this;
        if (elementSpan === void 0) {
          elementSpan = 1;
        }
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        _this = _super.call(this, -1, property) || this;
        _this.elementSpan = elementSpan;
        return _this;
      }
      GreedyCount2.prototype.isCount = function() {
        return true;
      };
      GreedyCount2.prototype.decode = function(b4, offset2) {
        checkUint8Array(b4);
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var rem = b4.length - offset2;
        return Math.floor(rem / this.elementSpan);
      };
      GreedyCount2.prototype.encode = function(src, b4, offset2) {
        return 0;
      };
      return GreedyCount2;
    }(ExternalLayout);
    exports.GreedyCount = GreedyCount;
    var OffsetLayout = function(_super) {
      __extends2(OffsetLayout2, _super);
      function OffsetLayout2(layout, offset2, property) {
        var _this = this;
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (offset2 === void 0) {
          offset2 = 0;
        } else if (!Number.isInteger(offset2)) {
          throw new TypeError("offset must be integer or undefined");
        }
        _this = _super.call(this, layout.span, property || layout.property) || this;
        _this.layout = layout;
        _this.offset = offset2;
        return _this;
      }
      OffsetLayout2.prototype.isCount = function() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      };
      OffsetLayout2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return this.layout.decode(b4, offset2 + this.offset);
      };
      OffsetLayout2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return this.layout.encode(src, b4, offset2 + this.offset);
      };
      return OffsetLayout2;
    }(ExternalLayout);
    exports.OffsetLayout = OffsetLayout;
    var UInt = function(_super) {
      __extends2(UInt2, _super);
      function UInt2(span, property) {
        var _this = _super.call(this, span, property) || this;
        if (6 < _this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
        return _this;
      }
      UInt2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readUIntLE(offset2, this.span);
      };
      UInt2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeUIntLE(src, offset2, this.span);
        return this.span;
      };
      return UInt2;
    }(Layout);
    exports.UInt = UInt;
    var UIntBE = function(_super) {
      __extends2(UIntBE2, _super);
      function UIntBE2(span, property) {
        var _this = _super.call(this, span, property) || this;
        if (6 < _this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
        return _this;
      }
      UIntBE2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readUIntBE(offset2, this.span);
      };
      UIntBE2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeUIntBE(src, offset2, this.span);
        return this.span;
      };
      return UIntBE2;
    }(Layout);
    exports.UIntBE = UIntBE;
    var Int = function(_super) {
      __extends2(Int2, _super);
      function Int2(span, property) {
        var _this = _super.call(this, span, property) || this;
        if (6 < _this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
        return _this;
      }
      Int2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readIntLE(offset2, this.span);
      };
      Int2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeIntLE(src, offset2, this.span);
        return this.span;
      };
      return Int2;
    }(Layout);
    exports.Int = Int;
    var IntBE = function(_super) {
      __extends2(IntBE2, _super);
      function IntBE2(span, property) {
        var _this = _super.call(this, span, property) || this;
        if (6 < _this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
        return _this;
      }
      IntBE2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readIntBE(offset2, this.span);
      };
      IntBE2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeIntBE(src, offset2, this.span);
        return this.span;
      };
      return IntBE2;
    }(Layout);
    exports.IntBE = IntBE;
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
      var hi32 = Math.floor(src / V2E32);
      var lo32 = src - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = function(_super) {
      __extends2(NearUInt642, _super);
      function NearUInt642(property) {
        return _super.call(this, 8, property) || this;
      }
      NearUInt642.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var buffer2 = uint8ArrayToBuffer(b4);
        var lo32 = buffer2.readUInt32LE(offset2);
        var hi32 = buffer2.readUInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      };
      NearUInt642.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var split = divmodInt64(src);
        var buffer2 = uint8ArrayToBuffer(b4);
        buffer2.writeUInt32LE(split.lo32, offset2);
        buffer2.writeUInt32LE(split.hi32, offset2 + 4);
        return 8;
      };
      return NearUInt642;
    }(Layout);
    exports.NearUInt64 = NearUInt64;
    var NearUInt64BE = function(_super) {
      __extends2(NearUInt64BE2, _super);
      function NearUInt64BE2(property) {
        return _super.call(this, 8, property) || this;
      }
      NearUInt64BE2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var buffer2 = uint8ArrayToBuffer(b4);
        var hi32 = buffer2.readUInt32BE(offset2);
        var lo32 = buffer2.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      };
      NearUInt64BE2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var split = divmodInt64(src);
        var buffer2 = uint8ArrayToBuffer(b4);
        buffer2.writeUInt32BE(split.hi32, offset2);
        buffer2.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      };
      return NearUInt64BE2;
    }(Layout);
    exports.NearUInt64BE = NearUInt64BE;
    var NearInt64 = function(_super) {
      __extends2(NearInt642, _super);
      function NearInt642(property) {
        return _super.call(this, 8, property) || this;
      }
      NearInt642.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var buffer2 = uint8ArrayToBuffer(b4);
        var lo32 = buffer2.readUInt32LE(offset2);
        var hi32 = buffer2.readInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      };
      NearInt642.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var split = divmodInt64(src);
        var buffer2 = uint8ArrayToBuffer(b4);
        buffer2.writeUInt32LE(split.lo32, offset2);
        buffer2.writeInt32LE(split.hi32, offset2 + 4);
        return 8;
      };
      return NearInt642;
    }(Layout);
    exports.NearInt64 = NearInt64;
    var NearInt64BE = function(_super) {
      __extends2(NearInt64BE2, _super);
      function NearInt64BE2(property) {
        return _super.call(this, 8, property) || this;
      }
      NearInt64BE2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var buffer2 = uint8ArrayToBuffer(b4);
        var hi32 = buffer2.readInt32BE(offset2);
        var lo32 = buffer2.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      };
      NearInt64BE2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var split = divmodInt64(src);
        var buffer2 = uint8ArrayToBuffer(b4);
        buffer2.writeInt32BE(split.hi32, offset2);
        buffer2.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      };
      return NearInt64BE2;
    }(Layout);
    exports.NearInt64BE = NearInt64BE;
    var Float = function(_super) {
      __extends2(Float2, _super);
      function Float2(property) {
        return _super.call(this, 4, property) || this;
      }
      Float2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readFloatLE(offset2);
      };
      Float2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeFloatLE(src, offset2);
        return 4;
      };
      return Float2;
    }(Layout);
    exports.Float = Float;
    var FloatBE = function(_super) {
      __extends2(FloatBE2, _super);
      function FloatBE2(property) {
        return _super.call(this, 4, property) || this;
      }
      FloatBE2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readFloatBE(offset2);
      };
      FloatBE2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeFloatBE(src, offset2);
        return 4;
      };
      return FloatBE2;
    }(Layout);
    exports.FloatBE = FloatBE;
    var Double = function(_super) {
      __extends2(Double2, _super);
      function Double2(property) {
        return _super.call(this, 8, property) || this;
      }
      Double2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readDoubleLE(offset2);
      };
      Double2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeDoubleLE(src, offset2);
        return 8;
      };
      return Double2;
    }(Layout);
    exports.Double = Double;
    var DoubleBE = function(_super) {
      __extends2(DoubleBE2, _super);
      function DoubleBE2(property) {
        return _super.call(this, 8, property) || this;
      }
      DoubleBE2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return uint8ArrayToBuffer(b4).readDoubleBE(offset2);
      };
      DoubleBE2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        uint8ArrayToBuffer(b4).writeDoubleBE(src, offset2);
        return 8;
      };
      return DoubleBE2;
    }(Layout);
    exports.DoubleBE = DoubleBE;
    var Sequence = function(_super) {
      __extends2(Sequence2, _super);
      function Sequence2(elementLayout, count2, property) {
        var _this = this;
        if (!(elementLayout instanceof Layout)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count2 instanceof ExternalLayout && count2.isCount() || Number.isInteger(count2) && 0 <= count2)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        var span = -1;
        if (!(count2 instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count2 * elementLayout.span;
        }
        _this = _super.call(this, span, property) || this;
        _this.elementLayout = elementLayout;
        _this.count = count2;
        return _this;
      }
      Sequence2.prototype.getSpan = function(b4, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var span = 0;
        var count2 = this.count;
        if (count2 instanceof ExternalLayout) {
          count2 = count2.decode(b4, offset2);
        }
        if (0 < this.elementLayout.span) {
          span = count2 * this.elementLayout.span;
        } else {
          var idx = 0;
          while (idx < count2) {
            span += this.elementLayout.getSpan(b4, offset2 + span);
            ++idx;
          }
        }
        return span;
      };
      Sequence2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var rv = [];
        var i5 = 0;
        var count2 = this.count;
        if (count2 instanceof ExternalLayout) {
          count2 = count2.decode(b4, offset2);
        }
        while (i5 < count2) {
          rv.push(this.elementLayout.decode(b4, offset2));
          offset2 += this.elementLayout.getSpan(b4, offset2);
          i5 += 1;
        }
        return rv;
      };
      Sequence2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var elo = this.elementLayout;
        var span = src.reduce(function(span2, v8) {
          return span2 + elo.encode(v8, b4, offset2 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b4, offset2);
        }
        return span;
      };
      return Sequence2;
    }(Layout);
    exports.Sequence = Sequence;
    var Structure = function(_super) {
      __extends2(Structure2, _super);
      function Structure2(fields, property, decodePrefixes) {
        var _this = this;
        if (!(Array.isArray(fields) && fields.reduce(function(acc, v8) {
          return acc && v8 instanceof Layout;
        }, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if (typeof property === "boolean" && decodePrefixes === void 0) {
          decodePrefixes = property;
          property = void 0;
        }
        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
          var fd = fields_1[_i];
          if (0 > fd.span && fd.property === void 0) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        var span = -1;
        try {
          span = fields.reduce(function(span2, fd2) {
            return span2 + fd2.getSpan();
          }, 0);
        } catch (e5) {
        }
        _this = _super.call(this, span, property) || this;
        _this.fields = fields;
        _this.decodePrefixes = !!decodePrefixes;
        return _this;
      }
      Structure2.prototype.getSpan = function(b4, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var span = 0;
        try {
          span = this.fields.reduce(function(span2, fd) {
            var fsp = fd.getSpan(b4, offset2);
            offset2 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e5) {
          throw new RangeError("indeterminate span");
        }
        return span;
      };
      Structure2.prototype.decode = function(b4, offset2) {
        checkUint8Array(b4);
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var dest = this.makeDestinationObject();
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          if (fd.property !== void 0) {
            dest[fd.property] = fd.decode(b4, offset2);
          }
          offset2 += fd.getSpan(b4, offset2);
          if (this.decodePrefixes && b4.length === offset2) {
            break;
          }
        }
        return dest;
      };
      Structure2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var firstOffset = offset2;
        var lastOffset = 0;
        var lastWrote = 0;
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          var span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (fd.property !== void 0) {
            var fv = src[fd.property];
            if (fv !== void 0) {
              lastWrote = fd.encode(fv, b4, offset2);
              if (0 > span) {
                span = fd.getSpan(b4, offset2);
              }
            }
          }
          lastOffset = offset2;
          offset2 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      };
      Structure2.prototype.fromArray = function(values) {
        var dest = this.makeDestinationObject();
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          if (fd.property !== void 0 && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      };
      Structure2.prototype.layoutFor = function(property) {
        if (typeof property !== "string") {
          throw new TypeError("property must be string");
        }
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      };
      Structure2.prototype.offsetOf = function(property) {
        if (typeof property !== "string") {
          throw new TypeError("property must be string");
        }
        var offset2 = 0;
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          if (fd.property === property) {
            return offset2;
          }
          if (0 > fd.span) {
            offset2 = -1;
          } else if (0 <= offset2) {
            offset2 += fd.span;
          }
        }
        return void 0;
      };
      return Structure2;
    }(Layout);
    exports.Structure = Structure;
    var UnionDiscriminator = function() {
      function UnionDiscriminator2(property) {
        this.property = property;
      }
      UnionDiscriminator2.prototype.decode = function(b4, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      };
      UnionDiscriminator2.prototype.encode = function(src, b4, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      };
      return UnionDiscriminator2;
    }();
    exports.UnionDiscriminator = UnionDiscriminator;
    var UnionLayoutDiscriminator = function(_super) {
      __extends2(UnionLayoutDiscriminator2, _super);
      function UnionLayoutDiscriminator2(layout, property) {
        var _this = this;
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        _this = _super.call(this, property || layout.property || "variant") || this;
        _this.layout = layout;
        return _this;
      }
      UnionLayoutDiscriminator2.prototype.decode = function(b4, offset2) {
        return this.layout.decode(b4, offset2);
      };
      UnionLayoutDiscriminator2.prototype.encode = function(src, b4, offset2) {
        return this.layout.encode(src, b4, offset2);
      };
      return UnionLayoutDiscriminator2;
    }(UnionDiscriminator);
    exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    var Union = function(_super) {
      __extends2(Union2, _super);
      function Union2(discr, defaultLayout, property) {
        var _this = this;
        var upv = discr instanceof UInt || discr instanceof UIntBE;
        var discriminator;
        if (upv) {
          discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discriminator = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        } else {
          discriminator = discr;
        }
        if (defaultLayout === void 0) {
          defaultLayout = null;
        }
        if (!(defaultLayout === null || defaultLayout instanceof Layout)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (defaultLayout !== null) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (defaultLayout.property === void 0) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        var span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && upv) {
            span += discriminator.layout.span;
          }
        }
        _this = _super.call(this, span, property) || this;
        _this.discriminator = discriminator;
        _this.usesPrefixDiscriminator = upv;
        _this.defaultLayout = defaultLayout;
        _this.registry = {};
        var boundGetSourceVariant = _this.defaultGetSourceVariant.bind(_this);
        _this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        _this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
        return _this;
      }
      Union2.prototype.getSpan = function(b4, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var vlo = this.getVariant(b4, offset2);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b4, offset2);
      };
      Union2.prototype.defaultGetSourceVariant = function(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
            return void 0;
          }
          var vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
            return vlo;
          }
        } else {
          for (var tag in this.registry) {
            var vlo = this.registry[tag];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      };
      Union2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var dest;
        var dlo = this.discriminator;
        var discr = dlo.decode(b4, offset2);
        var clo = this.registry[discr];
        if (clo === void 0) {
          var defaultLayout = this.defaultLayout;
          var contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[defaultLayout.property] = defaultLayout.decode(b4, offset2 + contentOffset);
        } else {
          dest = clo.decode(b4, offset2);
        }
        return dest;
      };
      Union2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var vlo = this.getSourceVariant(src);
        if (vlo === void 0) {
          var dlo = this.discriminator;
          var clo = this.defaultLayout;
          var contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b4, offset2);
          return contentOffset + clo.encode(src[clo.property], b4, offset2 + contentOffset);
        }
        return vlo.encode(src, b4, offset2);
      };
      Union2.prototype.addVariant = function(variant, layout, property) {
        var rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      };
      Union2.prototype.getVariant = function(vb, offset2) {
        var variant;
        if (vb instanceof Uint8Array) {
          if (offset2 === void 0) {
            offset2 = 0;
          }
          variant = this.discriminator.decode(vb, offset2);
        } else {
          variant = vb;
        }
        return this.registry[variant];
      };
      return Union2;
    }(Layout);
    exports.Union = Union;
    var VariantLayout = function(_super) {
      __extends2(VariantLayout2, _super);
      function VariantLayout2(union2, variant, layout, property) {
        var _this = this;
        if (!(union2 instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if (typeof layout === "string" && property === void 0) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (union2.defaultLayout !== null && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if (typeof property !== "string") {
            throw new TypeError("variant must have a String property");
          }
        }
        var span = union2.span;
        if (0 > union2.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union2.usesPrefixDiscriminator) {
            span += union2.discriminator.layout.span;
          }
        }
        _this = _super.call(this, span, property) || this;
        _this.union = union2;
        _this.variant = variant;
        _this.layout = layout || null;
        return _this;
      }
      VariantLayout2.prototype.getSpan = function(b4, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        var span = 0;
        if (this.layout) {
          span = this.layout.getSpan(b4, offset2 + contentOffset);
        }
        return contentOffset + span;
      };
      VariantLayout2.prototype.decode = function(b4, offset2) {
        var dest = this.makeDestinationObject();
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (this !== this.union.getVariant(b4, offset2)) {
          throw new Error("variant mismatch");
        }
        var contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        var property = this.property;
        if (this.layout) {
          dest[property] = this.layout.decode(b4, offset2 + contentOffset);
        } else if (property) {
          dest[property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      };
      VariantLayout2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        var property = this.property;
        if (this.layout && !Object.prototype.hasOwnProperty.call(src, property)) {
          throw new TypeError("variant lacks property " + property);
        }
        this.union.discriminator.encode(this.variant, b4, offset2);
        var span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[property], b4, offset2 + contentOffset);
          span += this.layout.getSpan(b4, offset2 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      };
      VariantLayout2.prototype.fromArray = function(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
        return void 0;
      };
      return VariantLayout2;
    }(Layout);
    exports.VariantLayout = VariantLayout;
    function fixBitwiseResult(v8) {
      if (0 > v8) {
        v8 += 4294967296;
      }
      return v8;
    }
    var BitStructure = function(_super) {
      __extends2(BitStructure2, _super);
      function BitStructure2(word, msb, property) {
        var _this = this;
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if (typeof msb === "string" && property === void 0) {
          property = msb;
          msb = false;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        _this = _super.call(this, word.span, property) || this;
        _this.word = word;
        _this.msb = !!msb;
        _this.fields = [];
        var value = 0;
        _this._packedSetValue = function(v8) {
          value = fixBitwiseResult(v8);
          return this;
        };
        _this._packedGetValue = function() {
          return value;
        };
        return _this;
      }
      BitStructure2.prototype.decode = function(b4, offset2) {
        var dest = this.makeDestinationObject();
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var value = this.word.decode(b4, offset2);
        this._packedSetValue(value);
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          if (fd.property !== void 0) {
            dest[fd.property] = fd.decode(value);
          }
        }
        return dest;
      };
      BitStructure2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var value = this.word.decode(b4, offset2);
        this._packedSetValue(value);
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          if (fd.property !== void 0) {
            var fv = src[fd.property];
            if (fv !== void 0) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b4, offset2);
      };
      BitStructure2.prototype.addField = function(bits, property) {
        var bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      };
      BitStructure2.prototype.addBoolean = function(property) {
        var bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      };
      BitStructure2.prototype.fieldFor = function(property) {
        if (typeof property !== "string") {
          throw new TypeError("property must be string");
        }
        for (var _i = 0, _a2 = this.fields; _i < _a2.length; _i++) {
          var fd = _a2[_i];
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      };
      return BitStructure2;
    }(Layout);
    exports.BitStructure = BitStructure;
    var BitField = function() {
      function BitField2(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        var totalBits = 8 * container.span;
        var usedBits = container.fields.reduce(function(sum, fd) {
          return sum + fd.bits;
        }, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (bits === 32) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      BitField2.prototype.decode = function(b4, offset2) {
        var word = this.container._packedGetValue();
        var wordValue = fixBitwiseResult(word & this.wordMask);
        var value = wordValue >>> this.start;
        return value;
      };
      BitField2.prototype.encode = function(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        var word = this.container._packedGetValue();
        var wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      };
      return BitField2;
    }();
    exports.BitField = BitField;
    var Boolean2 = function(_super) {
      __extends2(Boolean3, _super);
      function Boolean3(container, property) {
        return _super.call(this, container, 1, property) || this;
      }
      Boolean3.prototype.decode = function(b4, offset2) {
        return !!BitField.prototype.decode.call(this, b4, offset2);
      };
      Boolean3.prototype.encode = function(value) {
        if (typeof value === "boolean") {
          value = +value;
        }
        return BitField.prototype.encode.call(this, value);
      };
      return Boolean3;
    }(BitField);
    exports.Boolean = Boolean2;
    var Blob2 = function(_super) {
      __extends2(Blob3, _super);
      function Blob3(length, property) {
        var _this = this;
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        var span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        _this = _super.call(this, span, property) || this;
        _this.length = length;
        return _this;
      }
      Blob3.prototype.getSpan = function(b4, offset2) {
        var span = this.span;
        if (0 > span) {
          span = this.length.decode(b4, offset2);
        }
        return span;
      };
      Blob3.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var span = this.span;
        if (0 > span) {
          span = this.length.decode(b4, offset2);
        }
        return uint8ArrayToBuffer(b4).slice(offset2, offset2 + span);
      };
      Blob3.prototype.encode = function(src, b4, offset2) {
        var span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(src instanceof Uint8Array && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        }
        if (offset2 + span > b4.length) {
          throw new RangeError("encoding overruns Uint8Array");
        }
        var srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b4).write(srcBuffer.toString("hex"), offset2, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b4, offset2);
        }
        return span;
      };
      return Blob3;
    }(Layout);
    exports.Blob = Blob2;
    var CString = function(_super) {
      __extends2(CString2, _super);
      function CString2(property) {
        return _super.call(this, -1, property) || this;
      }
      CString2.prototype.getSpan = function(b4, offset2) {
        checkUint8Array(b4);
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var idx = offset2;
        while (idx < b4.length && b4[idx] !== 0) {
          idx += 1;
        }
        return 1 + idx - offset2;
      };
      CString2.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var span = this.getSpan(b4, offset2);
        return uint8ArrayToBuffer(b4).slice(offset2, offset2 + span - 1).toString("utf-8");
      };
      CString2.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (typeof src !== "string") {
          src = src.toString();
        }
        var srcb = buffer_1.Buffer.from(src, "utf8");
        var span = srcb.length;
        if (offset2 + span > b4.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        var buffer2 = uint8ArrayToBuffer(b4);
        srcb.copy(buffer2, offset2);
        buffer2[offset2 + span] = 0;
        return span + 1;
      };
      return CString2;
    }(Layout);
    exports.CString = CString;
    var UTF8 = function(_super) {
      __extends2(UTF82, _super);
      function UTF82(maxSpan, property) {
        var _this = this;
        if (typeof maxSpan === "string" && property === void 0) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (maxSpan === void 0) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        _this = _super.call(this, -1, property) || this;
        _this.maxSpan = maxSpan;
        return _this;
      }
      UTF82.prototype.getSpan = function(b4, offset2) {
        checkUint8Array(b4);
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b4.length - offset2;
      };
      UTF82.prototype.decode = function(b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var span = this.getSpan(b4, offset2);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return uint8ArrayToBuffer(b4).slice(offset2, offset2 + span).toString("utf-8");
      };
      UTF82.prototype.encode = function(src, b4, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (typeof src !== "string") {
          src = src.toString();
        }
        var srcb = buffer_1.Buffer.from(src, "utf8");
        var span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset2 + span > b4.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(uint8ArrayToBuffer(b4), offset2);
        return span;
      };
      return UTF82;
    }(Layout);
    exports.UTF8 = UTF8;
    var Constant = function(_super) {
      __extends2(Constant2, _super);
      function Constant2(value, property) {
        var _this = _super.call(this, 0, property) || this;
        _this.value = value;
        return _this;
      }
      Constant2.prototype.decode = function(b4, offset2) {
        return this.value;
      };
      Constant2.prototype.encode = function(src, b4, offset2) {
        return 0;
      };
      return Constant2;
    }(Layout);
    exports.Constant = Constant;
    exports.greedy = function(elementSpan, property) {
      return new GreedyCount(elementSpan, property);
    };
    exports.offset = function(layout, offset2, property) {
      return new OffsetLayout(layout, offset2, property);
    };
    exports.u8 = function(property) {
      return new UInt(1, property);
    };
    exports.u16 = function(property) {
      return new UInt(2, property);
    };
    exports.u24 = function(property) {
      return new UInt(3, property);
    };
    exports.u32 = function(property) {
      return new UInt(4, property);
    };
    exports.u40 = function(property) {
      return new UInt(5, property);
    };
    exports.u48 = function(property) {
      return new UInt(6, property);
    };
    exports.nu64 = function(property) {
      return new NearUInt64(property);
    };
    exports.u16be = function(property) {
      return new UIntBE(2, property);
    };
    exports.u24be = function(property) {
      return new UIntBE(3, property);
    };
    exports.u32be = function(property) {
      return new UIntBE(4, property);
    };
    exports.u40be = function(property) {
      return new UIntBE(5, property);
    };
    exports.u48be = function(property) {
      return new UIntBE(6, property);
    };
    exports.nu64be = function(property) {
      return new NearUInt64BE(property);
    };
    exports.s8 = function(property) {
      return new Int(1, property);
    };
    exports.s16 = function(property) {
      return new Int(2, property);
    };
    exports.s24 = function(property) {
      return new Int(3, property);
    };
    exports.s32 = function(property) {
      return new Int(4, property);
    };
    exports.s40 = function(property) {
      return new Int(5, property);
    };
    exports.s48 = function(property) {
      return new Int(6, property);
    };
    exports.ns64 = function(property) {
      return new NearInt64(property);
    };
    exports.s16be = function(property) {
      return new IntBE(2, property);
    };
    exports.s24be = function(property) {
      return new IntBE(3, property);
    };
    exports.s32be = function(property) {
      return new IntBE(4, property);
    };
    exports.s40be = function(property) {
      return new IntBE(5, property);
    };
    exports.s48be = function(property) {
      return new IntBE(6, property);
    };
    exports.ns64be = function(property) {
      return new NearInt64BE(property);
    };
    exports.f32 = function(property) {
      return new Float(property);
    };
    exports.f32be = function(property) {
      return new FloatBE(property);
    };
    exports.f64 = function(property) {
      return new Double(property);
    };
    exports.f64be = function(property) {
      return new DoubleBE(property);
    };
    exports.struct = function(fields, property, decodePrefixes) {
      return new Structure(fields, property, decodePrefixes);
    };
    exports.bits = function(word, msb, property) {
      return new BitStructure(word, msb, property);
    };
    exports.seq = function(elementLayout, count2, property) {
      return new Sequence(elementLayout, count2, property);
    };
    exports.union = function(discr, defaultLayout, property) {
      return new Union(discr, defaultLayout, property);
    };
    exports.unionLayoutDiscriminator = function(layout, property) {
      return new UnionLayoutDiscriminator(layout, property);
    };
    exports.blob = function(length, property) {
      return new Blob2(length, property);
    };
    exports.cstr = function(property) {
      return new CString(property);
    };
    exports.utf8 = function(maxSpan, property) {
      return new UTF8(maxSpan, property);
    };
    exports.constant = function(value, property) {
      return new Constant(value, property);
    };
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(o5, p5) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o6, p6) {
        o6.__proto__ = p6;
        return o6;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o5, p5);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        setPrototypeOf(subClass, superClass);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return assertThisInitialized(self2);
    }
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    function _getPrototypeOf(o5) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o6) {
        return o6.__proto__ || Object.getPrototypeOf(o6);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o5);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/dist/lib/client/websocket.browser.js
var require_websocket_browser = __commonJS({
  "node_modules/rpc-websockets/dist/lib/client/websocket.browser.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _eventemitter = require_eventemitter3();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e5) {
        return false;
      }
    }
    var WebSocketBrowserImpl = function(_EventEmitter) {
      (0, _inherits2["default"])(WebSocketBrowserImpl2, _EventEmitter);
      var _super = _createSuper(WebSocketBrowserImpl2);
      function WebSocketBrowserImpl2(address, options, protocols) {
        var _this;
        (0, _classCallCheck2["default"])(this, WebSocketBrowserImpl2);
        _this = _super.call(this);
        _this.socket = new window.WebSocket(address, protocols);
        _this.socket.onopen = function() {
          return _this.emit("open");
        };
        _this.socket.onmessage = function(event) {
          return _this.emit("message", event.data);
        };
        _this.socket.onerror = function(error) {
          return _this.emit("error", error);
        };
        _this.socket.onclose = function(event) {
          _this.emit("close", event.code, event.reason);
        };
        return _this;
      }
      (0, _createClass2["default"])(WebSocketBrowserImpl2, [{
        key: "send",
        value: function send(data, optionsOrCallback, callback) {
          var cb = callback || optionsOrCallback;
          try {
            this.socket.send(data);
            cb();
          } catch (error) {
            cb(error);
          }
        }
      }, {
        key: "close",
        value: function close(code, reason) {
          this.socket.close(code, reason);
        }
      }, {
        key: "addEventListener",
        value: function addEventListener(type2, listener, options) {
          this.socket.addEventListener(type2, listener, options);
        }
      }]);
      return WebSocketBrowserImpl2;
    }(_eventemitter.EventEmitter);
    function _default(address, options) {
      return new WebSocketBrowserImpl(address, options);
    }
  }
});

// node_modules/rpc-websockets/node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/rpc-websockets/node_modules/regenerator-runtime/runtime.js"(exports, module) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define3(obj, key2, value) {
        Object.defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key2];
      }
      try {
        define3({}, "");
      } catch (err) {
        define3 = function(obj, key2, value) {
          return obj[key2] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context2(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context);
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define3(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define3(Gp, "constructor", GeneratorFunctionPrototype);
      define3(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define3(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define3(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define3(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record2 = tryCatch(generator[method], generator, arg);
          if (record2.type === "throw") {
            reject(record2.arg);
          } else {
            var result = record2.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define3(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record2 = tryCatch(innerFn, self2, context);
            if (record2.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record2.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record2.arg,
                done: context.done
              };
            } else if (record2.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record2.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined2) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record2 = tryCatch(method, delegate.iterator, context.arg);
        if (record2.type === "throw") {
          context.method = "throw";
          context.arg = record2.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record2.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define3(Gp, toStringTagSymbol, "Generator");
      define3(Gp, iteratorSymbol, function() {
        return this;
      });
      define3(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record2 = entry.completion || {};
        record2.type = "normal";
        delete record2.arg;
        entry.completion = record2;
      }
      function Context2(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(object) {
        var keys = [];
        for (var key2 in object) {
          keys.push(key2);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key3 = keys.pop();
            if (key3 in object) {
              next.value = key3;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i5 = -1, next = function next2() {
              while (++i5 < iterable.length) {
                if (hasOwn.call(iterable, i5)) {
                  next2.value = iterable[i5];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context2.prototype = {
        constructor: Context2,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name2 in this) {
              if (name2.charAt(0) === "t" && hasOwn.call(this, name2) && !isNaN(+name2.slice(1))) {
                this[name2] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record2.type = "throw";
            record2.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i5 = this.tryEntries.length - 1; i5 >= 0; --i5) {
            var entry = this.tryEntries[i5];
            var record2 = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type2, arg) {
          for (var i5 = this.tryEntries.length - 1; i5 >= 0; --i5) {
            var entry = this.tryEntries[i5];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type2 === "break" || type2 === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record2 = finallyEntry ? finallyEntry.completion : {};
          record2.type = type2;
          record2.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record2);
        },
        complete: function(record2, afterLoc) {
          if (record2.type === "throw") {
            throw record2.arg;
          }
          if (record2.type === "break" || record2.type === "continue") {
            this.next = record2.arg;
          } else if (record2.type === "return") {
            this.rval = this.arg = record2.arg;
            this.method = "return";
            this.next = "end";
          } else if (record2.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i5 = this.tryEntries.length - 1; i5 >= 0; --i5) {
            var entry = this.tryEntries[i5];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i5 = this.tryEntries.length - 1; i5 >= 0; --i5) {
            var entry = this.tryEntries[i5];
            if (entry.tryLoc === tryLoc) {
              var record2 = entry.completion;
              if (record2.type === "throw") {
                var thrown = record2.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(typeof module === "object" ? module.exports : {});
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    module.exports = require_runtime();
  }
});

// node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/rpc-websockets/node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
      try {
        var info = gen[key2](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/circular-json/build/circular-json.node.js
var require_circular_json_node = __commonJS({
  "node_modules/circular-json/build/circular-json.node.js"(exports, module) {
    var specialChar = "~";
    var safeSpecialChar = "\\x" + ("0" + specialChar.charCodeAt(0).toString(16)).slice(-2);
    var escapedSafeSpecialChar = "\\" + safeSpecialChar;
    var specialCharRG = new RegExp(safeSpecialChar, "g");
    var safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, "g");
    var safeStartWithSpecialCharRG = new RegExp("(?:^|([^\\\\]))" + escapedSafeSpecialChar);
    var indexOf = [].indexOf || function(v8) {
      for (var i5 = this.length; i5-- && this[i5] !== v8; )
        ;
      return i5;
    };
    var $String = String;
    function generateReplacer(value, replacer, resolve) {
      var doNotIgnore = false, inspect4 = !!replacer, path = [], all = [value], seen = [value], mapp = [resolve ? specialChar : "[Circular]"], last2 = value, lvl = 1, i5, fn;
      if (inspect4) {
        fn = typeof replacer === "object" ? function(key2, value2) {
          return key2 !== "" && replacer.indexOf(key2) < 0 ? void 0 : value2;
        } : replacer;
      }
      return function(key2, value2) {
        if (inspect4)
          value2 = fn.call(this, key2, value2);
        if (doNotIgnore) {
          if (last2 !== this) {
            i5 = lvl - indexOf.call(all, this) - 1;
            lvl -= i5;
            all.splice(lvl, all.length);
            path.splice(lvl - 1, path.length);
            last2 = this;
          }
          if (typeof value2 === "object" && value2) {
            if (indexOf.call(all, value2) < 0) {
              all.push(last2 = value2);
            }
            lvl = all.length;
            i5 = indexOf.call(seen, value2);
            if (i5 < 0) {
              i5 = seen.push(value2) - 1;
              if (resolve) {
                path.push(("" + key2).replace(specialCharRG, safeSpecialChar));
                mapp[i5] = specialChar + path.join(specialChar);
              } else {
                mapp[i5] = mapp[0];
              }
            } else {
              value2 = mapp[i5];
            }
          } else {
            if (typeof value2 === "string" && resolve) {
              value2 = value2.replace(safeSpecialChar, escapedSafeSpecialChar).replace(specialChar, safeSpecialChar);
            }
          }
        } else {
          doNotIgnore = true;
        }
        return value2;
      };
    }
    function retrieveFromPath(current, keys) {
      for (var i5 = 0, length = keys.length; i5 < length; current = current[keys[i5++].replace(safeSpecialCharRG, specialChar)])
        ;
      return current;
    }
    function generateReviver(reviver) {
      return function(key2, value) {
        var isString2 = typeof value === "string";
        if (isString2 && value.charAt(0) === specialChar) {
          return new $String(value.slice(1));
        }
        if (key2 === "")
          value = regenerate(value, value, {});
        if (isString2)
          value = value.replace(safeStartWithSpecialCharRG, "$1" + specialChar).replace(escapedSafeSpecialChar, safeSpecialChar);
        return reviver ? reviver.call(this, key2, value) : value;
      };
    }
    function regenerateArray(root, current, retrieve) {
      for (var i5 = 0, length = current.length; i5 < length; i5++) {
        current[i5] = regenerate(root, current[i5], retrieve);
      }
      return current;
    }
    function regenerateObject(root, current, retrieve) {
      for (var key2 in current) {
        if (current.hasOwnProperty(key2)) {
          current[key2] = regenerate(root, current[key2], retrieve);
        }
      }
      return current;
    }
    function regenerate(root, current, retrieve) {
      return current instanceof Array ? regenerateArray(root, current, retrieve) : current instanceof $String ? current.length ? retrieve.hasOwnProperty(current) ? retrieve[current] : retrieve[current] = retrieveFromPath(root, current.split(specialChar)) : root : current instanceof Object ? regenerateObject(root, current, retrieve) : current;
    }
    var CircularJSON = {
      stringify: function stringify3(value, replacer, space, doNotResolve) {
        return CircularJSON.parser.stringify(value, generateReplacer(value, replacer, !doNotResolve), space);
      },
      parse: function parse4(text, reviver) {
        return CircularJSON.parser.parse(text, generateReviver(reviver));
      },
      parser: JSON
    };
    module.exports = CircularJSON;
  }
});

// node_modules/rpc-websockets/dist/lib/client.js
var require_client = __commonJS({
  "node_modules/rpc-websockets/dist/lib/client.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _eventemitter = require_eventemitter3();
    var _circularJson = _interopRequireDefault(require_circular_json_node());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e5) {
        return false;
      }
    }
    var __rest = function(s6, e5) {
      var t5 = {};
      for (var p5 in s6) {
        if (Object.prototype.hasOwnProperty.call(s6, p5) && e5.indexOf(p5) < 0)
          t5[p5] = s6[p5];
      }
      if (s6 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i5 = 0, p5 = Object.getOwnPropertySymbols(s6); i5 < p5.length; i5++) {
          if (e5.indexOf(p5[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s6, p5[i5]))
            t5[p5[i5]] = s6[p5[i5]];
        }
      return t5;
    };
    var CommonClient = function(_EventEmitter) {
      (0, _inherits2["default"])(CommonClient2, _EventEmitter);
      var _super = _createSuper(CommonClient2);
      function CommonClient2(webSocketFactory) {
        var _this;
        var address = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080";
        var _a2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var generate_request_id = arguments.length > 3 ? arguments[3] : void 0;
        (0, _classCallCheck2["default"])(this, CommonClient2);
        var _a$autoconnect = _a2.autoconnect, autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect, _a$reconnect = _a2.reconnect, reconnect = _a$reconnect === void 0 ? true : _a$reconnect, _a$reconnect_interval = _a2.reconnect_interval, reconnect_interval = _a$reconnect_interval === void 0 ? 1e3 : _a$reconnect_interval, _a$max_reconnects = _a2.max_reconnects, max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects, rest_options = __rest(_a2, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
        _this = _super.call(this);
        _this.webSocketFactory = webSocketFactory;
        _this.queue = {};
        _this.rpc_id = 0;
        _this.address = address;
        _this.autoconnect = autoconnect;
        _this.ready = false;
        _this.reconnect = reconnect;
        _this.reconnect_interval = reconnect_interval;
        _this.max_reconnects = max_reconnects;
        _this.rest_options = rest_options;
        _this.current_reconnects = 0;
        _this.generate_request_id = generate_request_id || function() {
          return ++_this.rpc_id;
        };
        if (_this.autoconnect)
          _this._connect(_this.address, Object.assign({
            autoconnect: _this.autoconnect,
            reconnect: _this.reconnect,
            reconnect_interval: _this.reconnect_interval,
            max_reconnects: _this.max_reconnects
          }, _this.rest_options));
        return _this;
      }
      (0, _createClass2["default"])(CommonClient2, [{
        key: "connect",
        value: function connect() {
          if (this.socket)
            return;
          this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
      }, {
        key: "call",
        value: function call(method, params, timeout2, ws_opts) {
          var _this2 = this;
          if (!ws_opts && (0, _typeof2["default"])(timeout2) === "object") {
            ws_opts = timeout2;
            timeout2 = null;
          }
          return new Promise(function(resolve, reject) {
            if (!_this2.ready)
              return reject(new Error("socket not ready"));
            var rpc_id = _this2.generate_request_id(method, params);
            var message = {
              jsonrpc: "2.0",
              method,
              params: params || null,
              id: rpc_id
            };
            _this2.socket.send(JSON.stringify(message), ws_opts, function(error) {
              if (error)
                return reject(error);
              _this2.queue[rpc_id] = {
                promise: [resolve, reject]
              };
              if (timeout2) {
                _this2.queue[rpc_id].timeout = setTimeout(function() {
                  delete _this2.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout2);
              }
            });
          });
        }
      }, {
        key: "login",
        value: function() {
          var _login = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(params) {
            var resp;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.call("rpc.login", params);
                  case 2:
                    resp = _context.sent;
                    if (resp) {
                      _context.next = 5;
                      break;
                    }
                    throw new Error("authentication failed");
                  case 5:
                    return _context.abrupt("return", resp);
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function login(_x) {
            return _login.apply(this, arguments);
          }
          return login;
        }()
      }, {
        key: "listMethods",
        value: function() {
          var _listMethods = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.call("__listMethods");
                  case 2:
                    return _context2.abrupt("return", _context2.sent);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function listMethods() {
            return _listMethods.apply(this, arguments);
          }
          return listMethods;
        }()
      }, {
        key: "notify",
        value: function notify(method, params) {
          var _this3 = this;
          return new Promise(function(resolve, reject) {
            if (!_this3.ready)
              return reject(new Error("socket not ready"));
            var message = {
              jsonrpc: "2.0",
              method,
              params: params || null
            };
            _this3.socket.send(JSON.stringify(message), function(error) {
              if (error)
                return reject(error);
              resolve();
            });
          });
        }
      }, {
        key: "subscribe",
        value: function() {
          var _subscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(event) {
            var result;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context3.next = 3;
                    return this.call("rpc.on", event);
                  case 3:
                    result = _context3.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context3.next = 6;
                      break;
                    }
                    throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
                  case 6:
                    return _context3.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function subscribe(_x2) {
            return _subscribe.apply(this, arguments);
          }
          return subscribe;
        }()
      }, {
        key: "unsubscribe",
        value: function() {
          var _unsubscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(event) {
            var result;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context4.next = 3;
                    return this.call("rpc.off", event);
                  case 3:
                    result = _context4.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context4.next = 6;
                      break;
                    }
                    throw new Error("Failed unsubscribing from an event with: " + result);
                  case 6:
                    return _context4.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function unsubscribe(_x3) {
            return _unsubscribe.apply(this, arguments);
          }
          return unsubscribe;
        }()
      }, {
        key: "close",
        value: function close(code, data) {
          this.socket.close(code || 1e3, data);
        }
      }, {
        key: "_connect",
        value: function _connect(address, options) {
          var _this4 = this;
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", function() {
            _this4.ready = true;
            _this4.emit("open");
            _this4.current_reconnects = 0;
          });
          this.socket.addEventListener("message", function(_ref) {
            var message = _ref.data;
            if (message instanceof ArrayBuffer)
              message = Buffer.from(message).toString();
            try {
              message = _circularJson["default"].parse(message);
            } catch (error) {
              return;
            }
            if (message.notification && _this4.listeners(message.notification).length) {
              if (!Object.keys(message.params).length)
                return _this4.emit(message.notification);
              var args = [message.notification];
              if (message.params.constructor === Object)
                args.push(message.params);
              else
                for (var i5 = 0; i5 < message.params.length; i5++) {
                  args.push(message.params[i5]);
                }
              return Promise.resolve().then(function() {
                _this4.emit.apply(_this4, args);
              });
            }
            if (!_this4.queue[message.id]) {
              if (message.method && message.params) {
                return Promise.resolve().then(function() {
                  _this4.emit(message.method, message.params);
                });
              }
              return;
            }
            if ("error" in message === "result" in message)
              _this4.queue[message.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
            if (_this4.queue[message.id].timeout)
              clearTimeout(_this4.queue[message.id].timeout);
            if (message.error)
              _this4.queue[message.id].promise[1](message.error);
            else
              _this4.queue[message.id].promise[0](message.result);
            delete _this4.queue[message.id];
          });
          this.socket.addEventListener("error", function(error) {
            return _this4.emit("error", error);
          });
          this.socket.addEventListener("close", function(_ref2) {
            var code = _ref2.code, reason = _ref2.reason;
            if (_this4.ready)
              setTimeout(function() {
                return _this4.emit("close", code, reason);
              }, 0);
            _this4.ready = false;
            _this4.socket = void 0;
            if (code === 1e3)
              return;
            _this4.current_reconnects++;
            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0))
              setTimeout(function() {
                return _this4._connect(address, options);
              }, _this4.reconnect_interval);
          });
        }
      }]);
      return CommonClient2;
    }(_eventemitter.EventEmitter);
    exports["default"] = CommonClient;
  }
});

// node_modules/rpc-websockets/dist/index.browser.js
var require_index_browser = __commonJS({
  "node_modules/rpc-websockets/dist/index.browser.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _websocket = _interopRequireDefault(require_websocket_browser());
    var _client = _interopRequireDefault(require_client());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e5) {
        return false;
      }
    }
    var Client2 = function(_CommonClient) {
      (0, _inherits2["default"])(Client3, _CommonClient);
      var _super = _createSuper(Client3);
      function Client3() {
        var address = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ws://localhost:8080";
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$autoconnect = _ref.autoconnect, autoconnect = _ref$autoconnect === void 0 ? true : _ref$autoconnect, _ref$reconnect = _ref.reconnect, reconnect = _ref$reconnect === void 0 ? true : _ref$reconnect, _ref$reconnect_interv = _ref.reconnect_interval, reconnect_interval = _ref$reconnect_interv === void 0 ? 1e3 : _ref$reconnect_interv, _ref$max_reconnects = _ref.max_reconnects, max_reconnects = _ref$max_reconnects === void 0 ? 5 : _ref$max_reconnects;
        var generate_request_id = arguments.length > 2 ? arguments[2] : void 0;
        (0, _classCallCheck2["default"])(this, Client3);
        return _super.call(this, _websocket["default"], address, {
          autoconnect,
          reconnect,
          reconnect_interval,
          max_reconnects
        }, generate_request_id);
      }
      return Client3;
    }(_client["default"]);
    exports.Client = Client2;
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid2) {
  return typeof uuid2 === "string" && regex_default.test(uuid2);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate2;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid2 = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate_default(uuid2)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid2;
}
var byteToHex, i5, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i5 = 0; i5 < 256; ++i5) {
      byteToHex.push((i5 + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset2) {
  var i5 = buf && offset2 || 0;
  var b4 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b4[i5++] = tl >>> 24 & 255;
  b4[i5++] = tl >>> 16 & 255;
  b4[i5++] = tl >>> 8 & 255;
  b4[i5++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b4[i5++] = tmh >>> 8 & 255;
  b4[i5++] = tmh & 255;
  b4[i5++] = tmh >>> 24 & 15 | 16;
  b4[i5++] = tmh >>> 16 & 255;
  b4[i5++] = clockseq >>> 8 | 128;
  b4[i5++] = clockseq & 255;
  for (var n3 = 0; n3 < 6; ++n3) {
    b4[i5 + n3] = node[n3];
  }
  return buf || stringify_default(b4);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid2) {
  if (!validate_default(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  var v8;
  var arr = new Uint8Array(16);
  arr[0] = (v8 = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
  arr[1] = v8 >>> 16 & 255;
  arr[2] = v8 >>> 8 & 255;
  arr[3] = v8 & 255;
  arr[4] = (v8 = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
  arr[5] = v8 & 255;
  arr[6] = (v8 = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
  arr[7] = v8 & 255;
  arr[8] = (v8 = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
  arr[9] = v8 & 255;
  arr[10] = (v8 = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v8 / 4294967296 & 255;
  arr[12] = v8 >>> 24 & 255;
  arr[13] = v8 >>> 16 & 255;
  arr[14] = v8 >>> 8 & 255;
  arr[15] = v8 & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i5 = 0; i5 < str.length; ++i5) {
    bytes.push(str.charCodeAt(i5));
  }
  return bytes;
}
function v35_default(name2, version29, hashfunc) {
  function generateUUID(value, namespace, buf, offset2) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version29;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i5 = 0; i5 < 16; ++i5) {
        buf[offset2 + i5] = bytes[i5];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i5 = 0; i5 < msg.length; ++i5) {
      bytes[i5] = msg.charCodeAt(i5);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i5 = 0; i5 < length32; i5 += 8) {
    var x5 = input[i5 >> 5] >>> i5 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x5 >>> 4 & 15) + hexTab.charAt(x5 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x5, len) {
  x5[len >> 5] |= 128 << len % 32;
  x5[getOutputLength(len) - 1] = len;
  var a5 = 1732584193;
  var b4 = -271733879;
  var c5 = -1732584194;
  var d5 = 271733878;
  for (var i5 = 0; i5 < x5.length; i5 += 16) {
    var olda = a5;
    var oldb = b4;
    var oldc = c5;
    var oldd = d5;
    a5 = md5ff(a5, b4, c5, d5, x5[i5], 7, -680876936);
    d5 = md5ff(d5, a5, b4, c5, x5[i5 + 1], 12, -389564586);
    c5 = md5ff(c5, d5, a5, b4, x5[i5 + 2], 17, 606105819);
    b4 = md5ff(b4, c5, d5, a5, x5[i5 + 3], 22, -1044525330);
    a5 = md5ff(a5, b4, c5, d5, x5[i5 + 4], 7, -176418897);
    d5 = md5ff(d5, a5, b4, c5, x5[i5 + 5], 12, 1200080426);
    c5 = md5ff(c5, d5, a5, b4, x5[i5 + 6], 17, -1473231341);
    b4 = md5ff(b4, c5, d5, a5, x5[i5 + 7], 22, -45705983);
    a5 = md5ff(a5, b4, c5, d5, x5[i5 + 8], 7, 1770035416);
    d5 = md5ff(d5, a5, b4, c5, x5[i5 + 9], 12, -1958414417);
    c5 = md5ff(c5, d5, a5, b4, x5[i5 + 10], 17, -42063);
    b4 = md5ff(b4, c5, d5, a5, x5[i5 + 11], 22, -1990404162);
    a5 = md5ff(a5, b4, c5, d5, x5[i5 + 12], 7, 1804603682);
    d5 = md5ff(d5, a5, b4, c5, x5[i5 + 13], 12, -40341101);
    c5 = md5ff(c5, d5, a5, b4, x5[i5 + 14], 17, -1502002290);
    b4 = md5ff(b4, c5, d5, a5, x5[i5 + 15], 22, 1236535329);
    a5 = md5gg(a5, b4, c5, d5, x5[i5 + 1], 5, -165796510);
    d5 = md5gg(d5, a5, b4, c5, x5[i5 + 6], 9, -1069501632);
    c5 = md5gg(c5, d5, a5, b4, x5[i5 + 11], 14, 643717713);
    b4 = md5gg(b4, c5, d5, a5, x5[i5], 20, -373897302);
    a5 = md5gg(a5, b4, c5, d5, x5[i5 + 5], 5, -701558691);
    d5 = md5gg(d5, a5, b4, c5, x5[i5 + 10], 9, 38016083);
    c5 = md5gg(c5, d5, a5, b4, x5[i5 + 15], 14, -660478335);
    b4 = md5gg(b4, c5, d5, a5, x5[i5 + 4], 20, -405537848);
    a5 = md5gg(a5, b4, c5, d5, x5[i5 + 9], 5, 568446438);
    d5 = md5gg(d5, a5, b4, c5, x5[i5 + 14], 9, -1019803690);
    c5 = md5gg(c5, d5, a5, b4, x5[i5 + 3], 14, -187363961);
    b4 = md5gg(b4, c5, d5, a5, x5[i5 + 8], 20, 1163531501);
    a5 = md5gg(a5, b4, c5, d5, x5[i5 + 13], 5, -1444681467);
    d5 = md5gg(d5, a5, b4, c5, x5[i5 + 2], 9, -51403784);
    c5 = md5gg(c5, d5, a5, b4, x5[i5 + 7], 14, 1735328473);
    b4 = md5gg(b4, c5, d5, a5, x5[i5 + 12], 20, -1926607734);
    a5 = md5hh(a5, b4, c5, d5, x5[i5 + 5], 4, -378558);
    d5 = md5hh(d5, a5, b4, c5, x5[i5 + 8], 11, -2022574463);
    c5 = md5hh(c5, d5, a5, b4, x5[i5 + 11], 16, 1839030562);
    b4 = md5hh(b4, c5, d5, a5, x5[i5 + 14], 23, -35309556);
    a5 = md5hh(a5, b4, c5, d5, x5[i5 + 1], 4, -1530992060);
    d5 = md5hh(d5, a5, b4, c5, x5[i5 + 4], 11, 1272893353);
    c5 = md5hh(c5, d5, a5, b4, x5[i5 + 7], 16, -155497632);
    b4 = md5hh(b4, c5, d5, a5, x5[i5 + 10], 23, -1094730640);
    a5 = md5hh(a5, b4, c5, d5, x5[i5 + 13], 4, 681279174);
    d5 = md5hh(d5, a5, b4, c5, x5[i5], 11, -358537222);
    c5 = md5hh(c5, d5, a5, b4, x5[i5 + 3], 16, -722521979);
    b4 = md5hh(b4, c5, d5, a5, x5[i5 + 6], 23, 76029189);
    a5 = md5hh(a5, b4, c5, d5, x5[i5 + 9], 4, -640364487);
    d5 = md5hh(d5, a5, b4, c5, x5[i5 + 12], 11, -421815835);
    c5 = md5hh(c5, d5, a5, b4, x5[i5 + 15], 16, 530742520);
    b4 = md5hh(b4, c5, d5, a5, x5[i5 + 2], 23, -995338651);
    a5 = md5ii(a5, b4, c5, d5, x5[i5], 6, -198630844);
    d5 = md5ii(d5, a5, b4, c5, x5[i5 + 7], 10, 1126891415);
    c5 = md5ii(c5, d5, a5, b4, x5[i5 + 14], 15, -1416354905);
    b4 = md5ii(b4, c5, d5, a5, x5[i5 + 5], 21, -57434055);
    a5 = md5ii(a5, b4, c5, d5, x5[i5 + 12], 6, 1700485571);
    d5 = md5ii(d5, a5, b4, c5, x5[i5 + 3], 10, -1894986606);
    c5 = md5ii(c5, d5, a5, b4, x5[i5 + 10], 15, -1051523);
    b4 = md5ii(b4, c5, d5, a5, x5[i5 + 1], 21, -2054922799);
    a5 = md5ii(a5, b4, c5, d5, x5[i5 + 8], 6, 1873313359);
    d5 = md5ii(d5, a5, b4, c5, x5[i5 + 15], 10, -30611744);
    c5 = md5ii(c5, d5, a5, b4, x5[i5 + 6], 15, -1560198380);
    b4 = md5ii(b4, c5, d5, a5, x5[i5 + 13], 21, 1309151649);
    a5 = md5ii(a5, b4, c5, d5, x5[i5 + 4], 6, -145523070);
    d5 = md5ii(d5, a5, b4, c5, x5[i5 + 11], 10, -1120210379);
    c5 = md5ii(c5, d5, a5, b4, x5[i5 + 2], 15, 718787259);
    b4 = md5ii(b4, c5, d5, a5, x5[i5 + 9], 21, -343485551);
    a5 = safeAdd(a5, olda);
    b4 = safeAdd(b4, oldb);
    c5 = safeAdd(c5, oldc);
    d5 = safeAdd(d5, oldd);
  }
  return [a5, b4, c5, d5];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i5 = 0; i5 < length8; i5 += 8) {
    output[i5 >> 5] |= (input[i5 / 8] & 255) << i5 % 32;
  }
  return output;
}
function safeAdd(x5, y5) {
  var lsw = (x5 & 65535) + (y5 & 65535);
  var msw = (x5 >> 16) + (y5 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q5, a5, b4, x5, s6, t5) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a5, q5), safeAdd(x5, t5)), s6), b4);
}
function md5ff(a5, b4, c5, d5, x5, s6, t5) {
  return md5cmn(b4 & c5 | ~b4 & d5, a5, b4, x5, s6, t5);
}
function md5gg(a5, b4, c5, d5, x5, s6, t5) {
  return md5cmn(b4 & d5 | c5 & ~d5, a5, b4, x5, s6, t5);
}
function md5hh(a5, b4, c5, d5, x5, s6, t5) {
  return md5cmn(b4 ^ c5 ^ d5, a5, b4, x5, s6, t5);
}
function md5ii(a5, b4, c5, d5, x5, s6, t5) {
  return md5cmn(c5 ^ (b4 | ~d5), a5, b4, x5, s6, t5);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i5 = 0; i5 < 16; ++i5) {
      buf[offset2 + i5] = rnds[i5];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s6, x5, y5, z4) {
  switch (s6) {
    case 0:
      return x5 & y5 ^ ~x5 & z4;
    case 1:
      return x5 ^ y5 ^ z4;
    case 2:
      return x5 & y5 ^ x5 & z4 ^ y5 & z4;
    case 3:
      return x5 ^ y5 ^ z4;
  }
}
function ROTL(x5, n3) {
  return x5 << n3 | x5 >>> 32 - n3;
}
function sha1(bytes) {
  var K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i5 = 0; i5 < msg.length; ++i5) {
      bytes.push(msg.charCodeAt(i5));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l5 = bytes.length / 4 + 2;
  var N5 = Math.ceil(l5 / 16);
  var M4 = new Array(N5);
  for (var _i = 0; _i < N5; ++_i) {
    var arr = new Uint32Array(16);
    for (var j5 = 0; j5 < 16; ++j5) {
      arr[j5] = bytes[_i * 64 + j5 * 4] << 24 | bytes[_i * 64 + j5 * 4 + 1] << 16 | bytes[_i * 64 + j5 * 4 + 2] << 8 | bytes[_i * 64 + j5 * 4 + 3];
    }
    M4[_i] = arr;
  }
  M4[N5 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M4[N5 - 1][14] = Math.floor(M4[N5 - 1][14]);
  M4[N5 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N5; ++_i2) {
    var W2 = new Uint32Array(80);
    for (var t5 = 0; t5 < 16; ++t5) {
      W2[t5] = M4[_i2][t5];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W2[_t] = ROTL(W2[_t - 3] ^ W2[_t - 8] ^ W2[_t - 14] ^ W2[_t - 16], 1);
    }
    var a5 = H4[0];
    var b4 = H4[1];
    var c5 = H4[2];
    var d5 = H4[3];
    var e5 = H4[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s6 = Math.floor(_t2 / 20);
      var T6 = ROTL(a5, 5) + f(s6, b4, c5, d5) + e5 + K3[s6] + W2[_t2] >>> 0;
      e5 = d5;
      d5 = c5;
      c5 = ROTL(b4, 30) >>> 0;
      b4 = a5;
      a5 = T6;
    }
    H4[0] = H4[0] + a5 >>> 0;
    H4[1] = H4[1] + b4 >>> 0;
    H4[2] = H4[2] + c5 >>> 0;
    H4[3] = H4[3] + d5 >>> 0;
    H4[4] = H4[4] + e5 >>> 0;
  }
  return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-browser/version.js
function version(uuid2) {
  if (!validate_default(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid2.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS({
  "node_modules/jayson/lib/generateRequest.js"(exports, module) {
    "use strict";
    var uuid2 = (init_esm_browser(), esm_browser_exports).v4;
    var generateRequest = function(method, params, id2, options) {
      if (typeof method !== "string") {
        throw new TypeError(method + " must be a string");
      }
      options = options || {};
      const version29 = typeof options.version === "number" ? options.version : 2;
      if (version29 !== 1 && version29 !== 2) {
        throw new TypeError(version29 + " must be 1 or 2");
      }
      const request = {
        method
      };
      if (version29 === 2) {
        request.jsonrpc = "2.0";
      }
      if (params) {
        if (typeof params !== "object" && !Array.isArray(params)) {
          throw new TypeError(params + " must be an object, array or omitted");
        }
        request.params = params;
      }
      if (typeof id2 === "undefined") {
        const generator = typeof options.generator === "function" ? options.generator : function() {
          return uuid2();
        };
        request.id = generator(request, options);
      } else if (version29 === 2 && id2 === null) {
        if (options.notificationIdNull) {
          request.id = null;
        }
      } else {
        request.id = id2;
      }
      return request;
    };
    module.exports = generateRequest;
  }
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser = __commonJS({
  "node_modules/jayson/lib/client/browser/index.js"(exports, module) {
    "use strict";
    var uuid2 = (init_esm_browser(), esm_browser_exports).v4;
    var generateRequest = require_generateRequest();
    var ClientBrowser = function(callServer, options) {
      if (!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }
      if (!options) {
        options = {};
      }
      this.options = {
        reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
        replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
        generator: typeof options.generator !== "undefined" ? options.generator : function() {
          return uuid2();
        },
        version: typeof options.version !== "undefined" ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
      };
      this.callServer = callServer;
    };
    module.exports = ClientBrowser;
    ClientBrowser.prototype.request = function(method, params, id2, callback) {
      const self2 = this;
      let request = null;
      const isBatch = Array.isArray(method) && typeof params === "function";
      if (this.options.version === 1 && isBatch) {
        throw new TypeError("JSON-RPC 1.0 does not support batching");
      }
      const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
      if (isBatch || isRaw) {
        callback = params;
        request = method;
      } else {
        if (typeof id2 === "function") {
          callback = id2;
          id2 = void 0;
        }
        const hasCallback = typeof callback === "function";
        try {
          request = generateRequest(method, params, id2, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull
          });
        } catch (err) {
          if (hasCallback) {
            return callback(err);
          }
          throw err;
        }
        if (!hasCallback) {
          return request;
        }
      }
      let message;
      try {
        message = JSON.stringify(request, this.options.replacer);
      } catch (err) {
        return callback(err);
      }
      this.callServer(message, function(err, response) {
        self2._parseResponse(err, response, callback);
      });
      return request;
    };
    ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
      if (err) {
        callback(err);
        return;
      }
      if (!responseText) {
        return callback();
      }
      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch (err2) {
        return callback(err2);
      }
      if (callback.length === 3) {
        if (Array.isArray(response)) {
          const isError = function(res) {
            return typeof res.error !== "undefined";
          };
          const isNotError = function(res) {
            return !isError(res);
          };
          return callback(null, response.filter(isError), response.filter(isNotError));
        } else {
          return callback(null, response.error, response.result);
        }
      }
      callback(null, response);
    };
  }
});

// node_modules/secp256k1/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/secp256k1/lib/index.js"(exports, module) {
    var errors = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert5(cond, msg) {
      if (!cond)
        throw new Error(msg);
    }
    function isUint8Array(name2, value, length) {
      assert5(value instanceof Uint8Array, `Expected ${name2} to be an Uint8Array`);
      if (length !== void 0) {
        if (Array.isArray(length)) {
          const numbers = length.join(", ");
          const msg = `Expected ${name2} to be an Uint8Array with length [${numbers}]`;
          assert5(length.includes(value.length), msg);
        } else {
          const msg = `Expected ${name2} to be an Uint8Array with length ${length}`;
          assert5(value.length === length, msg);
        }
      }
    }
    function isCompressed(value) {
      assert5(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
      if (typeof output === "function")
        output = output(length);
      isUint8Array("output", output, length);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module.exports = (secp256k12) => {
      return {
        contextRandomize(seed) {
          assert5(seed === null || seed instanceof Uint8Array, "Expected seed to be an Uint8Array or null");
          if (seed !== null)
            isUint8Array("seed", seed, 32);
          switch (secp256k12.contextRandomize(seed)) {
            case 1:
              throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k12.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k12.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k12.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k12.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k12.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k12.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SECKEY_INVALID);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k12.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k12.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert5(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert5(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k12.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k12.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k12.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k12.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k12.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k12.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert5(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0)
            assert5(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k12.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors.SIGN);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k12.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert5(toTypeString(recid) === "Number" && recid >= 0 && recid <= 3, "Expected recovery id to be a Number within interval [0, 3]");
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k12.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.RECOVER);
            case 3:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert5(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert5(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0)
              isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0)
              isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k12.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.ECDH);
          }
        }
      };
    };
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number2, base2, endian) {
        if (BN6.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = (init_buffer(), buffer_exports).Buffer;
        }
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert5(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN6.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number2, base2, endian) {
        assert5(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i5 = number2.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number2[i5] | number2[i5 - 1] << 8 | number2[i5 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number2.length; i5 += 3) {
            w6 = number2[i5] | number2[i5 + 1] << 8 | number2[i5 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string2, index) {
        var c5 = string2.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r6 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r6;
      }
      BN6.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number2.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number2.length; i5 += 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN6.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number2, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i5, number2.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN6.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r6 = new BN6(null);
        this.copy(r6);
        return r6;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer2(endian, length) {
        assert5(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN6.prototype.toArray = function toArray3(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN6.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN6.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t5 = new Array(N5);
        var l5 = BN6.prototype._countBits(N5) - 1;
        for (var i5 = 0; i5 < N5; i5++) {
          t5[i5] = this.revBin(i5, l5, N5);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N5) {
        if (x5 === 0 || x5 === N5 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i5 = 0; i5 < N5; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s6 = 1; s6 < N5; s6 <<= 1) {
          var l5 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N5; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s6; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s6];
              var io = itws[p5 + j5 + s6];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s6] = re - ro;
              itws[p5 + j5 + s6] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N5 = Math.max(m5, n3) | 1;
        var odd = N5 & 1;
        var i5 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1)
          return;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N5 - i5 - 1];
          rws[N5 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N5 - i5 - 1];
          iws[N5 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N5) * 8192 + Math.round(ws[2 * i5] / N5) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N5; ++i5) {
          rws[i5] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i5 = 0; i5 < N5; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N5 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N5);
        var _10 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x5.words, x5.length, rws, N5);
        this.convert13b(y5.words, y5.length, nrws, N5);
        this.transform(rws, _10, rwst, iwst, N5, rbt);
        this.transform(nrws, _10, nrwst, niwst, N5, rbt);
        for (var i5 = 0; i5 < N5; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _10, N5, rbt);
        this.conjugate(rmws, _10, N5);
        this.normalize13b(rmws, N5);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul3(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s6] = this.words[i5];
          }
          for (i5 = 0; i5 < s6; i5++) {
            this.words[i5] = 0;
          }
          this.length += s6;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s6;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s6; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w6 = this.words[s6];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask2;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul3;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert5(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert5(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert5(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert5(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B3.isOdd()) {
                A6.iadd(yp);
                B3.isub(xp);
              }
              A6.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g5)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s6; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert5(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert5(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p5) {
        this.name = name2;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert5(a5.negative === 0, "red works only with positives");
        assert5(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert5((a5.negative | b4.negative) === 0, "red works only with positives");
        assert5(a5.red && a5.red === b4.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s6 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s6++;
          q5.iushrn(1);
        }
        assert5(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c5 = this.pow(z4, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s6;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert5(i5 < m5);
          var b4 = this.pow(c5, new BN6(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils2 = exports;
    function toArray3(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i5 = 0; i5 < msg.length; i5++)
          res[i5] = msg[i5] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i5 = 0; i5 < msg.length; i5 += 2)
          res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
      } else {
        for (var i5 = 0; i5 < msg.length; i5++) {
          var c5 = msg.charCodeAt(i5);
          var hi = c5 >> 8;
          var lo = c5 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils2.toArray = toArray3;
    function zero22(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils2.zero2 = zero22;
    function toHex3(msg) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++)
        res += zero22(msg[i5].toString(16));
      return res;
    }
    utils2.toHex = toHex3;
    utils2.encode = function encode5(arr, enc) {
      if (enc === "hex")
        return toHex3(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils2 = exports;
    var BN6 = require_bn3();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils2.assert = minAssert;
    utils2.toArray = minUtils.toArray;
    utils2.zero2 = minUtils.zero2;
    utils2.toHex = minUtils.toHex;
    utils2.encode = minUtils.encode;
    function getNAF2(num, w6, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w6 + 1;
      var k5 = num.clone();
      for (var i5 = 0; i5 < naf.length; i5++) {
        var z4;
        var mod = k5.andln(ws - 1);
        if (k5.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z4 = (ws >> 1) - mod;
          else
            z4 = mod;
          k5.isubn(z4);
        } else {
          z4 = 0;
        }
        naf[i5] = z4;
        k5.iushrn(1);
      }
      return naf;
    }
    utils2.getNAF = getNAF2;
    function getJSF2(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils2.getJSF = getJSF2;
    function cachedProperty(obj, name2, computer) {
      var key2 = "_" + name2;
      obj.prototype[name2] = function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils2.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
    }
    utils2.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN6(bytes, "hex", "le");
    }
    utils2.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    var r6;
    module.exports = function rand2(len) {
      if (!r6)
        r6 = new Rand(null);
      return r6.generate(len);
    };
    function Rand(rand2) {
      this.rand = rand2;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate3(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n3) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n3);
      var res = new Uint8Array(n3);
      for (var i5 = 0; i5 < res.length; i5++)
        res[i5] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n3) {
          var arr = new Uint8Array(n3);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n3) {
          var arr = new Uint8Array(n3);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto4 = (init_crypto(), crypto_exports);
        if (typeof crypto4.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n3) {
          return crypto4.randomBytes(n3);
        };
      } catch (e5) {
      }
    }
    var crypto4;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN6 = require_bn3();
    var utils2 = require_utils3();
    var getNAF2 = utils2.getNAF;
    var getJSF2 = utils2.getJSF;
    var assert5 = utils2.assert;
    function BaseCurve2(type2, conf) {
      this.type = type2;
      this.p = new BN6(conf.p, 16);
      this.red = conf.prime ? BN6.red(conf.prime) : BN6.mont(this.p);
      this.zero = new BN6(0).toRed(this.red);
      this.one = new BN6(1).toRed(this.red);
      this.two = new BN6(2).toRed(this.red);
      this.n = conf.n && new BN6(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve2;
    BaseCurve2.prototype.point = function point3() {
      throw new Error("Not implemented");
    };
    BaseCurve2.prototype.validate = function validate7() {
      throw new Error("Not implemented");
    };
    BaseCurve2.prototype._fixedNafMul = function _fixedNafMul2(p5, k5) {
      assert5(p5.precomputed);
      var doubles = p5._getDoubles();
      var naf = getNAF2(k5, 1, this._bitLength);
      var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I5 /= 3;
      var repr = [];
      var j5;
      var nafW;
      for (j5 = 0; j5 < naf.length; j5 += doubles.step) {
        nafW = 0;
        for (var l5 = j5 + doubles.step - 1; l5 >= j5; l5--)
          nafW = (nafW << 1) + naf[l5];
        repr.push(nafW);
      }
      var a5 = this.jpoint(null, null, null);
      var b4 = this.jpoint(null, null, null);
      for (var i5 = I5; i5 > 0; i5--) {
        for (j5 = 0; j5 < repr.length; j5++) {
          nafW = repr[j5];
          if (nafW === i5)
            b4 = b4.mixedAdd(doubles.points[j5]);
          else if (nafW === -i5)
            b4 = b4.mixedAdd(doubles.points[j5].neg());
        }
        a5 = a5.add(b4);
      }
      return a5.toP();
    };
    BaseCurve2.prototype._wnafMul = function _wnafMul2(p5, k5) {
      var w6 = 4;
      var nafPoints = p5._getNAFPoints(w6);
      w6 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF2(k5, w6, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i5 = naf.length - 1; i5 >= 0; i5--) {
        for (var l5 = 0; i5 >= 0 && naf[i5] === 0; i5--)
          l5++;
        if (i5 >= 0)
          l5++;
        acc = acc.dblp(l5);
        if (i5 < 0)
          break;
        var z4 = naf[i5];
        assert5(z4 !== 0);
        if (p5.type === "affine") {
          if (z4 > 0)
            acc = acc.mixedAdd(wnd[z4 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z4 - 1 >> 1].neg());
        } else {
          if (z4 > 0)
            acc = acc.add(wnd[z4 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z4 - 1 >> 1].neg());
        }
      }
      return p5.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve2.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max2 = 0;
      var i5;
      var j5;
      var p5;
      for (i5 = 0; i5 < len; i5++) {
        p5 = points[i5];
        var nafPoints = p5._getNAFPoints(defW);
        wndWidth[i5] = nafPoints.wnd;
        wnd[i5] = nafPoints.points;
      }
      for (i5 = len - 1; i5 >= 1; i5 -= 2) {
        var a5 = i5 - 1;
        var b4 = i5;
        if (wndWidth[a5] !== 1 || wndWidth[b4] !== 1) {
          naf[a5] = getNAF2(coeffs[a5], wndWidth[a5], this._bitLength);
          naf[b4] = getNAF2(coeffs[b4], wndWidth[b4], this._bitLength);
          max2 = Math.max(naf[a5].length, max2);
          max2 = Math.max(naf[b4].length, max2);
          continue;
        }
        var comb = [
          points[a5],
          null,
          null,
          points[b4]
        ];
        if (points[a5].y.cmp(points[b4].y) === 0) {
          comb[1] = points[a5].add(points[b4]);
          comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
        } else if (points[a5].y.cmp(points[b4].y.redNeg()) === 0) {
          comb[1] = points[a5].toJ().mixedAdd(points[b4]);
          comb[2] = points[a5].add(points[b4].neg());
        } else {
          comb[1] = points[a5].toJ().mixedAdd(points[b4]);
          comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF2(coeffs[a5], coeffs[b4]);
        max2 = Math.max(jsf[0].length, max2);
        naf[a5] = new Array(max2);
        naf[b4] = new Array(max2);
        for (j5 = 0; j5 < max2; j5++) {
          var ja = jsf[0][j5] | 0;
          var jb = jsf[1][j5] | 0;
          naf[a5][j5] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b4][j5] = 0;
          wnd[a5] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i5 = max2; i5 >= 0; i5--) {
        var k5 = 0;
        while (i5 >= 0) {
          var zero = true;
          for (j5 = 0; j5 < len; j5++) {
            tmp[j5] = naf[j5][i5] | 0;
            if (tmp[j5] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k5++;
          i5--;
        }
        if (i5 >= 0)
          k5++;
        acc = acc.dblp(k5);
        if (i5 < 0)
          break;
        for (j5 = 0; j5 < len; j5++) {
          var z4 = tmp[j5];
          p5;
          if (z4 === 0)
            continue;
          else if (z4 > 0)
            p5 = wnd[j5][z4 - 1 >> 1];
          else if (z4 < 0)
            p5 = wnd[j5][-z4 - 1 >> 1].neg();
          if (p5.type === "affine")
            acc = acc.mixedAdd(p5);
          else
            acc = acc.add(p5);
        }
      }
      for (i5 = 0; i5 < len; i5++)
        wnd[i5] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint2(curve, type2) {
      this.curve = curve;
      this.type = type2;
      this.precomputed = null;
    }
    BaseCurve2.BasePoint = BasePoint2;
    BasePoint2.prototype.eq = function eq4() {
      throw new Error("Not implemented");
    };
    BasePoint2.prototype.validate = function validate7() {
      return this.curve.validate(this);
    };
    BaseCurve2.prototype.decodePoint = function decodePoint2(bytes, enc) {
      bytes = utils2.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert5(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert5(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint2.prototype.encodeCompressed = function encodeCompressed2(enc) {
      return this.encode(enc, true);
    };
    BasePoint2.prototype._encode = function _encode3(compact) {
      var len = this.curve.p.byteLength();
      var x5 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x5);
      return [4].concat(x5, this.getY().toArray("be", len));
    };
    BasePoint2.prototype.encode = function encode5(enc, compact) {
      return utils2.encode(this._encode(compact), enc);
    };
    BasePoint2.prototype.precompute = function precompute2(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint2.prototype._hasDoubles = function _hasDoubles2(k5) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
    };
    BasePoint2.prototype._getDoubles = function _getDoubles2(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i5 = 0; i5 < power; i5 += step) {
        for (var j5 = 0; j5 < step; j5++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint2.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max2 = (1 << wnd) - 1;
      var dbl3 = max2 === 1 ? null : this.dbl();
      for (var i5 = 1; i5 < max2; i5++)
        res[i5] = res[i5 - 1].add(dbl3);
      return {
        wnd,
        points: res
      };
    };
    BasePoint2.prototype._getBeta = function _getBeta3() {
      return null;
    };
    BasePoint2.prototype.dblp = function dblp3(k5) {
      var r6 = this;
      for (var i5 = 0; i5 < k5; i5++)
        r6 = r6.dbl();
      return r6;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils2 = require_utils3();
    var BN6 = require_bn3();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var assert5 = utils2.assert;
    function ShortCurve2(conf) {
      Base.call(this, "short", conf);
      this.a = new BN6(conf.a, 16).toRed(this.red);
      this.b = new BN6(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve2, Base);
    module.exports = ShortCurve2;
    ShortCurve2.prototype._getEndomorphism = function _getEndomorphism2(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN6(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN6(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert5(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN6(vec.a, 16),
            b: new BN6(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve2.prototype._getEndoRoots = function _getEndoRoots2(num) {
      var red = num === this.p ? this.red : BN6.mont(num);
      var tinv = new BN6(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s6 = new BN6(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s6).fromRed();
      var l22 = ntinv.redSub(s6).fromRed();
      return [l1, l22];
    };
    ShortCurve2.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u5 = lambda;
      var v8 = this.n.clone();
      var x1 = new BN6(1);
      var y1 = new BN6(0);
      var x22 = new BN6(0);
      var y22 = new BN6(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i5 = 0;
      var r6;
      var x5;
      while (u5.cmpn(0) !== 0) {
        var q5 = v8.div(u5);
        r6 = v8.sub(q5.mul(u5));
        x5 = x22.sub(q5.mul(x1));
        var y5 = y22.sub(q5.mul(y1));
        if (!a1 && r6.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r6.neg();
          b1 = x5;
        } else if (a1 && ++i5 === 2) {
          break;
        }
        prevR = r6;
        v8 = u5;
        u5 = r6;
        x22 = x1;
        x1 = x5;
        y22 = y1;
        y1 = y5;
      }
      a22 = r6.neg();
      b22 = x5;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve2.prototype._endoSplit = function _endoSplit2(k5) {
      var basis = this.endo.basis;
      var v12 = basis[0];
      var v22 = basis[1];
      var c1 = v22.b.mul(k5).divRound(this.n);
      var c22 = v12.b.neg().mul(k5).divRound(this.n);
      var p1 = c1.mul(v12.a);
      var p22 = c22.mul(v22.a);
      var q1 = c1.mul(v12.b);
      var q22 = c22.mul(v22.b);
      var k1 = k5.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve2.prototype.pointFromX = function pointFromX2(x5, odd) {
      x5 = new BN6(x5, 16);
      if (!x5.red)
        x5 = x5.toRed(this.red);
      var y22 = x5.redSqr().redMul(x5).redIAdd(x5.redMul(this.a)).redIAdd(this.b);
      var y5 = y22.redSqrt();
      if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y5.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y5 = y5.redNeg();
      return this.point(x5, y5);
    };
    ShortCurve2.prototype.validate = function validate7(point3) {
      if (point3.inf)
        return true;
      var x5 = point3.x;
      var y5 = point3.y;
      var ax = this.a.redMul(x5);
      var rhs = x5.redSqr().redMul(x5).redIAdd(ax).redIAdd(this.b);
      return y5.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve2.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i5 = 0; i5 < points.length; i5++) {
        var split = this._endoSplit(coeffs[i5]);
        var p5 = points[i5];
        var beta = p5._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p5 = p5.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i5 * 2] = p5;
        npoints[i5 * 2 + 1] = beta;
        ncoeffs[i5 * 2] = split.k1;
        ncoeffs[i5 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i5 * 2, jacobianResult);
      for (var j5 = 0; j5 < i5 * 2; j5++) {
        npoints[j5] = null;
        ncoeffs[j5] = null;
      }
      return res;
    };
    function Point2(curve, x5, y5, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x5 === null && y5 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN6(x5, 16);
        this.y = new BN6(y5, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point2, Base.BasePoint);
    ShortCurve2.prototype.point = function point3(x5, y5, isRed) {
      return new Point2(this, x5, y5, isRed);
    };
    ShortCurve2.prototype.pointFromJSON = function pointFromJSON2(obj, red) {
      return Point2.fromJSON(this, obj, red);
    };
    Point2.prototype._getBeta = function _getBeta3() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p5) {
          return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point2.prototype.toJSON = function toJSON2() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point2.fromJSON = function fromJSON2(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity3() {
      return this.inf;
    };
    Point2.prototype.add = function add3(p5) {
      if (this.inf)
        return p5;
      if (p5.inf)
        return this;
      if (this.eq(p5))
        return this.dbl();
      if (this.neg().eq(p5))
        return this.curve.point(null, null);
      if (this.x.cmp(p5.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p5.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p5.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p5.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.dbl = function dbl3() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a5 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.getX = function getX2() {
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY2() {
      return this.y.fromRed();
    };
    Point2.prototype.mul = function mul3(k5) {
      k5 = new BN6(k5, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k5]);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point2.prototype.mulAdd = function mulAdd2(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point2.prototype.jmulAdd = function jmulAdd2(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point2.prototype.eq = function eq4(p5) {
      return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
    };
    Point2.prototype.neg = function neg3(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p5) {
          return p5.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point2.prototype.toJ = function toJ2() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint2(curve, x5, y5, z4) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x5 === null && y5 === null && z4 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN6(0);
      } else {
        this.x = new BN6(x5, 16);
        this.y = new BN6(y5, 16);
        this.z = new BN6(z4, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint2, Base.BasePoint);
    ShortCurve2.prototype.jpoint = function jpoint2(x5, y5, z4) {
      return new JPoint2(this, x5, y5, z4);
    };
    JPoint2.prototype.toP = function toP2() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint2.prototype.neg = function neg3() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint2.prototype.add = function add3(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      var pz2 = p5.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p5.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p5.z));
      var s22 = p5.y.redMul(z22.redMul(this.z));
      var h5 = u1.redSub(u22);
      var r6 = s1.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r6.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v8 = u1.redMul(h22);
      var nx = r6.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r6.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p5.z).redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.mixedAdd = function mixedAdd2(p5) {
      if (this.isInfinity())
        return p5.toJ();
      if (p5.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p5.x.redMul(z22);
      var s1 = this.y;
      var s22 = p5.y.redMul(z22).redMul(this.z);
      var h5 = u1.redSub(u22);
      var r6 = s1.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r6.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v8 = u1.redMul(h22);
      var nx = r6.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r6.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.dblp = function dblp3(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i5;
      if (this.curve.zeroA || this.curve.threeA) {
        var r6 = this;
        for (i5 = 0; i5 < pow; i5++)
          r6 = r6.dbl();
        return r6;
      }
      var a5 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i5 = 0; i5 < pow; i5++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t1.redAdd(t1));
        var t22 = t1.redISub(nx);
        var dny = c5.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i5 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint2.prototype.dbl = function dbl3() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint2.prototype._zeroDbl = function _zeroDbl2() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s6 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s6 = s6.redIAdd(s6);
        var m5 = xx.redAdd(xx).redIAdd(xx);
        var t5 = m5.redSqr().redISub(s6).redISub(s6);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t5;
        ny = m5.redMul(s6.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a5 = this.x.redSqr();
        var b4 = this.y.redSqr();
        var c5 = b4.redSqr();
        var d5 = this.x.redAdd(b4).redSqr().redISub(a5).redISub(c5);
        d5 = d5.redIAdd(d5);
        var e5 = a5.redAdd(a5).redIAdd(a5);
        var f7 = e5.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f7.redISub(d5).redISub(d5);
        ny = e5.redMul(d5.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype._threeDbl = function _threeDbl2() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s6 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s6 = s6.redIAdd(s6);
        var m5 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t5 = m5.redSqr().redISub(s6).redISub(s6);
        nx = t5;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m5.redMul(s6.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype._dbl = function _dbl2() {
      var a5 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t22).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.trpl = function trpl2() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m5 = xx.redAdd(xx).redIAdd(xx);
      var mm = m5.redSqr();
      var e5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e5 = e5.redIAdd(e5);
      e5 = e5.redAdd(e5).redIAdd(e5);
      e5 = e5.redISub(mm);
      var ee = e5.redSqr();
      var t5 = yyyy.redIAdd(yyyy);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      var u5 = m5.redIAdd(e5).redSqr().redISub(mm).redISub(ee).redISub(t5);
      var yyu4 = yy.redMul(u5);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u5.redMul(t5.redISub(u5)).redISub(e5.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e5).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.mul = function mul3(k5, kbase) {
      k5 = new BN6(k5, kbase);
      return this.curve._wnafMul(this, k5);
    };
    JPoint2.prototype.eq = function eq4(p5) {
      if (p5.type === "affine")
        return this.eq(p5.toJ());
      if (this === p5)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p5.z.redSqr();
      if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p5.z);
      return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint2.prototype.eqXToP = function eqXToP2(x5) {
      var zs = this.z.redSqr();
      var rx = x5.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x5.clone();
      var t5 = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint2.prototype.isInfinity = function isInfinity3() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN6 = require_bn3();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var utils2 = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN6(conf.a, 16).toRed(this.red);
      this.b = new BN6(conf.b, 16).toRed(this.red);
      this.i4 = new BN6(4).toRed(this.red).redInvm();
      this.two = new BN6(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate7(point3) {
      var x5 = point3.normalize().x;
      var x22 = x5.redSqr();
      var rhs = x22.redMul(x5).redAdd(x22.redMul(this.a)).redAdd(x5);
      var y5 = rhs.redSqrt();
      return y5.redSqr().cmp(rhs) === 0;
    };
    function Point2(curve, x5, z4) {
      Base.BasePoint.call(this, curve, "projective");
      if (x5 === null && z4 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN6(x5, 16);
        this.z = new BN6(z4, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point2, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint2(bytes, enc) {
      return this.point(utils2.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point3(x5, z4) {
      return new Point2(this, x5, z4);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON2(obj) {
      return Point2.fromJSON(this, obj);
    };
    Point2.prototype.precompute = function precompute2() {
    };
    Point2.prototype._encode = function _encode3() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point2.fromJSON = function fromJSON2(curve, obj) {
      return new Point2(curve, obj[0], obj[1] || curve.one);
    };
    Point2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity3() {
      return this.z.cmpn(0) === 0;
    };
    Point2.prototype.dbl = function dbl3() {
      var a5 = this.x.redAdd(this.z);
      var aa = a5.redSqr();
      var b4 = this.x.redSub(this.z);
      var bb = b4.redSqr();
      var c5 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c5.redMul(bb.redAdd(this.curve.a24.redMul(c5)));
      return this.curve.point(nx, nz);
    };
    Point2.prototype.add = function add3() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.diffAdd = function diffAdd(p5, diff) {
      var a5 = this.x.redAdd(this.z);
      var b4 = this.x.redSub(this.z);
      var c5 = p5.x.redAdd(p5.z);
      var d5 = p5.x.redSub(p5.z);
      var da = d5.redMul(a5);
      var cb = c5.redMul(b4);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point2.prototype.mul = function mul3(k5) {
      var t5 = k5.clone();
      var a5 = this;
      var b4 = this.curve.point(null, null);
      var c5 = this;
      for (var bits = []; t5.cmpn(0) !== 0; t5.iushrn(1))
        bits.push(t5.andln(1));
      for (var i5 = bits.length - 1; i5 >= 0; i5--) {
        if (bits[i5] === 0) {
          a5 = a5.diffAdd(b4, c5);
          b4 = b4.dbl();
        } else {
          b4 = a5.diffAdd(b4, c5);
          a5 = a5.dbl();
        }
      }
      return b4;
    };
    Point2.prototype.mulAdd = function mulAdd2() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.eq = function eq4(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point2.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point2.prototype.getX = function getX2() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils2 = require_utils3();
    var BN6 = require_bn3();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var assert5 = utils2.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN6(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN6(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN6(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert5(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint2(x5, y5, z4, t5) {
      return this.point(x5, y5, z4, t5);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX2(x5, odd) {
      x5 = new BN6(x5, 16);
      if (!x5.red)
        x5 = x5.toRed(this.red);
      var x22 = x5.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y5 = y22.redSqrt();
      if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y5.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y5 = y5.redNeg();
      return this.point(x5, y5);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y5, odd) {
      y5 = new BN6(y5, 16);
      if (!y5.red)
        y5 = y5.toRed(this.red);
      var y22 = y5.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y5);
      }
      var x5 = x22.redSqrt();
      if (x5.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x5.fromRed().isOdd() !== odd)
        x5 = x5.redNeg();
      return this.point(x5, y5);
    };
    EdwardsCurve.prototype.validate = function validate7(point3) {
      if (point3.isInfinity())
        return true;
      point3.normalize();
      var x22 = point3.x.redSqr();
      var y22 = point3.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point2(curve, x5, y5, z4, t5) {
      Base.BasePoint.call(this, curve, "projective");
      if (x5 === null && y5 === null && z4 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN6(x5, 16);
        this.y = new BN6(y5, 16);
        this.z = z4 ? new BN6(z4, 16) : this.curve.one;
        this.t = t5 && new BN6(t5, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point2, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON2(obj) {
      return Point2.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point3(x5, y5, z4, t5) {
      return new Point2(this, x5, y5, z4, t5);
    };
    Point2.fromJSON = function fromJSON2(curve, obj) {
      return new Point2(curve, obj[0], obj[1], obj[2]);
    };
    Point2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity3() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point2.prototype._extDbl = function _extDbl() {
      var a5 = this.x.redSqr();
      var b4 = this.y.redSqr();
      var c5 = this.z.redSqr();
      c5 = c5.redIAdd(c5);
      var d5 = this.curve._mulA(a5);
      var e5 = this.x.redAdd(this.y).redSqr().redISub(a5).redISub(b4);
      var g5 = d5.redAdd(b4);
      var f7 = g5.redSub(c5);
      var h5 = d5.redSub(b4);
      var nx = e5.redMul(f7);
      var ny = g5.redMul(h5);
      var nt = e5.redMul(h5);
      var nz = f7.redMul(g5);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point2.prototype._projDbl = function _projDbl() {
      var b4 = this.x.redAdd(this.y).redSqr();
      var c5 = this.x.redSqr();
      var d5 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e5;
      var h5;
      var j5;
      if (this.curve.twisted) {
        e5 = this.curve._mulA(c5);
        var f7 = e5.redAdd(d5);
        if (this.zOne) {
          nx = b4.redSub(c5).redSub(d5).redMul(f7.redSub(this.curve.two));
          ny = f7.redMul(e5.redSub(d5));
          nz = f7.redSqr().redSub(f7).redSub(f7);
        } else {
          h5 = this.z.redSqr();
          j5 = f7.redSub(h5).redISub(h5);
          nx = b4.redSub(c5).redISub(d5).redMul(j5);
          ny = f7.redMul(e5.redSub(d5));
          nz = f7.redMul(j5);
        }
      } else {
        e5 = c5.redAdd(d5);
        h5 = this.curve._mulC(this.z).redSqr();
        j5 = e5.redSub(h5).redSub(h5);
        nx = this.curve._mulC(b4.redISub(e5)).redMul(j5);
        ny = this.curve._mulC(e5).redMul(c5.redISub(d5));
        nz = e5.redMul(j5);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.dbl = function dbl3() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point2.prototype._extAdd = function _extAdd(p5) {
      var a5 = this.y.redSub(this.x).redMul(p5.y.redSub(p5.x));
      var b4 = this.y.redAdd(this.x).redMul(p5.y.redAdd(p5.x));
      var c5 = this.t.redMul(this.curve.dd).redMul(p5.t);
      var d5 = this.z.redMul(p5.z.redAdd(p5.z));
      var e5 = b4.redSub(a5);
      var f7 = d5.redSub(c5);
      var g5 = d5.redAdd(c5);
      var h5 = b4.redAdd(a5);
      var nx = e5.redMul(f7);
      var ny = g5.redMul(h5);
      var nt = e5.redMul(h5);
      var nz = f7.redMul(g5);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point2.prototype._projAdd = function _projAdd(p5) {
      var a5 = this.z.redMul(p5.z);
      var b4 = a5.redSqr();
      var c5 = this.x.redMul(p5.x);
      var d5 = this.y.redMul(p5.y);
      var e5 = this.curve.d.redMul(c5).redMul(d5);
      var f7 = b4.redSub(e5);
      var g5 = b4.redAdd(e5);
      var tmp = this.x.redAdd(this.y).redMul(p5.x.redAdd(p5.y)).redISub(c5).redISub(d5);
      var nx = a5.redMul(f7).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a5.redMul(g5).redMul(d5.redSub(this.curve._mulA(c5)));
        nz = f7.redMul(g5);
      } else {
        ny = a5.redMul(g5).redMul(d5.redSub(c5));
        nz = this.curve._mulC(f7).redMul(g5);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.add = function add3(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p5);
      else
        return this._projAdd(p5);
    };
    Point2.prototype.mul = function mul3(k5) {
      if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point2.prototype.mulAdd = function mulAdd2(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, false);
    };
    Point2.prototype.jmulAdd = function jmulAdd2(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, true);
    };
    Point2.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point2.prototype.neg = function neg3() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point2.prototype.getX = function getX2() {
      this.normalize();
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY2() {
      this.normalize();
      return this.y.fromRed();
    };
    Point2.prototype.eq = function eq4(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point2.prototype.eqXToP = function eqXToP2(x5) {
      var rx = x5.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x5.clone();
      var t5 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point2.prototype.toP = Point2.prototype.normalize;
    Point2.prototype.mixedAdd = Point2.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash4 = require_hash();
    var curve = require_curve();
    var utils2 = require_utils3();
    var assert5 = utils2.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert5(this.g.validate(), "Invalid curve");
      assert5(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name2, options) {
      Object.defineProperty(curves, name2, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name2, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash4.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash4.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e5) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash4.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash4 = require_hash();
    var utils2 = require_utils2();
    var assert5 = require_minimalistic_assert();
    function HmacDRBG2(options) {
      if (!(this instanceof HmacDRBG2))
        return new HmacDRBG2(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils2.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils2.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils2.toArray(options.pers, options.persEnc || "hex");
      assert5(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG2;
    HmacDRBG2.prototype._init = function init3(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i5 = 0; i5 < this.V.length; i5++) {
        this.K[i5] = 0;
        this.V[i5] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG2.prototype._hmac = function hmac3() {
      return new hash4.hmac(this.hash, this.K);
    };
    HmacDRBG2.prototype._update = function update5(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG2.prototype.reseed = function reseed2(entropy, entropyEnc, add3, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add3;
        add3 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils2.toArray(entropy, entropyEnc);
      add3 = utils2.toArray(add3, addEnc);
      assert5(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._update(entropy.concat(add3 || []));
      this._reseed = 1;
    };
    HmacDRBG2.prototype.generate = function generate3(len, enc, add3, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add3;
        add3 = enc;
        enc = null;
      }
      if (add3) {
        add3 = utils2.toArray(add3, addEnc || "hex");
        this._update(add3);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add3);
      this._reseed++;
      return utils2.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN6 = require_bn3();
    var utils2 = require_utils3();
    var assert5 = utils2.assert;
    function KeyPair2(ec2, options) {
      this.ec = ec2;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair2;
    KeyPair2.fromPublic = function fromPublic2(ec2, pub, enc) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair2.fromPrivate = function fromPrivate2(ec2, priv, enc) {
      if (priv instanceof KeyPair2)
        return priv;
      return new KeyPair2(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair2.prototype.validate = function validate7() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair2.prototype.getPublic = function getPublic2(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair2.prototype.getPrivate = function getPrivate2(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair2.prototype._importPrivate = function _importPrivate2(key2, enc) {
      this.priv = new BN6(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair2.prototype._importPublic = function _importPublic2(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert5(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert5(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair2.prototype.derive = function derive2(pub) {
      if (!pub.validate()) {
        assert5(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair2.prototype.sign = function sign3(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair2.prototype.verify = function verify3(msg, signature2) {
      return this.ec.verify(msg, signature2, this);
    };
    KeyPair2.prototype.inspect = function inspect4() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN6 = require_bn3();
    var utils2 = require_utils3();
    var assert5 = utils2.assert;
    function Signature2(options, enc) {
      if (options instanceof Signature2)
        return options;
      if (this._importDER(options, enc))
        return;
      assert5(options.r && options.s, "Signature without r or s");
      this.r = new BN6(options.r, 16);
      this.s = new BN6(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature2;
    function Position2() {
      this.place = 0;
    }
    function getLength2(buf, p5) {
      var initial = buf[p5.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i5 = 0, off = p5.place; i5 < octetLen; i5++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p5.place = off;
      return val;
    }
    function rmPadding2(buf) {
      var i5 = 0;
      var len = buf.length - 1;
      while (!buf[i5] && !(buf[i5 + 1] & 128) && i5 < len) {
        i5++;
      }
      if (i5 === 0) {
        return buf;
      }
      return buf.slice(i5);
    }
    Signature2.prototype._importDER = function _importDER2(data, enc) {
      data = utils2.toArray(data, enc);
      var p5 = new Position2();
      if (data[p5.place++] !== 48) {
        return false;
      }
      var len = getLength2(data, p5);
      if (len === false) {
        return false;
      }
      if (len + p5.place !== data.length) {
        return false;
      }
      if (data[p5.place++] !== 2) {
        return false;
      }
      var rlen = getLength2(data, p5);
      if (rlen === false) {
        return false;
      }
      var r6 = data.slice(p5.place, rlen + p5.place);
      p5.place += rlen;
      if (data[p5.place++] !== 2) {
        return false;
      }
      var slen = getLength2(data, p5);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p5.place) {
        return false;
      }
      var s6 = data.slice(p5.place, slen + p5.place);
      if (r6[0] === 0) {
        if (r6[1] & 128) {
          r6 = r6.slice(1);
        } else {
          return false;
        }
      }
      if (s6[0] === 0) {
        if (s6[1] & 128) {
          s6 = s6.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN6(r6);
      this.s = new BN6(s6);
      this.recoveryParam = null;
      return true;
    };
    function constructLength2(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature2.prototype.toDER = function toDER2(enc) {
      var r6 = this.r.toArray();
      var s6 = this.s.toArray();
      if (r6[0] & 128)
        r6 = [0].concat(r6);
      if (s6[0] & 128)
        s6 = [0].concat(s6);
      r6 = rmPadding2(r6);
      s6 = rmPadding2(s6);
      while (!s6[0] && !(s6[1] & 128)) {
        s6 = s6.slice(1);
      }
      var arr = [2];
      constructLength2(arr, r6.length);
      arr = arr.concat(r6);
      arr.push(2);
      constructLength2(arr, s6.length);
      var backHalf = arr.concat(s6);
      var res = [48];
      constructLength2(res, backHalf.length);
      res = res.concat(backHalf);
      return utils2.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN6 = require_bn3();
    var HmacDRBG2 = require_hmac_drbg();
    var utils2 = require_utils3();
    var curves = require_curves();
    var rand2 = require_brorand();
    var assert5 = utils2.assert;
    var KeyPair2 = require_key();
    var Signature2 = require_signature();
    function EC2(options) {
      if (!(this instanceof EC2))
        return new EC2(options);
      if (typeof options === "string") {
        assert5(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC2;
    EC2.prototype.keyPair = function keyPair2(options) {
      return new KeyPair2(this, options);
    };
    EC2.prototype.keyFromPrivate = function keyFromPrivate2(priv, enc) {
      return KeyPair2.fromPrivate(this, priv, enc);
    };
    EC2.prototype.keyFromPublic = function keyFromPublic2(pub, enc) {
      return KeyPair2.fromPublic(this, pub, enc);
    };
    EC2.prototype.genKeyPair = function genKeyPair2(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG2({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand2(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN6(2));
      for (; ; ) {
        var priv = new BN6(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC2.prototype._truncateToN = function _truncateToN2(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC2.prototype.sign = function sign3(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new BN6(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG2({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN6(1));
      for (var iter = 0; ; iter++) {
        var k5 = options.k ? options.k(iter) : new BN6(drbg.generate(this.n.byteLength()));
        k5 = this._truncateToN(k5, true);
        if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k5);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r6 = kpX.umod(this.n);
        if (r6.cmpn(0) === 0)
          continue;
        var s6 = k5.invm(this.n).mul(r6.mul(key2.getPrivate()).iadd(msg));
        s6 = s6.umod(this.n);
        if (s6.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r6) !== 0 ? 2 : 0);
        if (options.canonical && s6.cmp(this.nh) > 0) {
          s6 = this.n.sub(s6);
          recoveryParam ^= 1;
        }
        return new Signature2({ r: r6, s: s6, recoveryParam });
      }
    };
    EC2.prototype.verify = function verify3(msg, signature2, key2, enc) {
      msg = this._truncateToN(new BN6(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature2 = new Signature2(signature2, "hex");
      var r6 = signature2.r;
      var s6 = signature2.s;
      if (r6.cmpn(1) < 0 || r6.cmp(this.n) >= 0)
        return false;
      if (s6.cmpn(1) < 0 || s6.cmp(this.n) >= 0)
        return false;
      var sinv = s6.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r6).umod(this.n);
      var p5;
      if (!this.curve._maxwellTrick) {
        p5 = this.g.mulAdd(u1, key2.getPublic(), u22);
        if (p5.isInfinity())
          return false;
        return p5.getX().umod(this.n).cmp(r6) === 0;
      }
      p5 = this.g.jmulAdd(u1, key2.getPublic(), u22);
      if (p5.isInfinity())
        return false;
      return p5.eqXToP(r6);
    };
    EC2.prototype.recoverPubKey = function(msg, signature2, j5, enc) {
      assert5((3 & j5) === j5, "The recovery param is more than two bits");
      signature2 = new Signature2(signature2, enc);
      var n3 = this.n;
      var e5 = new BN6(msg);
      var r6 = signature2.r;
      var s6 = signature2.s;
      var isYOdd = j5 & 1;
      var isSecondKey = j5 >> 1;
      if (r6.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r6 = this.curve.pointFromX(r6.add(this.curve.n), isYOdd);
      else
        r6 = this.curve.pointFromX(r6, isYOdd);
      var rInv = signature2.r.invm(n3);
      var s1 = n3.sub(e5).mul(rInv).umod(n3);
      var s22 = s6.mul(rInv).umod(n3);
      return this.g.mulAdd(s1, r6, s22);
    };
    EC2.prototype.getKeyRecoveryParam = function(e5, signature2, Q2, enc) {
      signature2 = new Signature2(signature2, enc);
      if (signature2.recoveryParam !== null)
        return signature2.recoveryParam;
      for (var i5 = 0; i5 < 4; i5++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e5, signature2, i5);
        } catch (e6) {
          continue;
        }
        if (Qprime.eq(Q2))
          return i5;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils2 = require_utils3();
    var assert5 = utils2.assert;
    var parseBytes = utils2.parseBytes;
    var cachedProperty = utils2.cachedProperty;
    function KeyPair2(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair2.fromPublic = function fromPublic2(eddsa, pub) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(eddsa, { pub });
    };
    KeyPair2.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair2)
        return secret;
      return new KeyPair2(eddsa, { secret });
    };
    KeyPair2.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair2, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair2, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair2, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash4 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a5 = hash4.slice(0, eddsa.encodingLength);
      a5[0] &= 248;
      a5[lastIx] &= 127;
      a5[lastIx] |= 64;
      return a5;
    });
    cachedProperty(KeyPair2, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair2, "hash", function hash4() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair2, "messagePrefix", function messagePrefix2() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair2.prototype.sign = function sign3(message) {
      assert5(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair2.prototype.verify = function verify3(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair2.prototype.getSecret = function getSecret(enc) {
      assert5(this._secret, "KeyPair is public only");
      return utils2.encode(this.secret(), enc);
    };
    KeyPair2.prototype.getPublic = function getPublic2(enc) {
      return utils2.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair2;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN6 = require_bn3();
    var utils2 = require_utils3();
    var assert5 = utils2.assert;
    var cachedProperty = utils2.cachedProperty;
    var parseBytes = utils2.parseBytes;
    function Signature2(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert5(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN6)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature2, "S", function S3() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature2, "R", function R2() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature2, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature2, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature2.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature2.prototype.toHex = function toHex3() {
      return utils2.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature2;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash4 = require_hash();
    var curves = require_curves();
    var utils2 = require_utils3();
    var assert5 = utils2.assert;
    var parseBytes = utils2.parseBytes;
    var KeyPair2 = require_key2();
    var Signature2 = require_signature2();
    function EDDSA(curve) {
      assert5(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash4.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign3(message, secret) {
      message = parseBytes(message);
      var key2 = this.keyFromSecret(secret);
      var r6 = this.hashInt(key2.messagePrefix(), message);
      var R2 = this.g.mul(r6);
      var Rencoded = this.encodePoint(R2);
      var s_ = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
      var S3 = r6.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R2, S: S3, Rencoded });
    };
    EDDSA.prototype.verify = function verify3(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key2 = this.keyFromPublic(pub);
      var h5 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key2.pub().mul(h5));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash5 = this.hash();
      for (var i5 = 0; i5 < arguments.length; i5++)
        hash5.update(arguments[i5]);
      return utils2.intFromLE(hash5.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic2(pub) {
      return KeyPair2.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair2.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature2)
        return sig;
      return new Signature2(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point3) {
      var enc = point3.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point3.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint2(bytes) {
      bytes = utils2.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y5 = utils2.intFromLE(normed);
      return this.curve.pointFromY(y5, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils2.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/secp256k1/lib/elliptic.js"(exports, module) {
    var EC2 = require_elliptic().ec;
    var ec2 = new EC2("secp256k1");
    var ecparams = ec2.curve;
    var BN6 = ecparams.n.constructor;
    function loadCompressedPublicKey(first2, xbuf) {
      let x5 = new BN6(xbuf);
      if (x5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      let y5 = x5.redSqr().redIMul(x5).redIAdd(ecparams.b).redSqrt();
      if (first2 === 3 !== y5.isOdd())
        y5 = y5.redNeg();
      return ec2.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadUncompressedPublicKey(first2, xbuf, ybuf) {
      let x5 = new BN6(xbuf);
      let y5 = new BN6(ybuf);
      if (x5.cmp(ecparams.p) >= 0 || y5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      y5 = y5.toRed(ecparams.red);
      if ((first2 === 6 || first2 === 7) && y5.isOdd() !== (first2 === 7))
        return null;
      const x32 = x5.redSqr().redIMul(x5);
      if (!y5.redSqr().redISub(x32.redIAdd(ecparams.b)).isZero())
        return null;
      return ec2.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadPublicKey(pubkey) {
      const first2 = pubkey[0];
      switch (first2) {
        case 2:
        case 3:
          if (pubkey.length !== 33)
            return null;
          return loadCompressedPublicKey(first2, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first2, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point3) {
      const pubkey = point3.encode(null, output.length === 33);
      for (let i5 = 0; i5 < output.length; ++i5)
        output[i5] = pubkey[i5];
    }
    module.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn = new BN6(seckey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn = new BN6(seckey);
        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn = new BN6(tweak);
        if (bn.cmp(ecparams.n) >= 0)
          return 1;
        bn.iadd(new BN6(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn.isub(ecparams.n);
        if (bn.isZero())
          return 1;
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn = new BN6(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        bn.imul(new BN6(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn = bn.umod(ecparams.n);
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn = new BN6(seckey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        const point3 = ec2.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point3);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point3 = pair.getPublic();
        savePublicKey(output, point3);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point3 = pair.getPublic();
        point3.y = point3.y.redNeg();
        savePublicKey(output, point3);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs2 = new Array(pubkeys.length);
        for (let i5 = 0; i5 < pubkeys.length; ++i5) {
          pairs2[i5] = loadPublicKey(pubkeys[i5]);
          if (pairs2[i5] === null)
            return 1;
        }
        let point3 = pairs2[0].getPublic();
        for (let i5 = 1; i5 < pairs2.length; ++i5)
          point3 = point3.add(pairs2[i5].pub);
        if (point3.isInfinity())
          return 2;
        savePublicKey(output, point3);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN6(tweak);
        if (tweak.cmp(ecparams.n) >= 0)
          return 2;
        const point3 = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point3.isInfinity())
          return 2;
        savePublicKey(output, point3);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN6(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
          return 2;
        const point3 = pair.getPublic().mul(tweak);
        savePublicKey(output, point3);
        return 0;
      },
      signatureNormalize(sig) {
        const r6 = new BN6(sig.subarray(0, 32));
        const s6 = new BN6(sig.subarray(32, 64));
        if (r6.cmp(ecparams.n) >= 0 || s6.cmp(ecparams.n) >= 0)
          return 1;
        if (s6.cmp(ec2.nh) === 1) {
          sig.set(ecparams.n.sub(s6).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN6(sigR).cmp(ecparams.n) >= 0)
          return 1;
        if (new BN6(sigS).cmp(ecparams.n) >= 0)
          return 1;
        const { output } = obj;
        let r6 = output.subarray(4, 4 + 33);
        r6[0] = 0;
        r6.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r6[posR] === 0 && !(r6[posR + 1] & 128); --lenR, ++posR)
          ;
        r6 = r6.subarray(posR);
        if (r6[0] & 128)
          return 1;
        if (lenR > 1 && r6[0] === 0 && !(r6[1] & 128))
          return 1;
        let s6 = output.subarray(6 + 33, 6 + 33 + 33);
        s6[0] = 0;
        s6.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s6[posS] === 0 && !(s6[posS + 1] & 128); --lenS, ++posS)
          ;
        s6 = s6.subarray(posS);
        if (s6[0] & 128)
          return 1;
        if (lenS > 1 && s6[0] === 0 && !(s6[1] & 128))
          return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r6.length;
        output.set(r6, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s6.length;
        output.set(s6, 6 + lenR);
        return 0;
      },
      signatureImport(output, sig) {
        if (sig.length < 8)
          return 1;
        if (sig.length > 72)
          return 1;
        if (sig[0] !== 48)
          return 1;
        if (sig[1] !== sig.length - 2)
          return 1;
        if (sig[2] !== 2)
          return 1;
        const lenR = sig[3];
        if (lenR === 0)
          return 1;
        if (5 + lenR >= sig.length)
          return 1;
        if (sig[4 + lenR] !== 2)
          return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0)
          return 1;
        if (6 + lenR + lenS !== sig.length)
          return 1;
        if (sig[4] & 128)
          return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
          return 1;
        if (sig[lenR + 6] & 128)
          return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
          return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0)
          sigR = sigR.subarray(1);
        if (sigR.length > 32)
          return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0)
          sigS = sigS.slice(1);
        if (sigS.length > 32)
          throw new Error("S length is too long");
        let r6 = new BN6(sigR);
        if (r6.cmp(ecparams.n) >= 0)
          r6 = new BN6(0);
        let s6 = new BN6(sig.subarray(6 + lenR));
        if (s6.cmp(ecparams.n) >= 0)
          s6 = new BN6(0);
        output.set(r6.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s6.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid)
              throw new Error("This is the way");
            return new BN6(nonce);
          };
        }
        const d5 = new BN6(seckey);
        if (d5.cmp(ecparams.n) >= 0 || d5.isZero())
          return 1;
        let sig;
        try {
          sig = ec2.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN6(sigObj.r);
        const sigs = new BN6(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigs.cmp(ec2.nh) === 1 || sigr.isZero() || sigs.isZero())
          return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 2;
        const point3 = pair.getPublic();
        const isValid = ec2.verify(msg32, sigObj, point3);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN6(sigObj.r);
        const sigs = new BN6(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigr.isZero() || sigs.isZero())
          return 2;
        let point3;
        try {
          point3 = ec2.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point3);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const scalar = new BN6(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
          return 2;
        const point3 = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point3.encode(null, true);
          const sha2565 = ec2.hash().update(data2).digest();
          for (let i5 = 0; i5 < 32; ++i5)
            output[i5] = sha2565[i5];
        } else {
          if (!xbuf)
            xbuf = new Uint8Array(32);
          const x5 = point3.getX().toArray("be", 32);
          for (let i5 = 0; i5 < 32; ++i5)
            xbuf[i5] = x5[i5];
          if (!ybuf)
            ybuf = new Uint8Array(32);
          const y5 = point3.getY().toArray("be", 32);
          for (let i5 = 0; i5 < 32; ++i5)
            ybuf[i5] = y5[i5];
          const hash4 = hashfn(xbuf, ybuf, data);
          const isValid = hash4 instanceof Uint8Array && hash4.length === output.length;
          if (!isValid)
            return 2;
          output.set(hash4);
        }
        return 0;
      }
    };
  }
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/secp256k1/elliptic.js"(exports, module) {
    module.exports = require_lib2()(require_elliptic2());
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING2 = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits, n3, s6) {
          return methods["cshake" + bits2].update(message, outputBits, n3, s6)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding2, outputType) {
        return function(key2, message, outputBits, s6) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s6)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding2) {
        for (var i6 = 0; i6 < OUTPUT_TYPES.length; ++i6) {
          var type2 = OUTPUT_TYPES[i6];
          method[type2] = createMethod2(bits2, padding2, type2);
        }
        return method;
      };
      var createMethod = function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      };
      var createShakeMethod = function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      };
      var createCshakeMethod = function(bits2, padding2) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n3, s6) {
          if (!n3 && !s6) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding2, outputBits).bytepad([n3, s6], w6);
          }
        };
        method.update = function(message, outputBits, n3, s6) {
          return method.create(outputBits, n3, s6).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      };
      var createKmacMethod = function(bits2, padding2) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key2, outputBits, s6) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s6], w6).bytepad([key2], w6);
        };
        method.update = function(key2, message, outputBits, s6) {
          return method.create(key2, outputBits, s6).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i5 = 0; i5 < algorithms.length; ++i5) {
        var algorithm = algorithms[i5];
        var bits = algorithm.bits;
        for (var j5 = 0; j5 < bits.length; ++j5) {
          var methodName = algorithm.name + "_" + bits[j5];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j5], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j5];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i6 = 0; i6 < 50; ++i6) {
          this.s[i6] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type2 = typeof message;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s6 = this.s, i6, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i6 = 1; i6 < blockCount + 1; ++i6) {
              blocks[i6] = 0;
            }
          }
          if (notString) {
            for (i6 = this.start; index < length && i6 < byteCount; ++index) {
              blocks[i6 >> 2] |= message[index] << SHIFT[i6++ & 3];
            }
          } else {
            for (i6 = this.start; index < length && i6 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i6 >> 2] |= code << SHIFT[i6++ & 3];
              } else if (code < 2048) {
                blocks[i6 >> 2] |= (192 | code >> 6) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i6 >> 2] |= (224 | code >> 12) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i6 >> 2] |= (240 | code >> 18) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              }
            }
          }
          this.lastByteIndex = i6;
          if (i6 >= byteCount) {
            this.start = i6 - byteCount;
            this.block = blocks[blockCount];
            for (i6 = 0; i6 < blockCount; ++i6) {
              s6[i6] ^= blocks[i6];
            }
            f7(s6);
            this.reset = true;
          } else {
            this.start = i6;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x5, right) {
        var o5 = x5 & 255, n3 = 1;
        var bytes = [o5];
        x5 = x5 >> 8;
        o5 = x5 & 255;
        while (o5 > 0) {
          bytes.unshift(o5);
          x5 = x5 >> 8;
          o5 = x5 & 255;
          ++n3;
        }
        if (right) {
          bytes.push(n3);
        } else {
          bytes.unshift(n3);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type2 = typeof str;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i6 = 0; i6 < str.length; ++i6) {
            var code = str.charCodeAt(i6);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i6) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w6) {
        var bytes = this.encode(w6);
        for (var i6 = 0; i6 < strs.length; ++i6) {
          bytes += this.encodeString(strs[i6]);
        }
        var paddingBytes = w6 - bytes % w6;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i6 = this.lastByteIndex, blockCount = this.blockCount, s6 = this.s;
        blocks[i6 >> 2] |= this.padding[i6 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i6 = 1; i6 < blockCount + 1; ++i6) {
            blocks[i6] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i6 = 0; i6 < blockCount; ++i6) {
          s6[i6] ^= blocks[i6];
        }
        f7(s6);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s6 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j6 = 0;
        var hex = "", block;
        while (j6 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j6 < outputBlocks; ++i6, ++j6) {
            block = s6[i6];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j6 % blockCount === 0) {
            f7(s6);
            i6 = 0;
          }
        }
        if (extraBytes) {
          block = s6[i6];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s6 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j6 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array2 = new Uint32Array(buffer2);
        while (j6 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j6 < outputBlocks; ++i6, ++j6) {
            array2[j6] = s6[i6];
          }
          if (j6 % blockCount === 0) {
            f7(s6);
          }
        }
        if (extraBytes) {
          array2[i6] = s6[i6];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s6 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j6 = 0;
        var array2 = [], offset2, block;
        while (j6 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j6 < outputBlocks; ++i6, ++j6) {
            offset2 = j6 << 2;
            block = s6[i6];
            array2[offset2] = block & 255;
            array2[offset2 + 1] = block >> 8 & 255;
            array2[offset2 + 2] = block >> 16 & 255;
            array2[offset2 + 3] = block >> 24 & 255;
          }
          if (j6 % blockCount === 0) {
            f7(s6);
          }
        }
        if (extraBytes) {
          offset2 = j6 << 2;
          block = s6[i6];
          array2[offset2] = block & 255;
          if (extraBytes > 1) {
            array2[offset2 + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array2[offset2 + 2] = block >> 16 & 255;
          }
        }
        return array2;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak.call(this, bits2, padding2, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f7 = function(s6) {
        var h5, l5, n3, c0, c1, c22, c32, c42, c5, c6, c7, c8, c9, b0, b1, b22, b32, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n3 = 0; n3 < 48; n3 += 2) {
          c0 = s6[0] ^ s6[10] ^ s6[20] ^ s6[30] ^ s6[40];
          c1 = s6[1] ^ s6[11] ^ s6[21] ^ s6[31] ^ s6[41];
          c22 = s6[2] ^ s6[12] ^ s6[22] ^ s6[32] ^ s6[42];
          c32 = s6[3] ^ s6[13] ^ s6[23] ^ s6[33] ^ s6[43];
          c42 = s6[4] ^ s6[14] ^ s6[24] ^ s6[34] ^ s6[44];
          c5 = s6[5] ^ s6[15] ^ s6[25] ^ s6[35] ^ s6[45];
          c6 = s6[6] ^ s6[16] ^ s6[26] ^ s6[36] ^ s6[46];
          c7 = s6[7] ^ s6[17] ^ s6[27] ^ s6[37] ^ s6[47];
          c8 = s6[8] ^ s6[18] ^ s6[28] ^ s6[38] ^ s6[48];
          c9 = s6[9] ^ s6[19] ^ s6[29] ^ s6[39] ^ s6[49];
          h5 = c8 ^ (c22 << 1 | c32 >>> 31);
          l5 = c9 ^ (c32 << 1 | c22 >>> 31);
          s6[0] ^= h5;
          s6[1] ^= l5;
          s6[10] ^= h5;
          s6[11] ^= l5;
          s6[20] ^= h5;
          s6[21] ^= l5;
          s6[30] ^= h5;
          s6[31] ^= l5;
          s6[40] ^= h5;
          s6[41] ^= l5;
          h5 = c0 ^ (c42 << 1 | c5 >>> 31);
          l5 = c1 ^ (c5 << 1 | c42 >>> 31);
          s6[2] ^= h5;
          s6[3] ^= l5;
          s6[12] ^= h5;
          s6[13] ^= l5;
          s6[22] ^= h5;
          s6[23] ^= l5;
          s6[32] ^= h5;
          s6[33] ^= l5;
          s6[42] ^= h5;
          s6[43] ^= l5;
          h5 = c22 ^ (c6 << 1 | c7 >>> 31);
          l5 = c32 ^ (c7 << 1 | c6 >>> 31);
          s6[4] ^= h5;
          s6[5] ^= l5;
          s6[14] ^= h5;
          s6[15] ^= l5;
          s6[24] ^= h5;
          s6[25] ^= l5;
          s6[34] ^= h5;
          s6[35] ^= l5;
          s6[44] ^= h5;
          s6[45] ^= l5;
          h5 = c42 ^ (c8 << 1 | c9 >>> 31);
          l5 = c5 ^ (c9 << 1 | c8 >>> 31);
          s6[6] ^= h5;
          s6[7] ^= l5;
          s6[16] ^= h5;
          s6[17] ^= l5;
          s6[26] ^= h5;
          s6[27] ^= l5;
          s6[36] ^= h5;
          s6[37] ^= l5;
          s6[46] ^= h5;
          s6[47] ^= l5;
          h5 = c6 ^ (c0 << 1 | c1 >>> 31);
          l5 = c7 ^ (c1 << 1 | c0 >>> 31);
          s6[8] ^= h5;
          s6[9] ^= l5;
          s6[18] ^= h5;
          s6[19] ^= l5;
          s6[28] ^= h5;
          s6[29] ^= l5;
          s6[38] ^= h5;
          s6[39] ^= l5;
          s6[48] ^= h5;
          s6[49] ^= l5;
          b0 = s6[0];
          b1 = s6[1];
          b322 = s6[11] << 4 | s6[10] >>> 28;
          b33 = s6[10] << 4 | s6[11] >>> 28;
          b14 = s6[20] << 3 | s6[21] >>> 29;
          b15 = s6[21] << 3 | s6[20] >>> 29;
          b46 = s6[31] << 9 | s6[30] >>> 23;
          b47 = s6[30] << 9 | s6[31] >>> 23;
          b28 = s6[40] << 18 | s6[41] >>> 14;
          b29 = s6[41] << 18 | s6[40] >>> 14;
          b20 = s6[2] << 1 | s6[3] >>> 31;
          b21 = s6[3] << 1 | s6[2] >>> 31;
          b22 = s6[13] << 12 | s6[12] >>> 20;
          b32 = s6[12] << 12 | s6[13] >>> 20;
          b34 = s6[22] << 10 | s6[23] >>> 22;
          b35 = s6[23] << 10 | s6[22] >>> 22;
          b16 = s6[33] << 13 | s6[32] >>> 19;
          b17 = s6[32] << 13 | s6[33] >>> 19;
          b48 = s6[42] << 2 | s6[43] >>> 30;
          b49 = s6[43] << 2 | s6[42] >>> 30;
          b40 = s6[5] << 30 | s6[4] >>> 2;
          b41 = s6[4] << 30 | s6[5] >>> 2;
          b222 = s6[14] << 6 | s6[15] >>> 26;
          b23 = s6[15] << 6 | s6[14] >>> 26;
          b4 = s6[25] << 11 | s6[24] >>> 21;
          b5 = s6[24] << 11 | s6[25] >>> 21;
          b36 = s6[34] << 15 | s6[35] >>> 17;
          b37 = s6[35] << 15 | s6[34] >>> 17;
          b18 = s6[45] << 29 | s6[44] >>> 3;
          b19 = s6[44] << 29 | s6[45] >>> 3;
          b10 = s6[6] << 28 | s6[7] >>> 4;
          b11 = s6[7] << 28 | s6[6] >>> 4;
          b42 = s6[17] << 23 | s6[16] >>> 9;
          b43 = s6[16] << 23 | s6[17] >>> 9;
          b24 = s6[26] << 25 | s6[27] >>> 7;
          b25 = s6[27] << 25 | s6[26] >>> 7;
          b6 = s6[36] << 21 | s6[37] >>> 11;
          b7 = s6[37] << 21 | s6[36] >>> 11;
          b38 = s6[47] << 24 | s6[46] >>> 8;
          b39 = s6[46] << 24 | s6[47] >>> 8;
          b30 = s6[8] << 27 | s6[9] >>> 5;
          b31 = s6[9] << 27 | s6[8] >>> 5;
          b12 = s6[18] << 20 | s6[19] >>> 12;
          b13 = s6[19] << 20 | s6[18] >>> 12;
          b44 = s6[29] << 7 | s6[28] >>> 25;
          b45 = s6[28] << 7 | s6[29] >>> 25;
          b26 = s6[38] << 8 | s6[39] >>> 24;
          b27 = s6[39] << 8 | s6[38] >>> 24;
          b8 = s6[48] << 14 | s6[49] >>> 18;
          b9 = s6[49] << 14 | s6[48] >>> 18;
          s6[0] = b0 ^ ~b22 & b4;
          s6[1] = b1 ^ ~b32 & b5;
          s6[10] = b10 ^ ~b12 & b14;
          s6[11] = b11 ^ ~b13 & b15;
          s6[20] = b20 ^ ~b222 & b24;
          s6[21] = b21 ^ ~b23 & b25;
          s6[30] = b30 ^ ~b322 & b34;
          s6[31] = b31 ^ ~b33 & b35;
          s6[40] = b40 ^ ~b42 & b44;
          s6[41] = b41 ^ ~b43 & b45;
          s6[2] = b22 ^ ~b4 & b6;
          s6[3] = b32 ^ ~b5 & b7;
          s6[12] = b12 ^ ~b14 & b16;
          s6[13] = b13 ^ ~b15 & b17;
          s6[22] = b222 ^ ~b24 & b26;
          s6[23] = b23 ^ ~b25 & b27;
          s6[32] = b322 ^ ~b34 & b36;
          s6[33] = b33 ^ ~b35 & b37;
          s6[42] = b42 ^ ~b44 & b46;
          s6[43] = b43 ^ ~b45 & b47;
          s6[4] = b4 ^ ~b6 & b8;
          s6[5] = b5 ^ ~b7 & b9;
          s6[14] = b14 ^ ~b16 & b18;
          s6[15] = b15 ^ ~b17 & b19;
          s6[24] = b24 ^ ~b26 & b28;
          s6[25] = b25 ^ ~b27 & b29;
          s6[34] = b34 ^ ~b36 & b38;
          s6[35] = b35 ^ ~b37 & b39;
          s6[44] = b44 ^ ~b46 & b48;
          s6[45] = b45 ^ ~b47 & b49;
          s6[6] = b6 ^ ~b8 & b0;
          s6[7] = b7 ^ ~b9 & b1;
          s6[16] = b16 ^ ~b18 & b10;
          s6[17] = b17 ^ ~b19 & b11;
          s6[26] = b26 ^ ~b28 & b20;
          s6[27] = b27 ^ ~b29 & b21;
          s6[36] = b36 ^ ~b38 & b30;
          s6[37] = b37 ^ ~b39 & b31;
          s6[46] = b46 ^ ~b48 & b40;
          s6[47] = b47 ^ ~b49 & b41;
          s6[8] = b8 ^ ~b0 & b22;
          s6[9] = b9 ^ ~b1 & b32;
          s6[18] = b18 ^ ~b10 & b12;
          s6[19] = b19 ^ ~b11 & b13;
          s6[28] = b28 ^ ~b20 & b222;
          s6[29] = b29 ^ ~b21 & b23;
          s6[38] = b38 ^ ~b30 & b322;
          s6[39] = b39 ^ ~b31 & b33;
          s6[48] = b48 ^ ~b40 & b42;
          s6[49] = b49 ^ ~b41 & b43;
          s6[0] ^= RC[n3];
          s6[1] ^= RC[n3 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i5 = 0; i5 < methodNames.length; ++i5) {
          root[methodNames[i5]] = methods[methodNames[i5]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "node_modules/aes-js/index.js"(exports, module) {
    "use strict";
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i5 = 0; i5 < arrayish.length; i5++) {
          if (!checkInt(arrayish[i5]) || arrayish[i5] < 0 || arrayish[i5] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length) {
        return new Uint8Array(length);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes(text) {
          var result = [], i5 = 0;
          text = encodeURI(text);
          while (i5 < text.length) {
            var c5 = text.charCodeAt(i5++);
            if (c5 === 37) {
              result.push(parseInt(text.substr(i5, 2), 16));
              i5 += 2;
            } else {
              result.push(c5);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes) {
          var result = [], i5 = 0;
          while (i5 < bytes.length) {
            var c5 = bytes[i5];
            if (c5 < 128) {
              result.push(String.fromCharCode(c5));
              i5++;
            } else if (c5 > 191 && c5 < 224) {
              result.push(String.fromCharCode((c5 & 31) << 6 | bytes[i5 + 1] & 63));
              i5 += 2;
            } else {
              result.push(String.fromCharCode((c5 & 15) << 12 | (bytes[i5 + 1] & 63) << 6 | bytes[i5 + 2] & 63));
              i5 += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes(text) {
          var result = [];
          for (var i5 = 0; i5 < text.length; i5 += 2) {
            result.push(parseInt(text.substr(i5, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
          var result = [];
          for (var i5 = 0; i5 < bytes.length; i5++) {
            var v8 = bytes[i5];
            result.push(Hex[(v8 & 240) >> 4] + Hex[v8 & 15]);
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S3 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T42 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T52 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i5 = 0; i5 < bytes.length; i5 += 4) {
          result.push(bytes[i5] << 24 | bytes[i5 + 1] << 16 | bytes[i5 + 2] << 8 | bytes[i5 + 3]);
        }
        return result;
      }
      var AES = function(key2) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key2, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i5 = 0; i5 <= rounds; i5++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i5 = 0; i5 < KC; i5++) {
          index = i5 >> 2;
          this._Ke[index][i5 % 4] = tk[i5];
          this._Kd[rounds - index][i5 % 4] = tk[i5];
        }
        var rconpointer = 0;
        var t5 = KC, tt;
        while (t5 < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S3[tt >> 16 & 255] << 24 ^ S3[tt >> 8 & 255] << 16 ^ S3[tt & 255] << 8 ^ S3[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i5 = 1; i5 < KC; i5++) {
              tk[i5] ^= tk[i5 - 1];
            }
          } else {
            for (var i5 = 1; i5 < KC / 2; i5++) {
              tk[i5] ^= tk[i5 - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S3[tt & 255] ^ S3[tt >> 8 & 255] << 8 ^ S3[tt >> 16 & 255] << 16 ^ S3[tt >> 24 & 255] << 24;
            for (var i5 = KC / 2 + 1; i5 < KC; i5++) {
              tk[i5] ^= tk[i5 - 1];
            }
          }
          var i5 = 0, r6, c5;
          while (i5 < KC && t5 < roundKeyCount) {
            r6 = t5 >> 2;
            c5 = t5 % 4;
            this._Ke[r6][c5] = tk[i5];
            this._Kd[rounds - r6][c5] = tk[i5++];
            t5++;
          }
        }
        for (var r6 = 1; r6 < rounds; r6++) {
          for (var c5 = 0; c5 < 4; c5++) {
            tt = this._Kd[r6][c5];
            this._Kd[r6][c5] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a5 = [0, 0, 0, 0];
        var t5 = convertToInt32(plaintext);
        for (var i5 = 0; i5 < 4; i5++) {
          t5[i5] ^= this._Ke[0][i5];
        }
        for (var r6 = 1; r6 < rounds; r6++) {
          for (var i5 = 0; i5 < 4; i5++) {
            a5[i5] = T1[t5[i5] >> 24 & 255] ^ T22[t5[(i5 + 1) % 4] >> 16 & 255] ^ T32[t5[(i5 + 2) % 4] >> 8 & 255] ^ T42[t5[(i5 + 3) % 4] & 255] ^ this._Ke[r6][i5];
          }
          t5 = a5.slice();
        }
        var result = createArray(16), tt;
        for (var i5 = 0; i5 < 4; i5++) {
          tt = this._Ke[rounds][i5];
          result[4 * i5] = (S3[t5[i5] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i5 + 1] = (S3[t5[(i5 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i5 + 2] = (S3[t5[(i5 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i5 + 3] = (S3[t5[(i5 + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a5 = [0, 0, 0, 0];
        var t5 = convertToInt32(ciphertext);
        for (var i5 = 0; i5 < 4; i5++) {
          t5[i5] ^= this._Kd[0][i5];
        }
        for (var r6 = 1; r6 < rounds; r6++) {
          for (var i5 = 0; i5 < 4; i5++) {
            a5[i5] = T52[t5[i5] >> 24 & 255] ^ T6[t5[(i5 + 3) % 4] >> 16 & 255] ^ T7[t5[(i5 + 2) % 4] >> 8 & 255] ^ T8[t5[(i5 + 1) % 4] & 255] ^ this._Kd[r6][i5];
          }
          t5 = a5.slice();
        }
        var result = createArray(16), tt;
        for (var i5 = 0; i5 < 4; i5++) {
          tt = this._Kd[rounds][i5];
          result[4 * i5] = (Si[t5[i5] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i5 + 1] = (Si[t5[(i5 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i5 + 2] = (Si[t5[(i5 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i5 + 3] = (Si[t5[(i5 + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key2) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key2);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i5 = 0; i5 < plaintext.length; i5 += 16) {
          copyArray(plaintext, block, 0, i5, i5 + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i5);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i5 = 0; i5 < ciphertext.length; i5 += 16) {
          copyArray(ciphertext, block, 0, i5, i5 + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i5);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key2, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i5 = 0; i5 < plaintext.length; i5 += 16) {
          copyArray(plaintext, block, 0, i5, i5 + 16);
          for (var j5 = 0; j5 < 16; j5++) {
            block[j5] ^= this._lastCipherblock[j5];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i5);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i5 = 0; i5 < ciphertext.length; i5 += 16) {
          copyArray(ciphertext, block, 0, i5, i5 + 16);
          block = this._aes.decrypt(block);
          for (var j5 = 0; j5 < 16; j5++) {
            plaintext[i5 + j5] = block[j5] ^ this._lastCipherblock[j5];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i5, i5 + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key2, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i5 = 0; i5 < encrypted.length; i5 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j5 = 0; j5 < this.segmentSize; j5++) {
            encrypted[i5 + j5] ^= xorSegment[j5];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i5, i5 + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i5 = 0; i5 < plaintext.length; i5 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j5 = 0; j5 < this.segmentSize; j5++) {
            plaintext[i5 + j5] ^= xorSegment[j5];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i5, i5 + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key2, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i5 = 0; i5 < encrypted.length; i5++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i5] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i5 = 15; i5 >= 0; i5--) {
          if (this._counter[i5] === 255) {
            this._counter[i5] = 0;
          } else {
            this._counter[i5]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key2, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i5 = 0; i5 < encrypted.length; i5++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i5] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i5 = data.length; i5 < result.length; i5++) {
          result[i5] = padder;
        }
        return result;
      }
      function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length = data.length - padder;
        for (var i5 = 0; i5 < padder; i5++) {
          if (data[length + i5] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/scrypt-js/scrypt.js"(exports, module) {
    "use strict";
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA2562(m5) {
        const K3 = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h32 = 2773480762;
        let h42 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w6 = new Uint32Array(64);
        function blocks(p6) {
          let off = 0, len = p6.length;
          while (len >= 64) {
            let a5 = h0, b4 = h1, c5 = h22, d5 = h32, e5 = h42, f7 = h5, g5 = h6, h8 = h7, u5, i6, j5, t1, t22;
            for (i6 = 0; i6 < 16; i6++) {
              j5 = off + i6 * 4;
              w6[i6] = (p6[j5] & 255) << 24 | (p6[j5 + 1] & 255) << 16 | (p6[j5 + 2] & 255) << 8 | p6[j5 + 3] & 255;
            }
            for (i6 = 16; i6 < 64; i6++) {
              u5 = w6[i6 - 2];
              t1 = (u5 >>> 17 | u5 << 32 - 17) ^ (u5 >>> 19 | u5 << 32 - 19) ^ u5 >>> 10;
              u5 = w6[i6 - 15];
              t22 = (u5 >>> 7 | u5 << 32 - 7) ^ (u5 >>> 18 | u5 << 32 - 18) ^ u5 >>> 3;
              w6[i6] = (t1 + w6[i6 - 7] | 0) + (t22 + w6[i6 - 16] | 0) | 0;
            }
            for (i6 = 0; i6 < 64; i6++) {
              t1 = (((e5 >>> 6 | e5 << 32 - 6) ^ (e5 >>> 11 | e5 << 32 - 11) ^ (e5 >>> 25 | e5 << 32 - 25)) + (e5 & f7 ^ ~e5 & g5) | 0) + (h8 + (K3[i6] + w6[i6] | 0) | 0) | 0;
              t22 = ((a5 >>> 2 | a5 << 32 - 2) ^ (a5 >>> 13 | a5 << 32 - 13) ^ (a5 >>> 22 | a5 << 32 - 22)) + (a5 & b4 ^ a5 & c5 ^ b4 & c5) | 0;
              h8 = g5;
              g5 = f7;
              f7 = e5;
              e5 = d5 + t1 | 0;
              d5 = c5;
              c5 = b4;
              b4 = a5;
              a5 = t1 + t22 | 0;
            }
            h0 = h0 + a5 | 0;
            h1 = h1 + b4 | 0;
            h22 = h22 + c5 | 0;
            h32 = h32 + d5 | 0;
            h42 = h42 + e5 | 0;
            h5 = h5 + f7 | 0;
            h6 = h6 + g5 | 0;
            h7 = h7 + h8 | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m5);
        let i5, bytesLeft = m5.length % 64, bitLenHi = m5.length / 536870912 | 0, bitLenLo = m5.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p5 = m5.slice(m5.length - bytesLeft, m5.length);
        p5.push(128);
        for (i5 = bytesLeft + 1; i5 < numZeros; i5++) {
          p5.push(0);
        }
        p5.push(bitLenHi >>> 24 & 255);
        p5.push(bitLenHi >>> 16 & 255);
        p5.push(bitLenHi >>> 8 & 255);
        p5.push(bitLenHi >>> 0 & 255);
        p5.push(bitLenLo >>> 24 & 255);
        p5.push(bitLenLo >>> 16 & 255);
        p5.push(bitLenLo >>> 8 & 255);
        p5.push(bitLenLo >>> 0 & 255);
        blocks(p5);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h22 >>> 24 & 255,
          h22 >>> 16 & 255,
          h22 >>> 8 & 255,
          h22 >>> 0 & 255,
          h32 >>> 24 & 255,
          h32 >>> 16 & 255,
          h32 >>> 8 & 255,
          h32 >>> 0 & 255,
          h42 >>> 24 & 255,
          h42 >>> 16 & 255,
          h42 >>> 8 & 255,
          h42 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA2562(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i5;
        let dk = [];
        for (i5 = 0; i5 < 64; i5++) {
          inner[i5] = 54;
        }
        for (i5 = 0; i5 < password.length; i5++) {
          inner[i5] ^= password[i5];
        }
        for (i5 = 0; i5 < salt.length; i5++) {
          inner[64 + i5] = salt[i5];
        }
        for (i5 = innerLen - 4; i5 < innerLen; i5++) {
          inner[i5] = 0;
        }
        for (i5 = 0; i5 < 64; i5++)
          outerKey[i5] = 92;
        for (i5 = 0; i5 < password.length; i5++)
          outerKey[i5] ^= password[i5];
        function incrementCounter() {
          for (let i6 = innerLen - 1; i6 >= innerLen - 4; i6--) {
            inner[i6]++;
            if (inner[i6] <= 255)
              return;
            inner[i6] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi, r6, x5, _X) {
        let i5;
        arraycopy(BY, (2 * r6 - 1) * 16, _X, 0, 16);
        for (i5 = 0; i5 < 2 * r6; i5++) {
          blockxor(BY, i5 * 16, _X, 16);
          salsa20_8(_X, x5);
          arraycopy(_X, 0, BY, Yi + i5 * 16, 16);
        }
        for (i5 = 0; i5 < r6; i5++) {
          arraycopy(BY, Yi + i5 * 2 * 16, BY, i5 * 16, 16);
        }
        for (i5 = 0; i5 < r6; i5++) {
          arraycopy(BY, Yi + (i5 * 2 + 1) * 16, BY, (i5 + r6) * 16, 16);
        }
      }
      function R2(a5, b4) {
        return a5 << b4 | a5 >>> 32 - b4;
      }
      function salsa20_8(B3, x5) {
        arraycopy(B3, 0, x5, 0, 16);
        for (let i5 = 8; i5 > 0; i5 -= 2) {
          x5[4] ^= R2(x5[0] + x5[12], 7);
          x5[8] ^= R2(x5[4] + x5[0], 9);
          x5[12] ^= R2(x5[8] + x5[4], 13);
          x5[0] ^= R2(x5[12] + x5[8], 18);
          x5[9] ^= R2(x5[5] + x5[1], 7);
          x5[13] ^= R2(x5[9] + x5[5], 9);
          x5[1] ^= R2(x5[13] + x5[9], 13);
          x5[5] ^= R2(x5[1] + x5[13], 18);
          x5[14] ^= R2(x5[10] + x5[6], 7);
          x5[2] ^= R2(x5[14] + x5[10], 9);
          x5[6] ^= R2(x5[2] + x5[14], 13);
          x5[10] ^= R2(x5[6] + x5[2], 18);
          x5[3] ^= R2(x5[15] + x5[11], 7);
          x5[7] ^= R2(x5[3] + x5[15], 9);
          x5[11] ^= R2(x5[7] + x5[3], 13);
          x5[15] ^= R2(x5[11] + x5[7], 18);
          x5[1] ^= R2(x5[0] + x5[3], 7);
          x5[2] ^= R2(x5[1] + x5[0], 9);
          x5[3] ^= R2(x5[2] + x5[1], 13);
          x5[0] ^= R2(x5[3] + x5[2], 18);
          x5[6] ^= R2(x5[5] + x5[4], 7);
          x5[7] ^= R2(x5[6] + x5[5], 9);
          x5[4] ^= R2(x5[7] + x5[6], 13);
          x5[5] ^= R2(x5[4] + x5[7], 18);
          x5[11] ^= R2(x5[10] + x5[9], 7);
          x5[8] ^= R2(x5[11] + x5[10], 9);
          x5[9] ^= R2(x5[8] + x5[11], 13);
          x5[10] ^= R2(x5[9] + x5[8], 18);
          x5[12] ^= R2(x5[15] + x5[14], 7);
          x5[13] ^= R2(x5[12] + x5[15], 9);
          x5[14] ^= R2(x5[13] + x5[12], 13);
          x5[15] ^= R2(x5[14] + x5[13], 18);
        }
        for (let i5 = 0; i5 < 16; ++i5) {
          B3[i5] += x5[i5];
        }
      }
      function blockxor(S3, Si, D4, len) {
        for (let i5 = 0; i5 < len; i5++) {
          D4[i5] ^= S3[Si + i5];
        }
      }
      function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      function checkBufferish(o5) {
        if (!o5 || typeof o5.length !== "number") {
          return false;
        }
        for (let i5 = 0; i5 < o5.length; i5++) {
          const v8 = o5[i5];
          if (typeof v8 !== "number" || v8 % 1 || v8 < 0 || v8 >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value, name2) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name2);
        }
        return value;
      }
      function _scrypt(password, salt, N5, r6, p5, dkLen, callback) {
        N5 = ensureInteger(N5, "N");
        r6 = ensureInteger(r6, "r");
        p5 = ensureInteger(p5, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N5 === 0 || (N5 & N5 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N5 > MAX_VALUE / 128 / r6) {
          throw new Error("N too large");
        }
        if (r6 > MAX_VALUE / 128 / p5) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b4 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p5 * 128 * r6);
        const B3 = new Uint32Array(p5 * 32 * r6);
        for (let i5 = 0; i5 < B3.length; i5++) {
          const j5 = i5 * 4;
          B3[i5] = (b4[j5 + 3] & 255) << 24 | (b4[j5 + 2] & 255) << 16 | (b4[j5 + 1] & 255) << 8 | (b4[j5 + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r6);
        const V2 = new Uint32Array(32 * r6 * N5);
        const Yi = 32 * r6;
        const x5 = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p5 * N5 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        const limit = callback ? parseInt(1e3 / r6) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state) {
            case 0:
              Bi = i0 * 32 * r6;
              arraycopy(B3, Bi, XY, 0, Yi);
              state = 1;
              i1 = 0;
            case 1:
              steps = N5 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i5 = 0; i5 < steps; i5++) {
                arraycopy(XY, 0, V2, (i1 + i5) * Yi, Yi);
                blockmix_salsa8(XY, Yi, r6, x5, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N5) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps = N5 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i5 = 0; i5 < steps; i5++) {
                const offset2 = (2 * r6 - 1) * 16;
                const j5 = XY[offset2] & N5 - 1;
                blockxor(V2, j5 * Yi, XY, Yi);
                blockmix_salsa8(XY, Yi, r6, x5, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N5) {
                break;
              }
              arraycopy(XY, 0, B3, Bi, Yi);
              i0++;
              if (i0 < p5) {
                state = 0;
                break;
              }
              b4 = [];
              for (let i5 = 0; i5 < B3.length; i5++) {
                b4.push(B3[i5] >> 0 & 255);
                b4.push(B3[i5] >> 8 & 255);
                b4.push(B3[i5] >> 16 & 255);
                b4.push(B3[i5] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b4, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N5, r6, p5, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N5, r6, p5, dkLen, function(error, progress, key2) {
              if (error) {
                reject(error);
              } else if (key2) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key2));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N5, r6, p5, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N5, r6, p5, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports, module) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z4 = 0; z4 < ALPHABET.length; z4++) {
      x5 = ALPHABET.charAt(z4);
      if (ALPHABET_MAP[x5] !== void 0)
        throw new TypeError(x5 + " is ambiguous");
      ALPHABET_MAP[x5] = z4;
    }
    var x5;
    var z4;
    function polymodStep(pre) {
      var b4 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b4 >> 0 & 1) & 996825010 ^ -(b4 >> 1 & 1) & 642813549 ^ -(b4 >> 2 & 1) & 513874426 ^ -(b4 >> 3 & 1) & 1027748829 ^ -(b4 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i5 = 0; i5 < prefix.length; ++i5) {
        var c5 = prefix.charCodeAt(i5);
        if (c5 < 33 || c5 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c5 >> 5;
      }
      chk = polymodStep(chk);
      for (i5 = 0; i5 < prefix.length; ++i5) {
        var v8 = prefix.charCodeAt(i5);
        chk = polymodStep(chk) ^ v8 & 31;
      }
      return chk;
    }
    function encode5(prefix, words2, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words2.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i5 = 0; i5 < words2.length; ++i5) {
        var x6 = words2[i5];
        if (x6 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x6;
        result += ALPHABET.charAt(x6);
      }
      for (i5 = 0; i5 < 6; ++i5) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i5 = 0; i5 < 6; ++i5) {
        var v8 = chk >> (5 - i5) * 5 & 31;
        result += ALPHABET.charAt(v8);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words2 = [];
      for (var i5 = 0; i5 < wordChars.length; ++i5) {
        var c5 = wordChars.charAt(i5);
        var v8 = ALPHABET_MAP[c5];
        if (v8 === void 0)
          return "Unknown character " + c5;
        chk = polymodStep(chk) ^ v8;
        if (i5 + 6 >= wordChars.length)
          continue;
        words2.push(v8);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words: words2 };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode4(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad2) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i5 = 0; i5 < data.length; ++i5) {
        value = value << inBits | data[i5];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad2) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module.exports = {
      decodeUnsafe,
      decode: decode4,
      encode: encode5,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/penpal/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/penpal/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ERR_NOT_IN_IFRAME = exports.ERR_CONNECTION_TIMEOUT = exports.ERR_CONNECTION_DESTROYED = void 0;
    var HANDSHAKE = "handshake";
    var HANDSHAKE_REPLY = "handshake-reply";
    var CALL = "call";
    var REPLY = "reply";
    var FULFILLED = "fulfilled";
    var REJECTED = "rejected";
    var MESSAGE = "message";
    var DATA_CLONE_ERROR = "DataCloneError";
    var ERR_CONNECTION_DESTROYED = "ConnectionDestroyed";
    exports.ERR_CONNECTION_DESTROYED = ERR_CONNECTION_DESTROYED;
    var ERR_CONNECTION_TIMEOUT = "ConnectionTimeout";
    exports.ERR_CONNECTION_TIMEOUT = ERR_CONNECTION_TIMEOUT;
    var ERR_NOT_IN_IFRAME = "NotInIframe";
    exports.ERR_NOT_IN_IFRAME = ERR_NOT_IN_IFRAME;
    var DEFAULT_PORTS = {
      "http:": "80",
      "https:": "443"
    };
    var URL_REGEX = /^(https?:)?\/\/([^/:]+)(:(\d+))?/;
    var Penpal2 = {
      ERR_CONNECTION_DESTROYED,
      ERR_CONNECTION_TIMEOUT,
      ERR_NOT_IN_IFRAME,
      Promise: function() {
        try {
          return window ? window.Promise : null;
        } catch (e5) {
          return null;
        }
      }(),
      debug: false
    };
    var generateId = function() {
      var id2 = 0;
      return function() {
        return ++id2;
      };
    }();
    var log = function log2() {
      if (Penpal2.debug) {
        var _console;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_console = console).log.apply(_console, ["[Penpal]"].concat(args));
      }
    };
    var getOriginFromUrl = function getOriginFromUrl2(url) {
      var location2 = document.location;
      var regexResult = URL_REGEX.exec(url);
      var protocol;
      var hostname;
      var port;
      if (regexResult) {
        protocol = regexResult[1] ? regexResult[1] : location2.protocol;
        hostname = regexResult[2];
        port = regexResult[4];
      } else {
        protocol = location2.protocol;
        hostname = location2.hostname;
        port = location2.port;
      }
      var portSuffix = port && port !== DEFAULT_PORTS[protocol] ? ":".concat(port) : "";
      return "".concat(protocol, "//").concat(hostname).concat(portSuffix);
    };
    var DestructionPromise = function DestructionPromise2(executor) {
      var handlers = [];
      executor(function() {
        handlers.forEach(function(handler) {
          handler();
        });
      });
      return {
        then: function then(handler) {
          handlers.push(handler);
        }
      };
    };
    var serializeError = function serializeError2(_ref) {
      var name2 = _ref.name, message = _ref.message, stack = _ref.stack;
      return {
        name: name2,
        message,
        stack
      };
    };
    var deserializeError = function deserializeError2(obj) {
      var deserializedError = new Error();
      Object.keys(obj).forEach(function(key2) {
        return deserializedError[key2] = obj[key2];
      });
      return deserializedError;
    };
    var connectCallSender = function connectCallSender2(callSender, info, methodNames, destructionPromise) {
      var localName = info.localName, local = info.local, remote = info.remote, remoteOrigin = info.remoteOrigin;
      var destroyed = false;
      log("".concat(localName, ": Connecting call sender"));
      var createMethodProxy = function createMethodProxy2(methodName) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          log("".concat(localName, ": Sending ").concat(methodName, "() call"));
          if (destroyed) {
            var error = new Error("Unable to send ".concat(methodName, "() call due ") + "to destroyed connection");
            error.code = ERR_CONNECTION_DESTROYED;
            throw error;
          }
          return new Penpal2.Promise(function(resolve, reject) {
            var id2 = generateId();
            var handleMessageEvent = function handleMessageEvent2(event) {
              if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === REPLY && event.data.id === id2) {
                log("".concat(localName, ": Received ").concat(methodName, "() reply"));
                local.removeEventListener(MESSAGE, handleMessageEvent2);
                var returnValue = event.data.returnValue;
                if (event.data.returnValueIsError) {
                  returnValue = deserializeError(returnValue);
                }
                (event.data.resolution === FULFILLED ? resolve : reject)(returnValue);
              }
            };
            local.addEventListener(MESSAGE, handleMessageEvent);
            remote.postMessage({
              penpal: CALL,
              id: id2,
              methodName,
              args
            }, remoteOrigin);
          });
        };
      };
      destructionPromise.then(function() {
        destroyed = true;
      });
      methodNames.reduce(function(api, methodName) {
        api[methodName] = createMethodProxy(methodName);
        return api;
      }, callSender);
    };
    var connectCallReceiver = function connectCallReceiver2(info, methods, destructionPromise) {
      var localName = info.localName, local = info.local, remote = info.remote, remoteOrigin = info.remoteOrigin;
      var destroyed = false;
      log("".concat(localName, ": Connecting call receiver"));
      var handleMessageEvent = function handleMessageEvent2(event) {
        if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === CALL) {
          var _event$data = event.data, methodName = _event$data.methodName, args = _event$data.args, id2 = _event$data.id;
          log("".concat(localName, ": Received ").concat(methodName, "() call"));
          if (methodName in methods) {
            var createPromiseHandler = function createPromiseHandler2(resolution) {
              return function(returnValue) {
                log("".concat(localName, ": Sending ").concat(methodName, "() reply"));
                if (destroyed) {
                  log("".concat(localName, ": Unable to send ").concat(methodName, "() reply due to destroyed connection"));
                  return;
                }
                var message = {
                  penpal: REPLY,
                  id: id2,
                  resolution,
                  returnValue
                };
                if (resolution === REJECTED && returnValue instanceof Error) {
                  message.returnValue = serializeError(returnValue);
                  message.returnValueIsError = true;
                }
                try {
                  remote.postMessage(message, remoteOrigin);
                } catch (err) {
                  if (err.name === DATA_CLONE_ERROR) {
                    remote.postMessage({
                      penpal: REPLY,
                      id: id2,
                      resolution: REJECTED,
                      returnValue: serializeError(err),
                      returnValueIsError: true
                    }, remoteOrigin);
                  }
                  throw err;
                }
              };
            };
            new Penpal2.Promise(function(resolve) {
              return resolve(methods[methodName].apply(methods, args));
            }).then(createPromiseHandler(FULFILLED), createPromiseHandler(REJECTED));
          }
        }
      };
      local.addEventListener(MESSAGE, handleMessageEvent);
      destructionPromise.then(function() {
        destroyed = true;
        local.removeEventListener(MESSAGE, handleMessageEvent);
      });
    };
    Penpal2.connectToChild = function(_ref2) {
      var url = _ref2.url, appendTo = _ref2.appendTo, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, timeout2 = _ref2.timeout;
      var destroy;
      var connectionDestructionPromise = new DestructionPromise(function(resolveConnectionDestructionPromise) {
        destroy = resolveConnectionDestructionPromise;
      });
      var parent = window;
      var iframe = document.createElement("iframe");
      (appendTo || document.body).appendChild(iframe);
      connectionDestructionPromise.then(function() {
        if (iframe.parentNode) {
          iframe.parentNode.removeChild(iframe);
        }
      });
      var child = iframe.contentWindow || iframe.contentDocument.parentWindow;
      var childOrigin = getOriginFromUrl(url);
      var promise = new Penpal2.Promise(function(resolveConnectionPromise, reject) {
        var connectionTimeoutId;
        if (timeout2 !== void 0) {
          connectionTimeoutId = setTimeout(function() {
            var error = new Error("Connection to child timed out after ".concat(timeout2, "ms"));
            error.code = ERR_CONNECTION_TIMEOUT;
            reject(error);
            destroy();
          }, timeout2);
        }
        var callSender = {};
        var receiverMethodNames;
        var destroyCallReceiver;
        var handleMessage = function handleMessage2(event) {
          if (event.source === child && event.origin === childOrigin && event.data.penpal === HANDSHAKE) {
            log("Parent: Received handshake, sending reply");
            event.source.postMessage({
              penpal: HANDSHAKE_REPLY,
              methodNames: Object.keys(methods)
            }, event.origin);
            var info = {
              localName: "Parent",
              local: parent,
              remote: child,
              remoteOrigin: event.origin
            };
            if (destroyCallReceiver) {
              destroyCallReceiver();
            }
            var callReceiverDestructionPromise = new DestructionPromise(function(resolveCallReceiverDestructionPromise) {
              connectionDestructionPromise.then(resolveCallReceiverDestructionPromise);
              destroyCallReceiver = resolveCallReceiverDestructionPromise;
            });
            connectCallReceiver(info, methods, callReceiverDestructionPromise);
            if (receiverMethodNames) {
              receiverMethodNames.forEach(function(receiverMethodName) {
                delete callSender[receiverMethodName];
              });
            }
            receiverMethodNames = event.data.methodNames;
            connectCallSender(callSender, info, receiverMethodNames, connectionDestructionPromise);
            clearTimeout(connectionTimeoutId);
            resolveConnectionPromise(callSender);
          }
        };
        parent.addEventListener(MESSAGE, handleMessage);
        connectionDestructionPromise.then(function() {
          parent.removeEventListener(MESSAGE, handleMessage);
          var error = new Error("Connection destroyed");
          error.code = ERR_CONNECTION_DESTROYED;
          reject(error);
        });
        log("Parent: Loading iframe");
        iframe.src = url;
      });
      return {
        promise,
        iframe,
        destroy
      };
    };
    Penpal2.connectToParent = function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$parentOrigin = _ref3.parentOrigin, parentOrigin = _ref3$parentOrigin === void 0 ? "*" : _ref3$parentOrigin, _ref3$methods = _ref3.methods, methods = _ref3$methods === void 0 ? {} : _ref3$methods, timeout2 = _ref3.timeout;
      if (window === window.top) {
        var error = new Error("connectToParent() must be called within an iframe");
        error.code = ERR_NOT_IN_IFRAME;
        throw error;
      }
      var destroy;
      var connectionDestructionPromise = new DestructionPromise(function(resolveConnectionDestructionPromise) {
        destroy = resolveConnectionDestructionPromise;
      });
      var child = window;
      var parent = child.parent;
      var promise = new Penpal2.Promise(function(resolveConnectionPromise, reject) {
        var connectionTimeoutId;
        if (timeout2 !== void 0) {
          connectionTimeoutId = setTimeout(function() {
            var error2 = new Error("Connection to parent timed out after ".concat(timeout2, "ms"));
            error2.code = ERR_CONNECTION_TIMEOUT;
            reject(error2);
            destroy();
          }, timeout2);
        }
        var handleMessageEvent = function handleMessageEvent2(event) {
          if ((parentOrigin === "*" || parentOrigin === event.origin) && event.source === parent && event.data.penpal === HANDSHAKE_REPLY) {
            log("Child: Received handshake reply");
            child.removeEventListener(MESSAGE, handleMessageEvent2);
            var info = {
              localName: "Child",
              local: child,
              remote: parent,
              remoteOrigin: event.origin
            };
            var callSender = {};
            connectCallReceiver(info, methods, connectionDestructionPromise);
            connectCallSender(callSender, info, event.data.methodNames, connectionDestructionPromise);
            clearTimeout(connectionTimeoutId);
            resolveConnectionPromise(callSender);
          }
        };
        child.addEventListener(MESSAGE, handleMessageEvent);
        connectionDestructionPromise.then(function() {
          child.removeEventListener(MESSAGE, handleMessageEvent);
          var error2 = new Error("Connection destroyed");
          error2.code = ERR_CONNECTION_DESTROYED;
          reject(error2);
        });
        log("Child: Sending handshake");
        parent.postMessage({
          penpal: HANDSHAKE,
          methodNames: Object.keys(methods)
        }, parentOrigin);
      });
      return {
        promise,
        destroy
      };
    };
    var _default = Penpal2;
    exports.default = _default;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i5 = 0; i5 < boundLength; i5++) {
        boundArgs.push("$" + i5);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src2 = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e5) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e5) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x5) {
      return x5.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src2();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var first2 = $strSlice(string2, 0, 1);
      var last2 = $strSlice(string2, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string2, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i5 = 1, isOwn = true; i5 < parts.length; i5 += 1) {
        var part = parts[i5];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i5 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e5) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e5) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/foreach/index.js
var require_foreach = __commonJS({
  "node_modules/foreach/index.js"(exports, module) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString2 = Object.prototype.toString;
    module.exports = function forEach(obj, fn, ctx) {
      if (toString2.call(fn) !== "[object Function]") {
        throw new TypeError("iterator must be a function");
      }
      var l5 = obj.length;
      if (l5 === +l5) {
        for (var i5 = 0; i5 < l5; i5++) {
          fn.call(ctx, obj[i5], i5, obj);
        }
      } else {
        for (var k5 in obj) {
          if (hasOwn.call(obj, k5)) {
            fn.call(ctx, obj[k5], k5, obj);
          }
        }
      }
    };
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i5 = 0; i5 < possibleNames.length; i5++) {
        if (typeof g5[possibleNames[i5]] === "function") {
          out[out.length] = possibleNames[i5];
        }
      }
      return out;
    };
  }
});

// node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
var require_getOwnPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e5) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_foreach();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array2, value) {
      for (var i5 = 0; i5 < array2.length; i5 += 1) {
        if (array2[i5] === value) {
          return i5;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g5[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e5) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_foreach();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g5 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g5[typedArray] === "function") {
          var arr = new g5[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name2 = getter.call(value);
            if (name2 === typedArray) {
              foundName = name2;
            }
          } catch (e5) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray2 = require_is_typed_array();
    module.exports = function whichTypedArray(value) {
      if (!isTypedArray2(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray2 = require_is_typed_array();
    function uncurryThis(f7) {
      return f7.call.bind(f7);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e5) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray2;
    function isPromise2(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise2;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer2(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer2;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer2(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer2(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i5 = 0; i5 < keys.length; i5++) {
        descriptors[keys[i5]] = Object.getOwnPropertyDescriptor(obj, keys[i5]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f7) {
      if (!isString2(f7)) {
        var objects = [];
        for (var i5 = 0; i5 < arguments.length; i5++) {
          objects.push(inspect4(arguments[i5]));
        }
        return objects.join(" ");
      }
      var i5 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f7).replace(formatRegExp, function(x6) {
        if (x6 === "%%")
          return "%";
        if (i5 >= len)
          return x6;
        switch (x6) {
          case "%s":
            return String(args[i5++]);
          case "%d":
            return Number(args[i5++]);
          case "%j":
            try {
              return JSON.stringify(args[i5++]);
            } catch (_10) {
              return "[Circular]";
            }
          default:
            return x6;
        }
      });
      for (var x5 = args[i5]; i5 < len; x5 = args[++i5]) {
        if (isNull(x5) || !isObject4(x5)) {
          str += " " + x5;
        } else {
          str += " " + inspect4(x5);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect4(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect4;
    inspect4.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect4.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect4.styles[styleType];
      if (style) {
        return "[" + inspect4.colors[style][0] + "m" + str + "[" + inspect4.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array2) {
      var hash4 = {};
      array2.forEach(function(val, idx) {
        hash4[val] = true;
      });
      return hash4;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction2(value)) {
          var name2 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate2(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base2 = "", array2 = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array2 = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n3 = value.name ? ": " + value.name : "";
        base2 = " [Function" + n3 + "]";
      }
      if (isRegExp(value)) {
        base2 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate2(value)) {
        base2 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base2 = " " + formatError(value);
      }
      if (keys.length === 0 && (!array2 || value.length == 0)) {
        return braces[0] + base2 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array2) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key2) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array2);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base2, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i5 = 0, l5 = value.length; i5 < l5; ++i5) {
        if (hasOwnProperty(value, String(i5))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i5), true));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key2) {
        if (!key2.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key2, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array2) {
      var name2, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key2)) {
        name2 = "[" + key2 + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array2) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name2)) {
        if (array2 && key2.match(/^\d+$/)) {
          return str;
        }
        name2 = JSON.stringify("" + key2);
        if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name2 = name2.substr(1, name2.length - 2);
          name2 = ctx.stylize(name2, "name");
        } else {
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name2 = ctx.stylize(name2, "string");
        }
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString(output, base2, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject4(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject4(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject4;
    function isDate2(d5) {
      return isObject4(d5) && objectToString(d5) === "[object Date]";
    }
    exports.isDate = isDate2;
    exports.types.isDate = isDate2;
    function isError(e5) {
      return isObject4(e5) && (objectToString(e5) === "[object Error]" || e5 instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o5) {
      return Object.prototype.toString.call(o5);
    }
    function pad2(n3) {
      return n3 < 10 ? "0" + n3.toString(10) : n3.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp2() {
      var d5 = new Date();
      var time = [
        pad2(d5.getHours()),
        pad2(d5.getMinutes()),
        pad2(d5.getSeconds())
      ].join(":");
      return [d5.getDate(), months[d5.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp2(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add3) {
      if (!add3 || !isObject4(add3))
        return origin;
      var keys = Object.keys(add3);
      var i5 = keys.length;
      while (i5--) {
        origin[keys[i5]] = add3[keys[i5]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i5 = 0; i5 < arguments.length; i5++) {
          args.push(arguments[i5]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i5 = 0; i5 < arguments.length; i5++) {
          args.push(arguments[i5]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(function(ret) {
          process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5] != null ? arguments[i5] : {};
        if (i5 % 2) {
          ownKeys(Object(source), true).forEach(function(key2) {
            _defineProperty(target, key2, source[key2]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key2) {
            Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer3 = _require.Buffer;
    var _require2 = require_util();
    var inspect4 = _require2.inspect;
    var custom = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src, target, offset2) {
      Buffer3.prototype.copy.call(src, target, offset2);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v8) {
          var entry = {
            data: v8,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v8) {
          var entry = {
            data: v8,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s6) {
          if (this.length === 0)
            return "";
          var p5 = this.head;
          var ret = "" + p5.data;
          while (p5 = p5.next) {
            ret += s6 + p5.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat4(n3) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n3 >>> 0);
          var p5 = this.head;
          var i5 = 0;
          while (p5) {
            copyBuffer(p5.data, ret, i5);
            i5 += p5.data.length;
            p5 = p5.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n3, hasStrings) {
          var ret;
          if (n3 < this.head.data.length) {
            ret = this.head.data.slice(0, n3);
            this.head.data = this.head.data.slice(n3);
          } else if (n3 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n3) {
          var p5 = this.head;
          var c5 = 1;
          var ret = p5.data;
          n3 -= ret.length;
          while (p5 = p5.next) {
            var str = p5.data;
            var nb = n3 > str.length ? str.length : n3;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n3);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n3) {
          var ret = Buffer3.allocUnsafe(n3);
          var p5 = this.head;
          var c5 = 1;
          p5.data.copy(ret);
          n3 -= p5.data.length;
          while (p5 = p5.next) {
            var buf = p5.data;
            var nb = n3 > buf.length ? buf.length : n3;
            buf.copy(ret, ret.length - n3, 0, nb);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_10, options) {
          return inspect4(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i5) {
          return String(i5);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type2 = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config2(name2) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_10) {
        return false;
      }
      var val = global.localStorage[name2];
      if (val == null)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream2 = require_stream_browser();
    var Buffer3 = require_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_10) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding5, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding5 === "function") {
        cb = encoding5;
        encoding5 = null;
      }
      if (isBuf)
        encoding5 = "buffer";
      else if (!encoding5)
        encoding5 = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding5, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding5) {
      if (typeof encoding5 === "string")
        encoding5 = encoding5.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding5 + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding5);
      this._writableState.defaultEncoding = encoding5;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding5) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding5);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding5, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding5);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding5 = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding: encoding5,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding5, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding5, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding5, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(state) || stream.destroyed;
        if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished2, cb);
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l5 = state.bufferedRequestCount;
        var buffer2 = new Array(l5);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding5 = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding5, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding5, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding5, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding5 = null;
      } else if (typeof encoding5 === "function") {
        cb = encoding5;
        encoding5 = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding5);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key2 in obj) {
        keys2.push(key2);
      }
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v8 = 0; v8 < keys.length; v8++) {
        method = keys[v8];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v8;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding5) {
      encoding5 = "" + encoding5;
      switch (encoding5 && encoding5.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding5) {
      this.encoding = normalizeEncoding(encoding5);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r6;
      var i5;
      if (this.lastNeed) {
        r6 = this.fillLast(buf);
        if (r6 === void 0)
          return "";
        i5 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i5 = 0;
      }
      if (i5 < buf.length)
        return r6 ? r6 + this.text(buf, i5) : this.text(buf, i5);
      return r6 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i5) {
      var j5 = buf.length - 1;
      if (j5 < i5)
        return 0;
      var nb = utf8CheckByte(buf[j5]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j5 < i5 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j5]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j5 < i5 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j5]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p5) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p5 = this.lastTotal - this.lastNeed;
      var r6 = utf8CheckExtraBytes(this, buf, p5);
      if (r6 !== void 0)
        return r6;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p5, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p5, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i5) {
      var total = utf8CheckIncomplete(this, buf, i5);
      if (!this.lastNeed)
        return buf.toString("utf8", i5);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i5, end);
    }
    function utf8End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + "\uFFFD";
      return r6;
    }
    function utf16Text(buf, i5) {
      if ((buf.length - i5) % 2 === 0) {
        var r6 = buf.toString("utf16le", i5);
        if (r6) {
          var c5 = r6.charCodeAt(r6.length - 1);
          if (c5 >= 55296 && c5 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r6.slice(0, -1);
          }
        }
        return r6;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i5, buf.length - 1);
    }
    function utf16End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r6 + this.lastChar.toString("utf16le", 0, end);
      }
      return r6;
    }
    function base64Text(buf, i5) {
      var n3 = (buf.length - i5) % 3;
      if (n3 === 0)
        return buf.toString("base64", i5);
      this.lastNeed = 3 - n3;
      this.lastTotal = 3;
      if (n3 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i5, buf.length - n3);
    }
    function base64End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r6;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    var finished2 = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator2[kStream].read();
          if (data) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator2[kLastResolve] = resolve;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished2(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve = iterator2[kLastResolve];
        if (resolve !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = require_stream_browser();
    var Buffer3 = require_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from2;
    require_inherits_browser()(Readable, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding5) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding5 = encoding5 || state.defaultEncoding;
          if (encoding5 !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding5);
            encoding5 = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding5, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding5, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding5) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p5 = this._readableState.buffer.head;
      var content = "";
      while (p5 !== null) {
        content += decoder.write(p5.data);
        p5 = p5.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n3) {
      if (n3 >= MAX_HWM) {
        n3 = MAX_HWM;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead(n3, state) {
      if (n3 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n3 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n3);
      if (n3 <= state.length)
        return n3;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n3) {
      debug("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n3 = howMuchToRead(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n3 = 0;
      } else {
        state.length -= n3;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n3) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++) {
          dests[i5].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n3, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n3 || n3 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n3, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from2 === void 0) {
          from2 = require_from_browser();
        }
        return from2(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x5) {
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x5)
          return i5;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding5) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding5);
    };
    Transform.prototype._transform = function(chunk, encoding5, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding5, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding5;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding5, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from2, to) {
      return from2.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i5) {
        var reading = i5 < streams.length - 1;
        var writing = i5 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    module.exports = pipeline;
  }
});

// node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "node_modules/stream-browserify/index.js"(exports, module) {
    module.exports = Stream2;
    var EE = require_events().EventEmitter;
    var inherits2 = require_inherits_browser();
    inherits2(Stream2, EE);
    Stream2.Readable = require_stream_readable();
    Stream2.Writable = require_stream_writable();
    Stream2.Duplex = require_stream_duplex();
    Stream2.Transform = require_stream_transform();
    Stream2.PassThrough = require_stream_passthrough();
    Stream2.finished = require_end_of_stream();
    Stream2.pipeline = require_pipeline();
    Stream2.Stream = Stream2;
    function Stream2() {
      EE.call(this);
    }
    Stream2.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/keccak.js"(exports, module) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var inherits2 = require_inherits_browser();
    module.exports = function(KeccakState) {
      function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {
        Transform.call(this, options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      inherits2(Keccak, Transform);
      Keccak.prototype._transform = function(chunk, encoding5, callback) {
        var error = null;
        try {
          this.update(chunk, encoding5);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Keccak.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Keccak.prototype.update = function(data, encoding5) {
        if (!Buffer3.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer3.isBuffer(data))
          data = Buffer3.from(data, encoding5);
        this._state.absorb(data);
        return this;
      };
      Keccak.prototype.digest = function(encoding5) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        var digest9 = this._state.squeeze(this._hashBitLength / 8);
        if (encoding5 !== void 0)
          digest9 = digest9.toString(encoding5);
        this._resetState();
        return digest9;
      };
      Keccak.prototype._resetState = function() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      };
      Keccak.prototype._clone = function() {
        var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      };
      return Keccak;
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/shake.js"(exports, module) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var inherits2 = require_inherits_browser();
    module.exports = function(KeccakState) {
      function Shake(rate, capacity, delimitedSuffix, options) {
        Transform.call(this, options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      inherits2(Shake, Transform);
      Shake.prototype._transform = function(chunk, encoding5, callback) {
        var error = null;
        try {
          this.update(chunk, encoding5);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Shake.prototype._flush = function() {
      };
      Shake.prototype._read = function(size) {
        this.push(this.squeeze(size));
      };
      Shake.prototype.update = function(data, encoding5) {
        if (!Buffer3.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer3.isBuffer(data))
          data = Buffer3.from(data, encoding5);
        this._state.absorb(data);
        return this;
      };
      Shake.prototype.squeeze = function(dataByteLength, encoding5) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        var data = this._state.squeeze(dataByteLength);
        if (encoding5 !== void 0)
          data = data.toString(encoding5);
        return data;
      };
      Shake.prototype._resetState = function() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      };
      Shake.prototype._clone = function() {
        var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      };
      return Shake;
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/index.js"(exports, module) {
    "use strict";
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      var Keccak = createKeccak(KeccakState);
      var Shake = createShake(KeccakState);
      return function(algorithm, options) {
        var hash4 = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash4) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    "use strict";
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s6) {
      for (var round = 0; round < 24; ++round) {
        var lo0 = s6[0] ^ s6[10] ^ s6[20] ^ s6[30] ^ s6[40];
        var hi0 = s6[1] ^ s6[11] ^ s6[21] ^ s6[31] ^ s6[41];
        var lo1 = s6[2] ^ s6[12] ^ s6[22] ^ s6[32] ^ s6[42];
        var hi1 = s6[3] ^ s6[13] ^ s6[23] ^ s6[33] ^ s6[43];
        var lo2 = s6[4] ^ s6[14] ^ s6[24] ^ s6[34] ^ s6[44];
        var hi2 = s6[5] ^ s6[15] ^ s6[25] ^ s6[35] ^ s6[45];
        var lo3 = s6[6] ^ s6[16] ^ s6[26] ^ s6[36] ^ s6[46];
        var hi3 = s6[7] ^ s6[17] ^ s6[27] ^ s6[37] ^ s6[47];
        var lo4 = s6[8] ^ s6[18] ^ s6[28] ^ s6[38] ^ s6[48];
        var hi4 = s6[9] ^ s6[19] ^ s6[29] ^ s6[39] ^ s6[49];
        var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        var t1slo0 = s6[0] ^ lo;
        var t1shi0 = s6[1] ^ hi;
        var t1slo5 = s6[10] ^ lo;
        var t1shi5 = s6[11] ^ hi;
        var t1slo10 = s6[20] ^ lo;
        var t1shi10 = s6[21] ^ hi;
        var t1slo15 = s6[30] ^ lo;
        var t1shi15 = s6[31] ^ hi;
        var t1slo20 = s6[40] ^ lo;
        var t1shi20 = s6[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        var t1slo1 = s6[2] ^ lo;
        var t1shi1 = s6[3] ^ hi;
        var t1slo6 = s6[12] ^ lo;
        var t1shi6 = s6[13] ^ hi;
        var t1slo11 = s6[22] ^ lo;
        var t1shi11 = s6[23] ^ hi;
        var t1slo16 = s6[32] ^ lo;
        var t1shi16 = s6[33] ^ hi;
        var t1slo21 = s6[42] ^ lo;
        var t1shi21 = s6[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        var t1slo2 = s6[4] ^ lo;
        var t1shi2 = s6[5] ^ hi;
        var t1slo7 = s6[14] ^ lo;
        var t1shi7 = s6[15] ^ hi;
        var t1slo12 = s6[24] ^ lo;
        var t1shi12 = s6[25] ^ hi;
        var t1slo17 = s6[34] ^ lo;
        var t1shi17 = s6[35] ^ hi;
        var t1slo22 = s6[44] ^ lo;
        var t1shi22 = s6[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        var t1slo3 = s6[6] ^ lo;
        var t1shi3 = s6[7] ^ hi;
        var t1slo8 = s6[16] ^ lo;
        var t1shi8 = s6[17] ^ hi;
        var t1slo13 = s6[26] ^ lo;
        var t1shi13 = s6[27] ^ hi;
        var t1slo18 = s6[36] ^ lo;
        var t1shi18 = s6[37] ^ hi;
        var t1slo23 = s6[46] ^ lo;
        var t1shi23 = s6[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        var t1slo4 = s6[8] ^ lo;
        var t1shi4 = s6[9] ^ hi;
        var t1slo9 = s6[18] ^ lo;
        var t1shi9 = s6[19] ^ hi;
        var t1slo14 = s6[28] ^ lo;
        var t1shi14 = s6[29] ^ hi;
        var t1slo19 = s6[38] ^ lo;
        var t1shi19 = s6[39] ^ hi;
        var t1slo24 = s6[48] ^ lo;
        var t1shi24 = s6[49] ^ hi;
        var t2slo0 = t1slo0;
        var t2shi0 = t1shi0;
        var t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        var t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        var t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        var t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        var t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        var t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        var t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        var t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        var t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        var t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        var t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        var t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        var t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        var t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        var t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        var t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        var t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        var t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        var t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        var t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        var t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        var t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        var t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        var t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        var t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        var t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        var t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        var t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        var t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        var t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        var t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        var t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        var t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        var t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        var t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        var t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        var t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        var t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        var t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        var t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        var t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        var t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        var t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        var t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        var t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        var t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        var t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        var t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s6[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s6[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s6[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s6[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s6[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s6[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s6[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s6[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s6[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s6[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s6[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s6[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s6[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s6[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s6[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s6[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s6[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s6[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s6[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s6[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s6[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s6[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s6[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s6[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s6[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s6[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s6[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s6[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s6[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s6[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s6[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s6[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s6[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s6[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s6[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s6[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s6[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s6[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s6[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s6[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s6[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s6[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s6[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s6[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s6[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s6[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s6[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s6[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s6[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s6[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s6[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s6[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/keccak.js"(exports, module) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (var i5 = 0; i5 < 50; ++i5)
        this.state[i5] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (var i5 = 0; i5 < data.length; ++i5) {
        this.state[~~(this.count / 4)] ^= data[i5] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      var output = Buffer3.alloc(length);
      for (var i5 = 0; i5 < length; ++i5) {
        output[i5] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (var i5 = 0; i5 < 50; ++i5)
        dest.state[i5] = this.state[i5];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/@portis/web3/node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/js.js"(exports, module) {
    "use strict";
    module.exports = require_api()(require_keccak2());
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/assert.js
var require_assert = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/assert.js"(exports) {
    "use strict";
    var toString2 = Object.prototype.toString;
    exports.isArray = function(value, message) {
      if (!Array.isArray(value))
        throw TypeError(message);
    };
    exports.isBoolean = function(value, message) {
      if (toString2.call(value) !== "[object Boolean]")
        throw TypeError(message);
    };
    exports.isBuffer = function(value, message) {
      if (!Buffer.isBuffer(value))
        throw TypeError(message);
    };
    exports.isFunction = function(value, message) {
      if (toString2.call(value) !== "[object Function]")
        throw TypeError(message);
    };
    exports.isNumber = function(value, message) {
      if (toString2.call(value) !== "[object Number]")
        throw TypeError(message);
    };
    exports.isObject = function(value, message) {
      if (toString2.call(value) !== "[object Object]")
        throw TypeError(message);
    };
    exports.isBufferLength = function(buffer2, length, message) {
      if (buffer2.length !== length)
        throw RangeError(message);
    };
    exports.isBufferLength2 = function(buffer2, length1, length2, message) {
      if (buffer2.length !== length1 && buffer2.length !== length2)
        throw RangeError(message);
    };
    exports.isLengthGTZero = function(value, message) {
      if (value.length === 0)
        throw RangeError(message);
    };
    exports.isNumberInInterval = function(number2, x5, y5, message) {
      if (number2 <= x5 || number2 >= y5)
        throw RangeError(message);
    };
  }
});

// node_modules/bip66/index.js
var require_bip66 = __commonJS({
  "node_modules/bip66/index.js"(exports, module) {
    var Buffer3 = require_safe_buffer().Buffer;
    function check(buffer2) {
      if (buffer2.length < 8)
        return false;
      if (buffer2.length > 72)
        return false;
      if (buffer2[0] !== 48)
        return false;
      if (buffer2[1] !== buffer2.length - 2)
        return false;
      if (buffer2[2] !== 2)
        return false;
      var lenR = buffer2[3];
      if (lenR === 0)
        return false;
      if (5 + lenR >= buffer2.length)
        return false;
      if (buffer2[4 + lenR] !== 2)
        return false;
      var lenS = buffer2[5 + lenR];
      if (lenS === 0)
        return false;
      if (6 + lenR + lenS !== buffer2.length)
        return false;
      if (buffer2[4] & 128)
        return false;
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
        return false;
      if (buffer2[lenR + 6] & 128)
        return false;
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        return false;
      return true;
    }
    function decode4(buffer2) {
      if (buffer2.length < 8)
        throw new Error("DER sequence length is too short");
      if (buffer2.length > 72)
        throw new Error("DER sequence length is too long");
      if (buffer2[0] !== 48)
        throw new Error("Expected DER sequence");
      if (buffer2[1] !== buffer2.length - 2)
        throw new Error("DER sequence length is invalid");
      if (buffer2[2] !== 2)
        throw new Error("Expected DER integer");
      var lenR = buffer2[3];
      if (lenR === 0)
        throw new Error("R length is zero");
      if (5 + lenR >= buffer2.length)
        throw new Error("R length is too long");
      if (buffer2[4 + lenR] !== 2)
        throw new Error("Expected DER integer (2)");
      var lenS = buffer2[5 + lenR];
      if (lenS === 0)
        throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer2.length)
        throw new Error("S length is invalid");
      if (buffer2[4] & 128)
        throw new Error("R value is negative");
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
        throw new Error("R value excessively padded");
      if (buffer2[lenR + 6] & 128)
        throw new Error("S value is negative");
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        throw new Error("S value excessively padded");
      return {
        r: buffer2.slice(4, 4 + lenR),
        s: buffer2.slice(6 + lenR)
      };
    }
    function encode5(r6, s6) {
      var lenR = r6.length;
      var lenS = s6.length;
      if (lenR === 0)
        throw new Error("R length is zero");
      if (lenS === 0)
        throw new Error("S length is zero");
      if (lenR > 33)
        throw new Error("R length is too long");
      if (lenS > 33)
        throw new Error("S length is too long");
      if (r6[0] & 128)
        throw new Error("R value is negative");
      if (s6[0] & 128)
        throw new Error("S value is negative");
      if (lenR > 1 && r6[0] === 0 && !(r6[1] & 128))
        throw new Error("R value excessively padded");
      if (lenS > 1 && s6[0] === 0 && !(s6[1] & 128))
        throw new Error("S value excessively padded");
      var signature2 = Buffer3.allocUnsafe(6 + lenR + lenS);
      signature2[0] = 48;
      signature2[1] = signature2.length - 2;
      signature2[2] = 2;
      signature2[3] = r6.length;
      r6.copy(signature2, 4);
      signature2[4 + lenR] = 2;
      signature2[5 + lenR] = s6.length;
      s6.copy(signature2, 6 + lenR);
      return signature2;
    }
    module.exports = {
      check,
      decode: decode4,
      encode: encode5
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/der.js
var require_der = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/der.js"(exports) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var bip66 = require_bip66();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer3.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer3.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey2, compressed) {
      var result = Buffer3.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey2.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return;
      if (length < index + lenb)
        return;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureExport = function(sigObj) {
      var r6 = Buffer3.concat([Buffer3.from([0]), sigObj.r]);
      for (var lenR = 33, posR = 0; lenR > 1 && r6[posR] === 0 && !(r6[posR + 1] & 128); --lenR, ++posR)
        ;
      var s6 = Buffer3.concat([Buffer3.from([0]), sigObj.s]);
      for (var lenS = 33, posS = 0; lenS > 1 && s6[posS] === 0 && !(s6[posS + 1] & 128); --lenS, ++posS)
        ;
      return bip66.encode(r6.slice(posR), s6.slice(posS));
    };
    exports.signatureImport = function(sig) {
      var r6 = Buffer3.alloc(32, 0);
      var s6 = Buffer3.alloc(32, 0);
      try {
        var sigObj = bip66.decode(sig);
        if (sigObj.r.length === 33 && sigObj.r[0] === 0)
          sigObj.r = sigObj.r.slice(1);
        if (sigObj.r.length > 32)
          throw new Error("R length is too long");
        if (sigObj.s.length === 33 && sigObj.s[0] === 0)
          sigObj.s = sigObj.s.slice(1);
        if (sigObj.s.length > 32)
          throw new Error("S length is too long");
      } catch (err) {
        return;
      }
      sigObj.r.copy(r6, 32 - sigObj.r.length);
      sigObj.s.copy(s6, 32 - sigObj.s.length);
      return { r: r6, s: s6 };
    };
    exports.signatureImportLax = function(sig) {
      var r6 = Buffer3.alloc(32, 0);
      var s6 = Buffer3.alloc(32, 0);
      var length = sig.length;
      var index = 0;
      if (sig[index++] !== 48)
        return;
      var lenbyte = sig[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length)
          return;
      }
      if (sig[index++] !== 2)
        return;
      var rlen = sig[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length)
          return;
        for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          rlen = (rlen << 8) + sig[index];
      }
      if (rlen > length - index)
        return;
      var rindex = index;
      index += rlen;
      if (sig[index++] !== 2)
        return;
      var slen = sig[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length)
          return;
        for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          slen = (slen << 8) + sig[index];
      }
      if (slen > length - index)
        return;
      var sindex = index;
      index += slen;
      for (; rlen > 0 && sig[rindex] === 0; rlen -= 1, rindex += 1)
        ;
      if (rlen > 32)
        return;
      var rvalue = sig.slice(rindex, rindex + rlen);
      rvalue.copy(r6, 32 - rvalue.length);
      for (; slen > 0 && sig[sindex] === 0; slen -= 1, sindex += 1)
        ;
      if (slen > 32)
        return;
      var svalue = sig.slice(sindex, sindex + slen);
      svalue.copy(s6, 32 - svalue.length);
      return { r: r6, s: s6 };
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/messages.json
var require_messages2 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/messages.json"(exports, module) {
    module.exports = {
      COMPRESSED_TYPE_INVALID: "compressed should be a boolean",
      EC_PRIVATE_KEY_TYPE_INVALID: "private key should be a Buffer",
      EC_PRIVATE_KEY_LENGTH_INVALID: "private key length is invalid",
      EC_PRIVATE_KEY_RANGE_INVALID: "private key range is invalid",
      EC_PRIVATE_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting private key is invalid",
      EC_PRIVATE_KEY_TWEAK_MUL_FAIL: "tweak out of range",
      EC_PRIVATE_KEY_EXPORT_DER_FAIL: "couldn't export to DER format",
      EC_PRIVATE_KEY_IMPORT_DER_FAIL: "couldn't import from DER format",
      EC_PUBLIC_KEYS_TYPE_INVALID: "public keys should be an Array",
      EC_PUBLIC_KEYS_LENGTH_INVALID: "public keys Array should have at least 1 element",
      EC_PUBLIC_KEY_TYPE_INVALID: "public key should be a Buffer",
      EC_PUBLIC_KEY_LENGTH_INVALID: "public key length is invalid",
      EC_PUBLIC_KEY_PARSE_FAIL: "the public key could not be parsed or is invalid",
      EC_PUBLIC_KEY_CREATE_FAIL: "private was invalid, try again",
      EC_PUBLIC_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting public key is invalid",
      EC_PUBLIC_KEY_TWEAK_MUL_FAIL: "tweak out of range",
      EC_PUBLIC_KEY_COMBINE_FAIL: "the sum of the public keys is not valid",
      ECDH_FAIL: "scalar was invalid (zero or overflow)",
      ECDSA_SIGNATURE_TYPE_INVALID: "signature should be a Buffer",
      ECDSA_SIGNATURE_LENGTH_INVALID: "signature length is invalid",
      ECDSA_SIGNATURE_PARSE_FAIL: "couldn't parse signature",
      ECDSA_SIGNATURE_PARSE_DER_FAIL: "couldn't parse DER signature",
      ECDSA_SIGNATURE_SERIALIZE_DER_FAIL: "couldn't serialize signature to DER format",
      ECDSA_SIGN_FAIL: "nonce generation function failed or private key is invalid",
      ECDSA_RECOVER_FAIL: "couldn't recover public key from signature",
      MSG32_TYPE_INVALID: "message should be a Buffer",
      MSG32_LENGTH_INVALID: "message length is invalid",
      OPTIONS_TYPE_INVALID: "options should be an Object",
      OPTIONS_DATA_TYPE_INVALID: "options.data should be a Buffer",
      OPTIONS_DATA_LENGTH_INVALID: "options.data length is invalid",
      OPTIONS_NONCEFN_TYPE_INVALID: "options.noncefn should be a Function",
      RECOVERY_ID_TYPE_INVALID: "recovery should be a Number",
      RECOVERY_ID_VALUE_INVALID: "recovery should have value between -1 and 4",
      TWEAK_TYPE_INVALID: "tweak should be a Buffer",
      TWEAK_LENGTH_INVALID: "tweak length is invalid"
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/index.js"(exports, module) {
    "use strict";
    var assert5 = require_assert();
    var der = require_der();
    var messages = require_messages2();
    function initCompressedValue(value, defaultValue) {
      if (value === void 0)
        return defaultValue;
      assert5.isBoolean(value, messages.COMPRESSED_TYPE_INVALID);
      return value;
    }
    module.exports = function(secp256k12) {
      return {
        privateKeyVerify: function(privateKey) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          return privateKey.length === 32 && secp256k12.privateKeyVerify(privateKey);
        },
        privateKeyExport: function(privateKey, compressed) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          var publicKey2 = secp256k12.privateKeyExport(privateKey, compressed);
          return der.privateKeyExport(privateKey, publicKey2, compressed);
        },
        privateKeyImport: function(privateKey) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          privateKey = der.privateKeyImport(privateKey);
          if (privateKey && privateKey.length === 32 && secp256k12.privateKeyVerify(privateKey))
            return privateKey;
          throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL);
        },
        privateKeyNegate: function(privateKey) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k12.privateKeyNegate(privateKey);
        },
        privateKeyModInverse: function(privateKey) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k12.privateKeyModInverse(privateKey);
        },
        privateKeyTweakAdd: function(privateKey, tweak) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          assert5.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert5.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          return secp256k12.privateKeyTweakAdd(privateKey, tweak);
        },
        privateKeyTweakMul: function(privateKey, tweak) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          assert5.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert5.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          return secp256k12.privateKeyTweakMul(privateKey, tweak);
        },
        publicKeyCreate: function(privateKey, compressed) {
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k12.publicKeyCreate(privateKey, compressed);
        },
        publicKeyConvert: function(publicKey2, compressed) {
          assert5.isBuffer(publicKey2, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert5.isBufferLength2(publicKey2, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k12.publicKeyConvert(publicKey2, compressed);
        },
        publicKeyVerify: function(publicKey2) {
          assert5.isBuffer(publicKey2, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          return secp256k12.publicKeyVerify(publicKey2);
        },
        publicKeyTweakAdd: function(publicKey2, tweak, compressed) {
          assert5.isBuffer(publicKey2, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert5.isBufferLength2(publicKey2, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert5.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert5.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k12.publicKeyTweakAdd(publicKey2, tweak, compressed);
        },
        publicKeyTweakMul: function(publicKey2, tweak, compressed) {
          assert5.isBuffer(publicKey2, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert5.isBufferLength2(publicKey2, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert5.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert5.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k12.publicKeyTweakMul(publicKey2, tweak, compressed);
        },
        publicKeyCombine: function(publicKeys, compressed) {
          assert5.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID);
          assert5.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID);
          for (var i5 = 0; i5 < publicKeys.length; ++i5) {
            assert5.isBuffer(publicKeys[i5], messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert5.isBufferLength2(publicKeys[i5], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          }
          compressed = initCompressedValue(compressed, true);
          return secp256k12.publicKeyCombine(publicKeys, compressed);
        },
        signatureNormalize: function(signature2) {
          assert5.isBuffer(signature2, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert5.isBufferLength(signature2, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          return secp256k12.signatureNormalize(signature2);
        },
        signatureExport: function(signature2) {
          assert5.isBuffer(signature2, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert5.isBufferLength(signature2, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = secp256k12.signatureExport(signature2);
          return der.signatureExport(sigObj);
        },
        signatureImport: function(sig) {
          assert5.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert5.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = der.signatureImport(sig);
          if (sigObj)
            return secp256k12.signatureImport(sigObj);
          throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
        },
        signatureImportLax: function(sig) {
          assert5.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert5.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = der.signatureImportLax(sig);
          if (sigObj)
            return secp256k12.signatureImport(sigObj);
          throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
        },
        sign: function(message, privateKey, options) {
          assert5.isBuffer(message, messages.MSG32_TYPE_INVALID);
          assert5.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          var data = null;
          var noncefn = null;
          if (options !== void 0) {
            assert5.isObject(options, messages.OPTIONS_TYPE_INVALID);
            if (options.data !== void 0) {
              assert5.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID);
              assert5.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID);
              data = options.data;
            }
            if (options.noncefn !== void 0) {
              assert5.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID);
              noncefn = options.noncefn;
            }
          }
          return secp256k12.sign(message, privateKey, noncefn, data);
        },
        verify: function(message, signature2, publicKey2) {
          assert5.isBuffer(message, messages.MSG32_TYPE_INVALID);
          assert5.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
          assert5.isBuffer(signature2, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert5.isBufferLength(signature2, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          assert5.isBuffer(publicKey2, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert5.isBufferLength2(publicKey2, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          return secp256k12.verify(message, signature2, publicKey2);
        },
        recover: function(message, signature2, recovery, compressed) {
          assert5.isBuffer(message, messages.MSG32_TYPE_INVALID);
          assert5.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
          assert5.isBuffer(signature2, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert5.isBufferLength(signature2, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          assert5.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID);
          assert5.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k12.recover(message, signature2, recovery, compressed);
        },
        ecdh: function(publicKey2, privateKey) {
          assert5.isBuffer(publicKey2, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert5.isBufferLength2(publicKey2, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k12.ecdh(publicKey2, privateKey);
        },
        ecdhUnsafe: function(publicKey2, privateKey, compressed) {
          assert5.isBuffer(publicKey2, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert5.isBufferLength2(publicKey2, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert5.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert5.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k12.ecdhUnsafe(publicKey2, privateKey, compressed);
        }
      };
    };
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports, module) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform = require_readable_browser().Transform;
    var inherits2 = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer3.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer3.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits2(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding5, callback) {
      var error = null;
      try {
        this.update(chunk, encoding5);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding5) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer3.isBuffer(data))
        data = Buffer3.from(data, encoding5);
      var block = this._block;
      var offset2 = 0;
      while (this._blockOffset + data.length - offset2 >= this._blockSize) {
        for (var i5 = this._blockOffset; i5 < this._blockSize; )
          block[i5++] = data[offset2++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset2 < data.length)
        block[this._blockOffset++] = data[offset2++];
      for (var j5 = 0, carry = data.length * 8; carry > 0; ++j5) {
        this._length[j5] += carry;
        carry = this._length[j5] / 4294967296 | 0;
        if (carry > 0)
          this._length[j5] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding5) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest9 = this._digest();
      if (encoding5 !== void 0)
        digest9 = digest9.toString(encoding5);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i5 = 0; i5 < 4; ++i5)
        this._length[i5] = 0;
      return digest9;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports, module) {
    "use strict";
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer3 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits2(MD5, HashBase);
    MD5.prototype._update = function() {
      var M4 = ARRAY16;
      for (var i5 = 0; i5 < 16; ++i5)
        M4[i5] = this._block.readInt32LE(i5 * 4);
      var a5 = this._a;
      var b4 = this._b;
      var c5 = this._c;
      var d5 = this._d;
      a5 = fnF(a5, b4, c5, d5, M4[0], 3614090360, 7);
      d5 = fnF(d5, a5, b4, c5, M4[1], 3905402710, 12);
      c5 = fnF(c5, d5, a5, b4, M4[2], 606105819, 17);
      b4 = fnF(b4, c5, d5, a5, M4[3], 3250441966, 22);
      a5 = fnF(a5, b4, c5, d5, M4[4], 4118548399, 7);
      d5 = fnF(d5, a5, b4, c5, M4[5], 1200080426, 12);
      c5 = fnF(c5, d5, a5, b4, M4[6], 2821735955, 17);
      b4 = fnF(b4, c5, d5, a5, M4[7], 4249261313, 22);
      a5 = fnF(a5, b4, c5, d5, M4[8], 1770035416, 7);
      d5 = fnF(d5, a5, b4, c5, M4[9], 2336552879, 12);
      c5 = fnF(c5, d5, a5, b4, M4[10], 4294925233, 17);
      b4 = fnF(b4, c5, d5, a5, M4[11], 2304563134, 22);
      a5 = fnF(a5, b4, c5, d5, M4[12], 1804603682, 7);
      d5 = fnF(d5, a5, b4, c5, M4[13], 4254626195, 12);
      c5 = fnF(c5, d5, a5, b4, M4[14], 2792965006, 17);
      b4 = fnF(b4, c5, d5, a5, M4[15], 1236535329, 22);
      a5 = fnG(a5, b4, c5, d5, M4[1], 4129170786, 5);
      d5 = fnG(d5, a5, b4, c5, M4[6], 3225465664, 9);
      c5 = fnG(c5, d5, a5, b4, M4[11], 643717713, 14);
      b4 = fnG(b4, c5, d5, a5, M4[0], 3921069994, 20);
      a5 = fnG(a5, b4, c5, d5, M4[5], 3593408605, 5);
      d5 = fnG(d5, a5, b4, c5, M4[10], 38016083, 9);
      c5 = fnG(c5, d5, a5, b4, M4[15], 3634488961, 14);
      b4 = fnG(b4, c5, d5, a5, M4[4], 3889429448, 20);
      a5 = fnG(a5, b4, c5, d5, M4[9], 568446438, 5);
      d5 = fnG(d5, a5, b4, c5, M4[14], 3275163606, 9);
      c5 = fnG(c5, d5, a5, b4, M4[3], 4107603335, 14);
      b4 = fnG(b4, c5, d5, a5, M4[8], 1163531501, 20);
      a5 = fnG(a5, b4, c5, d5, M4[13], 2850285829, 5);
      d5 = fnG(d5, a5, b4, c5, M4[2], 4243563512, 9);
      c5 = fnG(c5, d5, a5, b4, M4[7], 1735328473, 14);
      b4 = fnG(b4, c5, d5, a5, M4[12], 2368359562, 20);
      a5 = fnH(a5, b4, c5, d5, M4[5], 4294588738, 4);
      d5 = fnH(d5, a5, b4, c5, M4[8], 2272392833, 11);
      c5 = fnH(c5, d5, a5, b4, M4[11], 1839030562, 16);
      b4 = fnH(b4, c5, d5, a5, M4[14], 4259657740, 23);
      a5 = fnH(a5, b4, c5, d5, M4[1], 2763975236, 4);
      d5 = fnH(d5, a5, b4, c5, M4[4], 1272893353, 11);
      c5 = fnH(c5, d5, a5, b4, M4[7], 4139469664, 16);
      b4 = fnH(b4, c5, d5, a5, M4[10], 3200236656, 23);
      a5 = fnH(a5, b4, c5, d5, M4[13], 681279174, 4);
      d5 = fnH(d5, a5, b4, c5, M4[0], 3936430074, 11);
      c5 = fnH(c5, d5, a5, b4, M4[3], 3572445317, 16);
      b4 = fnH(b4, c5, d5, a5, M4[6], 76029189, 23);
      a5 = fnH(a5, b4, c5, d5, M4[9], 3654602809, 4);
      d5 = fnH(d5, a5, b4, c5, M4[12], 3873151461, 11);
      c5 = fnH(c5, d5, a5, b4, M4[15], 530742520, 16);
      b4 = fnH(b4, c5, d5, a5, M4[2], 3299628645, 23);
      a5 = fnI(a5, b4, c5, d5, M4[0], 4096336452, 6);
      d5 = fnI(d5, a5, b4, c5, M4[7], 1126891415, 10);
      c5 = fnI(c5, d5, a5, b4, M4[14], 2878612391, 15);
      b4 = fnI(b4, c5, d5, a5, M4[5], 4237533241, 21);
      a5 = fnI(a5, b4, c5, d5, M4[12], 1700485571, 6);
      d5 = fnI(d5, a5, b4, c5, M4[3], 2399980690, 10);
      c5 = fnI(c5, d5, a5, b4, M4[10], 4293915773, 15);
      b4 = fnI(b4, c5, d5, a5, M4[1], 2240044497, 21);
      a5 = fnI(a5, b4, c5, d5, M4[8], 1873313359, 6);
      d5 = fnI(d5, a5, b4, c5, M4[15], 4264355552, 10);
      c5 = fnI(c5, d5, a5, b4, M4[6], 2734768916, 15);
      b4 = fnI(b4, c5, d5, a5, M4[13], 1309151649, 21);
      a5 = fnI(a5, b4, c5, d5, M4[4], 4149444226, 6);
      d5 = fnI(d5, a5, b4, c5, M4[11], 3174756917, 10);
      c5 = fnI(c5, d5, a5, b4, M4[2], 718787259, 15);
      b4 = fnI(b4, c5, d5, a5, M4[9], 3951481745, 21);
      this._a = this._a + a5 | 0;
      this._b = this._b + b4 | 0;
      this._c = this._c + c5 | 0;
      this._d = this._d + d5 | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer3.allocUnsafe(16);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      return buffer2;
    };
    function rotl(x5, n3) {
      return x5 << n3 | x5 >>> 32 - n3;
    }
    function fnF(a5, b4, c5, d5, m5, k5, s6) {
      return rotl(a5 + (b4 & c5 | ~b4 & d5) + m5 + k5 | 0, s6) + b4 | 0;
    }
    function fnG(a5, b4, c5, d5, m5, k5, s6) {
      return rotl(a5 + (b4 & d5 | c5 & ~d5) + m5 + k5 | 0, s6) + b4 | 0;
    }
    function fnH(a5, b4, c5, d5, m5, k5, s6) {
      return rotl(a5 + (b4 ^ c5 ^ d5) + m5 + k5 | 0, s6) + b4 | 0;
    }
    function fnI(a5, b4, c5, d5, m5, k5, s6) {
      return rotl(a5 + (c5 ^ (b4 | ~d5)) + m5 + k5 | 0, s6) + b4 | 0;
    }
    module.exports = MD5;
  }
});

// node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/ripemd160/index.js"(exports, module) {
    "use strict";
    var Buffer3 = require_buffer().Buffer;
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD1602() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits2(RIPEMD1602, HashBase);
    RIPEMD1602.prototype._update = function() {
      var words2 = ARRAY16;
      for (var j5 = 0; j5 < 16; ++j5)
        words2[j5] = this._block.readInt32LE(j5 * 4);
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;
      for (var i5 = 0; i5 < 80; i5 += 1) {
        var tl;
        var tr;
        if (i5 < 16) {
          tl = fn1(al, bl, cl, dl, el, words2[zl[i5]], hl[0], sl[i5]);
          tr = fn5(ar, br, cr, dr, er, words2[zr[i5]], hr[0], sr[i5]);
        } else if (i5 < 32) {
          tl = fn2(al, bl, cl, dl, el, words2[zl[i5]], hl[1], sl[i5]);
          tr = fn4(ar, br, cr, dr, er, words2[zr[i5]], hr[1], sr[i5]);
        } else if (i5 < 48) {
          tl = fn3(al, bl, cl, dl, el, words2[zl[i5]], hl[2], sl[i5]);
          tr = fn3(ar, br, cr, dr, er, words2[zr[i5]], hr[2], sr[i5]);
        } else if (i5 < 64) {
          tl = fn4(al, bl, cl, dl, el, words2[zl[i5]], hl[3], sl[i5]);
          tr = fn2(ar, br, cr, dr, er, words2[zr[i5]], hr[3], sr[i5]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words2[zl[i5]], hl[4], sl[i5]);
          tr = fn1(ar, br, cr, dr, er, words2[zr[i5]], hr[4], sr[i5]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = tr;
      }
      var t5 = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t5;
    };
    RIPEMD1602.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer3.alloc ? Buffer3.alloc(20) : new Buffer3(20);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      buffer2.writeInt32LE(this._e, 16);
      return buffer2;
    };
    function rotl(x5, n3) {
      return x5 << n3 | x5 >>> 32 - n3;
    }
    function fn1(a5, b4, c5, d5, e5, m5, k5, s6) {
      return rotl(a5 + (b4 ^ c5 ^ d5) + m5 + k5 | 0, s6) + e5 | 0;
    }
    function fn2(a5, b4, c5, d5, e5, m5, k5, s6) {
      return rotl(a5 + (b4 & c5 | ~b4 & d5) + m5 + k5 | 0, s6) + e5 | 0;
    }
    function fn3(a5, b4, c5, d5, e5, m5, k5, s6) {
      return rotl(a5 + ((b4 | ~c5) ^ d5) + m5 + k5 | 0, s6) + e5 | 0;
    }
    function fn4(a5, b4, c5, d5, e5, m5, k5, s6) {
      return rotl(a5 + (b4 & d5 | c5 & ~d5) + m5 + k5 | 0, s6) + e5 | 0;
    }
    function fn5(a5, b4, c5, d5, e5, m5, k5, s6) {
      return rotl(a5 + (b4 ^ (c5 | ~d5)) + m5 + k5 | 0, s6) + e5 | 0;
    }
    module.exports = RIPEMD1602;
  }
});

// node_modules/sha.js/hash.js
var require_hash2 = __commonJS({
  "node_modules/sha.js/hash.js"(exports, module) {
    var Buffer3 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer3.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer3.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset2 = 0; offset2 < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset2, blockSize - assigned);
        for (var i5 = 0; i5 < remainder; i5++) {
          block[assigned + i5] = data[offset2 + i5];
        }
        accum += remainder;
        offset2 += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash4 = this._hash();
      return enc ? hash4.toString(enc) : hash4;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/sha.js"(exports, module) {
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer3 = require_safe_buffer().Buffer;
    var K3 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W2 = new Array(80);
    function Sha() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s6, b4, c5, d5) {
      if (s6 === 0)
        return b4 & c5 | ~b4 & d5;
      if (s6 === 2)
        return b4 & c5 | b4 & d5 | c5 & d5;
      return b4 ^ c5 ^ d5;
    }
    Sha.prototype._update = function(M4) {
      var W3 = this._w;
      var a5 = this._a | 0;
      var b4 = this._b | 0;
      var c5 = this._c | 0;
      var d5 = this._d | 0;
      var e5 = this._e | 0;
      for (var i5 = 0; i5 < 16; ++i5)
        W3[i5] = M4.readInt32BE(i5 * 4);
      for (; i5 < 80; ++i5)
        W3[i5] = W3[i5 - 3] ^ W3[i5 - 8] ^ W3[i5 - 14] ^ W3[i5 - 16];
      for (var j5 = 0; j5 < 80; ++j5) {
        var s6 = ~~(j5 / 20);
        var t5 = rotl5(a5) + ft(s6, b4, c5, d5) + e5 + W3[j5] + K3[s6] | 0;
        e5 = d5;
        d5 = c5;
        c5 = rotl30(b4);
        b4 = a5;
        a5 = t5;
      }
      this._a = a5 + this._a | 0;
      this._b = b4 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d5 + this._d | 0;
      this._e = e5 + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H4 = Buffer3.allocUnsafe(20);
      H4.writeInt32BE(this._a | 0, 0);
      H4.writeInt32BE(this._b | 0, 4);
      H4.writeInt32BE(this._c | 0, 8);
      H4.writeInt32BE(this._d | 0, 12);
      H4.writeInt32BE(this._e | 0, 16);
      return H4;
    };
    module.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports, module) {
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer3 = require_safe_buffer().Buffer;
    var K3 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W2 = new Array(80);
    function Sha1() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s6, b4, c5, d5) {
      if (s6 === 0)
        return b4 & c5 | ~b4 & d5;
      if (s6 === 2)
        return b4 & c5 | b4 & d5 | c5 & d5;
      return b4 ^ c5 ^ d5;
    }
    Sha1.prototype._update = function(M4) {
      var W3 = this._w;
      var a5 = this._a | 0;
      var b4 = this._b | 0;
      var c5 = this._c | 0;
      var d5 = this._d | 0;
      var e5 = this._e | 0;
      for (var i5 = 0; i5 < 16; ++i5)
        W3[i5] = M4.readInt32BE(i5 * 4);
      for (; i5 < 80; ++i5)
        W3[i5] = rotl1(W3[i5 - 3] ^ W3[i5 - 8] ^ W3[i5 - 14] ^ W3[i5 - 16]);
      for (var j5 = 0; j5 < 80; ++j5) {
        var s6 = ~~(j5 / 20);
        var t5 = rotl5(a5) + ft(s6, b4, c5, d5) + e5 + W3[j5] + K3[s6] | 0;
        e5 = d5;
        d5 = c5;
        c5 = rotl30(b4);
        b4 = a5;
        a5 = t5;
      }
      this._a = a5 + this._a | 0;
      this._b = b4 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d5 + this._d | 0;
      this._e = e5 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H4 = Buffer3.allocUnsafe(20);
      H4.writeInt32BE(this._a | 0, 0);
      H4.writeInt32BE(this._b | 0, 4);
      H4.writeInt32BE(this._c | 0, 8);
      H4.writeInt32BE(this._d | 0, 12);
      H4.writeInt32BE(this._e | 0, 16);
      return H4;
    };
    module.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports, module) {
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer3 = require_safe_buffer().Buffer;
    var K3 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W2 = new Array(64);
    function Sha256() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x5, y5, z4) {
      return z4 ^ x5 & (y5 ^ z4);
    }
    function maj(x5, y5, z4) {
      return x5 & y5 | z4 & (x5 | y5);
    }
    function sigma0(x5) {
      return (x5 >>> 2 | x5 << 30) ^ (x5 >>> 13 | x5 << 19) ^ (x5 >>> 22 | x5 << 10);
    }
    function sigma1(x5) {
      return (x5 >>> 6 | x5 << 26) ^ (x5 >>> 11 | x5 << 21) ^ (x5 >>> 25 | x5 << 7);
    }
    function gamma0(x5) {
      return (x5 >>> 7 | x5 << 25) ^ (x5 >>> 18 | x5 << 14) ^ x5 >>> 3;
    }
    function gamma1(x5) {
      return (x5 >>> 17 | x5 << 15) ^ (x5 >>> 19 | x5 << 13) ^ x5 >>> 10;
    }
    Sha256.prototype._update = function(M4) {
      var W3 = this._w;
      var a5 = this._a | 0;
      var b4 = this._b | 0;
      var c5 = this._c | 0;
      var d5 = this._d | 0;
      var e5 = this._e | 0;
      var f7 = this._f | 0;
      var g5 = this._g | 0;
      var h5 = this._h | 0;
      for (var i5 = 0; i5 < 16; ++i5)
        W3[i5] = M4.readInt32BE(i5 * 4);
      for (; i5 < 64; ++i5)
        W3[i5] = gamma1(W3[i5 - 2]) + W3[i5 - 7] + gamma0(W3[i5 - 15]) + W3[i5 - 16] | 0;
      for (var j5 = 0; j5 < 64; ++j5) {
        var T1 = h5 + sigma1(e5) + ch(e5, f7, g5) + K3[j5] + W3[j5] | 0;
        var T22 = sigma0(a5) + maj(a5, b4, c5) | 0;
        h5 = g5;
        g5 = f7;
        f7 = e5;
        e5 = d5 + T1 | 0;
        d5 = c5;
        c5 = b4;
        b4 = a5;
        a5 = T1 + T22 | 0;
      }
      this._a = a5 + this._a | 0;
      this._b = b4 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d5 + this._d | 0;
      this._e = e5 + this._e | 0;
      this._f = f7 + this._f | 0;
      this._g = g5 + this._g | 0;
      this._h = h5 + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H4 = Buffer3.allocUnsafe(32);
      H4.writeInt32BE(this._a, 0);
      H4.writeInt32BE(this._b, 4);
      H4.writeInt32BE(this._c, 8);
      H4.writeInt32BE(this._d, 12);
      H4.writeInt32BE(this._e, 16);
      H4.writeInt32BE(this._f, 20);
      H4.writeInt32BE(this._g, 24);
      H4.writeInt32BE(this._h, 28);
      return H4;
    };
    module.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports, module) {
    var inherits2 = require_inherits_browser();
    var Sha256 = require_sha2562();
    var Hash = require_hash2();
    var Buffer3 = require_safe_buffer().Buffer;
    var W2 = new Array(64);
    function Sha224() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H4 = Buffer3.allocUnsafe(28);
      H4.writeInt32BE(this._a, 0);
      H4.writeInt32BE(this._b, 4);
      H4.writeInt32BE(this._c, 8);
      H4.writeInt32BE(this._d, 12);
      H4.writeInt32BE(this._e, 16);
      H4.writeInt32BE(this._f, 20);
      H4.writeInt32BE(this._g, 24);
      return H4;
    };
    module.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports, module) {
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer3 = require_safe_buffer().Buffer;
    var K3 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W2 = new Array(160);
    function Sha512() {
      this.init();
      this._w = W2;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x5, y5, z4) {
      return z4 ^ x5 & (y5 ^ z4);
    }
    function maj(x5, y5, z4) {
      return x5 & y5 | z4 & (x5 | y5);
    }
    function sigma0(x5, xl) {
      return (x5 >>> 28 | xl << 4) ^ (xl >>> 2 | x5 << 30) ^ (xl >>> 7 | x5 << 25);
    }
    function sigma1(x5, xl) {
      return (x5 >>> 14 | xl << 18) ^ (x5 >>> 18 | xl << 14) ^ (xl >>> 9 | x5 << 23);
    }
    function Gamma0(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ x5 >>> 7;
    }
    function Gamma0l(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ (x5 >>> 7 | xl << 25);
    }
    function Gamma1(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ x5 >>> 6;
    }
    function Gamma1l(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ (x5 >>> 6 | xl << 26);
    }
    function getCarry(a5, b4) {
      return a5 >>> 0 < b4 >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M4) {
      var W3 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i5 = 0; i5 < 32; i5 += 2) {
        W3[i5] = M4.readInt32BE(i5 * 4);
        W3[i5 + 1] = M4.readInt32BE(i5 * 4 + 4);
      }
      for (; i5 < 160; i5 += 2) {
        var xh = W3[i5 - 15 * 2];
        var xl = W3[i5 - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W3[i5 - 2 * 2];
        xl = W3[i5 - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W3[i5 - 7 * 2];
        var Wi7l = W3[i5 - 7 * 2 + 1];
        var Wi16h = W3[i5 - 16 * 2];
        var Wi16l = W3[i5 - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W3[i5] = Wih;
        W3[i5 + 1] = Wil;
      }
      for (var j5 = 0; j5 < 160; j5 += 2) {
        Wih = W3[j5];
        Wil = W3[j5 + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K3[j5];
        var Kil = K3[j5 + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H4 = Buffer3.allocUnsafe(64);
      function writeInt64BE(h5, l5, offset2) {
        H4.writeInt32BE(h5, offset2);
        H4.writeInt32BE(l5, offset2 + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H4;
    };
    module.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports, module) {
    var inherits2 = require_inherits_browser();
    var SHA5122 = require_sha512();
    var Hash = require_hash2();
    var Buffer3 = require_safe_buffer().Buffer;
    var W2 = new Array(160);
    function Sha384() {
      this.init();
      this._w = W2;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha384, SHA5122);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H4 = Buffer3.allocUnsafe(48);
      function writeInt64BE(h5, l5, offset2) {
        H4.writeInt32BE(h5, offset2);
        H4.writeInt32BE(l5, offset2 + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H4;
    };
    module.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha4 = __commonJS({
  "node_modules/sha.js/index.js"(exports, module) {
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports.sha = require_sha2();
    exports.sha1 = require_sha1();
    exports.sha224 = require_sha224();
    exports.sha256 = require_sha2562();
    exports.sha384 = require_sha384();
    exports.sha512 = require_sha512();
  }
});

// node_modules/string_decoder/index.js
var require_string_decoder2 = __commonJS({
  "node_modules/string_decoder/index.js"(exports) {
    var Buffer3 = require_buffer().Buffer;
    var isBufferEncoding = Buffer3.isEncoding || function(encoding5) {
      switch (encoding5 && encoding5.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding5) {
      if (encoding5 && !isBufferEncoding(encoding5)) {
        throw new Error("Unknown encoding: " + encoding5);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding5) {
      this.encoding = (encoding5 || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding5);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer3(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer2) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
        buffer2.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer2 = buffer2.slice(available, buffer2.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer2.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer2);
      var end = buffer2.length;
      if (this.charLength) {
        buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer2.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer2.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer2) {
      var i5 = buffer2.length >= 3 ? 3 : buffer2.length;
      for (; i5 > 0; i5--) {
        var c5 = buffer2[buffer2.length - i5];
        if (i5 == 1 && c5 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i5 <= 2 && c5 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i5 <= 3 && c5 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i5;
    };
    StringDecoder.prototype.end = function(buffer2) {
      var res = "";
      if (buffer2 && buffer2.length)
        res = this.write(buffer2);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer2) {
      return buffer2.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer2) {
      this.charReceived = buffer2.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer2) {
      this.charReceived = buffer2.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports, module) {
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var StringDecoder = require_string_decoder2().StringDecoder;
    var inherits2 = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits2(CipherBase, Transform);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer3.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode)
        return this;
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _10, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e5) {
        err = e5;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e5) {
        err = e5;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer3.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc)
        throw new Error("can't switch encodings");
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module.exports = CipherBase;
  }
});

// node_modules/create-hash/browser.js
var require_browser3 = __commonJS({
  "node_modules/create-hash/browser.js"(exports, module) {
    "use strict";
    var inherits2 = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD1602 = require_ripemd160();
    var sha2 = require_sha4();
    var Base = require_cipher_base();
    function Hash(hash4) {
      Base.call(this, "digest");
      this._hash = hash4;
    }
    inherits2(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    module.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5")
        return new MD5();
      if (alg === "rmd160" || alg === "ripemd160")
        return new RIPEMD1602();
      return new Hash(sha2(alg));
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/elliptic/index.js
var require_elliptic4 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/elliptic/index.js"(exports) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var createHash = require_browser3();
    var BN6 = require_bn3();
    var EC2 = require_elliptic().ec;
    var messages = require_messages2();
    var ec2 = new EC2("secp256k1");
    var ecparams = ec2.curve;
    function loadCompressedPublicKey(first2, xBuffer) {
      var x5 = new BN6(xBuffer);
      if (x5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      var y5 = x5.redSqr().redIMul(x5).redIAdd(ecparams.b).redSqrt();
      if (first2 === 3 !== y5.isOdd())
        y5 = y5.redNeg();
      return ec2.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadUncompressedPublicKey(first2, xBuffer, yBuffer) {
      var x5 = new BN6(xBuffer);
      var y5 = new BN6(yBuffer);
      if (x5.cmp(ecparams.p) >= 0 || y5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      y5 = y5.toRed(ecparams.red);
      if ((first2 === 6 || first2 === 7) && y5.isOdd() !== (first2 === 7))
        return null;
      var x32 = x5.redSqr().redIMul(x5);
      if (!y5.redSqr().redISub(x32.redIAdd(ecparams.b)).isZero())
        return null;
      return ec2.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadPublicKey(publicKey2) {
      var first2 = publicKey2[0];
      switch (first2) {
        case 2:
        case 3:
          if (publicKey2.length !== 33)
            return null;
          return loadCompressedPublicKey(first2, publicKey2.slice(1, 33));
        case 4:
        case 6:
        case 7:
          if (publicKey2.length !== 65)
            return null;
          return loadUncompressedPublicKey(first2, publicKey2.slice(1, 33), publicKey2.slice(33, 65));
        default:
          return null;
      }
    }
    exports.privateKeyVerify = function(privateKey) {
      var bn = new BN6(privateKey);
      return bn.cmp(ecparams.n) < 0 && !bn.isZero();
    };
    exports.privateKeyExport = function(privateKey, compressed) {
      var d5 = new BN6(privateKey);
      if (d5.cmp(ecparams.n) >= 0 || d5.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL);
      return Buffer3.from(ec2.keyFromPrivate(privateKey).getPublic(compressed, true));
    };
    exports.privateKeyNegate = function(privateKey) {
      var bn = new BN6(privateKey);
      return bn.isZero() ? Buffer3.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer3, "be", 32);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN6(privateKey);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID);
      return bn.invm(ecparams.n).toArrayLike(Buffer3, "be", 32);
    };
    exports.privateKeyTweakAdd = function(privateKey, tweak) {
      var bn = new BN6(tweak);
      if (bn.cmp(ecparams.n) >= 0)
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      bn.iadd(new BN6(privateKey));
      if (bn.cmp(ecparams.n) >= 0)
        bn.isub(ecparams.n);
      if (bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      return bn.toArrayLike(Buffer3, "be", 32);
    };
    exports.privateKeyTweakMul = function(privateKey, tweak) {
      var bn = new BN6(tweak);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);
      bn.imul(new BN6(privateKey));
      if (bn.cmp(ecparams.n))
        bn = bn.umod(ecparams.n);
      return bn.toArrayLike(Buffer3, "be", 32);
    };
    exports.publicKeyCreate = function(privateKey, compressed) {
      var d5 = new BN6(privateKey);
      if (d5.cmp(ecparams.n) >= 0 || d5.isZero())
        throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL);
      return Buffer3.from(ec2.keyFromPrivate(privateKey).getPublic(compressed, true));
    };
    exports.publicKeyConvert = function(publicKey2, compressed) {
      var pair = loadPublicKey(publicKey2);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      return Buffer3.from(pair.getPublic(compressed, true));
    };
    exports.publicKeyVerify = function(publicKey2) {
      return loadPublicKey(publicKey2) !== null;
    };
    exports.publicKeyTweakAdd = function(publicKey2, tweak, compressed) {
      var pair = loadPublicKey(publicKey2);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      tweak = new BN6(tweak);
      if (tweak.cmp(ecparams.n) >= 0)
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      var point3 = ecparams.g.mul(tweak).add(pair.pub);
      if (point3.isInfinity())
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      return Buffer3.from(point3.encode(true, compressed));
    };
    exports.publicKeyTweakMul = function(publicKey2, tweak, compressed) {
      var pair = loadPublicKey(publicKey2);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      tweak = new BN6(tweak);
      if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
      return Buffer3.from(pair.pub.mul(tweak).encode(true, compressed));
    };
    exports.publicKeyCombine = function(publicKeys, compressed) {
      var pairs2 = new Array(publicKeys.length);
      for (var i5 = 0; i5 < publicKeys.length; ++i5) {
        pairs2[i5] = loadPublicKey(publicKeys[i5]);
        if (pairs2[i5] === null)
          throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      }
      var point3 = pairs2[0].pub;
      for (var j5 = 1; j5 < pairs2.length; ++j5)
        point3 = point3.add(pairs2[j5].pub);
      if (point3.isInfinity())
        throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL);
      return Buffer3.from(point3.encode(true, compressed));
    };
    exports.signatureNormalize = function(signature2) {
      var r6 = new BN6(signature2.slice(0, 32));
      var s6 = new BN6(signature2.slice(32, 64));
      if (r6.cmp(ecparams.n) >= 0 || s6.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      var result = Buffer3.from(signature2);
      if (s6.cmp(ec2.nh) === 1)
        ecparams.n.sub(s6).toArrayLike(Buffer3, "be", 32).copy(result, 32);
      return result;
    };
    exports.signatureExport = function(signature2) {
      var r6 = signature2.slice(0, 32);
      var s6 = signature2.slice(32, 64);
      if (new BN6(r6).cmp(ecparams.n) >= 0 || new BN6(s6).cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      return { r: r6, s: s6 };
    };
    exports.signatureImport = function(sigObj) {
      var r6 = new BN6(sigObj.r);
      if (r6.cmp(ecparams.n) >= 0)
        r6 = new BN6(0);
      var s6 = new BN6(sigObj.s);
      if (s6.cmp(ecparams.n) >= 0)
        s6 = new BN6(0);
      return Buffer3.concat([
        r6.toArrayLike(Buffer3, "be", 32),
        s6.toArrayLike(Buffer3, "be", 32)
      ]);
    };
    exports.sign = function(message, privateKey, noncefn, data) {
      if (typeof noncefn === "function") {
        var getNonce = noncefn;
        noncefn = function(counter) {
          var nonce = getNonce(message, privateKey, null, data, counter);
          if (!Buffer3.isBuffer(nonce) || nonce.length !== 32)
            throw new Error(messages.ECDSA_SIGN_FAIL);
          return new BN6(nonce);
        };
      }
      var d5 = new BN6(privateKey);
      if (d5.cmp(ecparams.n) >= 0 || d5.isZero())
        throw new Error(messages.ECDSA_SIGN_FAIL);
      var result = ec2.sign(message, privateKey, { canonical: true, k: noncefn, pers: data });
      return {
        signature: Buffer3.concat([
          result.r.toArrayLike(Buffer3, "be", 32),
          result.s.toArrayLike(Buffer3, "be", 32)
        ]),
        recovery: result.recoveryParam
      };
    };
    exports.verify = function(message, signature2, publicKey2) {
      var sigObj = { r: signature2.slice(0, 32), s: signature2.slice(32, 64) };
      var sigr = new BN6(sigObj.r);
      var sigs = new BN6(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      if (sigs.cmp(ec2.nh) === 1 || sigr.isZero() || sigs.isZero())
        return false;
      var pair = loadPublicKey(publicKey2);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      return ec2.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y });
    };
    exports.recover = function(message, signature2, recovery, compressed) {
      var sigObj = { r: signature2.slice(0, 32), s: signature2.slice(32, 64) };
      var sigr = new BN6(sigObj.r);
      var sigs = new BN6(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      try {
        if (sigr.isZero() || sigs.isZero())
          throw new Error();
        var point3 = ec2.recoverPubKey(message, sigObj, recovery);
        return Buffer3.from(point3.encode(true, compressed));
      } catch (err) {
        throw new Error(messages.ECDSA_RECOVER_FAIL);
      }
    };
    exports.ecdh = function(publicKey2, privateKey) {
      var shared = exports.ecdhUnsafe(publicKey2, privateKey, true);
      return createHash("sha256").update(shared).digest();
    };
    exports.ecdhUnsafe = function(publicKey2, privateKey, compressed) {
      var pair = loadPublicKey(publicKey2);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      var scalar = new BN6(privateKey);
      if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
        throw new Error(messages.ECDH_FAIL);
      return Buffer3.from(pair.pub.mul(scalar).encode(true, compressed));
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/elliptic.js
var require_elliptic5 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/elliptic.js"(exports, module) {
    "use strict";
    module.exports = require_lib4()(require_elliptic4());
  }
});

// browser-external:assert
var assert_exports = {};
__export(assert_exports, {
  default: () => assert_default
});
var assert_default;
var init_assert = __esm({
  "browser-external:assert"() {
    assert_default = new Proxy({}, {
      get() {
        throw new Error('Module "assert" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/rlp/node_modules/bn.js/lib/bn.js
var require_bn4 = __commonJS({
  "node_modules/rlp/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number2, base2, endian) {
        if (BN6.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = (init_buffer(), buffer_exports).Buffer;
        }
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert5(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN6.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number2, base2, endian) {
        assert5(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i5 = number2.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number2[i5] | number2[i5 - 1] << 8 | number2[i5 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number2.length; i5 += 3) {
            w6 = number2[i5] | number2[i5 + 1] << 8 | number2[i5 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c5 = string2.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert5(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r6 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r6;
      }
      BN6.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number2.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number2.length; i5 += 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var b4 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            b4 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b4 = c5 - 17 + 10;
          } else {
            b4 = c5;
          }
          assert5(c5 >= 0 && b4 < mul3, "Invalid character");
          r6 += b4;
        }
        return r6;
      }
      BN6.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number2, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i5, number2.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN6.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN6.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN6.prototype.clone = function clone() {
        var r6 = new BN6(null);
        this.copy(r6);
        return r6;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN6.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e5) {
          BN6.prototype.inspect = inspect4;
        }
      } else {
        BN6.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modrn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer3) {
        BN6.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer3, endian, length);
        };
      }
      BN6.prototype.toArray = function toArray3(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN6.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN6.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = num.words[off] >>> wbit & 1;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN6.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this._strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this._strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this._strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN6.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t5 = new Array(N5);
        var l5 = BN6.prototype._countBits(N5) - 1;
        for (var i5 = 0; i5 < N5; i5++) {
          t5[i5] = this.revBin(i5, l5, N5);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N5) {
        if (x5 === 0 || x5 === N5 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i5 = 0; i5 < N5; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s6 = 1; s6 < N5; s6 <<= 1) {
          var l5 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N5; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s6; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s6];
              var io = itws[p5 + j5 + s6];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s6] = re - ro;
              itws[p5 + j5 + s6] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N5 = Math.max(m5, n3) | 1;
        var odd = N5 & 1;
        var i5 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1)
          return;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N5 - i5 - 1];
          rws[N5 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N5 - i5 - 1];
          iws[N5 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N5) * 8192 + Math.round(ws[2 * i5] / N5) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N5; ++i5) {
          rws[i5] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i5 = 0; i5 < N5; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N5 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N5);
        var _10 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x5.words, x5.length, rws, N5);
        this.convert13b(y5.words, y5.length, nrws, N5);
        this.transform(rws, _10, rwst, iwst, N5, rbt);
        this.transform(nrws, _10, nrwst, niwst, N5, rbt);
        for (var i5 = 0; i5 < N5; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _10, N5, rbt);
        this.conjugate(rmws, _10, N5);
        this.normalize13b(rmws, N5);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out._strip();
      };
      BN6.prototype.mul = function mul3(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(typeof num === "number");
        assert5(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s6] = this.words[i5];
          }
          for (i5 = 0; i5 < s6; i5++) {
            this.words[i5] = 0;
          }
          this.length += s6;
        }
        return this._strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s6;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s6; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w6 = this.words[s6];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul3;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert5(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a5._strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert5(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN6.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN6.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B3.isOdd()) {
                A6.iadd(yp);
                B3.isub(xp);
              }
              A6.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g5)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s6; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert5(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert5(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p5) {
        this.name = name2;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert5(a5.negative === 0, "red works only with positives");
        assert5(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert5((a5.negative | b4.negative) === 0, "red works only with positives");
        assert5(a5.red && a5.red === b4.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        move(a5, a5.umod(this.m)._forceRed(this));
        return a5;
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s6 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s6++;
          q5.iushrn(1);
        }
        assert5(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c5 = this.pow(z4, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s6;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert5(i5 < m5);
          var b4 = this.pow(c5, new BN6(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/rlp/dist.browser/index.js
var require_dist3 = __commonJS({
  "node_modules/rlp/dist.browser/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLength = exports.decode = exports.encode = void 0;
    var bn_js_1 = __importDefault(require_bn4());
    function encode5(input) {
      if (Array.isArray(input)) {
        var output = [];
        for (var i5 = 0; i5 < input.length; i5++) {
          output.push(encode5(input[i5]));
        }
        var buf = Buffer.concat(output);
        return Buffer.concat([encodeLength2(buf.length, 192), buf]);
      } else {
        var inputBuf = toBuffer2(input);
        return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer.concat([encodeLength2(inputBuf.length, 128), inputBuf]);
      }
    }
    exports.encode = encode5;
    function safeParseInt(v8, base2) {
      if (v8[0] === "0" && v8[1] === "0") {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseInt(v8, base2);
    }
    function encodeLength2(len, offset2) {
      if (len < 56) {
        return Buffer.from([len + offset2]);
      } else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset2 + 55 + lLength);
        return Buffer.from(firstByte + hexLength, "hex");
      }
    }
    function decode4(input, stream) {
      if (stream === void 0) {
        stream = false;
      }
      if (!input || input.length === 0) {
        return Buffer.from([]);
      }
      var inputBuffer = toBuffer2(input);
      var decoded = _decode2(inputBuffer);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid remainder");
      }
      return decoded.data;
    }
    exports.decode = decode4;
    function getLength2(input) {
      if (!input || input.length === 0) {
        return Buffer.from([]);
      }
      var inputBuffer = toBuffer2(input);
      var firstByte = inputBuffer[0];
      if (firstByte <= 127) {
        return inputBuffer.length;
      } else if (firstByte <= 183) {
        return firstByte - 127;
      } else if (firstByte <= 191) {
        return firstByte - 182;
      } else if (firstByte <= 247) {
        return firstByte - 191;
      } else {
        var llength = firstByte - 246;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
        return llength + length_1;
      }
    }
    exports.getLength = getLength2;
    function _decode2(input) {
      var length, llength, data, innerRemainder, d5;
      var decoded = [];
      var firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Buffer.from([]);
        } else {
          data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid rlp encoding: byte must be less 0x80");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
          throw new Error("invalid RLP: not enough bytes for string");
        }
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
          d5 = _decode2(innerRemainder);
          decoded.push(d5.data);
          innerRemainder = d5.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid rlp: total length is larger than the data");
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
          throw new Error("invalid rlp, List has a invalid length");
        }
        while (innerRemainder.length) {
          d5 = _decode2(innerRemainder);
          decoded.push(d5.data);
          innerRemainder = d5.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    function isHexPrefixed(str) {
      return str.slice(0, 2) === "0x";
    }
    function stripHexPrefix2(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function intToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      var hex = integer.toString(16);
      return hex.length % 2 ? "0" + hex : hex;
    }
    function padToEven(a5) {
      return a5.length % 2 ? "0" + a5 : a5;
    }
    function intToBuffer2(integer) {
      var hex = intToHex(integer);
      return Buffer.from(hex, "hex");
    }
    function toBuffer2(v8) {
      if (!Buffer.isBuffer(v8)) {
        if (typeof v8 === "string") {
          if (isHexPrefixed(v8)) {
            return Buffer.from(padToEven(stripHexPrefix2(v8)), "hex");
          } else {
            return Buffer.from(v8);
          }
        } else if (typeof v8 === "number" || typeof v8 === "bigint") {
          if (!v8) {
            return Buffer.from([]);
          } else {
            return intToBuffer2(v8);
          }
        } else if (v8 === null || v8 === void 0) {
          return Buffer.from([]);
        } else if (v8 instanceof Uint8Array) {
          return Buffer.from(v8);
        } else if (bn_js_1.default.isBN(v8)) {
          return Buffer.from(v8.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v8;
    }
  }
});

// node_modules/is-hex-prefixed/src/index.js
var require_src3 = __commonJS({
  "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// node_modules/strip-hex-prefix/src/index.js
var require_src4 = __commonJS({
  "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    var isHexPrefixed = require_src3();
    module.exports = function stripHexPrefix2(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// node_modules/ethjs-util/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/ethjs-util/lib/index.js"(exports, module) {
    "use strict";
    var isHexPrefixed = require_src3();
    var stripHexPrefix2 = require_src4();
    function padToEven(value) {
      var a5 = value;
      if (typeof a5 !== "string") {
        throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a5 + ", while padToEven.");
      }
      if (a5.length % 2) {
        a5 = "0" + a5;
      }
      return a5;
    }
    function intToHex(i5) {
      var hex = i5.toString(16);
      return "0x" + hex;
    }
    function intToBuffer2(i5) {
      var hex = intToHex(i5);
      return new Buffer(padToEven(hex.slice(2)), "hex");
    }
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str + "'.");
      }
      return Buffer.byteLength(str, "utf8");
    }
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
      }
      return subset[Boolean(some) && "some" || "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    function toUtf8(hex) {
      var bufferValue = new Buffer(padToEven(stripHexPrefix2(hex).replace(/^0+|0+$/g, "")), "hex");
      return bufferValue.toString("utf8");
    }
    function toAscii(hex) {
      var str = "";
      var i5 = 0, l5 = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i5 = 2;
      }
      for (; i5 < l5; i5 += 2) {
        var code = parseInt(hex.substr(i5, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    function fromUtf8(stringValue) {
      var str = new Buffer(stringValue, "utf8");
      return "0x" + padToEven(str.toString("hex")).replace(/^0+|0+$/g, "");
    }
    function fromAscii(stringValue) {
      var hex = "";
      for (var i5 = 0; i5 < stringValue.length; i5++) {
        var code = stringValue.charCodeAt(i5);
        var n3 = code.toString(16);
        hex += n3.length < 2 ? "0" + n3 : n3;
      }
      return "0x" + hex;
    }
    function getKeys(params, key2, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
      }
      if (typeof key2 !== "string") {
        throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key2 + "'.");
      }
      var result = [];
      for (var i5 = 0; i5 < params.length; i5++) {
        var value = params[i5][key2];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi");
        }
        result.push(value);
      }
      return result;
    }
    function isHexString5(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    module.exports = {
      arrayContainsArray,
      intToBuffer: intToBuffer2,
      getBinarySize,
      isHexPrefixed,
      stripHexPrefix: stripHexPrefix2,
      padToEven,
      intToHex,
      fromAscii,
      fromUtf8,
      toAscii,
      toUtf8,
      getKeys,
      isHexString: isHexString5
    };
  }
});

// node_modules/@portis/web3/node_modules/ethereumjs-util/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@portis/web3/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var createKeccakHash = require_js();
    var secp256k12 = require_elliptic5();
    var assert5 = (init_assert(), assert_exports);
    var rlp = require_dist3();
    var BN6 = require_bn3();
    var createHash = require_browser3();
    var Buffer3 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib5());
    exports.MAX_INTEGER = new BN6("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN6("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer3.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer3.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer3.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN6;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k12;
    exports.zeros = function(bytes) {
      return Buffer3.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a5) {
      a5 = exports.stripHexPrefix(a5);
      var first2 = a5[0];
      while (a5.length > 0 && first2.toString() === "0") {
        a5 = a5.slice(1);
        first2 = a5[0];
      }
      return a5;
    };
    exports.toBuffer = function(v8) {
      if (!Buffer3.isBuffer(v8)) {
        if (Array.isArray(v8)) {
          v8 = Buffer3.from(v8);
        } else if (typeof v8 === "string") {
          if (exports.isHexString(v8)) {
            v8 = Buffer3.from(exports.padToEven(exports.stripHexPrefix(v8)), "hex");
          } else {
            v8 = Buffer3.from(v8);
          }
        } else if (typeof v8 === "number") {
          v8 = exports.intToBuffer(v8);
        } else if (v8 === null || v8 === void 0) {
          v8 = Buffer3.allocUnsafe(0);
        } else if (BN6.isBN(v8)) {
          v8 = v8.toArrayLike(Buffer3);
        } else if (v8.toArray) {
          v8 = Buffer3.from(v8.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v8;
    };
    exports.bufferToInt = function(buf) {
      return new BN6(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN6(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer3.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a5, bits) {
      a5 = exports.toBuffer(a5);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a5).digest();
    };
    exports.keccak256 = function(a5) {
      return exports.keccak(a5);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a5) {
      a5 = exports.toBuffer(a5);
      return createHash("sha256").update(a5).digest();
    };
    exports.ripemd160 = function(a5, padded) {
      a5 = exports.toBuffer(a5);
      var hash4 = createHash("rmd160").update(a5).digest();
      if (padded === true) {
        return exports.setLength(hash4, 32);
      } else {
        return hash4;
      }
    };
    exports.rlphash = function(a5) {
      return exports.keccak(rlp.encode(a5));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k12.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey2, sanitize) {
      if (publicKey2.length === 64) {
        return secp256k12.publicKeyVerify(Buffer3.concat([Buffer3.from([4]), publicKey2]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k12.publicKeyVerify(publicKey2);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k12.publicKeyConvert(pubKey, false).slice(1);
      }
      assert5(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k12.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey2) {
      publicKey2 = exports.toBuffer(publicKey2);
      if (publicKey2.length !== 64) {
        publicKey2 = secp256k12.publicKeyConvert(publicKey2, false).slice(1);
      }
      return publicKey2;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k12.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer3.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v8, r6, s6) {
      var signature2 = Buffer3.concat([exports.setLength(r6, 32), exports.setLength(s6, 32)], 64);
      var recovery = v8 - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k12.recover(msgHash, signature2, recovery);
      return secp256k12.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v8, r6, s6) {
      if (v8 !== 27 && v8 !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer3.concat([exports.setLengthLeft(r6, 32), exports.setLengthLeft(s6, 32), exports.toBuffer(v8 - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v8 = sig[64];
      if (v8 < 27) {
        v8 += 27;
      }
      return {
        v: v8,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash4 = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i5 = 0; i5 < address.length; i5++) {
        if (parseInt(hash4[i5], 16) >= 8) {
          ret += address[i5].toUpperCase();
        } else {
          ret += address[i5];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from2, nonce) {
      from2 = exports.toBuffer(from2);
      nonce = new BN6(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer3.from(nonce.toArray());
      }
      return exports.rlphash([from2, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a5 = exports.unpad(address);
      return a5.length === 1 && a5[0] >= 1 && a5[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v8, r6, s6, homestead2) {
      var SECP256K1_N_DIV_2 = new BN6("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN6("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r6.length !== 32 || s6.length !== 32) {
        return false;
      }
      if (v8 !== 27 && v8 !== 28) {
        return false;
      }
      r6 = new BN6(r6);
      s6 = new BN6(s6);
      if (r6.isZero() || r6.gt(SECP256K1_N) || s6.isZero() || s6.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead2 === false && new BN6(s6).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer3.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array2 = [];
        for (var i5 = 0; i5 < ba.length; i5++) {
          array2.push(exports.baToJSON(ba[i5]));
        }
        return array2;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize4() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i5) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i5];
        }
        function setter(v8) {
          v8 = exports.toBuffer(v8);
          if (v8.toString("hex") === "00" && !field.allowZero) {
            v8 = Buffer3.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v8 = exports.stripZeros(v8);
            assert5(field.length >= v8.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v8.length === 0) && field.length) {
            assert5(field.length === v8.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i5] = v8;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer3.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer3.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d5, i5) {
            self2[self2._fields[i5]] = exports.toBuffer(d5);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys = Object.keys(data);
          fields.forEach(function(field) {
            if (keys.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/ethereum-cryptography/hash-utils.js
var require_hash_utils = __commonJS({
  "node_modules/ethereum-cryptography/hash-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createHashFunction(hashConstructor) {
      return function(msg) {
        var hash4 = hashConstructor();
        hash4.update(msg);
        return Buffer.from(hash4.digest());
      };
    }
    exports.createHashFunction = createHashFunction;
  }
});

// node_modules/keccak/lib/api/keccak.js
var require_keccak3 = __commonJS({
  "node_modules/keccak/lib/api/keccak.js"(exports, module) {
    var { Transform } = require_readable_browser();
    module.exports = (KeccakState) => class Keccak extends Transform {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding5, callback) {
        let error = null;
        try {
          this.update(chunk, encoding5);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush(callback) {
        let error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      update(data, encoding5) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding5);
        this._state.absorb(data);
        return this;
      }
      digest(encoding5) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest9 = this._state.squeeze(this._hashBitLength / 8);
        if (encoding5 !== void 0)
          digest9 = digest9.toString(encoding5);
        this._resetState();
        return digest9;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/shake.js
var require_shake2 = __commonJS({
  "node_modules/keccak/lib/api/shake.js"(exports, module) {
    var { Transform } = require_readable_browser();
    module.exports = (KeccakState) => class Shake extends Transform {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding5, callback) {
        let error = null;
        try {
          this.update(chunk, encoding5);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush() {
      }
      _read(size) {
        this.push(this.squeeze(size));
      }
      update(data, encoding5) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding5);
        this._state.absorb(data);
        return this;
      }
      squeeze(dataByteLength, encoding5) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data = this._state.squeeze(dataByteLength);
        if (encoding5 !== void 0)
          data = data.toString(encoding5);
        return data;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/index.js
var require_api2 = __commonJS({
  "node_modules/keccak/lib/api/index.js"(exports, module) {
    var createKeccak = require_keccak3();
    var createShake = require_shake2();
    module.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm, options) {
        const hash4 = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash4) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll2 = __commonJS({
  "node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s6) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s6[0] ^ s6[10] ^ s6[20] ^ s6[30] ^ s6[40];
        const hi0 = s6[1] ^ s6[11] ^ s6[21] ^ s6[31] ^ s6[41];
        const lo1 = s6[2] ^ s6[12] ^ s6[22] ^ s6[32] ^ s6[42];
        const hi1 = s6[3] ^ s6[13] ^ s6[23] ^ s6[33] ^ s6[43];
        const lo2 = s6[4] ^ s6[14] ^ s6[24] ^ s6[34] ^ s6[44];
        const hi2 = s6[5] ^ s6[15] ^ s6[25] ^ s6[35] ^ s6[45];
        const lo3 = s6[6] ^ s6[16] ^ s6[26] ^ s6[36] ^ s6[46];
        const hi3 = s6[7] ^ s6[17] ^ s6[27] ^ s6[37] ^ s6[47];
        const lo4 = s6[8] ^ s6[18] ^ s6[28] ^ s6[38] ^ s6[48];
        const hi4 = s6[9] ^ s6[19] ^ s6[29] ^ s6[39] ^ s6[49];
        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s6[0] ^ lo;
        const t1shi0 = s6[1] ^ hi;
        const t1slo5 = s6[10] ^ lo;
        const t1shi5 = s6[11] ^ hi;
        const t1slo10 = s6[20] ^ lo;
        const t1shi10 = s6[21] ^ hi;
        const t1slo15 = s6[30] ^ lo;
        const t1shi15 = s6[31] ^ hi;
        const t1slo20 = s6[40] ^ lo;
        const t1shi20 = s6[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s6[2] ^ lo;
        const t1shi1 = s6[3] ^ hi;
        const t1slo6 = s6[12] ^ lo;
        const t1shi6 = s6[13] ^ hi;
        const t1slo11 = s6[22] ^ lo;
        const t1shi11 = s6[23] ^ hi;
        const t1slo16 = s6[32] ^ lo;
        const t1shi16 = s6[33] ^ hi;
        const t1slo21 = s6[42] ^ lo;
        const t1shi21 = s6[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s6[4] ^ lo;
        const t1shi2 = s6[5] ^ hi;
        const t1slo7 = s6[14] ^ lo;
        const t1shi7 = s6[15] ^ hi;
        const t1slo12 = s6[24] ^ lo;
        const t1shi12 = s6[25] ^ hi;
        const t1slo17 = s6[34] ^ lo;
        const t1shi17 = s6[35] ^ hi;
        const t1slo22 = s6[44] ^ lo;
        const t1shi22 = s6[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s6[6] ^ lo;
        const t1shi3 = s6[7] ^ hi;
        const t1slo8 = s6[16] ^ lo;
        const t1shi8 = s6[17] ^ hi;
        const t1slo13 = s6[26] ^ lo;
        const t1shi13 = s6[27] ^ hi;
        const t1slo18 = s6[36] ^ lo;
        const t1shi18 = s6[37] ^ hi;
        const t1slo23 = s6[46] ^ lo;
        const t1shi23 = s6[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s6[8] ^ lo;
        const t1shi4 = s6[9] ^ hi;
        const t1slo9 = s6[18] ^ lo;
        const t1shi9 = s6[19] ^ hi;
        const t1slo14 = s6[28] ^ lo;
        const t1shi14 = s6[29] ^ hi;
        const t1slo19 = s6[38] ^ lo;
        const t1shi19 = s6[39] ^ hi;
        const t1slo24 = s6[48] ^ lo;
        const t1shi24 = s6[49] ^ hi;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s6[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s6[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s6[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s6[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s6[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s6[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s6[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s6[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s6[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s6[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s6[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s6[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s6[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s6[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s6[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s6[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s6[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s6[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s6[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s6[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s6[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s6[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s6[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s6[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s6[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s6[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s6[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s6[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s6[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s6[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s6[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s6[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s6[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s6[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s6[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s6[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s6[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s6[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s6[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s6[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s6[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s6[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s6[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s6[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s6[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s6[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s6[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s6[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s6[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s6[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s6[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s6[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/keccak/lib/keccak.js
var require_keccak4 = __commonJS({
  "node_modules/keccak/lib/keccak.js"(exports, module) {
    var keccakState = require_keccak_state_unroll2();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i5 = 0; i5 < 50; ++i5)
        this.state[i5] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (let i5 = 0; i5 < data.length; ++i5) {
        this.state[~~(this.count / 4)] ^= data[i5] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = Buffer.alloc(length);
      for (let i5 = 0; i5 < length; ++i5) {
        output[i5] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i5 = 0; i5 < 50; ++i5)
        dest.state[i5] = this.state[i5];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/keccak/js.js
var require_js2 = __commonJS({
  "node_modules/keccak/js.js"(exports, module) {
    module.exports = require_api2()(require_keccak4());
  }
});

// node_modules/ethereum-cryptography/keccak.js
var require_keccak5 = __commonJS({
  "node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_utils_1 = require_hash_utils();
    var createKeccakHash = require_js2();
    exports.keccak224 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak224");
    });
    exports.keccak256 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak256");
    });
    exports.keccak384 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak384");
    });
    exports.keccak512 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak512");
    });
  }
});

// node_modules/randombytes/browser.js
var require_browser4 = __commonJS({
  "node_modules/randombytes/browser.js"(exports, module) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer3 = require_safe_buffer().Buffer;
    var crypto4 = global.crypto || global.msCrypto;
    if (crypto4 && crypto4.getRandomValues) {
      module.exports = randomBytes3;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes3(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer3.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto4.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto4.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/ethereum-cryptography/random.js
var require_random = __commonJS({
  "node_modules/ethereum-cryptography/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var randombytes = require_browser4();
    function getRandomBytes(bytes) {
      return new Promise(function(resolve, reject) {
        randombytes(bytes, function(err, resp) {
          if (err) {
            reject(err);
            return;
          }
          resolve(resp);
        });
      });
    }
    exports.getRandomBytes = getRandomBytes;
    function getRandomBytesSync(bytes) {
      return randombytes(bytes);
    }
    exports.getRandomBytesSync = getRandomBytesSync;
  }
});

// node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    var __awaiter22 = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator5 = exports && exports.__generator || function(thisArg, body) {
      var _10 = { label: 0, sent: function() {
        if (t5[0] & 1)
          throw t5[1];
        return t5[1];
      }, trys: [], ops: [] }, f7, y5, t5, g5;
      return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
        return this;
      }), g5;
      function verb(n3) {
        return function(v8) {
          return step([n3, v8]);
        };
      }
      function step(op) {
        if (f7)
          throw new TypeError("Generator is already executing.");
        while (_10)
          try {
            if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
              return t5;
            if (y5 = 0, t5)
              op = [op[0] & 2, t5.value];
            switch (op[0]) {
              case 0:
              case 1:
                t5 = op;
                break;
              case 4:
                _10.label++;
                return { value: op[1], done: false };
              case 5:
                _10.label++;
                y5 = op[1];
                op = [0];
                continue;
              case 7:
                op = _10.ops.pop();
                _10.trys.pop();
                continue;
              default:
                if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _10 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                  _10.label = op[1];
                  break;
                }
                if (op[0] === 6 && _10.label < t5[1]) {
                  _10.label = t5[1];
                  t5 = op;
                  break;
                }
                if (t5 && _10.label < t5[2]) {
                  _10.label = t5[2];
                  _10.ops.push(op);
                  break;
                }
                if (t5[2])
                  _10.ops.pop();
                _10.trys.pop();
                continue;
            }
            op = body.call(thisArg, _10);
          } catch (e5) {
            op = [6, e5];
            y5 = 0;
          } finally {
            f7 = t5 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    function __export2(m5) {
      for (var p5 in m5)
        if (!exports.hasOwnProperty(p5))
          exports[p5] = m5[p5];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var secp256k1_1 = require_elliptic3();
    var random_1 = require_random();
    var SECP256K1_PRIVATE_KEY_SIZE = 32;
    function createPrivateKey() {
      return __awaiter22(this, void 0, void 0, function() {
        var pk;
        return __generator5(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (false)
                return [3, 2];
              return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
            case 1:
              pk = _a2.sent();
              if (secp256k1_1.privateKeyVerify(pk)) {
                return [2, pk];
              }
              return [3, 0];
            case 2:
              return [2];
          }
        });
      });
    }
    exports.createPrivateKey = createPrivateKey;
    function createPrivateKeySync() {
      while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
          return pk;
        }
      }
    }
    exports.createPrivateKeySync = createPrivateKeySync;
    __export2(require_elliptic3());
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-lib/index.js
var require_secp256k1_lib = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-lib/index.js"(exports) {
    "use strict";
    var BN6 = require_bn3();
    var EC2 = require_elliptic().ec;
    var ec2 = new EC2("secp256k1");
    var ecparams = ec2.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      var d5 = new BN6(privateKey);
      if (d5.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point3 = ec2.g.mul(d5);
      return toPublicKey(point3.getX(), point3.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN6(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r6 = new BN6(sigObj.r);
      if (r6.ucmp(ecparams.n) >= 0) {
        r6 = new BN6(0);
      }
      var s6 = new BN6(sigObj.s);
      if (s6.ucmp(ecparams.n) >= 0) {
        s6 = new BN6(0);
      }
      return Buffer.concat([r6.toArrayLike(Buffer, "be", 32), s6.toArrayLike(Buffer, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey2, privateKey, compressed) {
      var point3 = ec2.keyFromPublic(publicKey2);
      var scalar = new BN6(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point3.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function toPublicKey2(x5, y5, compressed) {
      var publicKey2 = void 0;
      if (compressed) {
        publicKey2 = Buffer.alloc(33);
        publicKey2[0] = y5.isOdd() ? 3 : 2;
        x5.toArrayLike(Buffer, "be", 32).copy(publicKey2, 1);
      } else {
        publicKey2 = Buffer.alloc(65);
        publicKey2[0] = 4;
        x5.toArrayLike(Buffer, "be", 32).copy(publicKey2, 1);
        y5.toArrayLike(Buffer, "be", 32).copy(publicKey2, 33);
      }
      return publicKey2;
    };
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-lib/der.js
var require_der2 = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-lib/der.js"(exports) {
    "use strict";
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey2, compressed) {
      var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey2.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature2) {
      var r6 = Buffer.alloc(32, 0);
      var s6 = Buffer.alloc(32, 0);
      var length = signature2.length;
      var index = 0;
      if (signature2[index++] !== 48) {
        return null;
      }
      var lenbyte = signature2[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature2[index++] !== 2) {
        return null;
      }
      var rlen = signature2[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature2[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          rlen = (rlen << 8) + signature2[index];
        }
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature2[index++] !== 2) {
        return null;
      }
      var slen = signature2[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature2[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          slen = (slen << 8) + signature2[index];
        }
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature2[rindex] === 0; rlen -= 1, rindex += 1) {
      }
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature2.slice(rindex, rindex + rlen);
      rvalue.copy(r6, 32 - rvalue.length);
      for (; slen > 0 && signature2[sindex] === 0; slen -= 1, sindex += 1) {
      }
      if (slen > 32) {
        return null;
      }
      var svalue = signature2.slice(sindex, sindex + slen);
      svalue.copy(s6, 32 - svalue.length);
      return { r: r6, s: s6 };
    };
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-adapter.js
var require_secp256k1_adapter = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-adapter.js"(exports, module) {
    "use strict";
    var secp256k12 = require_secp256k12();
    var secp256k1v3 = require_secp256k1_lib();
    var der = require_der2();
    var privateKeyVerify = function privateKeyVerify2(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k12.privateKeyVerify(Uint8Array.from(privateKey));
    };
    var privateKeyExport = function privateKeyExport2(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey2 = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey2, compressed);
    };
    var privateKeyImport = function privateKeyImport2(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    var privateKeyNegate = function privateKeyNegate2(privateKey) {
      return Buffer.from(secp256k12.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    var privateKeyModInverse = function privateKeyModInverse2(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    var privateKeyTweakAdd = function privateKeyTweakAdd2(privateKey, tweak) {
      return Buffer.from(secp256k12.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    var privateKeyTweakMul = function privateKeyTweakMul2(privateKey, tweak) {
      return Buffer.from(secp256k12.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    var publicKeyCreate2 = function publicKeyCreate3(privateKey, compressed) {
      return Buffer.from(secp256k12.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    var publicKeyConvert = function publicKeyConvert2(publicKey2, compressed) {
      return Buffer.from(secp256k12.publicKeyConvert(Uint8Array.from(publicKey2), compressed));
    };
    var publicKeyVerify = function publicKeyVerify2(publicKey2) {
      if (publicKey2.length !== 33 && publicKey2.length !== 65) {
        return false;
      }
      return secp256k12.publicKeyVerify(Uint8Array.from(publicKey2));
    };
    var publicKeyTweakAdd = function publicKeyTweakAdd2(publicKey2, tweak, compressed) {
      return Buffer.from(secp256k12.publicKeyTweakAdd(Uint8Array.from(publicKey2), Uint8Array.from(tweak), compressed));
    };
    var publicKeyTweakMul = function publicKeyTweakMul2(publicKey2, tweak, compressed) {
      return Buffer.from(secp256k12.publicKeyTweakMul(Uint8Array.from(publicKey2), Uint8Array.from(tweak), compressed));
    };
    var publicKeyCombine = function publicKeyCombine2(publicKeys, compressed) {
      var keys = [];
      publicKeys.forEach(function(publicKey2) {
        keys.push(Uint8Array.from(publicKey2));
      });
      return Buffer.from(secp256k12.publicKeyCombine(keys, compressed));
    };
    var signatureNormalize = function signatureNormalize2(signature2) {
      return Buffer.from(secp256k12.signatureNormalize(Uint8Array.from(signature2)));
    };
    var signatureExport = function signatureExport2(signature2) {
      return Buffer.from(secp256k12.signatureExport(Uint8Array.from(signature2)));
    };
    var signatureImport = function signatureImport2(signature2) {
      return Buffer.from(secp256k12.signatureImport(Uint8Array.from(signature2)));
    };
    var signatureImportLax = function signatureImportLax2(signature2) {
      if (signature2.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature2);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    var sign3 = function sign4(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length !== 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer.from(algo) : null;
            var bufferData = data != null ? Buffer.from(data) : null;
            var buffer2 = Buffer.from("");
            if (options.noncefn) {
              buffer2 = options.noncefn(Buffer.from(message2), Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return Uint8Array.from(buffer2);
          };
        }
      }
      var sig = secp256k12.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid
      };
    };
    var verify3 = function verify4(message, signature2, publicKey2) {
      return secp256k12.ecdsaVerify(Uint8Array.from(signature2), Uint8Array.from(message), publicKey2);
    };
    var recover = function recover2(message, signature2, recid, compressed) {
      return Buffer.from(secp256k12.ecdsaRecover(Uint8Array.from(signature2), recid, Uint8Array.from(message), compressed));
    };
    var ecdh = function ecdh2(publicKey2, privateKey) {
      return Buffer.from(secp256k12.ecdh(Uint8Array.from(publicKey2), Uint8Array.from(privateKey), {}));
    };
    var ecdhUnsafe = function ecdhUnsafe2(publicKey2, privateKey, compressed) {
      if (publicKey2.length !== 33 && publicKey2.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey2), Uint8Array.from(privateKey), compressed));
    };
    module.exports = {
      privateKeyVerify,
      privateKeyExport,
      privateKeyImport,
      privateKeyNegate,
      privateKeyModInverse,
      privateKeyTweakAdd,
      privateKeyTweakMul,
      publicKeyCreate: publicKeyCreate2,
      publicKeyConvert,
      publicKeyVerify,
      publicKeyTweakAdd,
      publicKeyTweakMul,
      publicKeyCombine,
      signatureNormalize,
      signatureExport,
      signatureImport,
      signatureImportLax,
      sign: sign3,
      verify: verify3,
      recover,
      ecdh,
      ecdhUnsafe
    };
  }
});

// node_modules/ethereumjs-util/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _require = require_keccak5();
    var keccak224 = _require.keccak224;
    var keccak384 = _require.keccak384;
    var k256 = _require.keccak256;
    var keccak512 = _require.keccak512;
    var secp256k12 = require_secp256k1_adapter();
    var assert5 = (init_assert(), assert_exports);
    var rlp = require_dist3();
    var BN6 = require_bn3();
    var createHash = require_browser3();
    var Buffer3 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib5());
    exports.MAX_INTEGER = new BN6("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN6("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer3.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer3.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer3.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN6;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k12;
    exports.zeros = function(bytes) {
      return Buffer3.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a5) {
      a5 = exports.stripHexPrefix(a5);
      var first2 = a5[0];
      while (a5.length > 0 && first2.toString() === "0") {
        a5 = a5.slice(1);
        first2 = a5[0];
      }
      return a5;
    };
    exports.toBuffer = function(v8) {
      if (!Buffer3.isBuffer(v8)) {
        if (Array.isArray(v8)) {
          v8 = Buffer3.from(v8);
        } else if (typeof v8 === "string") {
          if (exports.isHexString(v8)) {
            v8 = Buffer3.from(exports.padToEven(exports.stripHexPrefix(v8)), "hex");
          } else {
            v8 = Buffer3.from(v8);
          }
        } else if (typeof v8 === "number") {
          v8 = exports.intToBuffer(v8);
        } else if (v8 === null || v8 === void 0) {
          v8 = Buffer3.allocUnsafe(0);
        } else if (BN6.isBN(v8)) {
          v8 = v8.toArrayLike(Buffer3);
        } else if (v8.toArray) {
          v8 = Buffer3.from(v8.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v8;
    };
    exports.bufferToInt = function(buf) {
      return new BN6(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN6(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer3.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a5, bits) {
      a5 = exports.toBuffer(a5);
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a5);
        }
        case 256: {
          return k256(a5);
        }
        case 384: {
          return keccak384(a5);
        }
        case 512: {
          return keccak512(a5);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a5) {
      return exports.keccak(a5);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a5) {
      a5 = exports.toBuffer(a5);
      return createHash("sha256").update(a5).digest();
    };
    exports.ripemd160 = function(a5, padded) {
      a5 = exports.toBuffer(a5);
      var hash4 = createHash("rmd160").update(a5).digest();
      if (padded === true) {
        return exports.setLength(hash4, 32);
      } else {
        return hash4;
      }
    };
    exports.rlphash = function(a5) {
      return exports.keccak(rlp.encode(a5));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k12.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey2, sanitize) {
      if (publicKey2.length === 64) {
        return secp256k12.publicKeyVerify(Buffer3.concat([Buffer3.from([4]), publicKey2]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k12.publicKeyVerify(publicKey2);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k12.publicKeyConvert(pubKey, false).slice(1);
      }
      assert5(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k12.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey2) {
      publicKey2 = exports.toBuffer(publicKey2);
      if (publicKey2.length !== 64) {
        publicKey2 = secp256k12.publicKeyConvert(publicKey2, false).slice(1);
      }
      return publicKey2;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k12.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer3.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v8, r6, s6) {
      var signature2 = Buffer3.concat([exports.setLength(r6, 32), exports.setLength(s6, 32)], 64);
      var recovery = v8 - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k12.recover(msgHash, signature2, recovery);
      return secp256k12.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v8, r6, s6) {
      if (v8 !== 27 && v8 !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer3.concat([exports.setLengthLeft(r6, 32), exports.setLengthLeft(s6, 32), exports.toBuffer(v8 - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v8 = sig[64];
      if (v8 < 27) {
        v8 += 27;
      }
      return {
        v: v8,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash4 = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i5 = 0; i5 < address.length; i5++) {
        if (parseInt(hash4[i5], 16) >= 8) {
          ret += address[i5].toUpperCase();
        } else {
          ret += address[i5];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from2, nonce) {
      from2 = exports.toBuffer(from2);
      nonce = new BN6(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer3.from(nonce.toArray());
      }
      return exports.rlphash([from2, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a5 = exports.unpad(address);
      return a5.length === 1 && a5[0] >= 1 && a5[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v8, r6, s6, homestead2) {
      var SECP256K1_N_DIV_2 = new BN6("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN6("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r6.length !== 32 || s6.length !== 32) {
        return false;
      }
      if (v8 !== 27 && v8 !== 28) {
        return false;
      }
      r6 = new BN6(r6);
      s6 = new BN6(s6);
      if (r6.isZero() || r6.gt(SECP256K1_N) || s6.isZero() || s6.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead2 === false && new BN6(s6).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer3.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array2 = [];
        for (var i5 = 0; i5 < ba.length; i5++) {
          array2.push(exports.baToJSON(ba[i5]));
        }
        return array2;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize4() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i5) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i5];
        }
        function setter(v8) {
          v8 = exports.toBuffer(v8);
          if (v8.toString("hex") === "00" && !field.allowZero) {
            v8 = Buffer3.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v8 = exports.stripZeros(v8);
            assert5(field.length >= v8.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v8.length === 0) && field.length) {
            assert5(field.length === v8.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i5] = v8;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer3.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer3.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d5, i5) {
            self2[self2._fields[i5]] = exports.toBuffer(d5);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys = Object.keys(data);
          fields.forEach(function(field) {
            if (keys.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, opts) => function() {
      const P4 = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i5 = 0; i5 < arguments.length; i5++) {
        args[i5] = arguments[i5];
      }
      return new P4((resolve, reject) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i5 = 1; i5 < arguments.length; i5++) {
                results2[i5 - 1] = arguments[i5];
              }
              if (err) {
                results2.unshift(err);
                reject(results2);
              } else {
                resolve(results2);
              }
            } else if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i5 = 0; i5 < arguments.length; i5++) {
                results2[i5] = arguments[i5];
              }
              resolve(results2);
            } else {
              resolve(result);
            }
          });
        }
        fn.apply(this, args);
      });
    };
    module.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter2 = (key2) => {
        const match = (pattern) => typeof pattern === "string" ? key2 === pattern : pattern.test(key2);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key2 in obj) {
        const x5 = obj[key2];
        ret[key2] = typeof x5 === "function" && filter2(key2) ? processFn(x5, opts) : x5;
      }
      return ret;
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i5 = 0; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key2 in source) {
          if (hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/json-rpc-random-id/index.js"(exports, module) {
    module.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max2 = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
      return function createRandomId() {
        idCounter = idCounter % max2;
        return idCounter++;
      };
    }
  }
});

// node_modules/eth-query/index.js
var require_eth_query = __commonJS({
  "node_modules/eth-query/index.js"(exports, module) {
    var extend = require_immutable();
    var createRandomId = require_json_rpc_random_id()();
    module.exports = EthQuery;
    function EthQuery(provider) {
      const self2 = this;
      self2.currentProvider = provider;
    }
    EthQuery.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
    EthQuery.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
    EthQuery.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
    EthQuery.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
    EthQuery.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
    EthQuery.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
    EthQuery.prototype.syncing = generateFnFor("eth_syncing");
    EthQuery.prototype.coinbase = generateFnFor("eth_coinbase");
    EthQuery.prototype.mining = generateFnFor("eth_mining");
    EthQuery.prototype.hashrate = generateFnFor("eth_hashrate");
    EthQuery.prototype.gasPrice = generateFnFor("eth_gasPrice");
    EthQuery.prototype.accounts = generateFnFor("eth_accounts");
    EthQuery.prototype.blockNumber = generateFnFor("eth_blockNumber");
    EthQuery.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
    EthQuery.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
    EthQuery.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
    EthQuery.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
    EthQuery.prototype.sign = generateFnFor("eth_sign");
    EthQuery.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
    EthQuery.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
    EthQuery.prototype.estimateGas = generateFnFor("eth_estimateGas");
    EthQuery.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
    EthQuery.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
    EthQuery.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
    EthQuery.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
    EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
    EthQuery.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
    EthQuery.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
    EthQuery.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
    EthQuery.prototype.getCompilers = generateFnFor("eth_getCompilers");
    EthQuery.prototype.compileLLL = generateFnFor("eth_compileLLL");
    EthQuery.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
    EthQuery.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
    EthQuery.prototype.newFilter = generateFnFor("eth_newFilter");
    EthQuery.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
    EthQuery.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
    EthQuery.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
    EthQuery.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
    EthQuery.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
    EthQuery.prototype.getLogs = generateFnFor("eth_getLogs");
    EthQuery.prototype.getWork = generateFnFor("eth_getWork");
    EthQuery.prototype.submitWork = generateFnFor("eth_submitWork");
    EthQuery.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
    EthQuery.prototype.sendAsync = function(opts, cb) {
      const self2 = this;
      self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
        if (!err && response.error)
          err = new Error("EthQuery - RPC Error - " + response.error.message);
        if (err)
          return cb(err);
        cb(null, response.result);
      });
    };
    function generateFnFor(methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function generateFnWithDefaultBlockFor(argCount, methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        if (args.length < argCount)
          args.push("latest");
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function createPayload(data) {
      return extend({
        id: createRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/safe-event-emitter/index.js
var require_safe_event_emitter = __commonJS({
  "node_modules/safe-event-emitter/index.js"(exports, module) {
    var util = require_util();
    var EventEmitter3 = require_events();
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    module.exports = SafeEventEmitter;
    function SafeEventEmitter() {
      EventEmitter3.call(this);
    }
    util.inherits(SafeEventEmitter, EventEmitter3);
    SafeEventEmitter.prototype.emit = function(type2) {
      var args = [];
      for (var i5 = 1; i5 < arguments.length; i5++)
        args.push(arguments[i5]);
      var doError = type2 === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type2];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i5 = 0; i5 < len; ++i5)
          safeApply(listeners[i5], this, args);
      }
      return true;
    };
    function safeApply(handler, context, args) {
      try {
        ReflectApply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr, n3) {
      var copy = new Array(n3);
      for (var i5 = 0; i5 < n3; ++i5)
        copy[i5] = arr[i5];
      return copy;
    }
  }
});

// node_modules/eth-block-tracker/src/base.js
var require_base2 = __commonJS({
  "node_modules/eth-block-tracker/src/base.js"(exports, module) {
    var EthQuery = require_eth_query();
    var pify = require_pify();
    var SafeEventEmitter = require_safe_event_emitter();
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends SafeEventEmitter {
      constructor(opts = {}) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._blockResetTimeout;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
      }
      _start() {
      }
      _end() {
      }
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName, handler) {
        if (!blockTrackerEvents.includes(eventName))
          return;
        this._maybeStart();
      }
      _onRemoveListener(eventName, handler) {
        if (this._getBlockTrackerEventCount() > 0)
          return;
        this._maybeEnd();
      }
      _maybeStart() {
        if (this._isRunning)
          return;
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        this._start();
      }
      _maybeEnd() {
        if (!this._isRunning)
          return;
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock))
          return;
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        clearTimeout(this._blockResetTimeout);
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    module.exports = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/eth-block-tracker/src/polling.js
var require_polling = __commonJS({
  "node_modules/eth-block-tracker/src/polling.js"(exports, module) {
    var pify = require_pify();
    var BaseBlockTracker = require_base2();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider)
          throw new Error("PollingBlockTracker - no provider specified.");
        const pollingInterval = opts.pollingInterval || 20 * sec;
        const retryTimeout = opts.retryTimeout || pollingInterval / 10;
        const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
        const setSkipCacheFlag = opts.setSkipCacheFlag || false;
        super(Object.assign({
          blockResetDuration: pollingInterval
        }, opts));
        this._provider = opts.provider;
        this._pollingInterval = pollingInterval;
        this._retryTimeout = retryTimeout;
        this._keepEventLoopActive = keepEventLoopActive;
        this._setSkipCacheFlag = setSkipCacheFlag;
      }
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      _start() {
        this._performSync().catch((err) => this.emit("error", err));
      }
      async _performSync() {
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            await timeout2(this._pollingInterval, !this._keepEventLoopActive);
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            await timeout2(this._retryTimeout, !this._keepEventLoopActive);
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
        if (this._setSkipCacheFlag)
          req.skipCache = true;
        const res = await pify((cb) => this._provider.sendAsync(req, cb))();
        if (res.error)
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
        return res.result;
      }
    };
    module.exports = PollingBlockTracker;
    function timeout2(duration, unref) {
      return new Promise((resolve) => {
        const timoutRef = setTimeout(resolve, duration);
        if (timoutRef.unref && unref) {
          timoutRef.unref();
        }
      });
    }
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e5) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject4(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    module.exports = isObject4;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject4 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject4(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction2;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction2 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    module.exports = isArrayLike2;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {};
    module.exports = exports["default"];
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop2() {
    }
    module.exports = noop2;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = once;
    function once(fn) {
      return function() {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    };
    var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
    module.exports = exports["default"];
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray2 = Array.isArray;
    module.exports = isArray2;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer3 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer2;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e5) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray2;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray2 = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike2 = require_isArrayLike();
    function keys(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterator2;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    var _keys = require_keys();
    var _keys2 = _interopRequireDefault(_keys);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i5 = -1;
      var len = coll.length;
      return function next() {
        return ++i5 < len ? { value: coll[i5], key: i5 } : null;
      };
    }
    function createES2015Iterator(iterator3) {
      var i5 = -1;
      return function next() {
        var item = iterator3.next();
        if (item.done)
          return null;
        i5++;
        return { value: item.value, key: i5 };
      };
    }
    function createObjectIterator(obj) {
      var okeys = (0, _keys2.default)(obj);
      var i5 = -1;
      var len = okeys.length;
      return function next() {
        var key2 = okeys[++i5];
        return i5 < len ? { value: obj[key2], key: key2 } : null;
      };
    }
    function iterator2(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator3 = (0, _getIterator2.default)(coll);
      return iterator3 ? createES2015Iterator(iterator3) : createObjectIterator(coll);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = onlyOnce;
    function onlyOnce(fn) {
      return function() {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _eachOfLimit;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _eachOfLimit(limit) {
      return function(obj, iteratee, callback) {
        callback = (0, _once2.default)(callback || _noop2.default);
        if (limit <= 0 || !obj) {
          return callback(null);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/slice.js
var require_slice = __commonJS({
  "node_modules/async/internal/slice.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = slice;
    function slice(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
        newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(fn) {
      return function() {
        var args = (0, _slice2.default)(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
      };
    };
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hasNextTick = exports.hasSetImmediate = void 0;
    exports.fallback = fallback;
    exports.wrap = wrap;
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer2) {
      return function(fn) {
        var args = (0, _slice2.default)(arguments, 1);
        defer2(function() {
          fn.apply(null, args);
        });
      };
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncify;
    var _isObject = require_isObject();
    var _isObject2 = _interopRequireDefault(_isObject);
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e5) {
          return callback(e5);
        }
        if ((0, _isObject2.default)(result) && typeof result.then === "function") {
          result.then(function(value) {
            invokeCallback(callback, null, value);
          }, function(err) {
            invokeCallback(callback, err.message ? err : new Error(err));
          });
        } else {
          callback(null, result);
        }
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (e5) {
        (0, _setImmediate2.default)(rethrow, e5);
      }
    }
    function rethrow(error) {
      throw error;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var supportsSymbol = typeof Symbol === "function";
    function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports.default = wrapAsync;
    exports.isAsync = isAsync;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachOfLimit;
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doLimit.js
var require_doLimit = __commonJS({
  "node_modules/async/internal/doLimit.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doLimit;
    function doLimit(fn, limit) {
      return function(iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    };
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      var index = 0, completed = 0, length = coll.length;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doParallel.js
var require_doParallel = __commonJS({
  "node_modules/async/internal/doParallel.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doParallel;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function doParallel(fn) {
      return function(obj, iteratee, callback) {
        return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/map.js
var require_map = __commonJS({
  "node_modules/async/internal/map.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _asyncMap;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      callback = callback || _noop2.default;
      arr = arr || [];
      var results2 = [];
      var counter = 0;
      var _iteratee = (0, _wrapAsync2.default)(iteratee);
      eachfn(arr, function(value, _10, callback2) {
        var index = counter++;
        _iteratee(value, function(err, v8) {
          results2[index] = v8;
          callback2(err);
        });
      }, function(err) {
        callback(err, results2);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/map.js
var require_map2 = __commonJS({
  "node_modules/async/map.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _doParallel = require_doParallel();
    var _doParallel2 = _interopRequireDefault(_doParallel);
    var _map = require_map();
    var _map2 = _interopRequireDefault(_map);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doParallel2.default)(_map2.default);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return function(value, index, callback) {
        return iteratee(value, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachLimit.js
var require_eachLimit = __commonJS({
  "node_modules/async/eachLimit.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachLimit;
    var _eachOfLimit = require_eachOfLimit();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachSeries.js
var require_eachSeries = __commonJS({
  "node_modules/async/eachSeries.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachLimit = require_eachLimit();
    var _eachLimit2 = _interopRequireDefault(_eachLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
    module.exports = exports["default"];
  }
});

// node_modules/web3-provider-engine/util/stoplight.js
var require_stoplight = __commonJS({
  "node_modules/web3-provider-engine/util/stoplight.js"(exports, module) {
    var EventEmitter3 = require_events().EventEmitter;
    var inherits2 = require_util().inherits;
    module.exports = Stoplight;
    inherits2(Stoplight, EventEmitter3);
    function Stoplight() {
      const self2 = this;
      EventEmitter3.call(self2);
      self2.isLocked = true;
    }
    Stoplight.prototype.go = function() {
      const self2 = this;
      self2.isLocked = false;
      self2.emit("unlock");
    };
    Stoplight.prototype.stop = function() {
      const self2 = this;
      self2.isLocked = true;
      self2.emit("lock");
    };
    Stoplight.prototype.await = function(fn) {
      const self2 = this;
      if (self2.isLocked) {
        self2.once("unlock", fn);
      } else {
        setTimeout(fn);
      }
    };
  }
});

// node_modules/jsonify/lib/parse.js
var require_parse = __commonJS({
  "node_modules/jsonify/lib/parse.js"(exports, module) {
    var at;
    var ch;
    var escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    };
    var text;
    var error = function(m5) {
      throw {
        name: "SyntaxError",
        message: m5,
        at,
        text
      };
    };
    var next = function(c5) {
      if (c5 && c5 !== ch) {
        error("Expected '" + c5 + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    };
    var number2 = function() {
      var number3, string3 = "";
      if (ch === "-") {
        string3 = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        string3 += ch;
        next();
      }
      if (ch === ".") {
        string3 += ".";
        while (next() && ch >= "0" && ch <= "9") {
          string3 += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        string3 += ch;
        next();
        if (ch === "-" || ch === "+") {
          string3 += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          string3 += ch;
          next();
        }
      }
      number3 = +string3;
      if (!isFinite(number3)) {
        error("Bad number");
      } else {
        return number3;
      }
    };
    var string2 = function() {
      var hex, i5, string3 = "", uffff;
      if (ch === '"') {
        while (next()) {
          if (ch === '"') {
            next();
            return string3;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i5 = 0; i5 < 4; i5 += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              string3 += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              string3 += escapee[ch];
            } else {
              break;
            }
          } else {
            string3 += ch;
          }
        }
      }
      error("Bad string");
    };
    var white = function() {
      while (ch && ch <= " ") {
        next();
      }
    };
    var word = function() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
      }
      error("Unexpected '" + ch + "'");
    };
    var value;
    var array2 = function() {
      var array3 = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return array3;
        }
        while (ch) {
          array3.push(value());
          white();
          if (ch === "]") {
            next("]");
            return array3;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    };
    var object = function() {
      var key2, object2 = {};
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return object2;
        }
        while (ch) {
          key2 = string2();
          white();
          next(":");
          if (Object.hasOwnProperty.call(object2, key2)) {
            error('Duplicate key "' + key2 + '"');
          }
          object2[key2] = value();
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    };
    value = function() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array2();
        case '"':
          return string2();
        case "-":
          return number2();
        default:
          return ch >= "0" && ch <= "9" ? number2() : word();
      }
    };
    module.exports = function(source, reviver) {
      var result;
      text = source;
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key2) {
        var k5, v8, value2 = holder[key2];
        if (value2 && typeof value2 === "object") {
          for (k5 in value2) {
            if (Object.prototype.hasOwnProperty.call(value2, k5)) {
              v8 = walk(value2, k5);
              if (v8 !== void 0) {
                value2[k5] = v8;
              } else {
                delete value2[k5];
              }
            }
          }
        }
        return reviver.call(holder, key2, value2);
      }({ "": result }, "") : result;
    };
  }
});

// node_modules/jsonify/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/jsonify/lib/stringify.js"(exports, module) {
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var gap;
    var indent;
    var meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var rep;
    function quote(string2) {
      escapable.lastIndex = 0;
      return escapable.test(string2) ? '"' + string2.replace(escapable, function(a5) {
        var c5 = meta[a5];
        return typeof c5 === "string" ? c5 : "\\u" + ("0000" + a5.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string2 + '"';
    }
    function str(key2, holder) {
      var i5, k5, v8, length, mind = gap, partial, value = holder[key2];
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key2);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key2, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
          return String(value);
        case "object":
          if (!value)
            return "null";
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i5 = 0; i5 < length; i5 += 1) {
              partial[i5] = str(i5, value) || "null";
            }
            v8 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v8;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i5 = 0; i5 < length; i5 += 1) {
              k5 = rep[i5];
              if (typeof k5 === "string") {
                v8 = str(k5, value);
                if (v8) {
                  partial.push(quote(k5) + (gap ? ": " : ":") + v8);
                }
              }
            }
          } else {
            for (k5 in value) {
              if (Object.prototype.hasOwnProperty.call(value, k5)) {
                v8 = str(k5, value);
                if (v8) {
                  partial.push(quote(k5) + (gap ? ": " : ":") + v8);
                }
              }
            }
          }
          v8 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v8;
      }
    }
    module.exports = function(value, replacer, space) {
      var i5;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i5 = 0; i5 < space; i5 += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str("", { "": value });
    };
  }
});

// node_modules/jsonify/index.js
var require_jsonify = __commonJS({
  "node_modules/jsonify/index.js"(exports) {
    exports.parse = require_parse();
    exports.stringify = require_stringify();
  }
});

// node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = __commonJS({
  "node_modules/json-stable-stringify/index.js"(exports, module) {
    var json = typeof JSON !== "undefined" ? JSON : require_jsonify();
    module.exports = function(obj, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var space = opts.space || "";
      if (typeof space === "number")
        space = Array(space + 1).join(" ");
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var replacer = opts.replacer || function(key2, value) {
        return value;
      };
      var cmp = opts.cmp && function(f7) {
        return function(node) {
          return function(a5, b4) {
            var aobj = { key: a5, value: node[a5] };
            var bobj = { key: b4, value: node[b4] };
            return f7(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify3(parent, key2, node, level) {
        var indent = space ? "\n" + new Array(level + 1).join(space) : "";
        var colonSeparator = space ? ": " : ":";
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        node = replacer.call(parent, key2, node);
        if (node === void 0) {
          return;
        }
        if (typeof node !== "object" || node === null) {
          return json.stringify(node);
        }
        if (isArray2(node)) {
          var out = [];
          for (var i5 = 0; i5 < node.length; i5++) {
            var item = stringify3(node, i5, node[i5], level + 1) || json.stringify(null);
            out.push(indent + space + item);
          }
          return "[" + out.join(",") + indent + "]";
        } else {
          if (seen.indexOf(node) !== -1) {
            if (cycles)
              return json.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          } else
            seen.push(node);
          var keys = objectKeys(node).sort(cmp && cmp(node));
          var out = [];
          for (var i5 = 0; i5 < keys.length; i5++) {
            var key2 = keys[i5];
            var value = stringify3(node, key2, node[key2], level + 1);
            if (!value)
              continue;
            var keyValue = json.stringify(key2) + colonSeparator + value;
            ;
            out.push(indent + space + keyValue);
          }
          seen.splice(seen.indexOf(node), 1);
          return "{" + out.join(",") + indent + "}";
        }
      }({ "": obj }, "", obj, 0);
    };
    var isArray2 = Array.isArray || function(x5) {
      return {}.toString.call(x5) === "[object Array]";
    };
    var objectKeys = Object.keys || function(obj) {
      var has = Object.prototype.hasOwnProperty || function() {
        return true;
      };
      var keys = [];
      for (var key2 in obj) {
        if (has.call(obj, key2))
          keys.push(key2);
      }
      return keys;
    };
  }
});

// node_modules/web3-provider-engine/util/rpc-cache-utils.js
var require_rpc_cache_utils = __commonJS({
  "node_modules/web3-provider-engine/util/rpc-cache-utils.js"(exports, module) {
    var stringify3 = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, opts = {}) {
      if (!canCache(payload))
        return null;
      const { includeBlockRef } = opts;
      const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify3(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/util/random-id.js
var require_random_id = __commonJS({
  "node_modules/web3-provider-engine/util/random-id.js"(exports, module) {
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/util/create-payload.js
var require_create_payload = __commonJS({
  "node_modules/web3-provider-engine/util/create-payload.js"(exports, module) {
    var getRandomId = require_random_id();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/index.js
var require_web3_provider_engine = __commonJS({
  "node_modules/web3-provider-engine/index.js"(exports, module) {
    var EventEmitter3 = require_events().EventEmitter;
    var inherits2 = require_util().inherits;
    var ethUtil = require_dist5();
    var EthBlockTracker = require_polling();
    var map2 = require_map2();
    var eachSeries = require_eachSeries();
    var Stoplight = require_stoplight();
    var cacheUtils = require_rpc_cache_utils();
    var createPayload = require_create_payload();
    var noop2 = function() {
    };
    module.exports = Web3ProviderEngine;
    inherits2(Web3ProviderEngine, EventEmitter3);
    function Web3ProviderEngine(opts) {
      const self2 = this;
      EventEmitter3.call(self2);
      self2.setMaxListeners(30);
      opts = opts || {};
      const directProvider = { sendAsync: self2._handleAsync.bind(self2) };
      const blockTrackerProvider = opts.blockTrackerProvider || directProvider;
      self2._blockTracker = opts.blockTracker || new EthBlockTracker({
        provider: blockTrackerProvider,
        pollingInterval: opts.pollingInterval || 4e3,
        setSkipCacheFlag: true
      });
      self2._ready = new Stoplight();
      self2.currentBlock = null;
      self2._providers = [];
    }
    Web3ProviderEngine.prototype.start = function(cb = noop2) {
      const self2 = this;
      self2._ready.go();
      self2._blockTracker.on("latest", (blockNumber) => {
        self2._getBlockByNumberWithRetry(blockNumber, (err, block) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          if (!block) {
            console.log(block);
            this.emit("error", new Error("Could not find block"));
            return;
          }
          const bufferBlock = toBufferBlock(block);
          self2._setCurrentBlock(bufferBlock);
          self2.emit("rawBlock", block);
          self2.emit("latest", block);
        });
      });
      self2._blockTracker.on("sync", self2.emit.bind(self2, "sync"));
      self2._blockTracker.on("error", self2.emit.bind(self2, "error"));
      self2._running = true;
      self2.emit("start");
    };
    Web3ProviderEngine.prototype.stop = function() {
      const self2 = this;
      self2._blockTracker.removeAllListeners();
      self2._running = false;
      self2.emit("stop");
    };
    Web3ProviderEngine.prototype.isRunning = function() {
      const self2 = this;
      return self2._running;
    };
    Web3ProviderEngine.prototype.addProvider = function(source, index) {
      const self2 = this;
      if (typeof index === "number") {
        self2._providers.splice(index, 0, source);
      } else {
        self2._providers.push(source);
      }
      source.setEngine(this);
    };
    Web3ProviderEngine.prototype.removeProvider = function(source) {
      const self2 = this;
      const index = self2._providers.indexOf(source);
      if (index < 0)
        throw new Error("Provider not found.");
      self2._providers.splice(index, 1);
    };
    Web3ProviderEngine.prototype.send = function(payload) {
      throw new Error("Web3ProviderEngine does not support synchronous requests.");
    };
    Web3ProviderEngine.prototype.sendAsync = function(payload, cb) {
      const self2 = this;
      self2._ready.await(function() {
        if (Array.isArray(payload)) {
          map2(payload, self2._handleAsync.bind(self2), cb);
        } else {
          self2._handleAsync(payload, cb);
        }
      });
    };
    Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {
      const self2 = this;
      let retriesRemaining = 5;
      attemptRequest();
      return;
      function attemptRequest() {
        self2._getBlockByNumber(blockNumber, afterRequest);
      }
      function afterRequest(err, block) {
        if (err)
          return cb(err);
        if (!block) {
          if (retriesRemaining > 0) {
            retriesRemaining--;
            setTimeout(function() {
              attemptRequest();
            }, 1e3);
            return;
          } else {
            cb(null, null);
            return;
          }
        }
        cb(null, block);
        return;
      }
    };
    Web3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {
      const req = createPayload({ method: "eth_getBlockByNumber", params: [blockNumber, false], skipCache: true });
      this._handleAsync(req, (err, res) => {
        if (err)
          return cb(err);
        return cb(null, res.result);
      });
    };
    Web3ProviderEngine.prototype._handleAsync = function(payload, finished2) {
      var self2 = this;
      var currentProvider = -1;
      var result = null;
      var error = null;
      var stack = [];
      next();
      function next(after) {
        currentProvider += 1;
        stack.unshift(after);
        if (currentProvider >= self2._providers.length) {
          end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));
        } else {
          try {
            var provider = self2._providers[currentProvider];
            provider.handleRequest(payload, next, end);
          } catch (e5) {
            end(e5);
          }
        }
      }
      function end(_error, _result) {
        error = _error;
        result = _result;
        eachSeries(stack, function(fn, callback) {
          if (fn) {
            fn(error, result, callback);
          } else {
            callback();
          }
        }, function() {
          var resultObj = {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            result
          };
          if (error != null) {
            resultObj.error = {
              message: error.stack || error.message || error,
              code: -32e3
            };
            finished2(error, resultObj);
          } else {
            finished2(null, resultObj);
          }
        });
      }
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function(block) {
      const self2 = this;
      self2.currentBlock = block;
      self2.emit("block", block);
    };
    function toBufferBlock(jsonBlock) {
      return {
        number: ethUtil.toBuffer(jsonBlock.number),
        hash: ethUtil.toBuffer(jsonBlock.hash),
        parentHash: ethUtil.toBuffer(jsonBlock.parentHash),
        nonce: ethUtil.toBuffer(jsonBlock.nonce),
        mixHash: ethUtil.toBuffer(jsonBlock.mixHash),
        sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),
        logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),
        transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),
        stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),
        receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
        miner: ethUtil.toBuffer(jsonBlock.miner),
        difficulty: ethUtil.toBuffer(jsonBlock.difficulty),
        totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),
        size: ethUtil.toBuffer(jsonBlock.size),
        extraData: ethUtil.toBuffer(jsonBlock.extraData),
        gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),
        gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),
        timestamp: ethUtil.toBuffer(jsonBlock.timestamp),
        transactions: jsonBlock.transactions
      };
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/util/random-id.js
var require_random_id2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/random-id.js"(exports, module) {
    "use strict";
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/util/create-payload.js
var require_create_payload2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/create-payload.js"(exports, module) {
    "use strict";
    var getRandomId = require_random_id2();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/subprovider.js
var require_subprovider = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/subprovider.js"(exports, module) {
    "use strict";
    var createPayload = require_create_payload2();
    module.exports = SubProvider;
    function SubProvider() {
    }
    SubProvider.prototype.setEngine = function(engine) {
      var self2 = this;
      if (self2.engine)
        return;
      self2.engine = engine;
      engine.on("block", function(block) {
        self2.currentBlock = block;
      });
      engine.on("start", function() {
        self2.start();
      });
      engine.on("stop", function() {
        self2.stop();
      });
    };
    SubProvider.prototype.handleRequest = function(payload, next, end) {
      throw new Error("Subproviders should override `handleRequest`.");
    };
    SubProvider.prototype.emitPayload = function(payload, cb) {
      var self2 = this;
      self2.engine.sendAsync(createPayload(payload), cb);
    };
    SubProvider.prototype.stop = function() {
    };
    SubProvider.prototype.start = function() {
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/json-rpc-engine-middleware.js
var require_json_rpc_engine_middleware = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/json-rpc-engine-middleware.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p5) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o6, p6) {
        o6.__proto__ = p6;
        return o6;
      };
      return _setPrototypeOf(o5, p5);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e5) {
        return false;
      }
    }
    function _getPrototypeOf(o5) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o6) {
        return o6.__proto__ || Object.getPrototypeOf(o6);
      };
      return _getPrototypeOf(o5);
    }
    var Subprovider = require_subprovider();
    var JsonRpcEngineMiddlewareSubprovider = function(_Subprovider) {
      _inherits(JsonRpcEngineMiddlewareSubprovider2, _Subprovider);
      var _super = _createSuper(JsonRpcEngineMiddlewareSubprovider2);
      function JsonRpcEngineMiddlewareSubprovider2(constructorFn) {
        var _this;
        _classCallCheck(this, JsonRpcEngineMiddlewareSubprovider2);
        _this = _super.call(this);
        if (!constructorFn)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - no constructorFn specified");
        _this._constructorFn = constructorFn;
        return _this;
      }
      _createClass(JsonRpcEngineMiddlewareSubprovider2, [{
        key: "setEngine",
        value: function setEngine(engine) {
          if (this.middleware)
            throw new Error("JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice");
          var blockTracker = engine._blockTracker;
          var middleware = this._constructorFn({
            engine,
            provider: engine,
            blockTracker
          });
          if (!middleware)
            throw new Error("JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware");
          if (typeof middleware !== "function")
            throw new Error("JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function");
          this.middleware = middleware;
        }
      }, {
        key: "handleRequest",
        value: function handleRequest(req, provEngNext, provEngEnd) {
          var res = {
            id: req.id
          };
          this.middleware(req, res, middlewareNext, middlewareEnd);
          function middlewareNext(handler) {
            provEngNext(function(err, result, cb) {
              if (err) {
                delete res.result;
                res.error = {
                  message: err.message || err
                };
              } else {
                res.result = result;
              }
              if (handler) {
                handler(cb);
              } else {
                cb();
              }
            });
          }
          function middlewareEnd(err) {
            if (err)
              return provEngEnd(err);
            provEngEnd(null, res.result);
          }
        }
      }]);
      return JsonRpcEngineMiddlewareSubprovider2;
    }(Subprovider);
    module.exports = JsonRpcEngineMiddlewareSubprovider;
  }
});

// node_modules/eth-json-rpc-middleware/cache-utils.js
var require_cache_utils = __commonJS({
  "node_modules/eth-json-rpc-middleware/cache-utils.js"(exports, module) {
    var stringify3 = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, skipBlockRef) {
      const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params;
      if (canCache(payload)) {
        return payload.method + ":" + stringify3(simpleParams);
      } else {
        return null;
      }
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      let index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      const index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
        case "test_permaCache":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
        case "test_forkCache":
          return "fork";
        case "eth_gasPrice":
        case "eth_blockNumber":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "test_blockCache":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
        case "test_neverCache":
          return "never";
      }
    }
  }
});

// node_modules/json-rpc-engine/src/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/src/createAsyncMiddleware.js"(exports, module) {
    module.exports = function createAsyncMiddleware(asyncMiddleware) {
      return (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback, nextWasCalled;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((callback) => {
            returnHandlerCallback = callback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        asyncMiddleware(req, res, asyncNext).then(async () => {
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        }).catch((error) => {
          if (returnHandlerCallback) {
            returnHandlerCallback(error);
          } else {
            end(error);
          }
        });
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/block-cache.js
var require_block_cache = __commonJS({
  "node_modules/eth-json-rpc-middleware/block-cache.js"(exports, module) {
    var cacheUtils = require_cache_utils();
    var createAsyncMiddleware = require_createAsyncMiddleware();
    var emptyValues = [void 0, null, "<nil>"];
    module.exports = createBlockCacheMiddleware;
    function createBlockCacheMiddleware(opts = {}) {
      const { blockTracker } = opts;
      if (!blockTracker)
        throw new Error("createBlockCacheMiddleware - No BlockTracker specified");
      const blockCache = new BlockCacheStrategy();
      const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache
      };
      return createAsyncMiddleware(async (req, res, next) => {
        if (req.skipCache) {
          return next();
        }
        const type2 = cacheUtils.cacheTypeForPayload(req);
        const strategy = strategies[type2];
        if (!strategy) {
          return next();
        }
        if (!strategy.canCacheRequest(req)) {
          return next();
        }
        let blockTag = cacheUtils.blockTagForPayload(req);
        if (!blockTag)
          blockTag = "latest";
        let requestedBlockNumber;
        if (blockTag === "earliest") {
          requestedBlockNumber = "0x00";
        } else if (blockTag === "latest") {
          const latestBlockNumber = await blockTracker.getLatestBlock();
          blockCache.clearBefore(latestBlockNumber);
          requestedBlockNumber = latestBlockNumber;
        } else {
          requestedBlockNumber = blockTag;
        }
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === void 0) {
          await next();
          await strategy.set(req, requestedBlockNumber, res.result);
        } else {
          res.result = cacheResult;
        }
      });
    }
    var BlockCacheStrategy = class {
      constructor() {
        this.cache = {};
      }
      getBlockCacheForPayload(payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        if (!blockCache) {
          const newCache = {};
          this.cache[blockNumber] = newCache;
          blockCache = newCache;
        }
        return blockCache;
      }
      async get(payload, requestedBlockNumber) {
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        if (!blockCache)
          return;
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        const cached = blockCache[identifier];
        return cached;
      }
      async set(payload, requestedBlockNumber, result) {
        const canCache = this.canCacheResult(payload, result);
        if (!canCache)
          return;
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        blockCache[identifier] = result;
      }
      canCacheRequest(payload) {
        if (!cacheUtils.canCache(payload)) {
          return false;
        }
        const blockTag = cacheUtils.blockTagForPayload(payload);
        if (blockTag === "pending") {
          return false;
        }
        return true;
      }
      canCacheResult(payload, result) {
        if (emptyValues.includes(result))
          return;
        if (["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(payload.method)) {
          if (!result || !result.blockHash || result.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000") {
            return false;
          }
        }
        return true;
      }
      clearBefore(oldBlockHex) {
        const self2 = this;
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        Object.keys(self2.cache).map(Number).filter((num) => num < oldBlockNumber).forEach((num) => delete self2.cache[num]);
      }
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/cache.js
var require_cache = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/cache.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p5) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o6, p6) {
        o6.__proto__ = p6;
        return o6;
      };
      return _setPrototypeOf(o5, p5);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e5) {
        return false;
      }
    }
    function _getPrototypeOf(o5) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o6) {
        return o6.__proto__ || Object.getPrototypeOf(o6);
      };
      return _getPrototypeOf(o5);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createBlockCacheMiddleware = require_block_cache();
    var BlockCacheSubprovider = function(_ProviderSubprovider) {
      _inherits(BlockCacheSubprovider2, _ProviderSubprovider);
      var _super = _createSuper(BlockCacheSubprovider2);
      function BlockCacheSubprovider2(opts) {
        _classCallCheck(this, BlockCacheSubprovider2);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker;
          return createBlockCacheMiddleware(Object.assign({
            blockTracker
          }, opts));
        });
      }
      return BlockCacheSubprovider2;
    }(ProviderSubprovider);
    module.exports = BlockCacheSubprovider;
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/fixture.js
var require_fixture = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/fixture.js"(exports, module) {
    "use strict";
    var inherits2 = require_util().inherits;
    var Subprovider = require_subprovider();
    module.exports = FixtureProvider;
    inherits2(FixtureProvider, Subprovider);
    function FixtureProvider(staticResponses) {
      var self2 = this;
      staticResponses = staticResponses || {};
      self2.staticResponses = staticResponses;
    }
    FixtureProvider.prototype.handleRequest = function(payload, next, end) {
      var self2 = this;
      var staticResponse = self2.staticResponses[payload.method];
      if (typeof staticResponse === "function") {
        staticResponse(payload, next, end);
      } else if (staticResponse !== void 0) {
        setTimeout(function() {
          return end(null, staticResponse);
        });
      } else {
        next();
      }
    };
  }
});

// node_modules/async-mutex/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/async-mutex/node_modules/tslib/tslib.js"(exports, module) {
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter22;
    var __generator5;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays2;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id2, v8) {
          return exports2[id2] = previous ? previous(id2, v8) : v8;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p5))
            d5[p5] = b4[p5];
      };
      __extends2 = function(d5, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics2(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
      __assign2 = Object.assign || function(t5) {
        for (var s6, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
          s6 = arguments[i5];
          for (var p5 in s6)
            if (Object.prototype.hasOwnProperty.call(s6, p5))
              t5[p5] = s6[p5];
        }
        return t5;
      };
      __rest = function(s6, e5) {
        var t5 = {};
        for (var p5 in s6)
          if (Object.prototype.hasOwnProperty.call(s6, p5) && e5.indexOf(p5) < 0)
            t5[p5] = s6[p5];
        if (s6 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i5 = 0, p5 = Object.getOwnPropertySymbols(s6); i5 < p5.length; i5++) {
            if (e5.indexOf(p5[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s6, p5[i5]))
              t5[p5[i5]] = s6[p5[i5]];
          }
        return t5;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d5;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r6 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i5 = decorators.length - 1; i5 >= 0; i5--)
            if (d5 = decorators[i5])
              r6 = (c5 < 3 ? d5(r6) : c5 > 3 ? d5(target, key2, r6) : d5(target, key2)) || r6;
        return c5 > 3 && r6 && Object.defineProperty(target, key2, r6), r6;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter22 = function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e5) {
              reject(e5);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e5) {
              reject(e5);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator5 = function(thisArg, body) {
        var _10 = { label: 0, sent: function() {
          if (t5[0] & 1)
            throw t5[1];
          return t5[1];
        }, trys: [], ops: [] }, f7, y5, t5, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n3) {
          return function(v8) {
            return step([n3, v8]);
          };
        }
        function step(op) {
          if (f7)
            throw new TypeError("Generator is already executing.");
          while (_10)
            try {
              if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
                return t5;
              if (y5 = 0, t5)
                op = [op[0] & 2, t5.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t5 = op;
                  break;
                case 4:
                  _10.label++;
                  return { value: op[1], done: false };
                case 5:
                  _10.label++;
                  y5 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _10.ops.pop();
                  _10.trys.pop();
                  continue;
                default:
                  if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _10 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                    _10.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _10.label < t5[1]) {
                    _10.label = t5[1];
                    t5 = op;
                    break;
                  }
                  if (t5 && _10.label < t5[2]) {
                    _10.label = t5[2];
                    _10.ops.push(op);
                    break;
                  }
                  if (t5[2])
                    _10.ops.pop();
                  _10.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _10);
            } catch (e5) {
              op = [6, e5];
              y5 = 0;
            } finally {
              f7 = t5 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m5, o5) {
        for (var p5 in m5)
          if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(o5, p5))
            __createBinding(o5, m5, p5);
      };
      __createBinding = Object.create ? function(o5, m5, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        Object.defineProperty(o5, k22, { enumerable: true, get: function() {
          return m5[k5];
        } });
      } : function(o5, m5, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        o5[k22] = m5[k5];
      };
      __values = function(o5) {
        var s6 = typeof Symbol === "function" && Symbol.iterator, m5 = s6 && o5[s6], i5 = 0;
        if (m5)
          return m5.call(o5);
        if (o5 && typeof o5.length === "number")
          return {
            next: function() {
              if (o5 && i5 >= o5.length)
                o5 = void 0;
              return { value: o5 && o5[i5++], done: !o5 };
            }
          };
        throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o5, n3) {
        var m5 = typeof Symbol === "function" && o5[Symbol.iterator];
        if (!m5)
          return o5;
        var i5 = m5.call(o5), r6, ar = [], e5;
        try {
          while ((n3 === void 0 || n3-- > 0) && !(r6 = i5.next()).done)
            ar.push(r6.value);
        } catch (error) {
          e5 = { error };
        } finally {
          try {
            if (r6 && !r6.done && (m5 = i5["return"]))
              m5.call(i5);
          } finally {
            if (e5)
              throw e5.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i5 = 0; i5 < arguments.length; i5++)
          ar = ar.concat(__read(arguments[i5]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s6 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)
          s6 += arguments[i5].length;
        for (var r6 = Array(s6), k5 = 0, i5 = 0; i5 < il; i5++)
          for (var a5 = arguments[i5], j5 = 0, jl = a5.length; j5 < jl; j5++, k5++)
            r6[k5] = a5[j5];
        return r6;
      };
      __spreadArray = function(to, from2, pack3) {
        if (pack3 || arguments.length === 2)
          for (var i5 = 0, l5 = from2.length, ar; i5 < l5; i5++) {
            if (ar || !(i5 in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i5);
              ar[i5] = from2[i5];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      __await = function(v8) {
        return this instanceof __await ? (this.v = v8, this) : new __await(v8);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g5 = generator.apply(thisArg, _arguments || []), i5, q5 = [];
        return i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
          return this;
        }, i5;
        function verb(n3) {
          if (g5[n3])
            i5[n3] = function(v8) {
              return new Promise(function(a5, b4) {
                q5.push([n3, v8, a5, b4]) > 1 || resume(n3, v8);
              });
            };
        }
        function resume(n3, v8) {
          try {
            step(g5[n3](v8));
          } catch (e5) {
            settle(q5[0][3], e5);
          }
        }
        function step(r6) {
          r6.value instanceof __await ? Promise.resolve(r6.value.v).then(fulfill, reject) : settle(q5[0][2], r6);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f7, v8) {
          if (f7(v8), q5.shift(), q5.length)
            resume(q5[0][0], q5[0][1]);
        }
      };
      __asyncDelegator = function(o5) {
        var i5, p5;
        return i5 = {}, verb("next"), verb("throw", function(e5) {
          throw e5;
        }), verb("return"), i5[Symbol.iterator] = function() {
          return this;
        }, i5;
        function verb(n3, f7) {
          i5[n3] = o5[n3] ? function(v8) {
            return (p5 = !p5) ? { value: __await(o5[n3](v8)), done: n3 === "return" } : f7 ? f7(v8) : v8;
          } : f7;
        }
      };
      __asyncValues = function(o5) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m5 = o5[Symbol.asyncIterator], i5;
        return m5 ? m5.call(o5) : (o5 = typeof __values === "function" ? __values(o5) : o5[Symbol.iterator](), i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
          return this;
        }, i5);
        function verb(n3) {
          i5[n3] = o5[n3] && function(v8) {
            return new Promise(function(resolve, reject) {
              v8 = o5[n3](v8), settle(resolve, reject, v8.done, v8.value);
            });
          };
        }
        function settle(resolve, reject, d5, v8) {
          Promise.resolve(v8).then(function(v9) {
            resolve({ value: v9, done: d5 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o5, v8) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v8 });
      } : function(o5, v8) {
        o5["default"] = v8;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k5 in mod)
            if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
              __createBinding(result, mod, k5);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f7) {
        if (kind === "a" && !f7)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f7 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f7 : kind === "a" ? f7.call(receiver) : f7 ? f7.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f7) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f7)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f7 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f7.call(receiver, value) : f7 ? f7.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter22);
      exporter("__generator", __generator5);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_189 = require_tslib();
    var Semaphore = function() {
      function Semaphore2(_maxConcurrency) {
        this._maxConcurrency = _maxConcurrency;
        this._queue = [];
        if (_maxConcurrency <= 0) {
          throw new Error("semaphore must be initialized to a positive value");
        }
        this._value = _maxConcurrency;
      }
      Semaphore2.prototype.acquire = function() {
        var _this = this;
        var locked = this.isLocked();
        var ticket = new Promise(function(r6) {
          return _this._queue.push(r6);
        });
        if (!locked)
          this._dispatch();
        return ticket;
      };
      Semaphore2.prototype.runExclusive = function(callback) {
        return tslib_189.__awaiter(this, void 0, void 0, function() {
          var _a2, value, release;
          return tslib_189.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.acquire()];
              case 1:
                _a2 = _b.sent(), value = _a2[0], release = _a2[1];
                _b.label = 2;
              case 2:
                _b.trys.push([2, , 4, 5]);
                return [4, callback(value)];
              case 3:
                return [2, _b.sent()];
              case 4:
                release();
                return [7];
              case 5:
                return [2];
            }
          });
        });
      };
      Semaphore2.prototype.isLocked = function() {
        return this._value <= 0;
      };
      Semaphore2.prototype.release = function() {
        if (this._maxConcurrency > 1) {
          throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
        }
        if (this._currentReleaser) {
          var releaser = this._currentReleaser;
          this._currentReleaser = void 0;
          releaser();
        }
      };
      Semaphore2.prototype._dispatch = function() {
        var _this = this;
        var nextConsumer = this._queue.shift();
        if (!nextConsumer)
          return;
        var released = false;
        this._currentReleaser = function() {
          if (released)
            return;
          released = true;
          _this._value++;
          _this._dispatch();
        };
        nextConsumer([this._value--, this._currentReleaser]);
      };
      return Semaphore2;
    }();
    exports.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_189 = require_tslib();
    var Semaphore_1 = require_Semaphore();
    var Mutex = function() {
      function Mutex2() {
        this._semaphore = new Semaphore_1.default(1);
      }
      Mutex2.prototype.acquire = function() {
        return tslib_189.__awaiter(this, void 0, void 0, function() {
          var _a2, releaser;
          return tslib_189.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._semaphore.acquire()];
              case 1:
                _a2 = _b.sent(), releaser = _a2[1];
                return [2, releaser];
            }
          });
        });
      };
      Mutex2.prototype.runExclusive = function(callback) {
        return this._semaphore.runExclusive(function() {
          return callback();
        });
      };
      Mutex2.prototype.isLocked = function() {
        return this._semaphore.isLocked();
      };
      Mutex2.prototype.release = function() {
        this._semaphore.release();
      };
      return Mutex2;
    }();
    exports.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    var tslib_189 = require_tslib();
    function withTimeout(sync, timeout2, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = new Error("timeout");
      }
      return {
        acquire: function() {
          return new Promise(function(resolve, reject) {
            return tslib_189.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, ticket, release;
              return tslib_189.__generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isTimeout = false;
                    setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout2);
                    return [4, sync.acquire()];
                  case 1:
                    ticket = _a2.sent();
                    if (isTimeout) {
                      release = Array.isArray(ticket) ? ticket[1] : ticket;
                      release();
                    } else {
                      resolve(ticket);
                    }
                    return [2];
                }
              });
            });
          });
        },
        runExclusive: function(callback) {
          return tslib_189.__awaiter(this, void 0, void 0, function() {
            var release, ticket;
            return tslib_189.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  release = function() {
                    return void 0;
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, , 7, 8]);
                  return [4, this.acquire()];
                case 2:
                  ticket = _a2.sent();
                  if (!Array.isArray(ticket))
                    return [3, 4];
                  release = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a2.sent()];
                case 4:
                  release = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a2.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release();
                  return [7];
                case 8:
                  return [2];
              }
            });
          });
        },
        release: function() {
          sync.release();
        },
        isLocked: function() {
          return sync.isLocked();
        }
      };
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/getUniqueId.js
var require_getUniqueId = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/getUniqueId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUniqueId = void 0;
    var MAX = 4294967295;
    var idCounter = Math.floor(Math.random() * MAX);
    function getUniqueId() {
      idCounter = (idCounter + 1) % MAX;
      return idCounter;
    }
    exports.getUniqueId = getUniqueId;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/idRemapMiddleware.js
var require_idRemapMiddleware = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/idRemapMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIdRemapMiddleware = void 0;
    var getUniqueId_1 = require_getUniqueId();
    function createIdRemapMiddleware() {
      return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done) => {
          req.id = originalId;
          res.id = originalId;
          done();
        });
      };
    }
    exports.createIdRemapMiddleware = createIdRemapMiddleware;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js
var require_createAsyncMiddleware2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAsyncMiddleware = void 0;
    function createAsyncMiddleware(asyncMiddleware) {
      return async (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((runReturnHandlersCallback) => {
            returnHandlerCallback = runReturnHandlersCallback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        try {
          await asyncMiddleware(req, res, asyncNext);
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        } catch (error) {
          if (returnHandlerCallback) {
            returnHandlerCallback(error);
          } else {
            end(error);
          }
        }
      };
    }
    exports.createAsyncMiddleware = createAsyncMiddleware;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js
var require_createScaffoldMiddleware = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScaffoldMiddleware = void 0;
    function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    }
    exports.createScaffoldMiddleware = createScaffoldMiddleware;
  }
});

// node_modules/@metamask/safe-event-emitter/index.js
var require_safe_event_emitter2 = __commonJS({
  "node_modules/@metamask/safe-event-emitter/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    function safeApply(handler, context, args) {
      try {
        Reflect.apply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr) {
      const n3 = arr.length;
      const copy = new Array(n3);
      for (let i5 = 0; i5 < n3; i5 += 1) {
        copy[i5] = arr[i5];
      }
      return copy;
    }
    var SafeEventEmitter = class extends events_1.EventEmitter {
      emit(type2, ...args) {
        let doError = type2 === "error";
        const events = this._events;
        if (events !== void 0) {
          doError = doError && events.error === void 0;
        } else if (!doError) {
          return false;
        }
        if (doError) {
          let er;
          if (args.length > 0) {
            [er] = args;
          }
          if (er instanceof Error) {
            throw er;
          }
          const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
          err.context = er;
          throw err;
        }
        const handler = events[type2];
        if (handler === void 0) {
          return false;
        }
        if (typeof handler === "function") {
          safeApply(handler, this, args);
        } else {
          const len = handler.length;
          const listeners = arrayClone(handler);
          for (let i5 = 0; i5 < len; i5 += 1) {
            safeApply(listeners[i5], this, args);
          }
        }
        return true;
      }
    };
    exports.default = SafeEventEmitter;
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_10) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k5, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k5);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k5, { value: replace });
          arr.push([parent, k5, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k5, replace]);
        }
      } else {
        parent[k5] = replace;
        arr.push([parent, k5, val]);
      }
    }
    function decirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i5;
      if (typeof val === "object" && val !== null) {
        for (i5 = 0; i5 < stack.length; i5++) {
          if (stack[i5] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i5 = 0; i5 < val.length; i5++) {
            decirc(val[i5], i5, i5, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i5 = 0; i5 < keys.length; i5++) {
            var key2 = keys[i5];
            decirc(val[key2], key2, i5, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a5, b4) {
      if (a5 < b4) {
        return -1;
      }
      if (a5 > b4) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_10) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i5;
      if (typeof val === "object" && val !== null) {
        for (i5 = 0; i5 < stack.length; i5++) {
          if (stack[i5] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_10) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i5 = 0; i5 < val.length; i5++) {
            deterministicDecirc(val[i5], i5, i5, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i5 = 0; i5 < keys.length; i5++) {
            var key2 = keys[i5];
            deterministicDecirc(val[key2], key2, i5, stack, val, depth, options);
            tmp[key2] = val[key2];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k5, val]);
            parent[k5] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k5, v8) {
        return v8;
      };
      return function(key2, val) {
        if (replacerStack.length > 0) {
          for (var i5 = 0; i5 < replacerStack.length; i5++) {
            var part = replacerStack[i5];
            if (part[1] === key2 && part[0] === val) {
              val = part[2];
              replacerStack.splice(i5, 1);
              break;
            }
          }
        }
        return replacer.call(this, key2, val);
      };
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_10, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/utils.js
var require_utils4 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a2, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key2) {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_12 = require_utils4();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_12.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_12.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_12 = require_utils4();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_12.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_12.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/JsonRpcEngine.js
var require_JsonRpcEngine = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/JsonRpcEngine.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcEngine = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter2());
    var eth_rpc_errors_1 = require_dist6();
    var JsonRpcEngine = class extends safe_event_emitter_1.default {
      constructor() {
        super();
        this._middleware = [];
      }
      push(middleware) {
        this._middleware.push(middleware);
      }
      handle(req, cb) {
        if (cb && typeof cb !== "function") {
          throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
          if (cb) {
            return this._handleBatch(req, cb);
          }
          return this._handleBatch(req);
        }
        if (cb) {
          return this._handle(req, cb);
        }
        return this._promiseHandle(req);
      }
      asMiddleware() {
        return async (req, res, next, end) => {
          try {
            const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
            if (isComplete) {
              await JsonRpcEngine._runReturnHandlers(returnHandlers);
              return end(middlewareError);
            }
            return next(async (handlerCallback) => {
              try {
                await JsonRpcEngine._runReturnHandlers(returnHandlers);
              } catch (error) {
                return handlerCallback(error);
              }
              return handlerCallback();
            });
          } catch (error) {
            return end(error);
          }
        };
      }
      async _handleBatch(reqs, cb) {
        try {
          const responses = await Promise.all(reqs.map(this._promiseHandle.bind(this)));
          if (cb) {
            return cb(null, responses);
          }
          return responses;
        } catch (error) {
          if (cb) {
            return cb(error);
          }
          throw error;
        }
      }
      _promiseHandle(req) {
        return new Promise((resolve) => {
          this._handle(req, (_err, res) => {
            resolve(res);
          });
        });
      }
      async _handle(callerReq, cb) {
        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
          return cb(error2, { id: void 0, jsonrpc: "2.0", error: error2 });
        }
        if (typeof callerReq.method !== "string") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
          return cb(error2, { id: callerReq.id, jsonrpc: "2.0", error: error2 });
        }
        const req = Object.assign({}, callerReq);
        const res = {
          id: req.id,
          jsonrpc: req.jsonrpc
        };
        let error = null;
        try {
          await this._processRequest(req, res);
        } catch (_error) {
          error = _error;
        }
        if (error) {
          delete res.result;
          if (!res.error) {
            res.error = eth_rpc_errors_1.serializeError(error);
          }
        }
        return cb(error, res);
      }
      async _processRequest(req, res) {
        const [error, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        if (error) {
          throw error;
        }
      }
      static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        for (const middleware of middlewareStack) {
          [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
          if (isComplete) {
            break;
          }
        }
        return [error, isComplete, returnHandlers.reverse()];
      }
      static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
          const end = (err) => {
            const error = err || res.error;
            if (error) {
              res.error = eth_rpc_errors_1.serializeError(error);
            }
            resolve([error, true]);
          };
          const next = (returnHandler) => {
            if (res.error) {
              end(res.error);
            } else {
              if (returnHandler) {
                if (typeof returnHandler !== "function") {
                  end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
                }
                returnHandlers.push(returnHandler);
              }
              resolve([null, false]);
            }
          };
          try {
            middleware(req, res, next, end);
          } catch (error) {
            end(error);
          }
        });
      }
      static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
          await new Promise((resolve, reject) => {
            handler((err) => err ? reject(err) : resolve());
          });
        }
      }
      static _checkForCompletion(req, res, isComplete) {
        if (!("result" in res) && !("error" in res)) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
        }
      }
    };
    exports.JsonRpcEngine = JsonRpcEngine;
    function jsonify(request) {
      return JSON.stringify(request, null, 2);
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/mergeMiddleware.js
var require_mergeMiddleware = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/mergeMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMiddleware = void 0;
    var JsonRpcEngine_1 = require_JsonRpcEngine();
    function mergeMiddleware(middlewareStack) {
      const engine = new JsonRpcEngine_1.JsonRpcEngine();
      middlewareStack.forEach((middleware) => engine.push(middleware));
      return engine.asMiddleware();
    }
    exports.mergeMiddleware = mergeMiddleware;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
          __createBinding(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_idRemapMiddleware(), exports);
    __exportStar(require_createAsyncMiddleware2(), exports);
    __exportStar(require_createScaffoldMiddleware(), exports);
    __exportStar(require_getUniqueId(), exports);
    __exportStar(require_JsonRpcEngine(), exports);
    __exportStar(require_mergeMiddleware(), exports);
  }
});

// node_modules/json-rpc-engine/src/createScaffoldMiddleware.js
var require_createScaffoldMiddleware2 = __commonJS({
  "node_modules/json-rpc-engine/src/createScaffoldMiddleware.js"(exports, module) {
    module.exports = function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/scaffold.js
var require_scaffold = __commonJS({
  "node_modules/eth-json-rpc-middleware/scaffold.js"(exports, module) {
    module.exports = require_createScaffoldMiddleware2();
  }
});

// node_modules/eth-json-rpc-filters/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
      const P4 = options.promiseModule;
      return new P4((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self2 = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self2, arguments_);
      });
    };
    var filterCache = new WeakMap();
    module.exports = (input, options) => {
      options = __spreadValues({
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options);
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter2 = (target, key2) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key2 in cached) {
          return cached[key2];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key2 === "symbol" ? key2 === pattern : pattern.test(key2);
        const desc = Reflect.getOwnPropertyDescriptor(target, key2);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key2] = shouldFilter;
        return shouldFilter;
      };
      const cache = new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key2) {
          const property = target[key2];
          if (!filter2(target, key2) || property === Function.prototype[key2]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/eth-json-rpc-filters/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter2().default;
    var BaseFilter = class extends SafeEventEmitter {
      constructor() {
        super();
        this.updates = [];
      }
      async initialize() {
      }
      async update() {
        throw new Error("BaseFilter - no update method specified");
      }
      addResults(newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach((result) => this.emit("update", result));
      }
      addInitialResults(newResults) {
      }
      getChangesAndClear() {
        const updates = this.updates;
        this.updates = [];
        return updates;
      }
    };
    module.exports = BaseFilter;
  }
});

// node_modules/eth-json-rpc-filters/base-filter-history.js
var require_base_filter_history = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter-history.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var BaseFilterWithHistory = class extends BaseFilter {
      constructor() {
        super();
        this.allResults = [];
      }
      async update() {
        throw new Error("BaseFilterWithHistory - no update method specified");
      }
      addResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }
      addInitialResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }
      getAllResults() {
        return this.allResults;
      }
    };
    module.exports = BaseFilterWithHistory;
  }
});

// node_modules/eth-json-rpc-filters/hexUtils.js
var require_hexUtils = __commonJS({
  "node_modules/eth-json-rpc-filters/hexUtils.js"(exports, module) {
    module.exports = {
      minBlockRef,
      maxBlockRef,
      sortBlockRefs,
      bnToHex: bnToHex2,
      blockRefIsNumber,
      hexToInt,
      incrementHexInt,
      intToHex,
      unsafeRandomBytes
    };
    function minBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0];
    }
    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length - 1];
    }
    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === "latest" || refB === "earliest")
          return 1;
        if (refB === "latest" || refA === "earliest")
          return -1;
        return hexToInt(refA) - hexToInt(refB);
      });
    }
    function bnToHex2(bn) {
      return "0x" + bn.toString(16);
    }
    function blockRefIsNumber(blockRef) {
      return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function incrementHexInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      const value = hexToInt(hexString);
      return intToHex(value + 1);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad)
        hexString = "0" + hexString;
      return "0x" + hexString;
    }
    function unsafeRandomBytes(byteCount) {
      let result = "0x";
      for (let i5 = 0; i5 < byteCount; i5++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result;
    }
    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16);
    }
  }
});

// node_modules/eth-json-rpc-filters/log-filter.js
var require_log_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/log-filter.js"(exports, module) {
    var EthQuery = require_eth_query();
    var pify = require_pify2();
    var BaseFilterWithHistory = require_base_filter_history();
    var { bnToHex: bnToHex2, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require_hexUtils();
    var LogFilter = class extends BaseFilterWithHistory {
      constructor({ provider, params }) {
        super();
        this.type = "log";
        this.ethQuery = new EthQuery(provider);
        this.params = Object.assign({
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: []
        }, params);
        if (this.params.address) {
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          this.params.address = this.params.address.map((address) => address.toLowerCase());
        }
      }
      async initialize({ currentBlock }) {
        let fromBlock = this.params.fromBlock;
        if (["latest", "pending"].includes(fromBlock))
          fromBlock = currentBlock;
        if (fromBlock === "earliest")
          fromBlock = "0x0";
        this.params.fromBlock = fromBlock;
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        let fromBlock;
        if (oldBlock) {
          fromBlock = incrementHexInt(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter((log) => this.matchLog(log));
        this.addResults(matchingLogs);
      }
      async _fetchLogs(params) {
        const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
        return newLogs;
      }
      matchLog(log) {
        if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber))
          return false;
        if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber))
          return false;
        const normalizedLogAddress = log.address && log.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
          return false;
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          let logTopic = log.topics[index];
          if (!logTopic)
            return false;
          logTopic = logTopic.toLowerCase();
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard)
            return true;
          subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch;
        });
        return topicsMatch;
      }
    };
    module.exports = LogFilter;
  }
});

// node_modules/eth-json-rpc-filters/getBlocksForRange.js
var require_getBlocksForRange = __commonJS({
  "node_modules/eth-json-rpc-filters/getBlocksForRange.js"(exports, module) {
    module.exports = getBlocksForRange;
    async function getBlocksForRange({ provider, fromBlock, toBlock }) {
      if (!fromBlock)
        fromBlock = toBlock;
      const fromBlockNumber = hexToInt(fromBlock);
      const toBlockNumber = hexToInt(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      const missingBlockNumbers = Array(blockCountToQuery).fill().map((_10, index) => fromBlockNumber + index).map(intToHex);
      const blockBodies = await Promise.all(missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false])));
      return blockBodies;
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      const hexString = int.toString(16);
      return "0x" + hexString;
    }
    function query(provider, method, params) {
      return new Promise((resolve, reject) => {
        provider.sendAsync({ id: 1, jsonrpc: "2.0", method, params }, (err, res) => {
          if (err)
            return reject(err);
          resolve(res.result);
        });
      });
    }
  }
});

// node_modules/eth-json-rpc-filters/block-filter.js
var require_block_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/block-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var BlockFilter = class extends BaseFilter {
      constructor({ provider, params }) {
        super();
        this.type = "block";
        this.provider = provider;
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }
    };
    module.exports = BlockFilter;
  }
});

// node_modules/eth-json-rpc-filters/tx-filter.js
var require_tx_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/tx-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var TxFilter = class extends BaseFilter {
      constructor({ provider }) {
        super();
        this.type = "tx";
        this.provider = provider;
      }
      async update({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks) {
          blockTxHashes.push(...block.transactions);
        }
        this.addResults(blockTxHashes);
      }
    };
    module.exports = TxFilter;
  }
});

// node_modules/eth-json-rpc-filters/index.js
var require_eth_json_rpc_filters = __commonJS({
  "node_modules/eth-json-rpc-filters/index.js"(exports, module) {
    var Mutex = require_lib6().Mutex;
    var { createAsyncMiddleware } = require_dist7();
    var createJsonRpcMiddleware = require_scaffold();
    var LogFilter = require_log_filter();
    var BlockFilter = require_block_filter();
    var TxFilter = require_tx_filter();
    var { intToHex, hexToInt } = require_hexUtils();
    module.exports = createEthFilterMiddleware;
    function createEthFilterMiddleware({ blockTracker, provider }) {
      let filterIndex = 0;
      let filters = {};
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });
      const middleware = createJsonRpcMiddleware({
        eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
      });
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0)
          return;
        const releaseLock = await mutex.acquire();
        try {
          await Promise.all(objValues(filters).map(async (filter2) => {
            try {
              await filter2.update({ oldBlock, newBlock });
            } catch (err) {
              console.error(err);
            }
          }));
        } catch (err) {
          console.error(err);
        }
        releaseLock();
      };
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;
      middleware.destroy = () => {
        uninstallAllFilters();
      };
      return middleware;
      async function newLogFilter(params) {
        const filter2 = new LogFilter({ provider, params });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newBlockFilter() {
        const filter2 = new BlockFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newPendingTransactionFilter() {
        const filter2 = new TxFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function getFilterChanges(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        const results2 = filter2.getChangesAndClear();
        return results2;
      }
      async function getFilterLogs(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        if (filter2.type === "log") {
          results = filter2.getAllResults();
        } else {
          results = [];
        }
        return results;
      }
      async function uninstallFilterHandler(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        const result = Boolean(filter2);
        if (result) {
          await uninstallFilter(filterIndex2);
        }
        return result;
      }
      async function installFilter(filter2) {
        const prevFilterCount = objValues(filters).length;
        const currentBlock = await blockTracker.getLatestBlock();
        await filter2.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter2;
        filter2.id = filterIndex;
        filter2.idHex = intToHex(filterIndex);
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex;
      }
      async function uninstallFilter(filterIndex2) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex2];
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }
      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }
      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on("sync", filterUpdater);
          return;
        }
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener("sync", filterUpdater);
          return;
        }
      }
    }
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter2 = await createFilterFn(...args);
        const result = intToHex(filter2.id);
        return result;
      });
    }
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      });
    }
    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        };
      };
    }
    function objValues(obj, fn) {
      const values = [];
      for (let key2 in obj) {
        values.push(obj[key2]);
      }
      return values;
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/filters.js
var require_filters = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/filters.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p5) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o6, p6) {
        o6.__proto__ = p6;
        return o6;
      };
      return _setPrototypeOf(o5, p5);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e5) {
        return false;
      }
    }
    function _getPrototypeOf(o5) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o6) {
        return o6.__proto__ || Object.getPrototypeOf(o6);
      };
      return _getPrototypeOf(o5);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var SubscriptionsSubprovider3 = function(_ProviderSubprovider) {
      _inherits(SubscriptionsSubprovider4, _ProviderSubprovider);
      var _super = _createSuper(SubscriptionsSubprovider4);
      function SubscriptionsSubprovider4() {
        _classCallCheck(this, SubscriptionsSubprovider4);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker, provider = _ref.provider, engine = _ref.engine;
          return createFilterMiddleware({
            blockTracker,
            provider
          });
        });
      }
      return SubscriptionsSubprovider4;
    }(ProviderSubprovider);
    module.exports = SubscriptionsSubprovider3;
  }
});

// node_modules/async/waterfall.js
var require_waterfall = __commonJS({
  "node_modules/async/waterfall.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(tasks, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      if (!(0, _isArray2.default)(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        args.push((0, _onlyOnce2.default)(next));
        task.apply(null, args);
      }
      function next(err) {
        if (err || taskIndex === tasks.length) {
          return callback.apply(null, arguments);
        }
        nextTask((0, _slice2.default)(arguments, 1));
      }
      nextTask([]);
    };
    var _isArray = require_isArray();
    var _isArray2 = _interopRequireDefault(_isArray);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _parallel;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _parallel(eachfn, tasks, callback) {
      callback = callback || _noop2.default;
      var results2 = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, function(task, key2, callback2) {
        (0, _wrapAsync2.default)(task)(function(err, result) {
          if (arguments.length > 2) {
            result = (0, _slice2.default)(arguments, 1);
          }
          results2[key2] = result;
          callback2(err);
        });
      }, function(err) {
        callback(err, results2);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/async/parallel.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parallelLimit;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _parallel = require_parallel();
    var _parallel2 = _interopRequireDefault(_parallel);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parallelLimit(tasks, callback) {
      (0, _parallel2.default)(_eachOf2.default, tasks, callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js
var require_secp256k1v3_lib = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BN6 = require_bn3();
    var EC2 = require_elliptic().ec;
    var ec2 = new EC2("secp256k1");
    var ecparams = ec2.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var d5 = new BN6(privateKey);
      if (d5.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point3 = ec2.g.mul(d5);
      return toPublicKey(point3.getX(), point3.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN6(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r6 = new BN6(sigObj.r);
      if (r6.ucmp(ecparams.n) >= 0) {
        r6 = new BN6(0);
      }
      var s6 = new BN6(sigObj.s);
      if (s6.ucmp(ecparams.n) >= 0) {
        s6 = new BN6(0);
      }
      return Buffer.concat([r6.toArrayLike(Buffer, "be", 32), s6.toArrayLike(Buffer, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey2, privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var point3 = ec2.keyFromPublic(publicKey2);
      var scalar = new BN6(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point3.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function(x5, y5, compressed) {
      var publicKey2;
      if (compressed) {
        publicKey2 = Buffer.alloc(33);
        publicKey2[0] = y5.isOdd() ? 3 : 2;
        x5.toArrayLike(Buffer, "be", 32).copy(publicKey2, 1);
      } else {
        publicKey2 = Buffer.alloc(65);
        publicKey2[0] = 4;
        x5.toArrayLike(Buffer, "be", 32).copy(publicKey2, 1);
        y5.toArrayLike(Buffer, "be", 32).copy(publicKey2, 33);
      }
      return publicKey2;
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js
var require_der3 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey2, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey2.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature2) {
      var r6 = Buffer.alloc(32, 0);
      var s6 = Buffer.alloc(32, 0);
      var length = signature2.length;
      var index = 0;
      if (signature2[index++] !== 48) {
        return null;
      }
      var lenbyte = signature2[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature2[index++] !== 2) {
        return null;
      }
      var rlen = signature2[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature2[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          rlen = (rlen << 8) + signature2[index];
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature2[index++] !== 2) {
        return null;
      }
      var slen = signature2[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature2[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          slen = (slen << 8) + signature2[index];
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature2[rindex] === 0; rlen -= 1, rindex += 1)
        ;
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature2.slice(rindex, rindex + rlen);
      rvalue.copy(r6, 32 - rvalue.length);
      for (; slen > 0 && signature2[sindex] === 0; slen -= 1, sindex += 1)
        ;
      if (slen > 32) {
        return null;
      }
      var svalue = signature2.slice(sindex, sindex + slen);
      svalue.copy(s6, 32 - svalue.length);
      return { r: r6, s: s6 };
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js
var require_secp256k1v3_adapter = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
    var secp256k12 = require_secp256k12();
    var secp256k1v3 = require_secp256k1v3_lib();
    var der = require_der3();
    exports.privateKeyVerify = function(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k12.privateKeyVerify(Uint8Array.from(privateKey));
    };
    exports.privateKeyExport = function(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey2 = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey2, compressed);
    };
    exports.privateKeyImport = function(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    exports.privateKeyNegate = function(privateKey) {
      return Buffer.from(secp256k12.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    exports.privateKeyModInverse = function(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    exports.privateKeyTweakAdd = function(privateKey, tweak) {
      return Buffer.from(secp256k12.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    exports.privateKeyTweakMul = function(privateKey, tweak) {
      return Buffer.from(secp256k12.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    exports.publicKeyCreate = function(privateKey, compressed) {
      return Buffer.from(secp256k12.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    exports.publicKeyConvert = function(publicKey2, compressed) {
      return Buffer.from(secp256k12.publicKeyConvert(Uint8Array.from(publicKey2), compressed));
    };
    exports.publicKeyVerify = function(publicKey2) {
      if (publicKey2.length !== 33 && publicKey2.length !== 65) {
        return false;
      }
      return secp256k12.publicKeyVerify(Uint8Array.from(publicKey2));
    };
    exports.publicKeyTweakAdd = function(publicKey2, tweak, compressed) {
      return Buffer.from(secp256k12.publicKeyTweakAdd(Uint8Array.from(publicKey2), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyTweakMul = function(publicKey2, tweak, compressed) {
      return Buffer.from(secp256k12.publicKeyTweakMul(Uint8Array.from(publicKey2), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyCombine = function(publicKeys, compressed) {
      var keys = [];
      publicKeys.forEach(function(publicKey2) {
        keys.push(Uint8Array.from(publicKey2));
      });
      return Buffer.from(secp256k12.publicKeyCombine(keys, compressed));
    };
    exports.signatureNormalize = function(signature2) {
      return Buffer.from(secp256k12.signatureNormalize(Uint8Array.from(signature2)));
    };
    exports.signatureExport = function(signature2) {
      return Buffer.from(secp256k12.signatureExport(Uint8Array.from(signature2)));
    };
    exports.signatureImport = function(signature2) {
      return Buffer.from(secp256k12.signatureImport(Uint8Array.from(signature2)));
    };
    exports.signatureImportLax = function(signature2) {
      if (signature2.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature2);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    exports.sign = function(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length != 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer.from(algo) : null;
            var bufferData = data != null ? Buffer.from(data) : null;
            var buffer2 = Buffer.from("");
            if (options.noncefn) {
              buffer2 = options.noncefn(Buffer.from(message2), Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return new Uint8Array(buffer2);
          };
        }
      }
      var sig = secp256k12.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid
      };
    };
    exports.verify = function(message, signature2, publicKey2) {
      return secp256k12.ecdsaVerify(Uint8Array.from(signature2), Uint8Array.from(message), publicKey2);
    };
    exports.recover = function(message, signature2, recid, compressed) {
      return Buffer.from(secp256k12.ecdsaRecover(Uint8Array.from(signature2), recid, Uint8Array.from(message), compressed));
    };
    exports.ecdh = function(publicKey2, privateKey) {
      return Buffer.from(secp256k12.ecdh(Uint8Array.from(publicKey2), Uint8Array.from(privateKey), {}));
    };
    exports.ecdhUnsafe = function(publicKey2, privateKey, compressed) {
      if (publicKey2.length !== 33 && publicKey2.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey2), Uint8Array.from(privateKey), compressed));
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js
var require_constants2 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
    var BN6 = require_bn3();
    exports.MAX_INTEGER = new BN6("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN6("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, "hex");
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js
var require_bytes = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
    var ethjsUtil = require_lib5();
    var BN6 = require_bn3();
    exports.zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.setLengthLeft = function(msg, length, right) {
      if (right === void 0) {
        right = false;
      }
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLength = exports.setLengthLeft;
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = function(a5) {
      a5 = ethjsUtil.stripHexPrefix(a5);
      var first2 = a5[0];
      while (a5.length > 0 && first2.toString() === "0") {
        a5 = a5.slice(1);
        first2 = a5[0];
      }
      return a5;
    };
    exports.stripZeros = exports.unpad;
    exports.toBuffer = function(v8) {
      if (!Buffer.isBuffer(v8)) {
        if (Array.isArray(v8)) {
          v8 = Buffer.from(v8);
        } else if (typeof v8 === "string") {
          if (ethjsUtil.isHexString(v8)) {
            v8 = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v8)), "hex");
          } else {
            throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v8);
          }
        } else if (typeof v8 === "number") {
          v8 = ethjsUtil.intToBuffer(v8);
        } else if (v8 === null || v8 === void 0) {
          v8 = Buffer.allocUnsafe(0);
        } else if (BN6.isBN(v8)) {
          v8 = v8.toArrayLike(Buffer);
        } else if (v8.toArray) {
          v8 = Buffer.from(v8.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v8;
    };
    exports.bufferToInt = function(buf) {
      return new BN6(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN6(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer.from(num.toTwos(256).toArray());
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return ethjsUtil.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array2 = [];
        for (var i5 = 0; i5 < ba.length; i5++) {
          array2.push(exports.baToJSON(ba[i5]));
        }
        return array2;
      }
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js
var require_hash3 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
    var _a2 = require_keccak5();
    var keccak224 = _a2.keccak224;
    var keccak384 = _a2.keccak384;
    var k256 = _a2.keccak256;
    var keccak512 = _a2.keccak512;
    var createHash = require_browser3();
    var ethjsUtil = require_lib5();
    var rlp = require_dist3();
    var bytes_1 = require_bytes();
    exports.keccak = function(a5, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      if (typeof a5 === "string" && !ethjsUtil.isHexString(a5)) {
        a5 = Buffer.from(a5, "utf8");
      } else {
        a5 = bytes_1.toBuffer(a5);
      }
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a5);
        }
        case 256: {
          return k256(a5);
        }
        case 384: {
          return keccak384(a5);
        }
        case 512: {
          return keccak512(a5);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a5) {
      return exports.keccak(a5);
    };
    exports.sha256 = function(a5) {
      a5 = bytes_1.toBuffer(a5);
      return createHash("sha256").update(a5).digest();
    };
    exports.ripemd160 = function(a5, padded) {
      a5 = bytes_1.toBuffer(a5);
      var hash4 = createHash("rmd160").update(a5).digest();
      if (padded === true) {
        return bytes_1.setLength(hash4, 32);
      } else {
        return hash4;
      }
    };
    exports.rlphash = function(a5) {
      return exports.keccak(rlp.encode(a5));
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js
var require_account = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
    var assert5 = (init_assert(), assert_exports);
    var ethjsUtil = require_lib5();
    var secp256k12 = require_secp256k1v3_adapter();
    var BN6 = require_bn3();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash3();
    exports.zeroAddress = function() {
      var addressLength = 20;
      var addr = bytes_1.zeros(addressLength);
      return bytes_1.bufferToHex(addr);
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddr = exports.zeroAddress();
      return zeroAddr === bytes_1.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address, eip1191ChainId) {
      address = ethjsUtil.stripHexPrefix(address).toLowerCase();
      var prefix = eip1191ChainId !== void 0 ? eip1191ChainId.toString() + "0x" : "";
      var hash4 = hash_1.keccak(prefix + address).toString("hex");
      var ret = "0x";
      for (var i5 = 0; i5 < address.length; i5++) {
        if (parseInt(hash4[i5], 16) >= 8) {
          ret += address[i5].toUpperCase();
        } else {
          ret += address[i5];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address, eip1191ChainId) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
    };
    exports.generateAddress = function(from2, nonce) {
      from2 = bytes_1.toBuffer(from2);
      var nonceBN = new BN6(nonce);
      if (nonceBN.isZero()) {
        return hash_1.rlphash([from2, null]).slice(-20);
      }
      return hash_1.rlphash([from2, Buffer.from(nonceBN.toArray())]).slice(-20);
    };
    exports.generateAddress2 = function(from2, salt, initCode) {
      var fromBuf = bytes_1.toBuffer(from2);
      var saltBuf = bytes_1.toBuffer(salt);
      var initCodeBuf = bytes_1.toBuffer(initCode);
      assert5(fromBuf.length === 20);
      assert5(saltBuf.length === 32);
      var address = hash_1.keccak256(Buffer.concat([Buffer.from("ff", "hex"), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
      return address.slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a5 = bytes_1.unpad(address);
      return a5.length === 1 && a5[0] >= 1 && a5[0] <= 8;
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k12.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey2, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      if (publicKey2.length === 64) {
        return secp256k12.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey2]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k12.publicKeyVerify(publicKey2);
    };
    exports.pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      pubKey = bytes_1.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k12.publicKeyConvert(pubKey, false).slice(1);
      }
      assert5(pubKey.length === 64);
      return hash_1.keccak(pubKey).slice(-20);
    };
    exports.publicToAddress = exports.pubToAddress;
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(exports.privateToPublic(privateKey));
    };
    exports.privateToPublic = function(privateKey) {
      privateKey = bytes_1.toBuffer(privateKey);
      return secp256k12.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey2) {
      publicKey2 = bytes_1.toBuffer(publicKey2);
      if (publicKey2.length !== 64) {
        publicKey2 = secp256k12.publicKeyConvert(publicKey2, false).slice(1);
      }
      return publicKey2;
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js
var require_signature3 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var secp256k12 = require_secp256k1v3_adapter();
    var BN6 = require_bn3();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash3();
    exports.ecsign = function(msgHash, privateKey, chainId) {
      var sig = secp256k12.sign(msgHash, privateKey);
      var recovery = sig.recovery;
      var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27
      };
      return ret;
    };
    exports.ecrecover = function(msgHash, v8, r6, s6, chainId) {
      var signature2 = Buffer.concat([bytes_1.setLength(r6, 32), bytes_1.setLength(s6, 32)], 64);
      var recovery = calculateSigRecovery(v8, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k12.recover(msgHash, signature2, recovery);
      return secp256k12.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v8, r6, s6, chainId) {
      var recovery = calculateSigRecovery(v8, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r6, 32), bytes_1.setLengthLeft(s6, 32), bytes_1.toBuffer(v8)]));
    };
    exports.fromRpcSig = function(sig) {
      var buf = bytes_1.toBuffer(sig);
      if (buf.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v8 = buf[64];
      if (v8 < 27) {
        v8 += 27;
      }
      return {
        v: v8,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64)
      };
    };
    exports.isValidSignature = function(v8, r6, s6, homesteadOrLater, chainId) {
      if (homesteadOrLater === void 0) {
        homesteadOrLater = true;
      }
      var SECP256K1_N_DIV_2 = new BN6("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN6("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r6.length !== 32 || s6.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v8, chainId))) {
        return false;
      }
      var rBN = new BN6(r6);
      var sBN = new BN6(s6);
      if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
      }
      if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = Buffer.from("Ethereum Signed Message:\n" + message.length.toString(), "utf-8");
      return hash_1.keccak(Buffer.concat([prefix, message]));
    };
    function calculateSigRecovery(v8, chainId) {
      return chainId ? v8 - (2 * chainId + 35) : v8 - 27;
    }
    function isValidSigRecovery(recovery) {
      return recovery === 0 || recovery === 1;
    }
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js
var require_object = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineProperties = void 0;
    var assert5 = (init_assert(), assert_exports);
    var ethjsUtil = require_lib5();
    var rlp = require_dist3();
    var bytes_1 = require_bytes();
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label === void 0) {
          label = false;
        }
        if (label) {
          var obj_1 = {};
          self2._fields.forEach(function(field) {
            obj_1[field] = "0x" + self2[field].toString("hex");
          });
          return obj_1;
        }
        return bytes_1.baToJSON(self2.raw);
      };
      self2.serialize = function serialize4() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i5) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i5];
        }
        function setter(v8) {
          v8 = bytes_1.toBuffer(v8);
          if (v8.toString("hex") === "00" && !field.allowZero) {
            v8 = Buffer.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v8 = bytes_1.stripZeros(v8);
            assert5(field.length >= v8.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v8.length === 0) && field.length) {
            assert5(field.length === v8.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i5] = v8;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer.from(ethjsUtil.stripHexPrefix(data), "hex");
        }
        if (Buffer.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d5, i5) {
            self2[self2._fields[i5]] = bytes_1.toBuffer(d5);
          });
        } else if (typeof data === "object") {
          var keys_1 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys_1.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys_1.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !exports2.hasOwnProperty(p5))
          __createBinding(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = exports.rlp = exports.BN = void 0;
    var secp256k12 = require_secp256k1v3_adapter();
    exports.secp256k1 = secp256k12;
    var ethjsUtil = require_lib5();
    var BN6 = require_bn3();
    exports.BN = BN6;
    var rlp = require_dist3();
    exports.rlp = rlp;
    Object.assign(exports, ethjsUtil);
    __exportStar(require_constants2(), exports);
    __exportStar(require_account(), exports);
    __exportStar(require_hash3(), exports);
    __exportStar(require_signature3(), exports);
    __exportStar(require_bytes(), exports);
    __exportStar(require_object(), exports);
  }
});

// node_modules/ethereumjs-abi/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/ethereumjs-abi/lib/index.js"(exports, module) {
    var utils2 = require_dist8();
    var BN6 = require_bn3();
    var ABI = function() {
    };
    function elementaryName(name2) {
      if (name2.startsWith("int[")) {
        return "int256" + name2.slice(3);
      } else if (name2 === "int") {
        return "int256";
      } else if (name2.startsWith("uint[")) {
        return "uint256" + name2.slice(4);
      } else if (name2 === "uint") {
        return "uint256";
      } else if (name2.startsWith("fixed[")) {
        return "fixed128x128" + name2.slice(5);
      } else if (name2 === "fixed") {
        return "fixed128x128";
      } else if (name2.startsWith("ufixed[")) {
        return "ufixed128x128" + name2.slice(6);
      } else if (name2 === "ufixed") {
        return "ufixed128x128";
      }
      return name2;
    }
    ABI.eventID = function(name2, types) {
      var sig = name2 + "(" + types.map(elementaryName).join(",") + ")";
      return utils2.keccak256(Buffer.from(sig));
    };
    ABI.methodID = function(name2, types) {
      return ABI.eventID(name2, types).slice(0, 4);
    };
    function parseTypeN(type2) {
      return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
    }
    function parseTypeNxM(type2) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type2) {
      var tmp = type2.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type2 = typeof arg;
      if (type2 === "string") {
        if (utils2.isHexPrefixed(arg)) {
          return new BN6(utils2.stripHexPrefix(arg), 16);
        } else {
          return new BN6(arg, 10);
        }
      } else if (type2 === "number") {
        return new BN6(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function parseSignature(sig) {
      var tmp = /^(\w+)\((.*)\)$/.exec(sig);
      if (tmp.length !== 3) {
        throw new Error("Invalid method signature");
      }
      var args = /^(.+)\):\((.+)$/.exec(tmp[2]);
      if (args !== null && args.length === 3) {
        return {
          method: tmp[1],
          args: args[1].split(","),
          retargs: args[2].split(",")
        };
      } else {
        var params = tmp[2].split(",");
        if (params.length === 1 && params[0] === "") {
          params = [];
        }
        return {
          method: tmp[1],
          args: params
        };
      }
    }
    function encodeSingle(type2, arg) {
      var size, num, ret, i5;
      if (type2 === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type2 === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type2 === "string") {
        return encodeSingle("bytes", Buffer.from(arg, "utf8"));
      } else if (isArray2(type2)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type2);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type2 = type2.slice(0, type2.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i5 in arg) {
          ret.push(encodeSingle(type2, arg[i5]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type2 === "bytes") {
        arg = Buffer.from(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, utils2.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils2.setLengthRight(arg, 32);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type2.startsWith("ufixed")) {
        size = parseTypeNxM(type2);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN6(2).pow(new BN6(size[1]))));
      } else if (type2.startsWith("fixed")) {
        size = parseTypeNxM(type2);
        return encodeSingle("int256", parseNumber(arg).mul(new BN6(2).pow(new BN6(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type2);
    }
    function decodeSingle(parsedType, data, offset2) {
      if (typeof parsedType === "string") {
        parsedType = parseType(parsedType);
      }
      var size, num, ret, i5;
      if (parsedType.name === "address") {
        return decodeSingle(parsedType.rawType, data, offset2).toArrayLike(Buffer, "be", 20).toString("hex");
      } else if (parsedType.name === "bool") {
        return decodeSingle(parsedType.rawType, data, offset2).toString() === new BN6(1).toString();
      } else if (parsedType.name === "string") {
        var bytes = decodeSingle(parsedType.rawType, data, offset2);
        return Buffer.from(bytes, "utf8").toString();
      } else if (parsedType.isArray) {
        ret = [];
        size = parsedType.size;
        if (parsedType.size === "dynamic") {
          offset2 = decodeSingle("uint256", data, offset2).toNumber();
          size = decodeSingle("uint256", data, offset2).toNumber();
          offset2 = offset2 + 32;
        }
        for (i5 = 0; i5 < size; i5++) {
          var decoded = decodeSingle(parsedType.subArray, data, offset2);
          ret.push(decoded);
          offset2 += parsedType.subArray.memoryUsage;
        }
        return ret;
      } else if (parsedType.name === "bytes") {
        offset2 = decodeSingle("uint256", data, offset2).toNumber();
        size = decodeSingle("uint256", data, offset2).toNumber();
        return data.slice(offset2 + 32, offset2 + 32 + size);
      } else if (parsedType.name.startsWith("bytes")) {
        return data.slice(offset2, offset2 + parsedType.size);
      } else if (parsedType.name.startsWith("uint")) {
        num = new BN6(data.slice(offset2, offset2 + 32), 16, "be");
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded int exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("int")) {
        num = new BN6(data.slice(offset2, offset2 + 32), 16, "be").fromTwos(256);
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded uint exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("ufixed")) {
        size = new BN6(2).pow(new BN6(parsedType.size[1]));
        num = decodeSingle("uint256", data, offset2);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      } else if (parsedType.name.startsWith("fixed")) {
        size = new BN6(2).pow(new BN6(parsedType.size[1]));
        num = decodeSingle("int256", data, offset2);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      }
      throw new Error("Unsupported or invalid type: " + parsedType.name);
    }
    function parseType(type2) {
      var size;
      var ret;
      if (isArray2(type2)) {
        size = parseTypeArray(type2);
        var subArray = type2.slice(0, type2.lastIndexOf("["));
        subArray = parseType(subArray);
        ret = {
          isArray: true,
          name: type2,
          size,
          memoryUsage: size === "dynamic" ? 32 : subArray.memoryUsage * size,
          subArray
        };
        return ret;
      } else {
        var rawType;
        switch (type2) {
          case "address":
            rawType = "uint160";
            break;
          case "bool":
            rawType = "uint8";
            break;
          case "string":
            rawType = "bytes";
            break;
        }
        ret = {
          rawType,
          name: type2,
          memoryUsage: 32
        };
        if (type2.startsWith("bytes") && type2 !== "bytes" || type2.startsWith("uint") || type2.startsWith("int")) {
          ret.size = parseTypeN(type2);
        } else if (type2.startsWith("ufixed") || type2.startsWith("fixed")) {
          ret.size = parseTypeNxM(type2);
        }
        if (type2.startsWith("bytes") && type2 !== "bytes" && (ret.size < 1 || ret.size > 32)) {
          throw new Error("Invalid bytes<N> width: " + ret.size);
        }
        if ((type2.startsWith("uint") || type2.startsWith("int")) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
          throw new Error("Invalid int/uint<N> width: " + ret.size);
        }
        return ret;
      }
    }
    function isDynamic(type2) {
      return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
    }
    function isArray2(type2) {
      return type2.lastIndexOf("]") === type2.length - 1;
    }
    ABI.rawEncode = function(types, values) {
      var output = [];
      var data = [];
      var headLength = 0;
      types.forEach(function(type3) {
        if (isArray2(type3)) {
          var size = parseTypeArray(type3);
          if (size !== "dynamic") {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        var cur = encodeSingle(type2, value);
        if (isDynamic(type2)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    };
    ABI.rawDecode = function(types, data) {
      var ret = [];
      data = Buffer.from(data);
      var offset2 = 0;
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var parsed = parseType(type2, data, offset2);
        var decoded = decodeSingle(parsed, data, offset2);
        offset2 += parsed.memoryUsage;
        ret.push(decoded);
      }
      return ret;
    };
    ABI.simpleEncode = function(method) {
      var args = Array.prototype.slice.call(arguments).slice(1);
      var sig = parseSignature(method);
      if (args.length !== sig.args.length) {
        throw new Error("Argument count mismatch");
      }
      return Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);
    };
    ABI.simpleDecode = function(method, data) {
      var sig = parseSignature(method);
      if (!sig.retargs) {
        throw new Error("No return values in method");
      }
      return ABI.rawDecode(sig.retargs, data);
    };
    function stringify3(type2, value) {
      if (type2.startsWith("address") || type2.startsWith("bytes")) {
        return "0x" + value.toString("hex");
      } else {
        return value.toString();
      }
    }
    ABI.stringify = function(types, values) {
      var ret = [];
      for (var i5 in types) {
        var type2 = types[i5];
        var value = values[i5];
        if (/^[^\[]+\[.*\]$/.test(type2)) {
          value = value.map(function(item) {
            return stringify3(type2, item);
          }).join(", ");
        } else {
          value = stringify3(type2, value);
        }
        ret.push(value);
      }
      return ret;
    };
    ABI.solidityHexValue = function(type2, value, bitsize) {
      var size, num;
      if (isArray2(type2)) {
        var subType = type2.replace(/\[.*?\]/, "");
        if (!isArray2(subType)) {
          var arraySize = parseTypeArray(type2);
          if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
            throw new Error("Elements exceed array size: " + arraySize);
          }
        }
        var arrayValues = value.map(function(v8) {
          return ABI.solidityHexValue(subType, v8, 256);
        });
        return Buffer.concat(arrayValues);
      } else if (type2 === "bytes") {
        return value;
      } else if (type2 === "string") {
        return Buffer.from(value, "utf8");
      } else if (type2 === "bool") {
        bitsize = bitsize || 8;
        var padding2 = Array(bitsize / 4).join("0");
        return Buffer.from(value ? padding2 + "1" : padding2 + "0", "hex");
      } else if (type2 === "address") {
        var bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return utils2.setLengthLeft(value, bytesize);
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils2.setLengthRight(value, size);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, "be", bitsize / 8);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, "be", bitsize / 8);
      } else {
        throw new Error("Unsupported or invalid type: " + type2);
      }
    };
    ABI.solidityPack = function(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var ret = [];
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        ret.push(ABI.solidityHexValue(type2, value, null));
      }
      return Buffer.concat(ret);
    };
    ABI.soliditySHA3 = function(types, values) {
      return utils2.keccak256(ABI.solidityPack(types, values));
    };
    ABI.soliditySHA256 = function(types, values) {
      return utils2.sha256(ABI.solidityPack(types, values));
    };
    ABI.solidityRIPEMD160 = function(types, values) {
      return utils2.ripemd160(ABI.solidityPack(types, values), true);
    };
    function isNumeric2(c5) {
      return c5 >= "0" && c5 <= "9";
    }
    ABI.fromSerpent = function(sig) {
      var ret = [];
      for (var i5 = 0; i5 < sig.length; i5++) {
        var type2 = sig[i5];
        if (type2 === "s") {
          ret.push("bytes");
        } else if (type2 === "b") {
          var tmp = "bytes";
          var j5 = i5 + 1;
          while (j5 < sig.length && isNumeric2(sig[j5])) {
            tmp += sig[j5] - "0";
            j5++;
          }
          i5 = j5 - 1;
          ret.push(tmp);
        } else if (type2 === "i") {
          ret.push("int256");
        } else if (type2 === "a") {
          ret.push("int256[]");
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return ret;
    };
    ABI.toSerpent = function(types) {
      var ret = [];
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = types[i5];
        if (type2 === "bytes") {
          ret.push("s");
        } else if (type2.startsWith("bytes")) {
          ret.push("b" + parseTypeN(type2));
        } else if (type2 === "int256") {
          ret.push("i");
        } else if (type2 === "int256[]") {
          ret.push("a");
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return ret.join("");
    };
    module.exports = ABI;
  }
});

// node_modules/ethereumjs-abi/index.js
var require_ethereumjs_abi = __commonJS({
  "node_modules/ethereumjs-abi/index.js"(exports, module) {
    module.exports = require_lib7();
  }
});

// node_modules/eth-sig-util/index.js
var require_eth_sig_util = __commonJS({
  "node_modules/eth-sig-util/index.js"(exports, module) {
    var ethUtil = require_dist5();
    var ethAbi = require_ethereumjs_abi();
    module.exports = {
      concatSig: function(v8, r6, s6) {
        const rSig = ethUtil.fromSigned(r6);
        const sSig = ethUtil.fromSigned(s6);
        const vSig = ethUtil.bufferToInt(v8);
        const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString("hex"), 64);
        const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString("hex"), 64);
        const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));
        return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString("hex");
      },
      normalize: function(input) {
        if (!input)
          return;
        if (typeof input === "number") {
          const buffer2 = ethUtil.toBuffer(input);
          input = ethUtil.bufferToHex(buffer2);
        }
        if (typeof input !== "string") {
          var msg = "eth-sig-util.normalize() requires hex string or integer input.";
          msg += " received " + typeof input + ": " + input;
          throw new Error(msg);
        }
        return ethUtil.addHexPrefix(input.toLowerCase());
      },
      personalSign: function(privateKey, msgParams) {
        var message = ethUtil.toBuffer(msgParams.data);
        var msgHash = ethUtil.hashPersonalMessage(message);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
        return serialized;
      },
      recoverPersonalSignature: function(msgParams) {
        const publicKey2 = getPublicKeyFor(msgParams);
        const sender = ethUtil.publicToAddress(publicKey2);
        const senderHex = ethUtil.bufferToHex(sender);
        return senderHex;
      },
      extractPublicKey: function(msgParams) {
        const publicKey2 = getPublicKeyFor(msgParams);
        return "0x" + publicKey2.toString("hex");
      },
      typedSignatureHash: function(typedData) {
        const hashBuffer = typedSignatureHash(typedData);
        return ethUtil.bufferToHex(hashBuffer);
      },
      signTypedData: function(privateKey, msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const sig = ethUtil.ecsign(msgHash, privateKey);
        return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
      },
      recoverTypedSignature: function(msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const publicKey2 = recoverPublicKey2(msgHash, msgParams.sig);
        const sender = ethUtil.publicToAddress(publicKey2);
        return ethUtil.bufferToHex(sender);
      }
    };
    function typedSignatureHash(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error;
      const data = typedData.map(function(e5) {
        return e5.type === "bytes" ? ethUtil.toBuffer(e5.value) : e5.value;
      });
      const types = typedData.map(function(e5) {
        return e5.type;
      });
      const schema = typedData.map(function(e5) {
        if (!e5.name)
          throw error;
        return e5.type + " " + e5.name;
      });
      return ethAbi.soliditySHA3(["bytes32", "bytes32"], [
        ethAbi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
        ethAbi.soliditySHA3(types, data)
      ]);
    }
    function recoverPublicKey2(hash4, sig) {
      const signature2 = ethUtil.toBuffer(sig);
      const sigParams = ethUtil.fromRpcSig(signature2);
      return ethUtil.ecrecover(hash4, sigParams.v, sigParams.r, sigParams.s);
    }
    function getPublicKeyFor(msgParams) {
      const message = ethUtil.toBuffer(msgParams.data);
      const msgHash = ethUtil.hashPersonalMessage(message);
      return recoverPublicKey2(msgHash, msgParams.sig);
    }
    function padWithZeroes(number2, length) {
      var myString = "" + number2;
      while (myString.length < length) {
        myString = "0" + myString;
      }
      return myString;
    }
  }
});

// node_modules/semaphore/lib/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/semaphore/lib/semaphore.js"(exports, module) {
    (function(global2) {
      "use strict";
      var nextTick = function(fn) {
        setTimeout(fn, 0);
      };
      if (typeof process != "undefined" && process && typeof process.nextTick == "function") {
        nextTick = process.nextTick;
      }
      function semaphore(capacity) {
        var semaphore2 = {
          capacity: capacity || 1,
          current: 0,
          queue: [],
          firstHere: false,
          take: function() {
            if (semaphore2.firstHere === false) {
              semaphore2.current++;
              semaphore2.firstHere = true;
              var isFirst = 1;
            } else {
              var isFirst = 0;
            }
            var item = { n: 1 };
            if (typeof arguments[0] == "function") {
              item.task = arguments[0];
            } else {
              item.n = arguments[0];
            }
            if (arguments.length >= 2) {
              if (typeof arguments[1] == "function")
                item.task = arguments[1];
              else
                item.n = arguments[1];
            }
            var task = item.task;
            item.task = function() {
              task(semaphore2.leave);
            };
            if (semaphore2.current + item.n - isFirst > semaphore2.capacity) {
              if (isFirst === 1) {
                semaphore2.current--;
                semaphore2.firstHere = false;
              }
              return semaphore2.queue.push(item);
            }
            semaphore2.current += item.n - isFirst;
            item.task(semaphore2.leave);
            if (isFirst === 1)
              semaphore2.firstHere = false;
          },
          leave: function(n3) {
            n3 = n3 || 1;
            semaphore2.current -= n3;
            if (!semaphore2.queue.length) {
              if (semaphore2.current < 0) {
                throw new Error("leave called too many times.");
              }
              return;
            }
            var item = semaphore2.queue[0];
            if (item.n + semaphore2.current > semaphore2.capacity) {
              return;
            }
            semaphore2.queue.shift();
            semaphore2.current += item.n;
            nextTick(item.task);
          },
          available: function(n3) {
            n3 = n3 || 1;
            return semaphore2.current + n3 <= semaphore2.capacity;
          }
        };
        return semaphore2;
      }
      ;
      if (typeof exports === "object") {
        module.exports = semaphore;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return semaphore;
        });
      } else {
        global2.semaphore = semaphore;
      }
    })(exports);
  }
});

// node_modules/web3-provider-engine/dist/es5/util/estimate-gas.js
var require_estimate_gas = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/estimate-gas.js"(exports, module) {
    "use strict";
    var createPayload = require_create_payload2();
    module.exports = estimateGas;
    function estimateGas(provider, txParams, cb) {
      provider.sendAsync(createPayload({
        method: "eth_estimateGas",
        params: [txParams]
      }), function(err, res) {
        if (err) {
          if (err.message === "no contract code at given address") {
            return cb(null, "0xcf08");
          } else {
            return cb(err);
          }
        }
        cb(null, res.result);
      });
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/hooked-wallet.js
var require_hooked_wallet = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/hooked-wallet.js"(exports, module) {
    "use strict";
    var waterfall = require_waterfall();
    var parallel = require_parallel2();
    var inherits2 = require_util().inherits;
    var ethUtil = require_dist5();
    var sigUtil = require_eth_sig_util();
    var extend = require_immutable();
    var Semaphore = require_semaphore();
    var Subprovider = require_subprovider();
    var estimateGas = require_estimate_gas();
    var hexRegex = /^[0-9A-Fa-f]+$/g;
    module.exports = HookedWalletSubprovider3;
    inherits2(HookedWalletSubprovider3, Subprovider);
    function HookedWalletSubprovider3(opts) {
      var self2 = this;
      self2.nonceLock = Semaphore(1);
      if (opts.getAccounts)
        self2.getAccounts = opts.getAccounts;
      if (opts.processTransaction)
        self2.processTransaction = opts.processTransaction;
      if (opts.processMessage)
        self2.processMessage = opts.processMessage;
      if (opts.processPersonalMessage)
        self2.processPersonalMessage = opts.processPersonalMessage;
      if (opts.processTypedMessage)
        self2.processTypedMessage = opts.processTypedMessage;
      self2.approveTransaction = opts.approveTransaction || self2.autoApprove;
      self2.approveMessage = opts.approveMessage || self2.autoApprove;
      self2.approvePersonalMessage = opts.approvePersonalMessage || self2.autoApprove;
      self2.approveDecryptMessage = opts.approveDecryptMessage || self2.autoApprove;
      self2.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self2.autoApprove;
      self2.approveTypedMessage = opts.approveTypedMessage || self2.autoApprove;
      if (opts.signTransaction)
        self2.signTransaction = opts.signTransaction || mustProvideInConstructor("signTransaction");
      if (opts.signMessage)
        self2.signMessage = opts.signMessage || mustProvideInConstructor("signMessage");
      if (opts.signPersonalMessage)
        self2.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor("signPersonalMessage");
      if (opts.decryptMessage)
        self2.decryptMessage = opts.decryptMessage || mustProvideInConstructor("decryptMessage");
      if (opts.encryptionPublicKey)
        self2.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor("encryptionPublicKey");
      if (opts.signTypedMessage)
        self2.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor("signTypedMessage");
      if (opts.recoverPersonalSignature)
        self2.recoverPersonalSignature = opts.recoverPersonalSignature;
      if (opts.publishTransaction)
        self2.publishTransaction = opts.publishTransaction;
      self2.estimateGas = opts.estimateGas || self2.estimateGas;
      self2.getGasPrice = opts.getGasPrice || self2.getGasPrice;
    }
    HookedWalletSubprovider3.prototype.handleRequest = function(payload, next, end) {
      var self2 = this;
      self2._parityRequests = {};
      self2._parityRequestCount = 0;
      var txParams, msgParams, extraParams;
      var message, address;
      switch (payload.method) {
        case "eth_coinbase":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            var result = accounts[0] || null;
            end(null, result);
          });
          return;
        case "eth_accounts":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            end(null, accounts);
          });
          return;
        case "eth_sendTransaction":
          txParams = payload.params[0];
          waterfall([function(cb) {
            return self2.validateTransaction(txParams, cb);
          }, function(cb) {
            return self2.processTransaction(txParams, cb);
          }], end);
          return;
        case "eth_signTransaction":
          txParams = payload.params[0];
          waterfall([function(cb) {
            return self2.validateTransaction(txParams, cb);
          }, function(cb) {
            return self2.processSignTransaction(txParams, cb);
          }], end);
          return;
        case "eth_sign":
          address = payload.params[0];
          message = payload.params[1];
          extraParams = payload.params[2] || {};
          msgParams = extend(extraParams, {
            from: address,
            data: message
          });
          waterfall([function(cb) {
            return self2.validateMessage(msgParams, cb);
          }, function(cb) {
            return self2.processMessage(msgParams, cb);
          }], end);
          return;
        case "personal_sign":
          return function() {
            var first2 = payload.params[0];
            var second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first2)) {
              var warning = "The eth_personalSign method requires params ordered ";
              warning += "[message, address]. This was previously handled incorrectly, ";
              warning += "and has been corrected automatically. ";
              warning += "Please switch this param order for smooth behavior in the future.";
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self2.validatePersonalMessage(msgParams, cb);
            }, function(cb) {
              return self2.processPersonalMessage(msgParams, cb);
            }], end);
          }();
        case "eth_decryptMessage":
          return function() {
            var first2 = payload.params[0];
            var second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first2)) {
              var warning = "The eth_decryptMessage method requires params ordered ";
              warning += "[message, address]. This was previously handled incorrectly, ";
              warning += "and has been corrected automatically. ";
              warning += "Please switch this param order for smooth behavior in the future.";
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self2.validateDecryptMessage(msgParams, cb);
            }, function(cb) {
              return self2.processDecryptMessage(msgParams, cb);
            }], end);
          }();
        case "encryption_public_key":
          return function() {
            var address2 = payload.params[0];
            waterfall([function(cb) {
              return self2.validateEncryptionPublicKey(address2, cb);
            }, function(cb) {
              return self2.processEncryptionPublicKey(address2, cb);
            }], end);
          }();
        case "personal_ecRecover":
          return function() {
            message = payload.params[0];
            var signature2 = payload.params[1];
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              sig: signature2,
              data: message
            });
            self2.recoverPersonalSignature(msgParams, end);
          }();
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          return function() {
            var first2 = payload.params[0];
            var second = payload.params[1];
            if (resemblesAddress(first2)) {
              address = first2;
              message = second;
            } else {
              message = first2;
              address = second;
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self2.validateTypedMessage(msgParams, cb);
            }, function(cb) {
              return self2.processTypedMessage(msgParams, cb);
            }], end);
          }();
        case "parity_postTransaction":
          txParams = payload.params[0];
          self2.parityPostTransaction(txParams, end);
          return;
        case "parity_postSign":
          address = payload.params[0];
          message = payload.params[1];
          self2.parityPostSign(address, message, end);
          return;
        case "parity_checkRequest":
          return function() {
            var requestId = payload.params[0];
            self2.parityCheckRequest(requestId, end);
          }();
        case "parity_defaultAccount":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            var account = accounts[0] || null;
            end(null, account);
          });
          return;
        default:
          next();
          return;
      }
    };
    HookedWalletSubprovider3.prototype.getAccounts = function(cb) {
      cb(null, []);
    };
    HookedWalletSubprovider3.prototype.processTransaction = function(txParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveTransaction(txParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("transaction", didApprove, cb2);
      }, function(cb2) {
        return self2.finalizeAndSubmitTx(txParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider3.prototype.processSignTransaction = function(txParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveTransaction(txParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("transaction", didApprove, cb2);
      }, function(cb2) {
        return self2.finalizeTx(txParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider3.prototype.processMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self2.signMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider3.prototype.processPersonalMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approvePersonalMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self2.signPersonalMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider3.prototype.processDecryptMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveDecryptMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("decryptMessage", didApprove, cb2);
      }, function(cb2) {
        return self2.decryptMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider3.prototype.processEncryptionPublicKey = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveEncryptionPublicKey(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("encryptionPublicKey", didApprove, cb2);
      }, function(cb2) {
        return self2.encryptionPublicKey(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider3.prototype.processTypedMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveTypedMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self2.signTypedMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider3.prototype.autoApprove = function(txParams, cb) {
      cb(null, true);
    };
    HookedWalletSubprovider3.prototype.checkApproval = function(type2, didApprove, cb) {
      cb(didApprove ? null : new Error("User denied " + type2 + " signature."));
    };
    HookedWalletSubprovider3.prototype.parityPostTransaction = function(txParams, cb) {
      var self2 = this;
      var count2 = self2._parityRequestCount;
      var reqId = "0x".concat(count2.toString(16));
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sendTransaction",
        params: [txParams]
      }, function(error, res) {
        if (error) {
          self2._parityRequests[reqId] = {
            error
          };
          return;
        }
        var txHash = res.result;
        self2._parityRequests[reqId] = txHash;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider3.prototype.parityPostSign = function(address, message, cb) {
      var self2 = this;
      var count2 = self2._parityRequestCount;
      var reqId = "0x".concat(count2.toString(16));
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sign",
        params: [address, message]
      }, function(error, res) {
        if (error) {
          self2._parityRequests[reqId] = {
            error
          };
          return;
        }
        var result = res.result;
        self2._parityRequests[reqId] = result;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider3.prototype.parityCheckRequest = function(reqId, cb) {
      var self2 = this;
      var result = self2._parityRequests[reqId] || null;
      if (!result)
        return cb(null, null);
      if (result.error)
        return cb(result.error);
      cb(null, result);
    };
    HookedWalletSubprovider3.prototype.recoverPersonalSignature = function(msgParams, cb) {
      var senderHex;
      try {
        senderHex = sigUtil.recoverPersonalSignature(msgParams);
      } catch (err) {
        return cb(err);
      }
      cb(null, senderHex);
    };
    HookedWalletSubprovider3.prototype.validateTransaction = function(txParams, cb) {
      var self2 = this;
      if (txParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign transaction."));
      self2.validateSender(txParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign transaction for this address: "'.concat(txParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateMessage = function(msgParams, cb) {
      var self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign message."));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validatePersonalMessage = function(msgParams, cb) {
      var self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign personal message."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined message - message required to sign personal message."));
      if (!isValidHex(msgParams.data))
        return cb(new Error("HookedWalletSubprovider - validateMessage - message was not encoded as hex."));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateDecryptMessage = function(msgParams, cb) {
      var self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to decrypt message."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined message - message required to decrypt message."));
      if (!isValidHex(msgParams.data))
        return cb(new Error("HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex."));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to decrypt message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateEncryptionPublicKey = function(address, cb) {
      var self2 = this;
      self2.validateSender(address, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to obtain encryption public key for this address: "'.concat(address, '"')));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateTypedMessage = function(msgParams, cb) {
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign typed data."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined data - message required to sign typed data."));
      this.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateSender = function(senderAddress, cb) {
      var self2 = this;
      if (!senderAddress)
        return cb(null, false);
      self2.getAccounts(function(err, accounts) {
        if (err)
          return cb(err);
        var senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;
        cb(null, senderIsValid);
      });
    };
    HookedWalletSubprovider3.prototype.finalizeAndSubmitTx = function(txParams, cb) {
      var self2 = this;
      self2.nonceLock.take(function() {
        waterfall([self2.fillInTxExtras.bind(self2, txParams), self2.signTransaction.bind(self2), self2.publishTransaction.bind(self2)], function(err, txHash) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, txHash);
        });
      });
    };
    HookedWalletSubprovider3.prototype.finalizeTx = function(txParams, cb) {
      var self2 = this;
      self2.nonceLock.take(function() {
        waterfall([self2.fillInTxExtras.bind(self2, txParams), self2.signTransaction.bind(self2)], function(err, signedTx) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, {
            raw: signedTx,
            tx: txParams
          });
        });
      });
    };
    HookedWalletSubprovider3.prototype.publishTransaction = function(rawTx, cb) {
      var self2 = this;
      self2.emitPayload({
        method: "eth_sendRawTransaction",
        params: [rawTx]
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider3.prototype.estimateGas = function(txParams, cb) {
      var self2 = this;
      estimateGas(self2.engine, txParams, cb);
    };
    HookedWalletSubprovider3.prototype.getGasPrice = function(cb) {
      var self2 = this;
      self2.emitPayload({
        method: "eth_gasPrice",
        params: []
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider3.prototype.fillInTxExtras = function(txParams, cb) {
      var self2 = this;
      var address = txParams.from;
      var tasks = {};
      if (txParams.gasPrice === void 0) {
        tasks.gasPrice = self2.getGasPrice.bind(self2);
      }
      if (txParams.nonce === void 0) {
        tasks.nonce = self2.emitPayload.bind(self2, {
          method: "eth_getTransactionCount",
          params: [address, "pending"]
        });
      }
      if (txParams.gas === void 0) {
        tasks.gas = self2.estimateGas.bind(self2, cloneTxParams(txParams));
      }
      parallel(tasks, function(err, taskResults) {
        if (err)
          return cb(err);
        var result = {};
        if (taskResults.gasPrice)
          result.gasPrice = taskResults.gasPrice;
        if (taskResults.nonce)
          result.nonce = taskResults.nonce.result;
        if (taskResults.gas)
          result.gas = taskResults.gas;
        cb(null, extend(txParams, result));
      });
    };
    function cloneTxParams(txParams) {
      return {
        from: txParams.from,
        to: txParams.to,
        value: txParams.value,
        data: txParams.data,
        gas: txParams.gas,
        gasPrice: txParams.gasPrice,
        nonce: txParams.nonce
      };
    }
    function toLowerCase(string2) {
      return string2.toLowerCase();
    }
    function resemblesAddress(string2) {
      var fixed = ethUtil.addHexPrefix(string2);
      var isValid = ethUtil.isValidAddress(fixed);
      return isValid;
    }
    function resemblesData(string2) {
      var fixed = ethUtil.addHexPrefix(string2);
      var isValidAddress2 = ethUtil.isValidAddress(fixed);
      return !isValidAddress2 && isValidHex(string2);
    }
    function isValidHex(data) {
      var isString2 = typeof data === "string";
      if (!isString2)
        return false;
      var isHexPrefixed = data.slice(0, 2) === "0x";
      if (!isHexPrefixed)
        return false;
      var nonPrefixed = data.slice(2);
      var isValid = nonPrefixed.match(hexRegex);
      return isValid;
    }
    function mustProvideInConstructor(methodName) {
      return function(params, cb) {
        cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'));
      };
    }
  }
});

// node_modules/ethereumjs-tx/node_modules/ethereum-common/params.json
var require_params = __commonJS({
  "node_modules/ethereumjs-tx/node_modules/ethereum-common/params.json"(exports, module) {
    module.exports = {
      genesisGasLimit: {
        v: 5e3,
        d: "Gas limit of the Genesis block."
      },
      genesisDifficulty: {
        v: 17179869184,
        d: "Difficulty of the Genesis block."
      },
      genesisNonce: {
        v: "0x0000000000000042",
        d: "the geneis nonce"
      },
      genesisExtraData: {
        v: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
        d: "extra data "
      },
      genesisHash: {
        v: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        d: "genesis hash"
      },
      genesisStateRoot: {
        v: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
        d: "the genesis state root"
      },
      minGasLimit: {
        v: 5e3,
        d: "Minimum the gas limit may ever be."
      },
      gasLimitBoundDivisor: {
        v: 1024,
        d: "The bound divisor of the gas limit, used in update calculations."
      },
      minimumDifficulty: {
        v: 131072,
        d: "The minimum that the difficulty may ever be."
      },
      difficultyBoundDivisor: {
        v: 2048,
        d: "The bound divisor of the difficulty, used in the update calculations."
      },
      durationLimit: {
        v: 13,
        d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not."
      },
      maximumExtraDataSize: {
        v: 32,
        d: "Maximum size extra data may be after Genesis."
      },
      epochDuration: {
        v: 3e4,
        d: "Duration between proof-of-work epochs."
      },
      stackLimit: {
        v: 1024,
        d: "Maximum size of VM stack allowed."
      },
      callCreateDepth: {
        v: 1024,
        d: "Maximum depth of call/create stack."
      },
      tierStepGas: {
        v: [0, 2, 3, 5, 8, 10, 20],
        d: "Once per operation, for a selection of them."
      },
      expGas: {
        v: 10,
        d: "Once per EXP instuction."
      },
      expByteGas: {
        v: 10,
        d: "Times ceil(log256(exponent)) for the EXP instruction."
      },
      sha3Gas: {
        v: 30,
        d: "Once per SHA3 operation."
      },
      sha3WordGas: {
        v: 6,
        d: "Once per word of the SHA3 operation's data."
      },
      sloadGas: {
        v: 50,
        d: "Once per SLOAD operation."
      },
      sstoreSetGas: {
        v: 2e4,
        d: "Once per SSTORE operation if the zeroness changes from zero."
      },
      sstoreResetGas: {
        v: 5e3,
        d: "Once per SSTORE operation if the zeroness does not change from zero."
      },
      sstoreRefundGas: {
        v: 15e3,
        d: "Once per SSTORE operation if the zeroness changes to zero."
      },
      jumpdestGas: {
        v: 1,
        d: "Refunded gas, once per SSTORE operation if the zeroness changes to zero."
      },
      logGas: {
        v: 375,
        d: "Per LOG* operation."
      },
      logDataGas: {
        v: 8,
        d: "Per byte in a LOG* operation's data."
      },
      logTopicGas: {
        v: 375,
        d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas."
      },
      createGas: {
        v: 32e3,
        d: "Once per CREATE operation & contract-creation transaction."
      },
      callGas: {
        v: 40,
        d: "Once per CALL operation & message call transaction."
      },
      callStipend: {
        v: 2300,
        d: "Free gas given at beginning of call."
      },
      callValueTransferGas: {
        v: 9e3,
        d: "Paid for CALL when the value transfor is non-zero."
      },
      callNewAccountGas: {
        v: 25e3,
        d: "Paid for CALL when the destination address didn't exist prior."
      },
      suicideRefundGas: {
        v: 24e3,
        d: "Refunded following a suicide operation."
      },
      memoryGas: {
        v: 3,
        d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL."
      },
      quadCoeffDiv: {
        v: 512,
        d: "Divisor for the quadratic particle of the memory cost equation."
      },
      createDataGas: {
        v: 200,
        d: ""
      },
      txGas: {
        v: 21e3,
        d: "Per transaction. NOTE: Not payable on data of calls between transactions."
      },
      txCreation: {
        v: 32e3,
        d: "the cost of creating a contract via tx"
      },
      txDataZeroGas: {
        v: 4,
        d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions."
      },
      txDataNonZeroGas: {
        v: 68,
        d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions."
      },
      copyGas: {
        v: 3,
        d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added."
      },
      ecrecoverGas: {
        v: 3e3,
        d: ""
      },
      sha256Gas: {
        v: 60,
        d: ""
      },
      sha256WordGas: {
        v: 12,
        d: ""
      },
      ripemd160Gas: {
        v: 600,
        d: ""
      },
      ripemd160WordGas: {
        v: 120,
        d: ""
      },
      identityGas: {
        v: 15,
        d: ""
      },
      identityWordGas: {
        v: 3,
        d: ""
      },
      minerReward: {
        v: "5000000000000000000",
        d: "the amount a miner get rewarded for mining a block"
      },
      ommerReward: {
        v: "625000000000000000",
        d: "The amount of wei a miner of an uncle block gets for being inculded in the blockchain"
      },
      niblingReward: {
        v: "156250000000000000",
        d: "the amount a miner gets for inculding a uncle"
      },
      homeSteadForkNumber: {
        v: 115e4,
        d: "the block that the Homestead fork started at"
      },
      homesteadRepriceForkNumber: {
        v: 2463e3,
        d: "the block that the Homestead Reprice (EIP150) fork started at"
      },
      timebombPeriod: {
        v: 1e5,
        d: "Exponential difficulty timebomb period"
      },
      freeBlockPeriod: {
        v: 2
      }
    };
  }
});

// node_modules/ethereumjs-tx/es5/index.js
var require_es5 = __commonJS({
  "node_modules/ethereumjs-tx/es5/index.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ethUtil = require_dist5();
    var fees = require_params();
    var BN6 = ethUtil.BN;
    var N_DIV_2 = new BN6("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
    var Transaction2 = function() {
      function Transaction3(data) {
        _classCallCheck(this, Transaction3);
        data = data || {};
        var fields = [{
          name: "nonce",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "gasPrice",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "gasLimit",
          alias: "gas",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "to",
          allowZero: true,
          length: 20,
          default: new Buffer([])
        }, {
          name: "value",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "data",
          alias: "input",
          allowZero: true,
          default: new Buffer([])
        }, {
          name: "v",
          allowZero: true,
          default: new Buffer([28])
        }, {
          name: "r",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "s",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer([])
        }];
        ethUtil.defineProperties(this, fields, data);
        Object.defineProperty(this, "from", {
          enumerable: true,
          configurable: true,
          get: this.getSenderAddress.bind(this)
        });
        var sigV = ethUtil.bufferToInt(this.v);
        var chainId = Math.floor((sigV - 35) / 2);
        if (chainId < 0)
          chainId = 0;
        this._chainId = chainId || data.chainId || 0;
        this._homestead = true;
      }
      Transaction3.prototype.toCreationAddress = function toCreationAddress() {
        return this.to.toString("hex") === "";
      };
      Transaction3.prototype.hash = function hash4(includeSignature) {
        if (includeSignature === void 0)
          includeSignature = true;
        var items = void 0;
        if (includeSignature) {
          items = this.raw;
        } else {
          if (this._chainId > 0) {
            var raw = this.raw.slice();
            this.v = this._chainId;
            this.r = 0;
            this.s = 0;
            items = this.raw;
            this.raw = raw;
          } else {
            items = this.raw.slice(0, 6);
          }
        }
        return ethUtil.rlphash(items);
      };
      Transaction3.prototype.getChainId = function getChainId() {
        return this._chainId;
      };
      Transaction3.prototype.getSenderAddress = function getSenderAddress() {
        if (this._from) {
          return this._from;
        }
        var pubkey = this.getSenderPublicKey();
        this._from = ethUtil.publicToAddress(pubkey);
        return this._from;
      };
      Transaction3.prototype.getSenderPublicKey = function getSenderPublicKey() {
        if (!this._senderPubKey || !this._senderPubKey.length) {
          if (!this.verifySignature())
            throw new Error("Invalid Signature");
        }
        return this._senderPubKey;
      };
      Transaction3.prototype.verifySignature = function verifySignature() {
        var msgHash = this.hash(false);
        if (this._homestead && new BN6(this.s).cmp(N_DIV_2) === 1) {
          return false;
        }
        try {
          var v8 = ethUtil.bufferToInt(this.v);
          if (this._chainId > 0) {
            v8 -= this._chainId * 2 + 8;
          }
          this._senderPubKey = ethUtil.ecrecover(msgHash, v8, this.r, this.s);
        } catch (e5) {
          return false;
        }
        return !!this._senderPubKey;
      };
      Transaction3.prototype.sign = function sign3(privateKey) {
        var msgHash = this.hash(false);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        if (this._chainId > 0) {
          sig.v += this._chainId * 2 + 8;
        }
        Object.assign(this, sig);
      };
      Transaction3.prototype.getDataFee = function getDataFee() {
        var data = this.raw[5];
        var cost = new BN6(0);
        for (var i5 = 0; i5 < data.length; i5++) {
          data[i5] === 0 ? cost.iaddn(fees.txDataZeroGas.v) : cost.iaddn(fees.txDataNonZeroGas.v);
        }
        return cost;
      };
      Transaction3.prototype.getBaseFee = function getBaseFee() {
        var fee = this.getDataFee().iaddn(fees.txGas.v);
        if (this._homestead && this.toCreationAddress()) {
          fee.iaddn(fees.txCreation.v);
        }
        return fee;
      };
      Transaction3.prototype.getUpfrontCost = function getUpfrontCost() {
        return new BN6(this.gasLimit).imul(new BN6(this.gasPrice)).iadd(new BN6(this.value));
      };
      Transaction3.prototype.validate = function validate7(stringError) {
        var errors = [];
        if (!this.verifySignature()) {
          errors.push("Invalid Signature");
        }
        if (this.getBaseFee().cmp(new BN6(this.gasLimit)) > 0) {
          errors.push(["gas limit is too low. Need at least " + this.getBaseFee()]);
        }
        if (stringError === void 0 || stringError === false) {
          return errors.length === 0;
        } else {
          return errors.join(" ");
        }
      };
      return Transaction3;
    }();
    module.exports = Transaction2;
  }
});

// node_modules/web3-provider-engine/dist/es5/util/rpc-cache-utils.js
var require_rpc_cache_utils2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/rpc-cache-utils.js"(exports, module) {
    "use strict";
    var stringify3 = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!canCache(payload))
        return null;
      var includeBlockRef = opts.includeBlockRef;
      var params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify3(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/nonce-tracker.js
var require_nonce_tracker = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/nonce-tracker.js"(exports, module) {
    "use strict";
    var inherits2 = require_util().inherits;
    var Transaction2 = require_es5();
    var ethUtil = require_dist5();
    var Subprovider = require_subprovider();
    var blockTagForPayload = require_rpc_cache_utils2().blockTagForPayload;
    module.exports = NonceTrackerSubprovider;
    inherits2(NonceTrackerSubprovider, Subprovider);
    function NonceTrackerSubprovider(opts) {
      var self2 = this;
      self2.nonceCache = {};
    }
    NonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end) {
      var self2 = this;
      switch (payload.method) {
        case "eth_getTransactionCount":
          var blockTag = blockTagForPayload(payload);
          var address = payload.params[0].toLowerCase();
          var cachedResult = self2.nonceCache[address];
          if (blockTag === "pending") {
            if (cachedResult) {
              end(null, cachedResult);
            } else {
              next(function(err, result, cb) {
                if (err)
                  return cb();
                if (self2.nonceCache[address] === void 0) {
                  self2.nonceCache[address] = result;
                }
                cb();
              });
            }
          } else {
            next();
          }
          return;
        case "eth_sendRawTransaction":
          next(function(err, result, cb) {
            if (err)
              return cb();
            var rawTx = payload.params[0];
            var stripped = ethUtil.stripHexPrefix(rawTx);
            var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex");
            var tx = new Transaction2(Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex"));
            var address2 = "0x" + tx.getSenderAddress().toString("hex").toLowerCase();
            var nonce = ethUtil.bufferToInt(tx.nonce);
            nonce++;
            var hexNonce = nonce.toString(16);
            if (hexNonce.length % 2)
              hexNonce = "0" + hexNonce;
            hexNonce = "0x" + hexNonce;
            self2.nonceCache[address2] = hexNonce;
            cb();
          });
          return;
        case "evm_revert":
          self2.nonceCache = {};
          next();
          return;
        default:
          next();
          return;
      }
    };
  }
});

// node_modules/eth-json-rpc-filters/subscriptionManager.js
var require_subscriptionManager = __commonJS({
  "node_modules/eth-json-rpc-filters/subscriptionManager.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter2().default;
    var createScaffoldMiddleware = require_scaffold();
    var { createAsyncMiddleware } = require_dist7();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var { unsafeRandomBytes, incrementHexInt } = require_hexUtils();
    var getBlocksForRange = require_getBlocksForRange();
    module.exports = createSubscriptionMiddleware;
    function createSubscriptionMiddleware({ blockTracker, provider }) {
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider });
      let isDestroyed = false;
      const events = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
      });
      middleware.destroy = destroy;
      return { events, middleware };
      async function subscribe(req, res) {
        if (isDestroyed)
          throw new Error("SubscriptionManager - attempting to use after destroying");
        const subscriptionType = req.params[0];
        const subId = unsafeRandomBytes(16);
        let sub;
        switch (subscriptionType) {
          case "newHeads":
            sub = createSubNewHeads({ subId });
            break;
          case "logs":
            const filterParams = req.params[1];
            const filter2 = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter: filter2 });
            break;
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
        }
        subscriptions[subId] = sub;
        res.result = subId;
        return;
        function createSubNewHeads({ subId: subId2 }) {
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener("sync", sub2.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
              const results2 = rawBlocks.map(normalizeBlock);
              results2.forEach((value) => {
                _emitSubscriptionResult(subId2, value);
              });
            }
          };
          blockTracker.on("sync", sub2.update);
          return sub2;
        }
        function createSubFromFilter({ subId: subId2, filter: filter2 }) {
          filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter2.idHex);
            }
          };
          return sub2;
        }
      }
      async function unsubscribe(req, res) {
        if (isDestroyed)
          throw new Error("SubscriptionManager - attempting to use after destroying");
        const id2 = req.params[0];
        const subscription = subscriptions[id2];
        if (!subscription) {
          res.result = false;
          return;
        }
        delete subscriptions[id2];
        await subscription.destroy();
        res.result = true;
      }
      function _emitSubscriptionResult(filterIdHex, value) {
        events.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: filterIdHex,
            result: value
          }
        });
      }
      function destroy() {
        events.removeAllListeners();
        for (const id2 in subscriptions) {
          subscriptions[id2].destroy();
          delete subscriptions[id2];
        }
        isDestroyed = true;
      }
    }
    function normalizeBlock(block) {
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
      };
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p5) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o6, p6) {
        o6.__proto__ = p6;
        return o6;
      };
      return _setPrototypeOf(o5, p5);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e5) {
        return false;
      }
    }
    function _getPrototypeOf(o5) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o6) {
        return o6.__proto__ || Object.getPrototypeOf(o6);
      };
      return _getPrototypeOf(o5);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createSubscriptionManager = require_subscriptionManager();
    var SubscriptionsSubprovider3 = function(_ProviderSubprovider) {
      _inherits(SubscriptionsSubprovider4, _ProviderSubprovider);
      var _super = _createSuper(SubscriptionsSubprovider4);
      function SubscriptionsSubprovider4() {
        _classCallCheck(this, SubscriptionsSubprovider4);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker, provider = _ref.provider, engine = _ref.engine;
          var _createSubscriptionMa = createSubscriptionManager({
            blockTracker,
            provider
          }), events = _createSubscriptionMa.events, middleware = _createSubscriptionMa.middleware;
          events.on("notification", function(data) {
            return engine.emit("data", null, data);
          });
          return middleware;
        });
      }
      return SubscriptionsSubprovider4;
    }(ProviderSubprovider);
    module.exports = SubscriptionsSubprovider3;
  }
});

// node_modules/fortmatic/dist/cjs/fortmatic.js
var require_fortmatic = __commonJS({
  "node_modules/fortmatic/dist/cjs/fortmatic.js"(exports, module) {
    module.exports = function(e5) {
      var t5 = {};
      function n3(r6) {
        if (t5[r6])
          return t5[r6].exports;
        var o5 = t5[r6] = { i: r6, l: false, exports: {} };
        return e5[r6].call(o5.exports, o5, o5.exports, n3), o5.l = true, o5.exports;
      }
      return n3.m = e5, n3.c = t5, n3.d = function(e6, t6, r6) {
        n3.o(e6, t6) || Object.defineProperty(e6, t6, { enumerable: true, get: r6 });
      }, n3.r = function(e6) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e6, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e6, "__esModule", { value: true });
      }, n3.t = function(e6, t6) {
        if (1 & t6 && (e6 = n3(e6)), 8 & t6)
          return e6;
        if (4 & t6 && typeof e6 == "object" && e6 && e6.__esModule)
          return e6;
        var r6 = Object.create(null);
        if (n3.r(r6), Object.defineProperty(r6, "default", { enumerable: true, value: e6 }), 2 & t6 && typeof e6 != "string")
          for (var o5 in e6)
            n3.d(r6, o5, function(t7) {
              return e6[t7];
            }.bind(null, o5));
        return r6;
      }, n3.n = function(e6) {
        var t6 = e6 && e6.__esModule ? function() {
          return e6.default;
        } : function() {
          return e6;
        };
        return n3.d(t6, "a", t6), t6;
      }, n3.o = function(e6, t6) {
        return Object.prototype.hasOwnProperty.call(e6, t6);
      }, n3.p = "", n3(n3.s = 8);
    }([function(e5, t5, n3) {
      "use strict";
      function r6(e6) {
        for (var n4 in e6)
          t5.hasOwnProperty(n4) || (t5[n4] = e6[n4]);
      }
      Object.defineProperty(t5, "__esModule", { value: true }), r6(n3(13)), r6(n3(17));
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true });
      var r6 = n3(18);
      function o5(e6) {
        var n4, i5;
        return e6.jsonrpc = e6.jsonrpc || t5.JSON_RPC_VERSION, e6.id = r6.getPayloadId(), e6.batch || e6.method === "eth_batchRequest" ? (e6.method = "eth_batchRequest", e6.batch = (i5 = (n4 = e6.batch) === null || n4 === void 0 ? void 0 : n4.map(function(e7) {
          return o5(e7);
        })) != null ? i5 : [], e6) : (e6.params = e6.params || [], e6);
      }
      t5.JSON_RPC_VERSION = "2.0", t5.createJsonRpcRequestPayload = function(e6, n4) {
        var o6 = [{}];
        return n4 && (o6 = Array.isArray(n4) ? n4 : [{ to: n4.to, value: n4.amount }]), { params: o6, method: e6, jsonrpc: t5.JSON_RPC_VERSION, id: r6.getPayloadId() };
      }, t5.createJsonRpcBatchRequestPayload = function(e6) {
        e6 === void 0 && (e6 = []);
        var n4 = Array.isArray(e6) ? e6 : [e6];
        return { method: "eth_batchRequest", jsonrpc: t5.JSON_RPC_VERSION, id: r6.getPayloadId(), batch: n4.filter(Boolean).map(function(e7) {
          return o5(e7);
        }) };
      }, t5.standardizeRequestPayload = o5;
    }, function(e5, t5, n3) {
      "use strict";
      var r6, o5 = this && this.__extends || (r6 = function(e6, t6) {
        return (r6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e7, t7) {
          e7.__proto__ = t7;
        } || function(e7, t7) {
          for (var n4 in t7)
            t7.hasOwnProperty(n4) && (e7[n4] = t7[n4]);
        })(e6, t6);
      }, function(e6, t6) {
        function n4() {
          this.constructor = e6;
        }
        r6(e6, t6), e6.prototype = t6 === null ? Object.create(t6) : (n4.prototype = t6.prototype, new n4());
      });
      Object.defineProperty(t5, "__esModule", { value: true });
      var i5 = n3(0), a5 = n3(4), s6 = function(e6) {
        function t6(n4, r7) {
          var o6 = e6.call(this, "Fortmatic SDK Error: [" + n4 + "] " + r7) || this;
          return o6.code = n4, o6.__proto__ = Error, Object.setPrototypeOf(o6, t6.prototype), o6;
        }
        return o5(t6, e6), t6;
      }(Error);
      t5.FortmaticError = s6;
      var u5 = function() {
        function e6(e7, t6) {
          this.code = e7, this.message = "Fortmatic SDK Warning: [" + e7 + "] " + t6;
        }
        return e6.prototype.log = function() {
          console.warn(this.message);
        }, e6;
      }();
      t5.FortmaticWarning = u5;
      var c5 = function(e6) {
        function t6(n4) {
          var r7, o6, s7 = e6.call(this) || this;
          s7.__proto__ = Error;
          var u6 = Number((r7 = n4) === null || r7 === void 0 ? void 0 : r7.code), c6 = ((o6 = n4) === null || o6 === void 0 ? void 0 : o6.message) || "Internal error";
          return s7.code = a5.isJsonRpcErrorCode(u6) ? u6 : i5.RPCErrorCode.InternalError, s7.message = "Fortmatic RPC Error: [" + s7.code + "] " + c6, Object.setPrototypeOf(s7, t6.prototype), s7;
        }
        return o5(t6, e6), t6;
      }(Error);
      t5.RpcError = c5, t5.createMissingApiKeyError = function() {
        return new s6(i5.SDKErrorCode.MissingApiKey, "Please provide a Fortmatic API key that you acquired from the developer dashboard.");
      }, t5.createModalNotReadyError = function() {
        return new s6(i5.SDKErrorCode.ModalNotReady, "Modal is not ready.");
      }, t5.createInvalidArgumentError = function(e6) {
        var t6, n4, r7, o6;
        return new s6(i5.SDKErrorCode.InvalidArgument, "Invalid " + (t6 = e6.argIndex, o6 = (n4 = t6 + 1) % 100, (r7 = n4 % 10) === 1 && o6 !== 11 ? n4 + "st" : r7 === 2 && o6 !== 12 ? n4 + "nd" : r7 === 3 && o6 !== 13 ? n4 + "rd" : n4 + "th") + " argument given to `" + e6.functionName + "`.\n  Expected: `" + e6.expected + "`\n  Received: `" + e6.received + "`");
      }, t5.createSynchronousWeb3MethodWarning = function() {
        return new u5(i5.SDKWarningCode.SyncWeb3Method, "Non-async web3 methods will be deprecated in web3 > 1.0 and are not supported by the Fortmatic provider. An async method is to be used instead.");
      }, t5.createDuplicateIframeWarning = function() {
        return new u5(i5.SDKWarningCode.DuplicateIframe, "Duplicate iframes found.");
      };
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true });
      var r6 = n3(1);
      t5.emitWeb3Payload = function(e6, t6, n4) {
        return n4 === void 0 && (n4 = []), new Promise(function(o5, i5) {
          e6.sendAsync(r6.createJsonRpcRequestPayload(t6, n4), function(e7, t7) {
            e7 ? i5(e7) : o5(t7.result);
          });
        });
      }, t5.emitFortmaticPayload = function(e6, t6) {
        return new Promise(function(n4, r7) {
          e6.sendFortmaticAsync(t6, function(e7, t7) {
            e7 ? r7(e7) : n4(t7 ? t7.result : {});
          });
        });
      };
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true });
      var r6 = n3(0);
      function o5(e6) {
        return !!e6 && !(!e6.jsonrpc || !e6.id || !e6.method || !e6.batch || e6.params);
      }
      function i5(e6) {
        return !!e6 && !(!e6.jsonrpc || !e6.id || !e6.method || !e6.params || e6.batch);
      }
      t5.isJsonRpcBatchRequestPayload = o5, t5.isJsonRpcRequestPayload = i5, t5.isJsonRpcResponsePayload = function(e6) {
        return !!e6 && !(!e6.jsonrpc || !e6.id || !e6.result && e6.result !== null && !e6.error);
      }, t5.isFmRequest = function(e6) {
        return !(!e6 || !e6.payload) && i5(e6.payload);
      }, t5.isFmBatchRequest = function(e6) {
        return !(!e6 || !e6.payload) && o5(e6.payload);
      }, t5.isFmPayloadMethod = function(e6) {
        return !!e6 && (typeof e6 == "string" && Object.values(r6.FmPayloadMethod).includes(e6));
      }, t5.isJsonRpcErrorCode = function(e6) {
        return !!e6 && (typeof e6 == "number" && Object.values(r6.RPCErrorCode).includes(e6));
      };
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true });
      var r6 = function(e6) {
        this.sdk = e6;
      };
      t5.BaseModule = r6;
    }, function(e5, t5, n3) {
      "use strict";
      var r6 = this && this.__awaiter || function(e6, t6, n4, r7) {
        return new (n4 || (n4 = Promise))(function(o6, i6) {
          function a6(e7) {
            try {
              u6(r7.next(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function s7(e7) {
            try {
              u6(r7.throw(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function u6(e7) {
            var t7;
            e7.done ? o6(e7.value) : (t7 = e7.value, t7 instanceof n4 ? t7 : new n4(function(e8) {
              e8(t7);
            })).then(a6, s7);
          }
          u6((r7 = r7.apply(e6, t6 || [])).next());
        });
      }, o5 = this && this.__generator || function(e6, t6) {
        var n4, r7, o6, i6, a6 = { label: 0, sent: function() {
          if (1 & o6[0])
            throw o6[1];
          return o6[1];
        }, trys: [], ops: [] };
        return i6 = { next: s7(0), throw: s7(1), return: s7(2) }, typeof Symbol == "function" && (i6[Symbol.iterator] = function() {
          return this;
        }), i6;
        function s7(i7) {
          return function(s8) {
            return function(i8) {
              if (n4)
                throw new TypeError("Generator is already executing.");
              for (; a6; )
                try {
                  if (n4 = 1, r7 && (o6 = 2 & i8[0] ? r7.return : i8[0] ? r7.throw || ((o6 = r7.return) && o6.call(r7), 0) : r7.next) && !(o6 = o6.call(r7, i8[1])).done)
                    return o6;
                  switch (r7 = 0, o6 && (i8 = [2 & i8[0], o6.value]), i8[0]) {
                    case 0:
                    case 1:
                      o6 = i8;
                      break;
                    case 4:
                      return a6.label++, { value: i8[1], done: false };
                    case 5:
                      a6.label++, r7 = i8[1], i8 = [0];
                      continue;
                    case 7:
                      i8 = a6.ops.pop(), a6.trys.pop();
                      continue;
                    default:
                      if (!(o6 = (o6 = a6.trys).length > 0 && o6[o6.length - 1]) && (i8[0] === 6 || i8[0] === 2)) {
                        a6 = 0;
                        continue;
                      }
                      if (i8[0] === 3 && (!o6 || i8[1] > o6[0] && i8[1] < o6[3])) {
                        a6.label = i8[1];
                        break;
                      }
                      if (i8[0] === 6 && a6.label < o6[1]) {
                        a6.label = o6[1], o6 = i8;
                        break;
                      }
                      if (o6 && a6.label < o6[2]) {
                        a6.label = o6[2], a6.ops.push(i8);
                        break;
                      }
                      o6[2] && a6.ops.pop(), a6.trys.pop();
                      continue;
                  }
                  i8 = t6.call(e6, a6);
                } catch (e7) {
                  i8 = [6, e7], r7 = 0;
                } finally {
                  n4 = o6 = 0;
                }
              if (5 & i8[0])
                throw i8[1];
              return { value: i8[0] ? i8[1] : void 0, done: true };
            }([i7, s8]);
          };
        }
      }, i5 = this && this.__values || function(e6) {
        var t6 = typeof Symbol == "function" && Symbol.iterator, n4 = t6 && e6[t6], r7 = 0;
        if (n4)
          return n4.call(e6);
        if (e6 && typeof e6.length == "number")
          return { next: function() {
            return e6 && r7 >= e6.length && (e6 = void 0), { value: e6 && e6[r7++], done: !e6 };
          } };
        throw new TypeError(t6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(t5, "__esModule", { value: true });
      var a5 = n3(0), s6 = n3(4), u5 = n3(7), c5 = n3(2);
      function l5(e6, t6) {
        var n4, r7, o6, i6, a6, c6;
        !function(e7) {
          var t7, n5, r8, o7, i7, a7, s7 = !!e7.data.response.error || !!e7.data.response.message || !!e7.data.response.code, u6 = { message: (n5 = (t7 = e7.data.response.error) === null || t7 === void 0 ? void 0 : t7.message, r8 = n5 != null ? n5 : e7.data.response.message, r8 != null ? r8 : "Fortmatic: Modal was closed without executing action!"), code: (i7 = (o7 = e7.data.response.error) === null || o7 === void 0 ? void 0 : o7.code, a7 = i7 != null ? i7 : e7.data.response.code, a7 != null ? a7 : 1) };
          e7.data.response.error = s7 ? u6 : null;
        }(t6);
        var l6 = (r7 = (n4 = t6.data.response) === null || n4 === void 0 ? void 0 : n4.id) != null ? r7 : void 0;
        return { response: new u5.JsonRpcResponse(function(e7, t7) {
          return t7 && s6.isJsonRpcBatchRequestPayload(e7) && e7.batch.find(function(e8) {
            return e8.id === t7;
          }) || e7;
        }(e6, l6)).applyResult((o6 = t6.data.response) === null || o6 === void 0 ? void 0 : o6.result).applyError((i6 = t6.data.response) === null || i6 === void 0 ? void 0 : i6.error), id: (c6 = (a6 = t6.data.response) === null || a6 === void 0 ? void 0 : a6.id, c6 != null ? c6 : void 0) };
      }
      var d5 = function() {
        function e6(e7, t6) {
          this.endpoint = e7, this.encodedQueryParams = t6, this.messageHandlers = new Set(), this.initMessageListener();
        }
        return e6.prototype.post = function(e7, t6, n4) {
          return r6(this, void 0, void 0, function() {
            var r7, i6 = this;
            return o5(this, function(o6) {
              switch (o6.label) {
                case 0:
                  return [4, e7.iframe];
                case 1:
                  return r7 = o6.sent(), [2, new Promise(function(e8, o7) {
                    if (r7.contentWindow) {
                      var d6 = [], p5 = s6.isJsonRpcBatchRequestPayload(n4) ? n4.batch.map(function(e9) {
                        return e9.id;
                      }) : [];
                      r7.contentWindow.postMessage({ msgType: t6 + "-" + i6.encodedQueryParams, payload: n4 }, "*");
                      var f7 = i6.on(a5.FmIncomingWindowMessage.FORTMATIC_HANDLE_RESPONSE, (h5 = function() {
                        f7(), y5();
                      }, function(t7) {
                        var r8 = l5(n4, t7), o8 = r8.id, i7 = r8.response;
                        o8 && s6.isJsonRpcBatchRequestPayload(n4) && p5.includes(o8) ? (d6.push(i7.payload), d6.length === n4.batch.length && (h5(), e8(d6))) : o8 && o8 === n4.id && (h5(), e8(i7.payload));
                      })), y5 = i6.on(a5.FmIncomingWindowMessage.FORTMATIC_USER_DENIED, function(t7) {
                        return function(r8) {
                          var o8 = l5(n4, r8), i7 = o8.id, a6 = o8.response, c6 = { message: "Fortmatic: Modal was closed without executing action!", code: 1 }, f8 = a6.hasError ? a6.payload : a6.applyError(c6).payload;
                          if (i7 && s6.isJsonRpcBatchRequestPayload(n4) && p5.includes(i7)) {
                            d6.push(f8);
                            for (var y6 = d6.length; y6 < n4.batch.length; y6++)
                              d6.push(new u5.JsonRpcResponse(n4.batch[y6]).applyError(c6).payload);
                            t7(), e8(d6);
                          } else
                            i7 && i7 === n4.id && (t7(), e8(f8));
                        };
                      }(function() {
                        y5(), f7();
                      }));
                    } else
                      o7(c5.createModalNotReadyError());
                    var h5;
                  })];
              }
            });
          });
        }, e6.prototype.on = function(e7, t6) {
          var n4 = this, r7 = t6.bind(window), o6 = function(t7) {
            t7.data.msgType === e7 + "-" + n4.encodedQueryParams && r7(t7);
          };
          return this.messageHandlers.add(o6), function() {
            return n4.messageHandlers.delete(o6);
          };
        }, e6.prototype.initMessageListener = function() {
          var e7 = this;
          window.addEventListener("message", function(t6) {
            var n4, r7, o6;
            if (t6.origin === e7.endpoint && t6.data && t6.data.msgType && e7.messageHandlers.size) {
              t6.data.response = (o6 = t6.data.response) != null ? o6 : {};
              try {
                for (var a6 = i5(e7.messageHandlers.values()), s7 = a6.next(); !s7.done; s7 = a6.next()) {
                  (0, s7.value)(t6);
                }
              } catch (e8) {
                n4 = { error: e8 };
              } finally {
                try {
                  s7 && !s7.done && (r7 = a6.return) && r7.call(a6);
                } finally {
                  if (n4)
                    throw n4.error;
                }
              }
            }
          });
        }, e6;
      }();
      t5.FmPayloadTransport = d5;
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true });
      var r6 = n3(4), o5 = function() {
        function e6(t6) {
          t6 instanceof e6 ? (this._jsonrpc = t6.payload.jsonrpc, this._id = t6.payload.id, this._result = t6.payload.result, this._error = t6.payload.error) : r6.isJsonRpcResponsePayload(t6) ? (this._jsonrpc = t6.jsonrpc, this._id = t6.id, this._result = t6.result, this._error = t6.error) : (this._jsonrpc = t6.jsonrpc, this._id = t6.id, this._result = null, this._error = null);
        }
        return e6.prototype.applyError = function(e7) {
          return this._error = e7, this;
        }, e6.prototype.applyResult = function(e7) {
          return this._result = e7, this;
        }, Object.defineProperty(e6.prototype, "hasError", { get: function() {
          return this._error !== void 0 && this._error !== null;
        }, enumerable: true, configurable: true }), Object.defineProperty(e6.prototype, "hasResult", { get: function() {
          return this._result !== void 0 && this._result !== null;
        }, enumerable: true, configurable: true }), Object.defineProperty(e6.prototype, "payload", { get: function() {
          return { jsonrpc: this._jsonrpc, id: this._id, result: this._result, error: this._error };
        }, enumerable: true, configurable: true }), e6;
      }();
      t5.JsonRpcResponse = o5;
    }, function(e5, t5, n3) {
      e5.exports = n3(9);
    }, function(e5, t5, n3) {
      "use strict";
      var r6 = this && this.__assign || function() {
        return (r6 = Object.assign || function(e6) {
          for (var t6, n4 = 1, r7 = arguments.length; n4 < r7; n4++)
            for (var o6 in t6 = arguments[n4])
              Object.prototype.hasOwnProperty.call(t6, o6) && (e6[o6] = t6[o6]);
          return e6;
        }).apply(this, arguments);
      };
      var o5 = this && this.__importStar || function(e6) {
        if (e6 && e6.__esModule)
          return e6;
        var t6 = {};
        if (e6 != null)
          for (var n4 in e6)
            Object.hasOwnProperty.call(e6, n4) && (t6[n4] = e6[n4]);
        return t6.default = e6, t6;
      };
      Object.defineProperty(t5, "__esModule", { value: true });
      var i5 = n3(10);
      t5.default = i5.Fortmatic;
      var a5 = n3(2);
      t5.FortmaticError = a5.FortmaticError, t5.FortmaticWarning = a5.FortmaticWarning, t5.RpcError = a5.RpcError;
      var s6 = o5(n3(0));
      Object.assign(i5.Fortmatic, r6(r6({}, s6), { FortmaticError: a5.FortmaticError, FortmaticWarning: a5.FortmaticWarning, RpcError: a5.RpcError })), function(e6) {
        for (var n4 in e6)
          t5.hasOwnProperty(n4) || (t5[n4] = e6[n4]);
      }(n3(0));
    }, function(e5, t5, n3) {
      "use strict";
      var r6, o5 = this && this.__extends || (r6 = function(e6, t6) {
        return (r6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e7, t7) {
          e7.__proto__ = t7;
        } || function(e7, t7) {
          for (var n4 in t7)
            t7.hasOwnProperty(n4) && (e7[n4] = t7[n4]);
        })(e6, t6);
      }, function(e6, t6) {
        function n4() {
          this.constructor = e6;
        }
        r6(e6, t6), e6.prototype = t6 === null ? Object.create(t6) : (n4.prototype = t6.prototype, new n4());
      }), i5 = this && this.__awaiter || function(e6, t6, n4, r7) {
        return new (n4 || (n4 = Promise))(function(o6, i6) {
          function a6(e7) {
            try {
              u6(r7.next(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function s7(e7) {
            try {
              u6(r7.throw(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function u6(e7) {
            var t7;
            e7.done ? o6(e7.value) : (t7 = e7.value, t7 instanceof n4 ? t7 : new n4(function(e8) {
              e8(t7);
            })).then(a6, s7);
          }
          u6((r7 = r7.apply(e6, t6 || [])).next());
        });
      }, a5 = this && this.__generator || function(e6, t6) {
        var n4, r7, o6, i6, a6 = { label: 0, sent: function() {
          if (1 & o6[0])
            throw o6[1];
          return o6[1];
        }, trys: [], ops: [] };
        return i6 = { next: s7(0), throw: s7(1), return: s7(2) }, typeof Symbol == "function" && (i6[Symbol.iterator] = function() {
          return this;
        }), i6;
        function s7(i7) {
          return function(s8) {
            return function(i8) {
              if (n4)
                throw new TypeError("Generator is already executing.");
              for (; a6; )
                try {
                  if (n4 = 1, r7 && (o6 = 2 & i8[0] ? r7.return : i8[0] ? r7.throw || ((o6 = r7.return) && o6.call(r7), 0) : r7.next) && !(o6 = o6.call(r7, i8[1])).done)
                    return o6;
                  switch (r7 = 0, o6 && (i8 = [2 & i8[0], o6.value]), i8[0]) {
                    case 0:
                    case 1:
                      o6 = i8;
                      break;
                    case 4:
                      return a6.label++, { value: i8[1], done: false };
                    case 5:
                      a6.label++, r7 = i8[1], i8 = [0];
                      continue;
                    case 7:
                      i8 = a6.ops.pop(), a6.trys.pop();
                      continue;
                    default:
                      if (!(o6 = (o6 = a6.trys).length > 0 && o6[o6.length - 1]) && (i8[0] === 6 || i8[0] === 2)) {
                        a6 = 0;
                        continue;
                      }
                      if (i8[0] === 3 && (!o6 || i8[1] > o6[0] && i8[1] < o6[3])) {
                        a6.label = i8[1];
                        break;
                      }
                      if (i8[0] === 6 && a6.label < o6[1]) {
                        a6.label = o6[1], o6 = i8;
                        break;
                      }
                      if (o6 && a6.label < o6[2]) {
                        a6.label = o6[2], a6.ops.push(i8);
                        break;
                      }
                      o6[2] && a6.ops.pop(), a6.trys.pop();
                      continue;
                  }
                  i8 = t6.call(e6, a6);
                } catch (e7) {
                  i8 = [6, e7], r7 = 0;
                } finally {
                  n4 = o6 = 0;
                }
              if (5 & i8[0])
                throw i8[1];
              return { value: i8[0] ? i8[1] : void 0, done: true };
            }([i7, s8]);
          };
        }
      };
      Object.defineProperty(t5, "__esModule", { value: true });
      var s6 = n3(11), u5 = n3(12), c5 = n3(19), l5 = n3(20), d5 = n3(0), p5 = n3(3), f7 = n3(1), y5 = n3(21), h5 = n3(23), _10 = n3(24), m5 = n3(2), v8 = function() {
        function e6(e7) {
          if (!e7.apiKey)
            throw m5.createMissingApiKeyError();
          this.apiKey = e7.apiKey, this.gsnRelay = e7.gsnRelay, this.endpoint = new URL(e7.endpoint).origin, this.encodedQueryParams = h5.encodeQueryParameters({ API_KEY: this.apiKey, DOMAIN_ORIGIN: window.location ? window.location.origin : "", ETH_NETWORK: e7.ethNetwork, host: new URL(this.endpoint).host, sdk: _10.name, version: _10.version, gsnRelay: e7.gsnRelay });
        }
        return e6.prototype.getProvider = function() {
          return e6.__provider__.has(this.encodedQueryParams) || e6.__provider__.set(this.encodedQueryParams, new y5.FmProvider(this.endpoint, this.apiKey, this.encodedQueryParams)), e6.__provider__.get(this.encodedQueryParams);
        }, e6.__provider__ = new Map(), e6;
      }();
      t5.SDK = v8;
      var g5 = function(e6) {
        function t6(t7, n4) {
          var r7 = e6.call(this, { apiKey: t7, ethNetwork: n4, endpoint: s6.PHANTOM_URL }) || this;
          return r7.user = new u5.PhantomUser(r7), r7;
        }
        return o5(t6, e6), t6.prototype.loginWithMagicLink = function(e7) {
          return i5(this, void 0, void 0, function() {
            var t7, n4, r7, o6;
            return a5(this, function(i6) {
              switch (i6.label) {
                case 0:
                  return t7 = e7.email, n4 = e7.showUI, r7 = n4 === void 0 || n4, o6 = f7.createJsonRpcRequestPayload(d5.FmPayloadMethod.fm_auth_login_with_magic_link, [{ email: t7, showUI: r7 }]), [4, p5.emitFortmaticPayload(this.getProvider(), o6)];
                case 1:
                  return i6.sent(), [2, this.user];
              }
            });
          });
        }, t6;
      }(v8);
      t5.PhantomMode = g5;
      var b4 = function(e6) {
        function t6(t7, n4, r7) {
          r7 === void 0 && (r7 = { gsnRelay: false });
          var o6 = e6.call(this, { apiKey: t7, ethNetwork: n4, endpoint: s6.WIDGET_URL, gsnRelay: r7.gsnRelay }) || this;
          return o6.transactions = new c5.TransactionsModule(o6), o6.user = new l5.UserModule(o6), o6;
        }
        return o5(t6, e6), t6.prototype.configure = function(e7) {
          e7 === void 0 && (e7 = {});
          var t7 = f7.createJsonRpcRequestPayload(d5.FmPayloadMethod.fm_configure, [e7]);
          return p5.emitFortmaticPayload(this.getProvider(), t7);
        }, t6.Phantom = g5, t6;
      }(v8);
      t5.WidgetMode = b4, t5.Fortmatic = b4;
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true }), t5.WIDGET_URL = "https://x2.fortmatic.com", t5.PHANTOM_URL = "https://auth.fortmatic.com";
    }, function(e5, t5, n3) {
      "use strict";
      var r6, o5 = this && this.__extends || (r6 = function(e6, t6) {
        return (r6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e7, t7) {
          e7.__proto__ = t7;
        } || function(e7, t7) {
          for (var n4 in t7)
            t7.hasOwnProperty(n4) && (e7[n4] = t7[n4]);
        })(e6, t6);
      }, function(e6, t6) {
        function n4() {
          this.constructor = e6;
        }
        r6(e6, t6), e6.prototype = t6 === null ? Object.create(t6) : (n4.prototype = t6.prototype, new n4());
      });
      Object.defineProperty(t5, "__esModule", { value: true });
      var i5 = n3(0), a5 = n3(3), s6 = n3(1), u5 = function(e6) {
        function t6() {
          return e6 !== null && e6.apply(this, arguments) || this;
        }
        return o5(t6, e6), t6.prototype.getIdToken = function(e7) {
          var t7 = s6.createJsonRpcRequestPayload(i5.FmPayloadMethod.fm_auth_get_access_token, [e7]);
          return a5.emitFortmaticPayload(this.sdk.getProvider(), t7);
        }, t6.prototype.getMetadata = function() {
          var e7 = s6.createJsonRpcRequestPayload(i5.FmPayloadMethod.fm_auth_get_metadata);
          return a5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.isLoggedIn = function() {
          var e7 = s6.createJsonRpcRequestPayload(i5.FmPayloadMethod.fm_is_logged_in);
          return a5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.logout = function() {
          var e7 = s6.createJsonRpcRequestPayload(i5.FmPayloadMethod.fm_auth_logout);
          return a5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6;
      }(n3(5).BaseModule);
      t5.PhantomUser = u5;
    }, function(e5, t5, n3) {
      "use strict";
      function r6(e6) {
        for (var n4 in e6)
          t5.hasOwnProperty(n4) || (t5[n4] = e6[n4]);
      }
      Object.defineProperty(t5, "__esModule", { value: true }), r6(n3(14)), r6(n3(15)), r6(n3(16));
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true }), function(e6) {
        e6.fm_composeSend = "fm_composeSend", e6.fm_logout = "fm_logout", e6.fm_get_balances = "fm_get_balances", e6.fm_get_transactions = "fm_get_transactions", e6.fm_is_logged_in = "fm_is_logged_in", e6.fm_accountSettings = "fm_accountSettings", e6.fm_deposit = "fm_deposit", e6.fm_get_user = "fm_get_user", e6.fm_configure = "fm_configure", e6.fm_auth_login_with_magic_link = "fm_auth_login_with_magic_link", e6.fm_auth_get_access_token = "fm_auth_get_access_token", e6.fm_auth_get_metadata = "fm_auth_get_metadata", e6.fm_auth_logout = "fm_auth_logout";
      }(t5.FmPayloadMethod || (t5.FmPayloadMethod = {}));
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true }), function(e6) {
        e6.FORTMATIC_HANDLE_RESPONSE = "FORTMATIC_HANDLE_RESPONSE", e6.FORTMATIC_OVERLAY_READY = "FORTMATIC_OVERLAY_READY", e6.FORTMATIC_SHOW_OVERLAY = "FORTMATIC_SHOW_OVERLAY", e6.FORTMATIC_HIDE_OVERLAY = "FORTMATIC_HIDE_OVERLAY", e6.FORTMATIC_USER_DENIED = "FORTMATIC_USER_DENIED", e6.FORTMATIC_USER_LOGOUT = "FORTMATIC_USER_LOGOUT";
      }(t5.FmIncomingWindowMessage || (t5.FmIncomingWindowMessage = {})), function(e6) {
        e6.FORTMATIC_HANDLE_BATCH_REQUEST = "FORTMATIC_HANDLE_BATCH_REQUEST", e6.FORTMATIC_HANDLE_REQUEST = "FORTMATIC_HANDLE_REQUEST", e6.FORTMATIC_HANDLE_FORTMATIC_REQUEST = "FORTMATIC_HANDLE_FORTMATIC_REQUEST";
      }(t5.FmOutgoingWindowMessage || (t5.FmOutgoingWindowMessage = {}));
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true }), function(e6) {
        e6.MissingApiKey = "MISSING_API_KEY", e6.ModalNotReady = "MODAL_NOT_READY", e6.InvalidArgument = "INVALID_ARGUMENT";
      }(t5.SDKErrorCode || (t5.SDKErrorCode = {})), function(e6) {
        e6.SyncWeb3Method = "SYNC_WEB3_METHOD", e6.DuplicateIframe = "DUPLICATE_IFRAME";
      }(t5.SDKWarningCode || (t5.SDKWarningCode = {})), function(e6) {
        e6[e6.ParseError = -32700] = "ParseError", e6[e6.InvalidRequest = -32600] = "InvalidRequest", e6[e6.MethodNotFound = -32601] = "MethodNotFound", e6[e6.InvalidParams = -32602] = "InvalidParams", e6[e6.InternalError = -32603] = "InternalError", e6[e6.MagicLinkFailedVerification = -1e4] = "MagicLinkFailedVerification", e6[e6.MagicLinkExpired = -10001] = "MagicLinkExpired", e6[e6.MagicLinkRateLimited = -10002] = "MagicLinkRateLimited", e6[e6.UserAlreadyLoggedIn = -10003] = "UserAlreadyLoggedIn";
      }(t5.RPCErrorCode || (t5.RPCErrorCode = {}));
    }, function(e5, t5, n3) {
      "use strict";
      Object.defineProperty(t5, "__esModule", { value: true }), function(e6) {
        e6.LoginWithEmail = "email", e6.LoginWithPhone = "phone";
      }(t5.WidgetModePrimaryLoginOption || (t5.WidgetModePrimaryLoginOption = {}));
    }, function(e5, t5, n3) {
      "use strict";
      var r6 = this && this.__generator || function(e6, t6) {
        var n4, r7, o6, i5, a5 = { label: 0, sent: function() {
          if (1 & o6[0])
            throw o6[1];
          return o6[1];
        }, trys: [], ops: [] };
        return i5 = { next: s6(0), throw: s6(1), return: s6(2) }, typeof Symbol == "function" && (i5[Symbol.iterator] = function() {
          return this;
        }), i5;
        function s6(i6) {
          return function(s7) {
            return function(i7) {
              if (n4)
                throw new TypeError("Generator is already executing.");
              for (; a5; )
                try {
                  if (n4 = 1, r7 && (o6 = 2 & i7[0] ? r7.return : i7[0] ? r7.throw || ((o6 = r7.return) && o6.call(r7), 0) : r7.next) && !(o6 = o6.call(r7, i7[1])).done)
                    return o6;
                  switch (r7 = 0, o6 && (i7 = [2 & i7[0], o6.value]), i7[0]) {
                    case 0:
                    case 1:
                      o6 = i7;
                      break;
                    case 4:
                      return a5.label++, { value: i7[1], done: false };
                    case 5:
                      a5.label++, r7 = i7[1], i7 = [0];
                      continue;
                    case 7:
                      i7 = a5.ops.pop(), a5.trys.pop();
                      continue;
                    default:
                      if (!(o6 = (o6 = a5.trys).length > 0 && o6[o6.length - 1]) && (i7[0] === 6 || i7[0] === 2)) {
                        a5 = 0;
                        continue;
                      }
                      if (i7[0] === 3 && (!o6 || i7[1] > o6[0] && i7[1] < o6[3])) {
                        a5.label = i7[1];
                        break;
                      }
                      if (i7[0] === 6 && a5.label < o6[1]) {
                        a5.label = o6[1], o6 = i7;
                        break;
                      }
                      if (o6 && a5.label < o6[2]) {
                        a5.label = o6[2], a5.ops.push(i7);
                        break;
                      }
                      o6[2] && a5.ops.pop(), a5.trys.pop();
                      continue;
                  }
                  i7 = t6.call(e6, a5);
                } catch (e7) {
                  i7 = [6, e7], r7 = 0;
                } finally {
                  n4 = o6 = 0;
                }
              if (5 & i7[0])
                throw i7[1];
              return { value: i7[0] ? i7[1] : void 0, done: true };
            }([i6, s7]);
          };
        }
      };
      Object.defineProperty(t5, "__esModule", { value: true });
      var o5 = function() {
        var e6;
        return r6(this, function(t6) {
          switch (t6.label) {
            case 0:
              e6 = 0, t6.label = 1;
            case 1:
              return e6 < Number.MAX_SAFE_INTEGER ? [4, ++e6] : [3, 3];
            case 2:
              return t6.sent(), [3, 4];
            case 3:
              e6 = 0, t6.label = 4;
            case 4:
              return [3, 1];
            case 5:
              return [2];
          }
        });
      }();
      t5.getPayloadId = function() {
        return o5.next().value;
      };
    }, function(e5, t5, n3) {
      "use strict";
      var r6, o5 = this && this.__extends || (r6 = function(e6, t6) {
        return (r6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e7, t7) {
          e7.__proto__ = t7;
        } || function(e7, t7) {
          for (var n4 in t7)
            t7.hasOwnProperty(n4) && (e7[n4] = t7[n4]);
        })(e6, t6);
      }, function(e6, t6) {
        function n4() {
          this.constructor = e6;
        }
        r6(e6, t6), e6.prototype = t6 === null ? Object.create(t6) : (n4.prototype = t6.prototype, new n4());
      });
      Object.defineProperty(t5, "__esModule", { value: true });
      var i5 = n3(0), a5 = n3(1), s6 = function(e6) {
        function t6() {
          return e6 !== null && e6.apply(this, arguments) || this;
        }
        return o5(t6, e6), t6.prototype.send = function(e7, t7) {
          var n4 = a5.createJsonRpcRequestPayload(i5.FmPayloadMethod.fm_composeSend, e7);
          this.sdk.getProvider().sendFortmaticAsync(n4, t7);
        }, t6;
      }(n3(5).BaseModule);
      t5.TransactionsModule = s6;
    }, function(e5, t5, n3) {
      "use strict";
      var r6, o5 = this && this.__extends || (r6 = function(e6, t6) {
        return (r6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e7, t7) {
          e7.__proto__ = t7;
        } || function(e7, t7) {
          for (var n4 in t7)
            t7.hasOwnProperty(n4) && (e7[n4] = t7[n4]);
        })(e6, t6);
      }, function(e6, t6) {
        function n4() {
          this.constructor = e6;
        }
        r6(e6, t6), e6.prototype = t6 === null ? Object.create(t6) : (n4.prototype = t6.prototype, new n4());
      }), i5 = this && this.__awaiter || function(e6, t6, n4, r7) {
        return new (n4 || (n4 = Promise))(function(o6, i6) {
          function a6(e7) {
            try {
              u6(r7.next(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function s7(e7) {
            try {
              u6(r7.throw(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function u6(e7) {
            var t7;
            e7.done ? o6(e7.value) : (t7 = e7.value, t7 instanceof n4 ? t7 : new n4(function(e8) {
              e8(t7);
            })).then(a6, s7);
          }
          u6((r7 = r7.apply(e6, t6 || [])).next());
        });
      }, a5 = this && this.__generator || function(e6, t6) {
        var n4, r7, o6, i6, a6 = { label: 0, sent: function() {
          if (1 & o6[0])
            throw o6[1];
          return o6[1];
        }, trys: [], ops: [] };
        return i6 = { next: s7(0), throw: s7(1), return: s7(2) }, typeof Symbol == "function" && (i6[Symbol.iterator] = function() {
          return this;
        }), i6;
        function s7(i7) {
          return function(s8) {
            return function(i8) {
              if (n4)
                throw new TypeError("Generator is already executing.");
              for (; a6; )
                try {
                  if (n4 = 1, r7 && (o6 = 2 & i8[0] ? r7.return : i8[0] ? r7.throw || ((o6 = r7.return) && o6.call(r7), 0) : r7.next) && !(o6 = o6.call(r7, i8[1])).done)
                    return o6;
                  switch (r7 = 0, o6 && (i8 = [2 & i8[0], o6.value]), i8[0]) {
                    case 0:
                    case 1:
                      o6 = i8;
                      break;
                    case 4:
                      return a6.label++, { value: i8[1], done: false };
                    case 5:
                      a6.label++, r7 = i8[1], i8 = [0];
                      continue;
                    case 7:
                      i8 = a6.ops.pop(), a6.trys.pop();
                      continue;
                    default:
                      if (!(o6 = (o6 = a6.trys).length > 0 && o6[o6.length - 1]) && (i8[0] === 6 || i8[0] === 2)) {
                        a6 = 0;
                        continue;
                      }
                      if (i8[0] === 3 && (!o6 || i8[1] > o6[0] && i8[1] < o6[3])) {
                        a6.label = i8[1];
                        break;
                      }
                      if (i8[0] === 6 && a6.label < o6[1]) {
                        a6.label = o6[1], o6 = i8;
                        break;
                      }
                      if (o6 && a6.label < o6[2]) {
                        a6.label = o6[2], a6.ops.push(i8);
                        break;
                      }
                      o6[2] && a6.ops.pop(), a6.trys.pop();
                      continue;
                  }
                  i8 = t6.call(e6, a6);
                } catch (e7) {
                  i8 = [6, e7], r7 = 0;
                } finally {
                  n4 = o6 = 0;
                }
              if (5 & i8[0])
                throw i8[1];
              return { value: i8[0] ? i8[1] : void 0, done: true };
            }([i7, s8]);
          };
        }
      };
      Object.defineProperty(t5, "__esModule", { value: true });
      var s6 = n3(0), u5 = n3(3), c5 = n3(1), l5 = function(e6) {
        function t6() {
          return e6 !== null && e6.apply(this, arguments) || this;
        }
        return o5(t6, e6), t6.prototype.login = function() {
          return i5(this, void 0, void 0, function() {
            return a5(this, function(e7) {
              return [2, this.sdk.getProvider().enable()];
            });
          });
        }, t6.prototype.logout = function() {
          var e7 = c5.createJsonRpcRequestPayload(s6.FmPayloadMethod.fm_logout);
          return u5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.getUser = function() {
          var e7 = c5.createJsonRpcRequestPayload(s6.FmPayloadMethod.fm_get_user);
          return u5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.getBalances = function() {
          var e7 = c5.createJsonRpcRequestPayload(s6.FmPayloadMethod.fm_get_balances);
          return u5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.getTransactions = function() {
          var e7 = c5.createJsonRpcRequestPayload(s6.FmPayloadMethod.fm_get_transactions);
          return u5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.isLoggedIn = function() {
          var e7 = c5.createJsonRpcRequestPayload(s6.FmPayloadMethod.fm_is_logged_in);
          return u5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.settings = function() {
          var e7 = c5.createJsonRpcRequestPayload(s6.FmPayloadMethod.fm_accountSettings);
          return u5.emitFortmaticPayload(this.sdk.getProvider(), e7);
        }, t6.prototype.deposit = function(e7) {
          var t7 = c5.createJsonRpcRequestPayload(s6.FmPayloadMethod.fm_deposit, [e7 || {}]);
          return u5.emitFortmaticPayload(this.sdk.getProvider(), t7);
        }, t6;
      }(n3(5).BaseModule);
      t5.UserModule = l5;
    }, function(e5, t5, n3) {
      "use strict";
      var r6 = this && this.__awaiter || function(e6, t6, n4, r7) {
        return new (n4 || (n4 = Promise))(function(o6, i6) {
          function a6(e7) {
            try {
              u6(r7.next(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function s7(e7) {
            try {
              u6(r7.throw(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function u6(e7) {
            var t7;
            e7.done ? o6(e7.value) : (t7 = e7.value, t7 instanceof n4 ? t7 : new n4(function(e8) {
              e8(t7);
            })).then(a6, s7);
          }
          u6((r7 = r7.apply(e6, t6 || [])).next());
        });
      }, o5 = this && this.__generator || function(e6, t6) {
        var n4, r7, o6, i6, a6 = { label: 0, sent: function() {
          if (1 & o6[0])
            throw o6[1];
          return o6[1];
        }, trys: [], ops: [] };
        return i6 = { next: s7(0), throw: s7(1), return: s7(2) }, typeof Symbol == "function" && (i6[Symbol.iterator] = function() {
          return this;
        }), i6;
        function s7(i7) {
          return function(s8) {
            return function(i8) {
              if (n4)
                throw new TypeError("Generator is already executing.");
              for (; a6; )
                try {
                  if (n4 = 1, r7 && (o6 = 2 & i8[0] ? r7.return : i8[0] ? r7.throw || ((o6 = r7.return) && o6.call(r7), 0) : r7.next) && !(o6 = o6.call(r7, i8[1])).done)
                    return o6;
                  switch (r7 = 0, o6 && (i8 = [2 & i8[0], o6.value]), i8[0]) {
                    case 0:
                    case 1:
                      o6 = i8;
                      break;
                    case 4:
                      return a6.label++, { value: i8[1], done: false };
                    case 5:
                      a6.label++, r7 = i8[1], i8 = [0];
                      continue;
                    case 7:
                      i8 = a6.ops.pop(), a6.trys.pop();
                      continue;
                    default:
                      if (!(o6 = (o6 = a6.trys).length > 0 && o6[o6.length - 1]) && (i8[0] === 6 || i8[0] === 2)) {
                        a6 = 0;
                        continue;
                      }
                      if (i8[0] === 3 && (!o6 || i8[1] > o6[0] && i8[1] < o6[3])) {
                        a6.label = i8[1];
                        break;
                      }
                      if (i8[0] === 6 && a6.label < o6[1]) {
                        a6.label = o6[1], o6 = i8;
                        break;
                      }
                      if (o6 && a6.label < o6[2]) {
                        a6.label = o6[2], a6.ops.push(i8);
                        break;
                      }
                      o6[2] && a6.ops.pop(), a6.trys.pop();
                      continue;
                  }
                  i8 = t6.call(e6, a6);
                } catch (e7) {
                  i8 = [6, e7], r7 = 0;
                } finally {
                  n4 = o6 = 0;
                }
              if (5 & i8[0])
                throw i8[1];
              return { value: i8[0] ? i8[1] : void 0, done: true };
            }([i7, s8]);
          };
        }
      };
      Object.defineProperty(t5, "__esModule", { value: true });
      var i5 = n3(0), a5 = n3(3), s6 = n3(1), u5 = n3(4), c5 = n3(22), l5 = n3(6), d5 = n3(7), p5 = n3(2), f7 = function() {
        function e6(e7, t6, n4) {
          this.apiKey = t6, this.isFortmatic = true, this.queue = [], this.overlay = new c5.FmIframeController(e7, n4), this.payloadTransport = new l5.FmPayloadTransport(e7, n4), this.listen();
        }
        return e6.prototype.sendAsync = function(e7, t6) {
          if (!t6)
            throw p5.createInvalidArgumentError({ functionName: "sendAsync", argIndex: 1, expected: "function", received: t6 === null ? "null" : typeof t6 });
          if (Array.isArray(e7))
            return this.enqueue({ onRequestComplete: t6, payload: s6.createJsonRpcBatchRequestPayload(e7) });
          var n4 = s6.standardizeRequestPayload(e7);
          return u5.isJsonRpcBatchRequestPayload(n4), this.enqueue({ onRequestComplete: t6, payload: n4 });
        }, e6.prototype.sendFortmaticAsync = function(e7, t6) {
          if (!t6)
            throw p5.createInvalidArgumentError({ functionName: "sendFortmaticAsync", argIndex: 1, expected: "function", received: t6 === null ? "null" : typeof t6 });
          var n4 = s6.standardizeRequestPayload(e7);
          this.enqueue({ onRequestComplete: t6, payload: n4, isFortmaticMethod: true });
        }, e6.prototype.send = function(e7, t6) {
          return typeof e7 == "string" ? a5.emitWeb3Payload(this, e7, t6) : t6 ? void this.sendAsync(e7, t6) : (p5.createSynchronousWeb3MethodWarning().log(), new d5.JsonRpcResponse(e7).applyError({ code: -32603, message: "Non-async web3 methods will be deprecated in web3 > 1.0 and are not supported by the Fortmatic provider. An async method is to be used instead." }).payload);
        }, e6.prototype.enable = function() {
          return a5.emitWeb3Payload(this, "eth_accounts");
        }, e6.prototype.enqueue = function(e7) {
          e7 && (this.queue.push(e7), this.overlay.overlayReady && this.dequeue());
        }, e6.prototype.dequeue = function() {
          return r6(this, void 0, void 0, function() {
            var e7, t6, n4, r7;
            return o5(this, function(o6) {
              switch (o6.label) {
                case 0:
                  return this.queue.length === 0 ? [2] : (e7 = this.queue.shift()) ? (t6 = e7.payload, u5.isJsonRpcBatchRequestPayload(t6) ? t6.batch.length === 0 ? [2, e7.onRequestComplete(null, [])] : [4, this.payloadTransport.post(this.overlay, i5.FmOutgoingWindowMessage.FORTMATIC_HANDLE_REQUEST, t6)] : [3, 2]) : [3, 5];
                case 1:
                  n4 = o6.sent(), e7.onRequestComplete(null, n4), o6.label = 2;
                case 2:
                  return u5.isJsonRpcRequestPayload(t6) ? [4, this.payloadTransport.post(this.overlay, e7.isFortmaticMethod ? i5.FmOutgoingWindowMessage.FORTMATIC_HANDLE_FORTMATIC_REQUEST : i5.FmOutgoingWindowMessage.FORTMATIC_HANDLE_REQUEST, t6)] : [3, 4];
                case 3:
                  (r7 = o6.sent()).error ? e7.onRequestComplete(new p5.RpcError(r7.error), r7) : e7.onRequestComplete(null, r7), o6.label = 4;
                case 4:
                  this.dequeue(), o6.label = 5;
                case 5:
                  return [2];
              }
            });
          });
        }, e6.prototype.listen = function() {
          var e7 = this;
          this.payloadTransport.on(i5.FmIncomingWindowMessage.FORTMATIC_OVERLAY_READY, function() {
            e7.dequeue();
          }), this.payloadTransport.on(i5.FmIncomingWindowMessage.FORTMATIC_USER_DENIED, function() {
            e7.queue.forEach(function(e8) {
              var t6 = new d5.JsonRpcResponse(e8.payload), n4 = { message: "Fortmatic: Modal was closed without executing action!", code: 1 };
              e8.onRequestComplete(new p5.RpcError(n4), t6.applyError(n4).payload);
            }), e7.queue.slice(0);
          });
        }, e6;
      }();
      t5.FmProvider = f7;
    }, function(e5, t5, n3) {
      "use strict";
      var r6 = this && this.__awaiter || function(e6, t6, n4, r7) {
        return new (n4 || (n4 = Promise))(function(o6, i6) {
          function a6(e7) {
            try {
              u6(r7.next(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function s7(e7) {
            try {
              u6(r7.throw(e7));
            } catch (e8) {
              i6(e8);
            }
          }
          function u6(e7) {
            var t7;
            e7.done ? o6(e7.value) : (t7 = e7.value, t7 instanceof n4 ? t7 : new n4(function(e8) {
              e8(t7);
            })).then(a6, s7);
          }
          u6((r7 = r7.apply(e6, t6 || [])).next());
        });
      }, o5 = this && this.__generator || function(e6, t6) {
        var n4, r7, o6, i6, a6 = { label: 0, sent: function() {
          if (1 & o6[0])
            throw o6[1];
          return o6[1];
        }, trys: [], ops: [] };
        return i6 = { next: s7(0), throw: s7(1), return: s7(2) }, typeof Symbol == "function" && (i6[Symbol.iterator] = function() {
          return this;
        }), i6;
        function s7(i7) {
          return function(s8) {
            return function(i8) {
              if (n4)
                throw new TypeError("Generator is already executing.");
              for (; a6; )
                try {
                  if (n4 = 1, r7 && (o6 = 2 & i8[0] ? r7.return : i8[0] ? r7.throw || ((o6 = r7.return) && o6.call(r7), 0) : r7.next) && !(o6 = o6.call(r7, i8[1])).done)
                    return o6;
                  switch (r7 = 0, o6 && (i8 = [2 & i8[0], o6.value]), i8[0]) {
                    case 0:
                    case 1:
                      o6 = i8;
                      break;
                    case 4:
                      return a6.label++, { value: i8[1], done: false };
                    case 5:
                      a6.label++, r7 = i8[1], i8 = [0];
                      continue;
                    case 7:
                      i8 = a6.ops.pop(), a6.trys.pop();
                      continue;
                    default:
                      if (!(o6 = (o6 = a6.trys).length > 0 && o6[o6.length - 1]) && (i8[0] === 6 || i8[0] === 2)) {
                        a6 = 0;
                        continue;
                      }
                      if (i8[0] === 3 && (!o6 || i8[1] > o6[0] && i8[1] < o6[3])) {
                        a6.label = i8[1];
                        break;
                      }
                      if (i8[0] === 6 && a6.label < o6[1]) {
                        a6.label = o6[1], o6 = i8;
                        break;
                      }
                      if (o6 && a6.label < o6[2]) {
                        a6.label = o6[2], a6.ops.push(i8);
                        break;
                      }
                      o6[2] && a6.ops.pop(), a6.trys.pop();
                      continue;
                  }
                  i8 = t6.call(e6, a6);
                } catch (e7) {
                  i8 = [6, e7], r7 = 0;
                } finally {
                  n4 = o6 = 0;
                }
              if (5 & i8[0])
                throw i8[1];
              return { value: i8[0] ? i8[1] : void 0, done: true };
            }([i7, s8]);
          };
        }
      }, i5 = this && this.__values || function(e6) {
        var t6 = typeof Symbol == "function" && Symbol.iterator, n4 = t6 && e6[t6], r7 = 0;
        if (n4)
          return n4.call(e6);
        if (e6 && typeof e6.length == "number")
          return { next: function() {
            return e6 && r7 >= e6.length && (e6 = void 0), { value: e6 && e6[r7++], done: !e6 };
          } };
        throw new TypeError(t6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, a5 = this && this.__read || function(e6, t6) {
        var n4 = typeof Symbol == "function" && e6[Symbol.iterator];
        if (!n4)
          return e6;
        var r7, o6, i6 = n4.call(e6), a6 = [];
        try {
          for (; (t6 === void 0 || t6-- > 0) && !(r7 = i6.next()).done; )
            a6.push(r7.value);
        } catch (e7) {
          o6 = { error: e7 };
        } finally {
          try {
            r7 && !r7.done && (n4 = i6.return) && n4.call(i6);
          } finally {
            if (o6)
              throw o6.error;
          }
        }
        return a6;
      };
      Object.defineProperty(t5, "__esModule", { value: true });
      var s6 = n3(0), u5 = n3(6), c5 = n3(2), l5 = { display: "none", position: "fixed", top: "0", right: "0", width: "100%", height: "100%", borderRadius: "0", border: "none", zIndex: "2147483647" };
      var d5 = function() {
        function e6(e7, t6) {
          this.endpoint = e7, this.encodedQueryParams = t6, this._overlayReady = false, this.iframe = this.init(), this.payloadTransport = new u5.FmPayloadTransport(e7, t6), this.listen();
        }
        return Object.defineProperty(e6.prototype, "overlayReady", { get: function() {
          return this._overlayReady;
        }, enumerable: true, configurable: true }), e6.prototype.init = function() {
          var e7 = this;
          return new Promise(function(t6) {
            var n4 = function() {
              if (o6 = e7.encodedQueryParams, s7 = [].slice.call(document.querySelectorAll(".fortmatic-iframe")), Boolean(s7.find(function(e8) {
                var t7;
                return (t7 = e8.src) === null || t7 === void 0 ? void 0 : t7.includes(o6);
              })))
                c5.createDuplicateIframeWarning().log();
              else {
                var n5 = document.createElement("iframe");
                n5.classList.add("fortmatic-iframe"), n5.dataset.fortmaticIframeLabel = new URL(e7.endpoint).host, n5.src = new URL("/send?params=" + e7.encodedQueryParams, e7.endpoint).href, function(e8) {
                  var t7, n6;
                  try {
                    for (var r8 = i5(Object.entries(l5)), o7 = r8.next(); !o7.done; o7 = r8.next()) {
                      var s8 = a5(o7.value, 2), u6 = s8[0], c6 = s8[1];
                      e8.style[u6] = c6;
                    }
                  } catch (e9) {
                    t7 = { error: e9 };
                  } finally {
                    try {
                      o7 && !o7.done && (n6 = r8.return) && n6.call(r8);
                    } finally {
                      if (t7)
                        throw t7.error;
                    }
                  }
                }(n5), document.body.appendChild(n5);
                var r7 = document.createElement("img");
                r7.src = "https://static.fortmatic.com/assets/trans.gif", r7.style.position = "fixed", document.body.appendChild(r7), t6(n5);
              }
              var o6, s7;
            };
            ["loaded", "interactive", "complete"].includes(document.readyState) ? n4() : window.addEventListener("load", n4, false);
          });
        }, e6.prototype.showOverlay = function() {
          return r6(this, void 0, void 0, function() {
            return o5(this, function(e7) {
              switch (e7.label) {
                case 0:
                  return [4, this.iframe];
                case 1:
                  return e7.sent().style.display = "block", [2];
              }
            });
          });
        }, e6.prototype.hideOverlay = function() {
          return r6(this, void 0, void 0, function() {
            return o5(this, function(e7) {
              switch (e7.label) {
                case 0:
                  return [4, this.iframe];
                case 1:
                  return e7.sent().style.display = "none", [2];
              }
            });
          });
        }, e6.prototype.listen = function() {
          var e7 = this;
          this.payloadTransport.on(s6.FmIncomingWindowMessage.FORTMATIC_OVERLAY_READY, function() {
            e7._overlayReady = true;
          }), this.payloadTransport.on(s6.FmIncomingWindowMessage.FORTMATIC_HIDE_OVERLAY, function() {
            e7.hideOverlay();
          }), this.payloadTransport.on(s6.FmIncomingWindowMessage.FORTMATIC_SHOW_OVERLAY, function() {
            e7.showOverlay();
          });
        }, e6;
      }();
      t5.FmIframeController = d5;
    }, function(e5, t5, n3) {
      "use strict";
      var r6;
      Object.defineProperty(t5, "__esModule", { value: true }), function(e6) {
        e6.HARMONY = "HARMONY";
      }(r6 || (r6 = {})), t5.encodeQueryParameters = function(e6) {
        return btoa(JSON.stringify(e6));
      }, t5.decodeQueryParameters = function(e6) {
        return JSON.parse(atob(e6));
      };
    }, function(e5) {
      e5.exports = JSON.parse('{"name":"fortmatic","version":"2.2.1","description":"Fortmatic Javascript SDK","author":"Fortmatic <team@fortmatic.com> (https://fortmatic.com/)","license":"MIT","repository":{"type":"git","url":"https://github.com/fortmatic/fortmatic-js"},"keywords":["auth","login","web3","crypto","ethereum","metaMask","wallet","blockchain","dapp"],"homepage":"https://www.fortmatic.com","main":"dist/cjs/fortmatic.js","types":"dist/cjs/src/index.d.ts","scripts":{"start":"npm run clean:build && ./scripts/start.sh","build":"npm run clean:build && ./scripts/build.sh","test":"npm run clean:test-artifacts && ./scripts/test.sh","lint":"eslint --fix src/**/*.ts","clean":"npm-run-all -s clean:*","clean:test-artifacts":"rimraf coverage && rimraf .nyc_output","clean:build":"rimraf dist","clean_node_modules":"rimraf node_modules"},"dependencies":{},"devDependencies":{"@ikscodes/browser-env":"~0.3.1","@ikscodes/eslint-config":"~6.2.0","@ikscodes/prettier-config":"^0.1.0","@istanbuljs/nyc-config-typescript":"~0.1.3","@types/jsdom":"~12.2.4","@types/sinon":"~7.5.0","@types/webpack":"~4.41.0","@typescript-eslint/eslint-plugin":"~2.17.0","ava":"2.2.0","cross-env":"~6.0.3","eslint":"~6.8.0","eslint-import-resolver-typescript":"~2.0.0","eslint-plugin-import":"~2.20.0","eslint-plugin-jsx-a11y":"~6.2.3","eslint-plugin-prettier":"~3.1.2","eslint-plugin-react":"~7.18.0","eslint-plugin-react-hooks":"~1.7.0","lodash":"~4.17.15","npm-run-all":"~4.1.5","nyc":"13.1.0","prettier":"~1.19.1","rimraf":"~3.0.0","sinon":"7.1.1","ts-loader":"~6.2.1","ts-node":"~8.5.2","typescript":"~3.7.2","webpack":"~4.41.2","webpack-chain":"~6.2.0","webpack-cli":"~3.3.10"},"ava":{"require":["ts-node/register"],"files":["test/**/*.spec.ts"],"extensions":["ts"],"compileEnhancements":false,"verbose":true},"nyc":{"extends":"@istanbuljs/nyc-config-typescript","all":false,"check-coverage":true,"per-file":true,"lines":99,"statements":99,"functions":99,"branches":99,"reporter":["html","lcov"]}}');
    }]).default;
  }
});

// node_modules/walletlink/node_modules/bn.js/lib/bn.js
var require_bn5 = __commonJS({
  "node_modules/walletlink/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number2, base2, endian) {
        if (BN6.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = (init_buffer(), buffer_exports).Buffer;
        }
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert5(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN6.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number2, base2, endian) {
        assert5(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i5 = number2.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number2[i5] | number2[i5 - 1] << 8 | number2[i5 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number2.length; i5 += 3) {
            w6 = number2[i5] | number2[i5 + 1] << 8 | number2[i5 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c5 = string2.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert5(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r6 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r6;
      }
      BN6.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number2.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number2.length; i5 += 2) {
            w6 = parseHexByte(number2, start, i5) << off;
            this.words[j5] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var b4 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            b4 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b4 = c5 - 17 + 10;
          } else {
            b4 = c5;
          }
          assert5(c5 >= 0 && b4 < mul3, "Invalid character");
          r6 += b4;
        }
        return r6;
      }
      BN6.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number2, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i5, number2.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN6.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN6.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN6.prototype.clone = function clone() {
        var r6 = new BN6(null);
        this.copy(r6);
        return r6;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN6.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e5) {
          BN6.prototype.inspect = inspect4;
        }
      } else {
        BN6.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modrn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer3) {
        BN6.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer3, endian, length);
        };
      }
      BN6.prototype.toArray = function toArray3(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN6.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN6.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = num.words[off] >>> wbit & 1;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN6.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this._strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this._strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this._strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN6.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t5 = new Array(N5);
        var l5 = BN6.prototype._countBits(N5) - 1;
        for (var i5 = 0; i5 < N5; i5++) {
          t5[i5] = this.revBin(i5, l5, N5);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N5) {
        if (x5 === 0 || x5 === N5 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i5 = 0; i5 < N5; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s6 = 1; s6 < N5; s6 <<= 1) {
          var l5 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N5; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s6; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s6];
              var io = itws[p5 + j5 + s6];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s6] = re - ro;
              itws[p5 + j5 + s6] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N5 = Math.max(m5, n3) | 1;
        var odd = N5 & 1;
        var i5 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1)
          return;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N5 - i5 - 1];
          rws[N5 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N5 - i5 - 1];
          iws[N5 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N5) * 8192 + Math.round(ws[2 * i5] / N5) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N5; ++i5) {
          rws[i5] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i5 = 0; i5 < N5; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N5 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N5);
        var _10 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x5.words, x5.length, rws, N5);
        this.convert13b(y5.words, y5.length, nrws, N5);
        this.transform(rws, _10, rwst, iwst, N5, rbt);
        this.transform(nrws, _10, nrwst, niwst, N5, rbt);
        for (var i5 = 0; i5 < N5; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _10, N5, rbt);
        this.conjugate(rmws, _10, N5);
        this.normalize13b(rmws, N5);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out._strip();
      };
      BN6.prototype.mul = function mul3(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(typeof num === "number");
        assert5(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s6] = this.words[i5];
          }
          for (i5 = 0; i5 < s6; i5++) {
            this.words[i5] = 0;
          }
          this.length += s6;
        }
        return this._strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s6;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s6; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w6 = this.words[s6];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul3;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert5(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a5._strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert5(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN6.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN6.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B3.isOdd()) {
                A6.iadd(yp);
                B3.isub(xp);
              }
              A6.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g5)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s6; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert5(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert5(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p5) {
        this.name = name2;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert5(a5.negative === 0, "red works only with positives");
        assert5(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert5((a5.negative | b4.negative) === 0, "red works only with positives");
        assert5(a5.red && a5.red === b4.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        move(a5, a5.umod(this.m)._forceRed(this));
        return a5;
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s6 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s6++;
          q5.iushrn(1);
        }
        assert5(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c5 = this.pow(z4, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s6;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert5(i5 < m5);
          var b4 = this.pow(c5, new BN6(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/classes.js
var require_classes2 = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_10, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants2 = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/utils.js
var require_utils5 = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants2();
    var classes_1 = require_classes2();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a2, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key2) {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    }
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes2();
    var utils_12 = require_utils5();
    var error_constants_1 = require_error_constants2();
    exports.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_12.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_12.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes2();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_12 = require_utils5();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_12.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_12.getMessageFromCode;
    } });
    var errors_1 = require_errors2();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants2();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/walletlink/dist/connection/WalletLinkAnalytics.js
var require_WalletLinkAnalytics = __commonJS({
  "node_modules/walletlink/dist/connection/WalletLinkAnalytics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkAnalytics = void 0;
    var WalletLinkAnalytics = class {
      sendEvent(_eventType, _eventProperties) {
      }
    };
    exports.WalletLinkAnalytics = WalletLinkAnalytics;
  }
});

// node_modules/walletlink/dist/EthereumChain.js
var require_EthereumChain = __commonJS({
  "node_modules/walletlink/dist/EthereumChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumChain = void 0;
    var EthereumChain;
    (function(EthereumChain2) {
      EthereumChain2[EthereumChain2["ETHEREUM_MAINNET"] = 1] = "ETHEREUM_MAINNET";
      EthereumChain2[EthereumChain2["OPTIMISM_MAINNET"] = 10] = "OPTIMISM_MAINNET";
      EthereumChain2[EthereumChain2["POLYGON_MAINNET"] = 137] = "POLYGON_MAINNET";
      EthereumChain2[EthereumChain2["ETHEREUM_CLASSIC_MAINNET"] = 61] = "ETHEREUM_CLASSIC_MAINNET";
      EthereumChain2[EthereumChain2["BSC_MAINNET"] = 56] = "BSC_MAINNET";
      EthereumChain2[EthereumChain2["FANTOM_MAINNET"] = 250] = "FANTOM_MAINNET";
      EthereumChain2[EthereumChain2["ARBITRUM_MAINNET"] = 42161] = "ARBITRUM_MAINNET";
      EthereumChain2[EthereumChain2["XDAI_MAINNET"] = 100] = "XDAI_MAINNET";
      EthereumChain2[EthereumChain2["AVALANCHE_MAINNET"] = 43114] = "AVALANCHE_MAINNET";
      EthereumChain2[EthereumChain2["ROPSTEN"] = 3] = "ROPSTEN";
      EthereumChain2[EthereumChain2["RINKEBY"] = 4] = "RINKEBY";
      EthereumChain2[EthereumChain2["GOERLI"] = 5] = "GOERLI";
      EthereumChain2[EthereumChain2["KOVAN"] = 42] = "KOVAN";
      EthereumChain2[EthereumChain2["OPTIMISM_KOVAN"] = 69] = "OPTIMISM_KOVAN";
      EthereumChain2[EthereumChain2["POLYGON_TESTNET"] = 80001] = "POLYGON_TESTNET";
      EthereumChain2[EthereumChain2["BSC_TESTNET"] = 97] = "BSC_TESTNET";
      EthereumChain2[EthereumChain2["FANTOM_TESTNET"] = 4002] = "FANTOM_TESTNET";
      EthereumChain2[EthereumChain2["ARBITRUM_TESTNET"] = 421611] = "ARBITRUM_TESTNET";
      EthereumChain2[EthereumChain2["AVALANCHE_FUJI"] = 43113] = "AVALANCHE_FUJI";
    })(EthereumChain = exports.EthereumChain || (exports.EthereumChain = {}));
    (function(EthereumChain2) {
      function rpcUrl(thiz) {
        switch (thiz) {
          case EthereumChain2.ETHEREUM_MAINNET:
            return "https://mainnet-infura.wallet.coinbase.com";
          case EthereumChain2.ROPSTEN:
            return "https://ropsten-infura.wallet.coinbase.com";
          case EthereumChain2.RINKEBY:
            return "https://rinkeby-infura.wallet.coinbase.com";
          case EthereumChain2.KOVAN:
            return "https://kovan-infura.wallet.coinbase.com";
          case EthereumChain2.GOERLI:
            return "https://goerli-node.wallet.coinbase.com";
          case EthereumChain2.OPTIMISM_KOVAN:
            return "https://optimism-node.wallet.coinbase.com";
          case EthereumChain2.OPTIMISM_MAINNET:
            return "https://optimism-mainnet.wallet.coinbase.com";
          case EthereumChain2.POLYGON_MAINNET:
            return "https://polygon-mainnet-infura.wallet.coinbase.com";
          case EthereumChain2.POLYGON_TESTNET:
            return "https://polygon-mumbai-infura.wallet.coinbase.com";
          case EthereumChain2.BSC_MAINNET:
            return "https://bsc-dataseed.binance.org";
          case EthereumChain2.BSC_TESTNET:
            return "https://data-seed-prebsc-1-s1.binance.org:8545";
          case EthereumChain2.FANTOM_MAINNET:
            return "https://rpcapi.fantom.network";
          case EthereumChain2.FANTOM_TESTNET:
            return "https://rpc.testnet.fantom.network";
          case EthereumChain2.ARBITRUM_MAINNET:
            return "https://l2-mainnet.wallet.coinbase.com?targetName=arbitrum";
          case EthereumChain2.ARBITRUM_TESTNET:
            return "https://rinkeby.arbitrum.io/rpc";
          case EthereumChain2.XDAI_MAINNET:
            return "https://rpc.xdaichain.com";
          case EthereumChain2.AVALANCHE_MAINNET:
            return "https://api.avax.network/ext/bc/C/rpc";
          case EthereumChain2.AVALANCHE_FUJI:
            return "https://api.avax-test.network/ext/bc/C/rpc";
          default:
            return void 0;
        }
      }
      EthereumChain2.rpcUrl = rpcUrl;
      function fromChainId(chainId) {
        switch (Number(chainId)) {
          case EthereumChain2.ETHEREUM_MAINNET.valueOf():
            return EthereumChain2.ETHEREUM_MAINNET;
          case EthereumChain2.OPTIMISM_MAINNET.valueOf():
            return EthereumChain2.OPTIMISM_MAINNET;
          case EthereumChain2.POLYGON_MAINNET.valueOf():
            return EthereumChain2.POLYGON_MAINNET;
          case EthereumChain2.ETHEREUM_CLASSIC_MAINNET.valueOf():
            return EthereumChain2.ETHEREUM_CLASSIC_MAINNET;
          case EthereumChain2.BSC_MAINNET.valueOf():
            return EthereumChain2.BSC_MAINNET;
          case EthereumChain2.FANTOM_MAINNET.valueOf():
            return EthereumChain2.FANTOM_MAINNET;
          case EthereumChain2.ARBITRUM_MAINNET.valueOf():
            return EthereumChain2.ARBITRUM_MAINNET;
          case EthereumChain2.AVALANCHE_MAINNET.valueOf():
            return EthereumChain2.AVALANCHE_MAINNET;
          case EthereumChain2.XDAI_MAINNET.valueOf():
            return EthereumChain2.XDAI_MAINNET;
          case EthereumChain2.ROPSTEN.valueOf():
            return EthereumChain2.ROPSTEN;
          case EthereumChain2.RINKEBY.valueOf():
            return EthereumChain2.RINKEBY;
          case EthereumChain2.GOERLI.valueOf():
            return EthereumChain2.GOERLI;
          case EthereumChain2.KOVAN.valueOf():
            return EthereumChain2.KOVAN;
          case EthereumChain2.OPTIMISM_KOVAN.valueOf():
            return EthereumChain2.OPTIMISM_KOVAN;
          case EthereumChain2.POLYGON_TESTNET.valueOf():
            return EthereumChain2.POLYGON_TESTNET;
          case EthereumChain2.BSC_TESTNET.valueOf():
            return EthereumChain2.BSC_TESTNET;
          case EthereumChain2.FANTOM_TESTNET.valueOf():
            return EthereumChain2.FANTOM_TESTNET;
          case EthereumChain2.ARBITRUM_TESTNET.valueOf():
            return EthereumChain2.ARBITRUM_TESTNET;
          case EthereumChain2.AVALANCHE_FUJI.valueOf():
            return EthereumChain2.AVALANCHE_FUJI;
          default:
            return void 0;
        }
      }
      EthereumChain2.fromChainId = fromChainId;
    })(EthereumChain = exports.EthereumChain || (exports.EthereumChain = {}));
  }
});

// node_modules/walletlink/dist/init/events.js
var require_events2 = __commonJS({
  "node_modules/walletlink/dist/init/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EVENTS = void 0;
    exports.EVENTS = {
      REQUEST_CHILD_ETHEREUM_ACCOUNTS_START: "walletlink_sdk.request_child_ethereum_accounts.start",
      REQUEST_CHILD_ETHEREUM_ACCOUNTS_RESPONSE: "walletlink_sdk.request_child_ethereum_accounts.response",
      STARTED_CONNECTING: "walletlink_sdk.started.connecting",
      CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
      DISCONNECTED: "walletlink_sdk.disconnected",
      METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
      LINKED: "walletlink_sdk.linked",
      FAILURE: "walletlink_sdk.generic_failure",
      SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
      ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
      SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
      UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
      SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
      GENERAL_ERROR: "walletlink_sdk.general_error",
      WEB3_REQUEST: "walletlink_sdk.web3.request",
      WEB3_RESPONSE: "walletlink_sdk.web3.response"
    };
  }
});

// node_modules/walletlink/dist/init/WalletLinkAnalyticsAbstract.js
var require_WalletLinkAnalyticsAbstract = __commonJS({
  "node_modules/walletlink/dist/init/WalletLinkAnalyticsAbstract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkAnalyticsAbstract = void 0;
    var WalletLinkAnalyticsAbstract = class {
    };
    exports.WalletLinkAnalyticsAbstract = WalletLinkAnalyticsAbstract;
  }
});

// node_modules/walletlink/dist/init/index.js
var require_init = __commonJS({
  "node_modules/walletlink/dist/init/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
          __createBinding(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_events2(), exports);
    __exportStar(require_WalletLinkAnalyticsAbstract(), exports);
  }
});

// node_modules/walletlink/node_modules/tslib/tslib.es6.js
function __extends(d5, b4) {
  extendStatics(d5, b4);
  function __() {
    this.constructor = d5;
  }
  d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
var extendStatics;
var init_tslib_es6 = __esm({
  "node_modules/walletlink/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d5, b4) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
        d6.__proto__ = b5;
      } || function(d6, b5) {
        for (var p5 in b5)
          if (b5.hasOwnProperty(p5))
            d6[p5] = b5[p5];
      };
      return extendStatics(d5, b4);
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isFunction.js
function isFunction(x5) {
  return typeof x5 === "function";
}
var init_isFunction = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isFunction.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/config.js
var _enable_super_gross_mode_that_will_cause_bad_things, config;
var init_config = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/config.js"() {
    _enable_super_gross_mode_that_will_cause_bad_things = false;
    config = {
      Promise: void 0,
      set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
          var error = new Error();
          console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log("RxJS: Back to a better error behavior. Thank you. <3");
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/hostReportError.js
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var init_hostReportError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/hostReportError.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/Observer.js
var empty;
var init_Observer = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/Observer.js"() {
    init_config();
    init_hostReportError();
    empty = {
      closed: true,
      next: function(value) {
      },
      error: function(err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      },
      complete: function() {
      }
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray;
var init_isArray = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isArray.js"() {
    isArray = function() {
      return Array.isArray || function(x5) {
        return x5 && typeof x5.length === "number";
      };
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isObject.js
function isObject3(x5) {
  return x5 !== null && typeof x5 === "object";
}
var init_isObject = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isObject.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionErrorImpl, UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js"() {
    UnsubscriptionErrorImpl = function() {
      function UnsubscriptionErrorImpl2(errors) {
        Error.call(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i5) {
          return i5 + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
        return this;
      }
      UnsubscriptionErrorImpl2.prototype = Object.create(Error.prototype);
      return UnsubscriptionErrorImpl2;
    }();
    UnsubscriptionError = UnsubscriptionErrorImpl;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/Subscription.js
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var Subscription;
var init_Subscription = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/Subscription.js"() {
    init_isArray();
    init_isObject();
    init_isFunction();
    init_UnsubscriptionError();
    Subscription = function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._ctorUnsubscribe = true;
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var errors;
        if (this.closed) {
          return;
        }
        var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription2) {
          _parentOrParents.remove(this);
        } else if (_parentOrParents !== null) {
          for (var index = 0; index < _parentOrParents.length; ++index) {
            var parent_1 = _parentOrParents[index];
            parent_1.remove(this);
          }
        }
        if (isFunction(_unsubscribe)) {
          if (_ctorUnsubscribe) {
            this._unsubscribe = void 0;
          }
          try {
            _unsubscribe.call(this);
          } catch (e5) {
            errors = e5 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e5.errors) : [e5];
          }
        }
        if (isArray(_subscriptions)) {
          var index = -1;
          var len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject3(sub)) {
              try {
                sub.unsubscribe();
              } catch (e5) {
                errors = errors || [];
                if (e5 instanceof UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(e5.errors));
                } else {
                  errors.push(e5);
                }
              }
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var subscription = teardown;
        if (!teardown) {
          return Subscription2.EMPTY;
        }
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription2)) {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default: {
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
          }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
          subscription._parentOrParents = this;
        } else if (_parentOrParents instanceof Subscription2) {
          if (_parentOrParents === this) {
            return subscription;
          }
          subscription._parentOrParents = [_parentOrParents, this];
        } else if (_parentOrParents.indexOf(this) === -1) {
          _parentOrParents.push(this);
        } else {
          return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
          this._subscriptions = [subscription];
        } else {
          subscriptions.push(subscription);
        }
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.EMPTY = function(empty3) {
        empty3.closed = true;
        return empty3;
      }(new Subscription2());
      return Subscription2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber;
var init_rxSubscriber = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js"() {
    rxSubscriber = function() {
      return typeof Symbol === "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber, SafeSubscriber;
var init_Subscriber = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/Subscriber.js"() {
    init_tslib_es6();
    init_isFunction();
    init_Observer();
    init_Subscription();
    init_rxSubscriber();
    init_config();
    init_hostReportError();
    Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
          case 0:
            _this.destination = empty;
            break;
          case 1:
            if (!destinationOrNext) {
              _this.destination = empty;
              break;
            }
            if (typeof destinationOrNext === "object") {
              if (destinationOrNext instanceof Subscriber2) {
                _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                _this.destination = destinationOrNext;
                destinationOrNext.add(_this);
              } else {
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext);
              }
              break;
            }
          default:
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
            break;
        }
        return _this;
      }
      Subscriber2.prototype[rxSubscriber] = function() {
        return this;
      };
      Subscriber2.create = function(next, error, complete) {
        var subscriber = new Subscriber2(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      };
      Subscriber2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
      };
      Subscriber2.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
      };
      Subscriber2.prototype._unsubscribeAndRecycle = function() {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
      };
      return Subscriber2;
    }(Subscription);
    SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== empty) {
            context = Object.create(observerOrNext);
            if (isFunction(context.unsubscribe)) {
              _this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = _this.unsubscribe.bind(_this);
          }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
      }
      SafeSubscriber2.prototype.next = function(value) {
        if (!this.isStopped && this._next) {
          var _parentSubscriber = this._parentSubscriber;
          if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }
            hostReportError(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              hostReportError(err);
            }
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._complete) {
            var wrappedComplete = function() {
              return _this._complete.call(_this._context);
            };
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
        try {
          fn.call(this._context, value);
        } catch (err) {
          this.unsubscribe();
          if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            hostReportError(err);
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
          throw new Error("bad call");
        }
        try {
          fn.call(this._context, value);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            hostReportError(err);
            return true;
          }
        }
        return false;
      };
      SafeSubscriber2.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/canReportError.js
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
var init_canReportError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/canReportError.js"() {
    init_Subscriber();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/toSubscriber.js
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var init_toSubscriber = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/toSubscriber.js"() {
    init_Subscriber();
    init_rxSubscriber();
    init_Observer();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/symbol/observable.js"() {
    observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/identity.js
function identity(x5) {
  return x5;
}
var init_identity = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/identity.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var init_pipe = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/pipe.js"() {
    init_identity();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var Observable;
var init_Observable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/Observable.js"() {
    init_canReportError();
    init_toSubscriber();
    init_observable();
    init_pipe();
    init_config();
    Observable = function() {
      function Observable2(subscribe) {
        this._isScalar = false;
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }
        return sink;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }
          if (canReportError(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscription;
          subscription = _this.subscribe(function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
          return this;
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x5) {
            return value = x5;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedErrorImpl, ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js"() {
    ObjectUnsubscribedErrorImpl = function() {
      function ObjectUnsubscribedErrorImpl2() {
        Error.call(this);
        this.message = "object unsubscribed";
        this.name = "ObjectUnsubscribedError";
        return this;
      }
      ObjectUnsubscribedErrorImpl2.prototype = Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl2;
    }();
    ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription;
var init_SubjectSubscription = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/SubjectSubscription.js"() {
    init_tslib_es6();
    init_Subscription();
    SubjectSubscription = function(_super) {
      __extends(SubjectSubscription2, _super);
      function SubjectSubscription2(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
      }
      SubjectSubscription2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };
      return SubjectSubscription2;
    }(Subscription);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/Subject.js
var SubjectSubscriber, Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/Subject.js"() {
    init_tslib_es6();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    init_rxSubscriber();
    SubjectSubscriber = function(_super) {
      __extends(SubjectSubscriber2, _super);
      function SubjectSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
      }
      return SubjectSubscriber2;
    }(Subscriber);
    Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype[rxSubscriber] = function() {
        return new SubjectSubscriber(this);
      };
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype.next = function(value) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();
          for (var i5 = 0; i5 < len; i5++) {
            copy[i5].next(value);
          }
        }
      };
      Subject2.prototype.error = function(err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i5 = 0; i5 < len; i5++) {
          copy[i5].error(err);
        }
        this.observers.length = 0;
      };
      Subject2.prototype.complete = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i5 = 0; i5 < len; i5++) {
          copy[i5].complete();
        }
        this.observers.length = 0;
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };
      Subject2.prototype._trySubscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };
      Subject2.prototype._subscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription(this, subscriber);
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var destination = this.destination;
        if (destination && destination.next) {
          destination.next(value);
        }
      };
      AnonymousSubject2.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) {
          this.destination.error(err);
        }
      };
      AnonymousSubject2.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) {
          this.destination.complete();
        }
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription.EMPTY;
        }
      };
      return AnonymousSubject2;
    }(Subject);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/refCount.js
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator, RefCountSubscriber;
var init_refCount = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/refCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    RefCountOperator = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable, connectableObservableDescriptor, ConnectableSubscriber, RefCountOperator2, RefCountSubscriber2;
var init_ConnectableObservable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js"() {
    init_tslib_es6();
    init_Subject();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_refCount();
    ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype.connect = function() {
        var connection = this._connection;
        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new Subscription();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable);
    connectableObservableDescriptor = function() {
      var connectableProto = ConnectableObservable.prototype;
      return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
      };
    }();
    ConnectableSubscriber = function(_super) {
      __extends(ConnectableSubscriber2, _super);
      function ConnectableSubscriber2(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      ConnectableSubscriber2.prototype._error = function(err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
      };
      ConnectableSubscriber2.prototype._complete = function() {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
      };
      ConnectableSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (connectable) {
          this.connectable = null;
          var connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;
          if (connection) {
            connection.unsubscribe();
          }
        }
      };
      return ConnectableSubscriber2;
    }(SubjectSubscriber);
    RefCountOperator2 = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber2(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber2 = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator, GroupBySubscriber, GroupDurationSubscriber, GroupedObservable, InnerRefCountSubscription;
var init_groupBy = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/groupBy.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    init_Observable();
    init_Subject();
    GroupByOperator = function() {
      function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
      }
      GroupByOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
      };
      return GroupByOperator2;
    }();
    GroupBySubscriber = function(_super) {
      __extends(GroupBySubscriber2, _super);
      function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
      }
      GroupBySubscriber2.prototype._next = function(value) {
        var key2;
        try {
          key2 = this.keySelector(value);
        } catch (err) {
          this.error(err);
          return;
        }
        this._group(value, key2);
      };
      GroupBySubscriber2.prototype._group = function(value, key2) {
        var groups = this.groups;
        if (!groups) {
          groups = this.groups = new Map();
        }
        var group = groups.get(key2);
        var element;
        if (this.elementSelector) {
          try {
            element = this.elementSelector(value);
          } catch (err) {
            this.error(err);
          }
        } else {
          element = value;
        }
        if (!group) {
          group = this.subjectSelector ? this.subjectSelector() : new Subject();
          groups.set(key2, group);
          var groupedObservable = new GroupedObservable(key2, group, this);
          this.destination.next(groupedObservable);
          if (this.durationSelector) {
            var duration = void 0;
            try {
              duration = this.durationSelector(new GroupedObservable(key2, group));
            } catch (err) {
              this.error(err);
              return;
            }
            this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
          }
        }
        if (!group.closed) {
          group.next(element);
        }
      };
      GroupBySubscriber2.prototype._error = function(err) {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key2) {
            group.error(err);
          });
          groups.clear();
        }
        this.destination.error(err);
      };
      GroupBySubscriber2.prototype._complete = function() {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key2) {
            group.complete();
          });
          groups.clear();
        }
        this.destination.complete();
      };
      GroupBySubscriber2.prototype.removeGroup = function(key2) {
        this.groups.delete(key2);
      };
      GroupBySubscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.attemptedToUnsubscribe = true;
          if (this.count === 0) {
            _super.prototype.unsubscribe.call(this);
          }
        }
      };
      return GroupBySubscriber2;
    }(Subscriber);
    GroupDurationSubscriber = function(_super) {
      __extends(GroupDurationSubscriber2, _super);
      function GroupDurationSubscriber2(key2, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key2;
        _this.group = group;
        _this.parent = parent;
        return _this;
      }
      GroupDurationSubscriber2.prototype._next = function(value) {
        this.complete();
      };
      GroupDurationSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, parent = _a2.parent, key2 = _a2.key;
        this.key = this.parent = null;
        if (parent) {
          parent.removeGroup(key2);
        }
      };
      return GroupDurationSubscriber2;
    }(Subscriber);
    GroupedObservable = function(_super) {
      __extends(GroupedObservable2, _super);
      function GroupedObservable2(key2, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key2;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
      }
      GroupedObservable2.prototype._subscribe = function(subscriber) {
        var subscription = new Subscription();
        var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
          subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
      };
      return GroupedObservable2;
    }(Observable);
    InnerRefCountSubscription = function(_super) {
      __extends(InnerRefCountSubscription2, _super);
      function InnerRefCountSubscription2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
      }
      InnerRefCountSubscription2.prototype.unsubscribe = function() {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
          _super.prototype.unsubscribe.call(this);
          parent.count -= 1;
          if (parent.count === 0 && parent.attemptedToUnsubscribe) {
            parent.unsubscribe();
          }
        }
      };
      return InnerRefCountSubscription2;
    }(Subscription);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/BehaviorSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_ObjectUnsubscribedError();
    BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: true,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return this._value;
        }
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/Action.js"() {
    init_tslib_es6();
    init_Subscription();
    Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"() {
    init_tslib_es6();
    init_Action();
    AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id2 = this.id;
        var scheduler = this.scheduler;
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && this.delay === delay2 && this.pending === false) {
          return id2;
        }
        clearInterval(id2);
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay2);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, delay2) {
        var errored = false;
        var errorValue = void 0;
        try {
          this.work(state);
        } catch (e5) {
          errored = true;
          errorValue = !!e5 && e5 || new Error(e5);
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype._unsubscribe = function() {
        var id2 = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
          actions.splice(index, 1);
        }
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, null);
        }
        this.delay = null;
      };
      return AsyncAction2;
    }(Action);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
var QueueAction;
var init_QueueAction = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.delay = delay2;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        return scheduler.flush(this);
      };
      return QueueAction2;
    }(AsyncAction);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/Scheduler.js"() {
    Scheduler = function() {
      function Scheduler2(SchedulerAction, now2) {
        if (now2 === void 0) {
          now2 = Scheduler2.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now2;
      }
      Scheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay2);
      };
      Scheduler2.now = function() {
        return Date.now();
      };
      return Scheduler2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"() {
    init_tslib_es6();
    init_Scheduler();
    AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now2) {
        if (now2 === void 0) {
          now2 = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
            return AsyncScheduler2.delegate.now();
          } else {
            return now2();
          }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = void 0;
        return _this;
      }
      AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
          return AsyncScheduler2.delegate.schedule(work, delay2, state);
        } else {
          return _super.prototype.schedule.call(this, work, delay2, state);
        }
      };
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this.active) {
          actions.push(action);
          return;
        }
        var error;
        this.active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler;
var init_QueueScheduler = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/queue.js
var queueScheduler, queue;
var init_queue = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/queue.js"() {
    init_QueueAction();
    init_QueueScheduler();
    queueScheduler = new QueueScheduler(QueueAction);
    queue = queueScheduler;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/empty.js
function empty2(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
var EMPTY;
var init_empty = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/empty.js"() {
    init_Observable();
    EMPTY = new Observable(function(subscriber) {
      return subscriber.complete();
    });
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var init_isScheduler = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isScheduler.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray;
var init_subscribeToArray = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToArray.js"() {
    subscribeToArray = function(array2) {
      return function(subscriber) {
        for (var i5 = 0, len = array2.length; i5 < len && !subscriber.closed; i5++) {
          subscriber.next(array2[i5]);
        }
        subscriber.complete();
      };
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i5 = 0;
    sub.add(scheduler.schedule(function() {
      if (i5 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i5++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
var init_scheduleArray = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/fromArray.js
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
var init_fromArray = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/fromArray.js"() {
    init_Observable();
    init_subscribeToArray();
    init_scheduleArray();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
var init_of = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/of.js"() {
    init_isScheduler();
    init_fromArray();
    init_scheduleArray();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/throwError.js
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch, 0, { error, subscriber });
    });
  }
}
function dispatch(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var init_throwError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/throwError.js"() {
    init_Observable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/Notification.js
var NotificationKind, Notification;
var init_Notification = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/Notification.js"() {
    init_empty();
    init_of();
    init_throwError();
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        switch (this.kind) {
          case "N":
            return observer.next && observer.next(this.value);
          case "E":
            return observer.error && observer.error(this.error);
          case "C":
            return observer.complete && observer.complete();
        }
      };
      Notification2.prototype.do = function(next, error, complete) {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return next && next(this.value);
          case "E":
            return error && error(this.error);
          case "C":
            return complete && complete();
        }
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === "function") {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error, complete);
        }
      };
      Notification2.prototype.toObservable = function() {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return of(this.value);
          case "E":
            return throwError(this.error);
          case "C":
            return empty2();
        }
        throw new Error("unexpected notification kind value");
      };
      Notification2.createNext = function(value) {
        if (typeof value !== "undefined") {
          return new Notification2("N", value);
        }
        return Notification2.undefinedValueNotification;
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      Notification2.undefinedValueNotification = new Notification2("N", void 0);
      return Notification2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator, ObserveOnSubscriber, ObserveOnMessage;
var init_observeOn = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/observeOn.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    ObserveOnOperator = function() {
      function ObserveOnOperator2(scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      ObserveOnOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      };
      return ObserveOnOperator2;
    }();
    ObserveOnSubscriber = function(_super) {
      __extends(ObserveOnSubscriber2, _super);
      function ObserveOnSubscriber2(destination, scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay2;
        return _this;
      }
      ObserveOnSubscriber2.dispatch = function(arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };
      ObserveOnSubscriber2.prototype._next = function(value) {
        this.scheduleMessage(Notification.createNext(value));
      };
      ObserveOnSubscriber2.prototype._error = function(err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype._complete = function() {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
      };
      return ObserveOnSubscriber2;
    }(Subscriber);
    ObserveOnMessage = function() {
      function ObserveOnMessage2(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }
      return ObserveOnMessage2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/ReplaySubject.js
var ReplaySubject, ReplayEvent;
var init_ReplaySubject = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/ReplaySubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_queue();
    init_Subscription();
    init_observeOn();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(bufferSize, windowTime2, scheduler) {
        if (bufferSize === void 0) {
          bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime2 === void 0) {
          windowTime2 = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
        if (windowTime2 === Number.POSITIVE_INFINITY) {
          _this._infiniteTimeWindow = true;
          _this.next = _this.nextInfiniteTimeWindow;
        } else {
          _this.next = _this.nextTimeWindow;
        }
        return _this;
      }
      ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
        if (!this.isStopped) {
          var _events = this._events;
          _events.push(value);
          if (_events.length > this._bufferSize) {
            _events.shift();
          }
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype.nextTimeWindow = function(value) {
        if (!this.isStopped) {
          this._events.push(new ReplayEvent(this._getNow(), value));
          this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.isStopped || this.hasError) {
          subscription = Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
          subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
          for (var i5 = 0; i5 < len && !subscriber.closed; i5++) {
            subscriber.next(_events[i5]);
          }
        } else {
          for (var i5 = 0; i5 < len && !subscriber.closed; i5++) {
            subscriber.next(_events[i5].value);
          }
        }
        if (this.hasError) {
          subscriber.error(this.thrownError);
        } else if (this.isStopped) {
          subscriber.complete();
        }
        return subscription;
      };
      ReplaySubject2.prototype._getNow = function() {
        return (this.scheduler || queue).now();
      };
      ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
        var now2 = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
          if (now2 - _events[spliceCount].time < _windowTime) {
            break;
          }
          spliceCount++;
        }
        if (eventsCount > _bufferSize) {
          spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
          _events.splice(0, spliceCount);
        }
        return _events;
      };
      return ReplaySubject2;
    }(Subject);
    ReplayEvent = function() {
      function ReplayEvent2(time, value) {
        this.time = time;
        this.value = value;
      }
      return ReplayEvent2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/AsyncSubject.js
var AsyncSubject;
var init_AsyncSubject = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/AsyncSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
      }
      AsyncSubject2.prototype._subscribe = function(subscriber) {
        if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
          subscriber.next(this.value);
          subscriber.complete();
          return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.hasCompleted) {
          this.value = value;
          this.hasNext = true;
        }
      };
      AsyncSubject2.prototype.error = function(error) {
        if (!this.hasCompleted) {
          _super.prototype.error.call(this, error);
        }
      };
      AsyncSubject2.prototype.complete = function() {
        this.hasCompleted = true;
        if (this.hasNext) {
          _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
      };
      return AsyncSubject2;
    }(Subject);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, RESOLVED, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/Immediate.js"() {
    nextHandle = 1;
    RESOLVED = function() {
      return Promise.resolve();
    }();
    activeHandles = {};
    Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js"() {
    init_tslib_es6();
    init_Immediate();
    init_AsyncAction();
    AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
        }
        if (scheduler.actions.length === 0) {
          Immediate.clearImmediate(id2);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/asap.js
var asapScheduler, asap;
var init_asap = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/asap.js"() {
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
    asap = asapScheduler;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/async.js"() {
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
          return scheduler.flush(null);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
        }
        if (scheduler.actions.length === 0) {
          cancelAnimationFrame(id2);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler, animationFrame;
var init_animationFrame = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js"() {
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
    animationFrame = animationFrameScheduler;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler, VirtualAction;
var init_VirtualTimeScheduler = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js"() {
    init_tslib_es6();
    init_AsyncAction();
    init_AsyncScheduler();
    VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
          SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler);
    VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay2);
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler.frame + delay2;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return true;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay2);
        }
      };
      VirtualAction2.sortActions = function(a5, b4) {
        if (a5.delay === b4.delay) {
          if (a5.index === b4.index) {
            return 0;
          } else if (a5.index > b4.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a5.delay > b4.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/noop.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var init_isObservable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isObservable.js"() {
    init_Observable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeErrorImpl, ArgumentOutOfRangeError;
var init_ArgumentOutOfRangeError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js"() {
    ArgumentOutOfRangeErrorImpl = function() {
      function ArgumentOutOfRangeErrorImpl2() {
        Error.call(this);
        this.message = "argument out of range";
        this.name = "ArgumentOutOfRangeError";
        return this;
      }
      ArgumentOutOfRangeErrorImpl2.prototype = Object.create(Error.prototype);
      return ArgumentOutOfRangeErrorImpl2;
    }();
    ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/EmptyError.js
var EmptyErrorImpl, EmptyError;
var init_EmptyError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/EmptyError.js"() {
    EmptyErrorImpl = function() {
      function EmptyErrorImpl2() {
        Error.call(this);
        this.message = "no elements in sequence";
        this.name = "EmptyError";
        return this;
      }
      EmptyErrorImpl2.prototype = Object.create(Error.prototype);
      return EmptyErrorImpl2;
    }();
    EmptyError = EmptyErrorImpl;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/TimeoutError.js
var TimeoutErrorImpl, TimeoutError;
var init_TimeoutError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/TimeoutError.js"() {
    TimeoutErrorImpl = function() {
      function TimeoutErrorImpl2() {
        Error.call(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        return this;
      }
      TimeoutErrorImpl2.prototype = Object.create(Error.prototype);
      return TimeoutErrorImpl2;
    }();
    TimeoutError = TimeoutErrorImpl;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/map.js
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator, MapSubscriber;
var init_map = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/map.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapOperator = function() {
      function MapOperator2(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      MapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator2;
    }();
    MapSubscriber = function(_super) {
      __extends(MapSubscriber2, _super);
      function MapSubscriber2(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      MapSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return MapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/bindCallback.js
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch2, 0, state);
      }
    });
  };
}
function dispatch2(state) {
  var _this = this;
  var self2 = this;
  var args = state.args, subscriber = state.subscriber, params = state.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
  var value = state.value, subject = state.subject;
  subject.next(value);
  subject.complete();
}
var init_bindCallback = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/bindCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isArray();
    init_isScheduler();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch3, 0, { params, subscriber, context });
      }
    });
  };
}
function dispatch3(state) {
  var _this = this;
  var params = state.params, subscriber = state.subscriber, context = state.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var init_bindNodeCallback = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isScheduler();
    init_isArray();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber;
var init_OuterSubscriber = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/OuterSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    OuterSubscriber = function(_super) {
      __extends(OuterSubscriber2, _super);
      function OuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
        this.destination.error(error);
      };
      OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
      };
      return OuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/InnerSubscriber.js
var InnerSubscriber;
var init_InnerSubscriber = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/InnerSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    InnerSubscriber = function(_super) {
      __extends(InnerSubscriber2, _super);
      function InnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
      }
      InnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };
      InnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      };
      InnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return InnerSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
var subscribeToPromise;
var init_subscribeToPromise = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js"() {
    init_hostReportError();
    subscribeToPromise = function(promise) {
      return function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, hostReportError);
        return subscriber;
      };
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/symbol/iterator.js"() {
    iterator = getSymbolIterator();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
var subscribeToIterable;
var init_subscribeToIterable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js"() {
    init_iterator();
    subscribeToIterable = function(iterable) {
      return function(subscriber) {
        var iterator2 = iterable[iterator]();
        do {
          var item = void 0;
          try {
            item = iterator2.next();
          } catch (err) {
            subscriber.error(err);
            return subscriber;
          }
          if (item.done) {
            subscriber.complete();
            break;
          }
          subscriber.next(item.value);
          if (subscriber.closed) {
            break;
          }
        } while (true);
        if (typeof iterator2.return === "function") {
          subscriber.add(function() {
            if (iterator2.return) {
              iterator2.return();
            }
          });
        }
        return subscriber;
      };
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
var subscribeToObservable;
var init_subscribeToObservable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js"() {
    init_observable();
    subscribeToObservable = function(obj) {
      return function(subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== "function") {
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        } else {
          return obs.subscribe(subscriber);
        }
      };
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isArrayLike.js"() {
    isArrayLike = function(x5) {
      return x5 && typeof x5.length === "number" && typeof x5 !== "function";
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isPromise.js
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var init_isPromise = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isPromise.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeTo.js
var subscribeTo;
var init_subscribeTo = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeTo.js"() {
    init_subscribeToArray();
    init_subscribeToPromise();
    init_subscribeToIterable();
    init_subscribeToObservable();
    init_isArrayLike();
    init_isPromise();
    init_isObject();
    init_iterator();
    init_observable();
    subscribeTo = function(result) {
      if (!!result && typeof result[observable] === "function") {
        return subscribeToObservable(result);
      } else if (isArrayLike(result)) {
        return subscribeToArray(result);
      } else if (isPromise(result)) {
        return subscribeToPromise(result);
      } else if (!!result && typeof result[iterator] === "function") {
        return subscribeToIterable(result);
      } else {
        var value = isObject3(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
        throw new TypeError(msg);
      }
    };
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var init_subscribeToResult = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"() {
    init_InnerSubscriber();
    init_subscribeTo();
    init_Observable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/combineLatest.js
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var NONE, CombineLatestOperator, CombineLatestSubscriber;
var init_combineLatest = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/combineLatest.js"() {
    init_tslib_es6();
    init_isScheduler();
    init_isArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    init_fromArray();
    NONE = {};
    CombineLatestOperator = function() {
      function CombineLatestOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      CombineLatestOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
      };
      return CombineLatestOperator2;
    }();
    CombineLatestSubscriber = function(_super) {
      __extends(CombineLatestSubscriber2, _super);
      function CombineLatestSubscriber2(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
      }
      CombineLatestSubscriber2.prototype._next = function(observable2) {
        this.values.push(NONE);
        this.observables.push(observable2);
      };
      CombineLatestSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;
          for (var i5 = 0; i5 < len; i5++) {
            var observable2 = observables[i5];
            this.add(subscribeToResult(this, observable2, void 0, i5));
          }
        }
      };
      CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      };
      CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
          if (this.resultSelector) {
            this._tryResultSelector(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      };
      CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
        var result;
        try {
          result = this.resultSelector.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return CombineLatestSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable2 = input[observable]();
      sub.add(observable2.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleObservable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js"() {
    init_Observable();
    init_Subscription();
    init_observable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
var init_schedulePromise = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator2;
    sub.add(function() {
      if (iterator2 && typeof iterator2.return === "function") {
        iterator2.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator2 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done;
        try {
          var result = iterator2.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleIterable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js"() {
    init_Observable();
    init_Subscription();
    init_iterator();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
var init_isInteropObservable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isInteropObservable.js"() {
    init_observable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isIterable.js
function isIterable2(input) {
  return input && typeof input[iterator] === "function";
}
var init_isIterable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isIterable.js"() {
    init_iterator();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable2(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
var init_scheduled = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/scheduled/scheduled.js"() {
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/from.js
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var init_from = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/from.js"() {
    init_Observable();
    init_subscribeTo();
    init_scheduled();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/innerSubscribe.js
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
var SimpleInnerSubscriber, ComplexInnerSubscriber, SimpleOuterSubscriber, ComplexOuterSubscriber;
var init_innerSubscribe = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/innerSubscribe.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_subscribeTo();
    SimpleInnerSubscriber = function(_super) {
      __extends(SimpleInnerSubscriber2, _super);
      function SimpleInnerSubscriber2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
      }
      SimpleInnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(value);
      };
      SimpleInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      SimpleInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete();
        this.unsubscribe();
      };
      return SimpleInnerSubscriber2;
    }(Subscriber);
    ComplexInnerSubscriber = function(_super) {
      __extends(ComplexInnerSubscriber2, _super);
      function ComplexInnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
      }
      ComplexInnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
      };
      ComplexInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      ComplexInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return ComplexInnerSubscriber2;
    }(Subscriber);
    SimpleOuterSubscriber = function(_super) {
      __extends(SimpleOuterSubscriber2, _super);
      function SimpleOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      SimpleOuterSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      SimpleOuterSubscriber2.prototype.notifyComplete = function() {
        this.destination.complete();
      };
      return SimpleOuterSubscriber2;
    }(Subscriber);
    ComplexOuterSubscriber = function(_super) {
      __extends(ComplexOuterSubscriber2, _super);
      function ComplexOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ComplexOuterSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
      };
      ComplexOuterSubscriber2.prototype.notifyError = function(error) {
        this.destination.error(error);
      };
      ComplexOuterSubscriber2.prototype.notifyComplete = function(_innerSub) {
        this.destination.complete();
      };
      return ComplexOuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a5, i5) {
        return from(project(a5, i5)).pipe(map(function(b4, ii) {
          return resultSelector(a5, b4, i5, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator, MergeMapSubscriber, flatMap;
var init_mergeMap = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    MergeMapOperator = function() {
      function MergeMapOperator2(project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
      }
      MergeMapOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };
      return MergeMapOperator2;
    }();
    MergeMapSubscriber = function(_super) {
      __extends(MergeMapSubscriber2, _super);
      function MergeMapSubscriber2(destination, project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeMapSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          this._tryNext(value);
        } else {
          this.buffer.push(value);
        }
      };
      MergeMapSubscriber2.prototype._tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.active++;
        this._innerSub(result);
      };
      MergeMapSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      MergeMapSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      };
      return MergeMapSubscriber2;
    }(SimpleOuterSubscriber);
    flatMap = mergeMap;
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeAll.js"() {
    init_mergeMap();
    init_identity();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concatAll.js"() {
    init_mergeAll();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/concat.js
function concat2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
var init_concat = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/concat.js"() {
    init_of();
    init_concatAll();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty2();
    return source.subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/defer.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/forkJoin.js
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject3(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function(key2) {
        return first_1[key2];
      }), keys);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i6) {
      var source = from(sources[i6]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i6] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce(function(result, key2, i7) {
                return result[key2] = values[i7], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i5 = 0; i5 < len; i5++) {
      _loop_1(i5);
    }
  });
}
var init_forkJoin = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/forkJoin.js"() {
    init_Observable();
    init_isArray();
    init_map();
    init_isObject();
    init_from();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/fromEvent.js
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e5) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e5);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i5 = 0, len = sourceObj.length; i5 < len; i5++) {
      setupSubscription(sourceObj[i5], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
var toString;
var init_fromEvent = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/fromEvent.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
    toString = function() {
      return Object.prototype.toString;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e5 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e5[_i] = arguments[_i];
      }
      return subscriber.next(e5.length === 1 ? e5[0] : e5);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
var init_fromEventPattern = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/generate.js
function generate2(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value);
      if (subscriber.closed) {
        break;
      }
      try {
        state = iterate(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch4(state) {
  var subscriber = state.subscriber, condition = state.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state.needIterate) {
    try {
      state.state = state.iterate(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value;
  try {
    value = state.resultSelector(state.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state);
}
var init_generate = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/generate.js"() {
    init_Observable();
    init_identity();
    init_isScheduler();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/iif.js
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
var init_iif = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/iif.js"() {
    init_defer();
    init_empty();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isNumeric.js
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
var init_isNumeric = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isNumeric.js"() {
    init_isArray();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch5, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch5(state) {
  var subscriber = state.subscriber, counter = state.counter, period = state.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
var init_interval = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/interval.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/merge.js
function merge() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var init_merge = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/merge.js"() {
    init_Observable();
    init_isScheduler();
    init_mergeAll();
    init_fromArray();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/never.js
function never2() {
  return NEVER;
}
var NEVER;
var init_never = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/never.js"() {
    init_Observable();
    init_noop();
    NEVER = new Observable(noop);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray(first2)) {
    return onErrorResumeNext.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
var init_onErrorResumeNext = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js"() {
    init_Observable();
    init_from();
    init_isArray();
    init_empty();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/pairs.js
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      for (var i5 = 0; i5 < keys.length && !subscriber.closed; i5++) {
        var key2 = keys[i5];
        if (obj.hasOwnProperty(key2)) {
          subscriber.next([key2, obj[key2]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch6, 0, { keys, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch6(state) {
  var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
  if (!subscriber.closed) {
    if (index < keys.length) {
      var key2 = keys[index];
      subscriber.next([key2, obj[key2]]);
      subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
var init_pairs = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/pairs.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/not.js
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
var init_not = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/not.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator, FilterSubscriber;
var init_filter = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/filter.js"() {
    init_tslib_es6();
    init_Subscriber();
    FilterOperator = function() {
      function FilterOperator2(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
      }
      FilterOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator2;
    }();
    FilterSubscriber = function(_super) {
      __extends(FilterSubscriber2, _super);
      function FilterSubscriber2(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
      }
      FilterSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.destination.next(value);
        }
      };
      return FilterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/partition.js
function partition(source, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source))),
    filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))
  ];
}
var init_partition = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/partition.js"() {
    init_not();
    init_subscribeTo();
    init_filter();
    init_Observable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/race.js
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator, RaceSubscriber;
var init_race = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/race.js"() {
    init_tslib_es6();
    init_isArray();
    init_fromArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    RaceOperator = function() {
      function RaceOperator2() {
      }
      RaceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
      };
      return RaceOperator2;
    }();
    RaceSubscriber = function(_super) {
      __extends(RaceSubscriber2, _super);
      function RaceSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
      }
      RaceSubscriber2.prototype._next = function(observable2) {
        this.observables.push(observable2);
      };
      RaceSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          for (var i5 = 0; i5 < len && !this.hasFirst; i5++) {
            var observable2 = observables[i5];
            var subscription = subscribeToResult(this, observable2, void 0, i5);
            if (this.subscriptions) {
              this.subscriptions.push(subscription);
            }
            this.add(subscription);
          }
          this.observables = null;
        }
      };
      RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
          this.hasFirst = true;
          for (var i5 = 0; i5 < this.subscriptions.length; i5++) {
            if (i5 !== outerIndex) {
              var subscription = this.subscriptions[i5];
              subscription.unsubscribe();
              this.remove(subscription);
            }
          }
          this.subscriptions = null;
        }
        this.destination.next(innerValue);
      };
      return RaceSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/range.js
function range(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch7, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch7(state) {
  var start = state.start, index = state.index, count2 = state.count, subscriber = state.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state.index = index + 1;
  state.start = start + 1;
  this.schedule(state);
}
var init_range = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/range.js"() {
    init_Observable();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/timer.js
function timer2(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch8, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch8(state) {
  var index = state.index, period = state.period, subscriber = state.subscriber;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
var init_timer = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/timer.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
    init_isScheduler();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/using.js
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
var init_using = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/using.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/zip.js
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator, ZipSubscriber, StaticIterator, StaticArrayIterator, ZipBufferIterator;
var init_zip = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/zip.js"() {
    init_tslib_es6();
    init_fromArray();
    init_isArray();
    init_Subscriber();
    init_iterator();
    init_innerSubscribe();
    ZipOperator = function() {
      function ZipOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      ZipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
      };
      return ZipOperator2;
    }();
    ZipSubscriber = function(_super) {
      __extends(ZipSubscriber2, _super);
      function ZipSubscriber2(destination, resultSelector, values) {
        if (values === void 0) {
          values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
        return _this;
      }
      ZipSubscriber2.prototype._next = function(value) {
        var iterators = this.iterators;
        if (isArray(value)) {
          iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator] === "function") {
          iterators.push(new StaticIterator(value[iterator]()));
        } else {
          iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
      };
      ZipSubscriber2.prototype._complete = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
          this.destination.complete();
          return;
        }
        this.active = len;
        for (var i5 = 0; i5 < len; i5++) {
          var iterator2 = iterators[i5];
          if (iterator2.stillUnsubscribed) {
            var destination = this.destination;
            destination.add(iterator2.subscribe());
          } else {
            this.active--;
          }
        }
      };
      ZipSubscriber2.prototype.notifyInactive = function() {
        this.active--;
        if (this.active === 0) {
          this.destination.complete();
        }
      };
      ZipSubscriber2.prototype.checkIterators = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i5 = 0; i5 < len; i5++) {
          var iterator2 = iterators[i5];
          if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
            return;
          }
        }
        var shouldComplete = false;
        var args = [];
        for (var i5 = 0; i5 < len; i5++) {
          var iterator2 = iterators[i5];
          var result = iterator2.next();
          if (iterator2.hasCompleted()) {
            shouldComplete = true;
          }
          if (result.done) {
            destination.complete();
            return;
          }
          args.push(result.value);
        }
        if (this.resultSelector) {
          this._tryresultSelector(args);
        } else {
          destination.next(args);
        }
        if (shouldComplete) {
          destination.complete();
        }
      };
      ZipSubscriber2.prototype._tryresultSelector = function(args) {
        var result;
        try {
          result = this.resultSelector.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return ZipSubscriber2;
    }(Subscriber);
    StaticIterator = function() {
      function StaticIterator2(iterator2) {
        this.iterator = iterator2;
        this.nextResult = iterator2.next();
      }
      StaticIterator2.prototype.hasValue = function() {
        return true;
      };
      StaticIterator2.prototype.next = function() {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
      };
      StaticIterator2.prototype.hasCompleted = function() {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
      };
      return StaticIterator2;
    }();
    StaticArrayIterator = function() {
      function StaticArrayIterator2(array2) {
        this.array = array2;
        this.index = 0;
        this.length = 0;
        this.length = array2.length;
      }
      StaticArrayIterator2.prototype[iterator] = function() {
        return this;
      };
      StaticArrayIterator2.prototype.next = function(value) {
        var i5 = this.index++;
        var array2 = this.array;
        return i5 < this.length ? { value: array2[i5], done: false } : { value: null, done: true };
      };
      StaticArrayIterator2.prototype.hasValue = function() {
        return this.array.length > this.index;
      };
      StaticArrayIterator2.prototype.hasCompleted = function() {
        return this.array.length === this.index;
      };
      return StaticArrayIterator2;
    }();
    ZipBufferIterator = function(_super) {
      __extends(ZipBufferIterator2, _super);
      function ZipBufferIterator2(destination, parent, observable2) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable2;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
      }
      ZipBufferIterator2.prototype[iterator] = function() {
        return this;
      };
      ZipBufferIterator2.prototype.next = function() {
        var buffer2 = this.buffer;
        if (buffer2.length === 0 && this.isComplete) {
          return { value: null, done: true };
        } else {
          return { value: buffer2.shift(), done: false };
        }
      };
      ZipBufferIterator2.prototype.hasValue = function() {
        return this.buffer.length > 0;
      };
      ZipBufferIterator2.prototype.hasCompleted = function() {
        return this.buffer.length === 0 && this.isComplete;
      };
      ZipBufferIterator2.prototype.notifyComplete = function() {
        if (this.buffer.length > 0) {
          this.isComplete = true;
          this.parent.notifyInactive();
        } else {
          this.destination.complete();
        }
      };
      ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
      };
      ZipBufferIterator2.prototype.subscribe = function() {
        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
      };
      return ZipBufferIterator2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/index.js
var esm5_exports = {};
__export(esm5_exports, {
  ArgumentOutOfRangeError: () => ArgumentOutOfRangeError,
  AsyncSubject: () => AsyncSubject,
  BehaviorSubject: () => BehaviorSubject,
  ConnectableObservable: () => ConnectableObservable,
  EMPTY: () => EMPTY,
  EmptyError: () => EmptyError,
  GroupedObservable: () => GroupedObservable,
  NEVER: () => NEVER,
  Notification: () => Notification,
  NotificationKind: () => NotificationKind,
  ObjectUnsubscribedError: () => ObjectUnsubscribedError,
  Observable: () => Observable,
  ReplaySubject: () => ReplaySubject,
  Scheduler: () => Scheduler,
  Subject: () => Subject,
  Subscriber: () => Subscriber,
  Subscription: () => Subscription,
  TimeoutError: () => TimeoutError,
  UnsubscriptionError: () => UnsubscriptionError,
  VirtualAction: () => VirtualAction,
  VirtualTimeScheduler: () => VirtualTimeScheduler,
  animationFrame: () => animationFrame,
  animationFrameScheduler: () => animationFrameScheduler,
  asap: () => asap,
  asapScheduler: () => asapScheduler,
  async: () => async,
  asyncScheduler: () => asyncScheduler,
  bindCallback: () => bindCallback,
  bindNodeCallback: () => bindNodeCallback,
  combineLatest: () => combineLatest,
  concat: () => concat2,
  config: () => config,
  defer: () => defer,
  empty: () => empty2,
  forkJoin: () => forkJoin,
  from: () => from,
  fromEvent: () => fromEvent,
  fromEventPattern: () => fromEventPattern,
  generate: () => generate2,
  identity: () => identity,
  iif: () => iif,
  interval: () => interval,
  isObservable: () => isObservable,
  merge: () => merge,
  never: () => never2,
  noop: () => noop,
  observable: () => observable,
  of: () => of,
  onErrorResumeNext: () => onErrorResumeNext,
  pairs: () => pairs,
  partition: () => partition,
  pipe: () => pipe,
  queue: () => queue,
  queueScheduler: () => queueScheduler,
  race: () => race,
  range: () => range,
  scheduled: () => scheduled,
  throwError: () => throwError,
  timer: () => timer2,
  using: () => using,
  zip: () => zip
});
var init_esm5 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/index.js"() {
    init_Observable();
    init_ConnectableObservable();
    init_groupBy();
    init_observable();
    init_Subject();
    init_BehaviorSubject();
    init_ReplaySubject();
    init_AsyncSubject();
    init_asap();
    init_async();
    init_queue();
    init_animationFrame();
    init_VirtualTimeScheduler();
    init_Scheduler();
    init_Subscription();
    init_Subscriber();
    init_Notification();
    init_pipe();
    init_noop();
    init_identity();
    init_isObservable();
    init_ArgumentOutOfRangeError();
    init_EmptyError();
    init_ObjectUnsubscribedError();
    init_UnsubscriptionError();
    init_TimeoutError();
    init_bindCallback();
    init_bindNodeCallback();
    init_combineLatest();
    init_concat();
    init_defer();
    init_empty();
    init_forkJoin();
    init_from();
    init_fromEvent();
    init_fromEventPattern();
    init_generate();
    init_iif();
    init_interval();
    init_merge();
    init_never();
    init_of();
    init_onErrorResumeNext();
    init_pairs();
    init_partition();
    init_race();
    init_range();
    init_throwError();
    init_timer();
    init_using();
    init_zip();
    init_scheduled();
    init_empty();
    init_never();
    init_config();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/audit.js
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator, AuditSubscriber;
var init_audit = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/audit.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    AuditOperator = function() {
      function AuditOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      AuditOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
      };
      return AuditOperator2;
    }();
    AuditSubscriber = function(_super) {
      __extends(AuditSubscriber2, _super);
      function AuditSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      AuditSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
          var duration = void 0;
          try {
            var durationSelector = this.durationSelector;
            duration = durationSelector(value);
          } catch (err) {
            return this.destination.error(err);
          }
          var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
          if (!innerSubscription || innerSubscription.closed) {
            this.clearThrottle();
          } else {
            this.add(this.throttled = innerSubscription);
          }
        }
      };
      AuditSubscriber2.prototype.clearThrottle = function() {
        var _a2 = this, value = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
        if (throttled) {
          this.remove(throttled);
          this.throttled = void 0;
          throttled.unsubscribe();
        }
        if (hasValue) {
          this.value = void 0;
          this.hasValue = false;
          this.destination.next(value);
        }
      };
      AuditSubscriber2.prototype.notifyNext = function() {
        this.clearThrottle();
      };
      AuditSubscriber2.prototype.notifyComplete = function() {
        this.clearThrottle();
      };
      return AuditSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer2(duration, scheduler);
  });
}
var init_auditTime = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/auditTime.js"() {
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator, BufferSubscriber;
var init_buffer2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/buffer.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    BufferOperator = function() {
      function BufferOperator2(closingNotifier) {
        this.closingNotifier = closingNotifier;
      }
      BufferOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
      };
      return BufferOperator2;
    }();
    BufferSubscriber = function(_super) {
      __extends(BufferSubscriber2, _super);
      function BufferSubscriber2(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
        return _this;
      }
      BufferSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferSubscriber2.prototype.notifyNext = function() {
        var buffer2 = this.buffer;
        this.buffer = [];
        this.destination.next(buffer2);
      };
      return BufferSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferCount.js
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator, BufferCountSubscriber, BufferSkipCountSubscriber;
var init_bufferCount = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    BufferCountOperator = function() {
      function BufferCountOperator2(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
          this.subscriberClass = BufferCountSubscriber;
        } else {
          this.subscriberClass = BufferSkipCountSubscriber;
        }
      }
      BufferCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
      };
      return BufferCountOperator2;
    }();
    BufferCountSubscriber = function(_super) {
      __extends(BufferCountSubscriber2, _super);
      function BufferCountSubscriber2(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
      }
      BufferCountSubscriber2.prototype._next = function(value) {
        var buffer2 = this.buffer;
        buffer2.push(value);
        if (buffer2.length == this.bufferSize) {
          this.destination.next(buffer2);
          this.buffer = [];
        }
      };
      BufferCountSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2.length > 0) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      return BufferCountSubscriber2;
    }(Subscriber);
    BufferSkipCountSubscriber = function(_super) {
      __extends(BufferSkipCountSubscriber2, _super);
      function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
      }
      BufferSkipCountSubscriber2.prototype._next = function(value) {
        var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
        this.count++;
        if (count2 % startBufferEvery === 0) {
          buffers.push([]);
        }
        for (var i5 = buffers.length; i5--; ) {
          var buffer2 = buffers[i5];
          buffer2.push(value);
          if (buffer2.length === bufferSize) {
            buffers.splice(i5, 1);
            this.destination.next(buffer2);
          }
        }
      };
      BufferSkipCountSubscriber2.prototype._complete = function() {
        var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
        while (buffers.length > 0) {
          var buffer2 = buffers.shift();
          if (buffer2.length > 0) {
            destination.next(buffer2);
          }
        }
        _super.prototype._complete.call(this);
      };
      return BufferSkipCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }
  var bufferCreationInterval = null;
  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
function dispatchBufferTimeSpanOnly(state) {
  var subscriber = state.subscriber;
  var prevContext = state.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state.context = subscriber.openContext();
    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state) {
  var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));
    action.schedule(state, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
var BufferTimeOperator, Context, BufferTimeSubscriber;
var init_bufferTime = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferTime.js"() {
    init_tslib_es6();
    init_async();
    init_Subscriber();
    init_isScheduler();
    BufferTimeOperator = function() {
      function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
      }
      BufferTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
      };
      return BufferTimeOperator2;
    }();
    Context = function() {
      function Context2() {
        this.buffer = [];
      }
      return Context2;
    }();
    BufferTimeSubscriber = function(_super) {
      __extends(BufferTimeSubscriber2, _super);
      function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
          var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
          var closeState = { subscriber: _this, context };
          var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
      }
      BufferTimeSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i5 = 0; i5 < len; i5++) {
          var context_1 = contexts[i5];
          var buffer2 = context_1.buffer;
          buffer2.push(value);
          if (buffer2.length == this.maxBufferSize) {
            filledBufferContext = context_1;
          }
        }
        if (filledBufferContext) {
          this.onBufferFull(filledBufferContext);
        }
      };
      BufferTimeSubscriber2.prototype._error = function(err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
      };
      BufferTimeSubscriber2.prototype._complete = function() {
        var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
      };
      BufferTimeSubscriber2.prototype._unsubscribe = function() {
        this.contexts = null;
      };
      BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
          context = this.openContext();
          var bufferTimeSpan = this.bufferTimeSpan;
          var timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
          this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
      };
      BufferTimeSubscriber2.prototype.openContext = function() {
        var context = new Context();
        this.contexts.push(context);
        return context;
      };
      BufferTimeSubscriber2.prototype.closeContext = function(context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
          contexts.splice(contexts.indexOf(context), 1);
        }
      };
      return BufferTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator, BufferToggleSubscriber;
var init_bufferToggle = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferToggle.js"() {
    init_tslib_es6();
    init_Subscription();
    init_subscribeToResult();
    init_OuterSubscriber();
    BufferToggleOperator = function() {
      function BufferToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      BufferToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return BufferToggleOperator2;
    }();
    BufferToggleSubscriber = function(_super) {
      __extends(BufferToggleSubscriber2, _super);
      function BufferToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
      }
      BufferToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i5 = 0; i5 < len; i5++) {
          contexts[i5].buffer.push(value);
        }
      };
      BufferToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_1 = contexts.shift();
          context_1.subscription.unsubscribe();
          context_1.buffer = null;
          context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
      };
      BufferToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          this.destination.next(context_2.buffer);
          context_2.subscription.unsubscribe();
          context_2.buffer = null;
          context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
      };
      BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
      };
      BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.closeBuffer(innerSub.context);
      };
      BufferToggleSubscriber2.prototype.openBuffer = function(value) {
        try {
          var closingSelector = this.closingSelector;
          var closingNotifier = closingSelector.call(this, value);
          if (closingNotifier) {
            this.trySubscribe(closingNotifier);
          }
        } catch (err) {
          this._error(err);
        }
      };
      BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
        var contexts = this.contexts;
        if (contexts && context) {
          var buffer2 = context.buffer, subscription = context.subscription;
          this.destination.next(buffer2);
          contexts.splice(contexts.indexOf(context), 1);
          this.remove(subscription);
          subscription.unsubscribe();
        }
      };
      BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
        var contexts = this.contexts;
        var buffer2 = [];
        var subscription = new Subscription();
        var context = { buffer: buffer2, subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
          this.closeBuffer(context);
        } else {
          innerSubscription.context = context;
          this.add(innerSubscription);
          subscription.add(innerSubscription);
        }
      };
      return BufferToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator, BufferWhenSubscriber;
var init_bufferWhen = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/bufferWhen.js"() {
    init_tslib_es6();
    init_Subscription();
    init_innerSubscribe();
    BufferWhenOperator = function() {
      function BufferWhenOperator2(closingSelector) {
        this.closingSelector = closingSelector;
      }
      BufferWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
      };
      return BufferWhenOperator2;
    }();
    BufferWhenSubscriber = function(_super) {
      __extends(BufferWhenSubscriber2, _super);
      function BufferWhenSubscriber2(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
      }
      BufferWhenSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferWhenSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      BufferWhenSubscriber2.prototype._unsubscribe = function() {
        this.buffer = void 0;
        this.subscribing = false;
      };
      BufferWhenSubscriber2.prototype.notifyNext = function() {
        this.openBuffer();
      };
      BufferWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.subscribing) {
          this.complete();
        } else {
          this.openBuffer();
        }
      };
      BufferWhenSubscriber2.prototype.openBuffer = function() {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
          this.remove(closingSubscription);
          closingSubscription.unsubscribe();
        }
        var buffer2 = this.buffer;
        if (this.buffer) {
          this.destination.next(buffer2);
        }
        this.buffer = [];
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (err) {
          return this.error(err);
        }
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
        this.subscribing = false;
      };
      return BufferWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/catchError.js
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator, CatchSubscriber;
var init_catchError = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/catchError.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    CatchOperator = function() {
      function CatchOperator2(selector) {
        this.selector = selector;
      }
      CatchOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      };
      return CatchOperator2;
    }();
    CatchSubscriber = function(_super) {
      __extends(CatchSubscriber2, _super);
      function CatchSubscriber2(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
      }
      CatchSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var result = void 0;
          try {
            result = this.selector(err, this.caught);
          } catch (err2) {
            _super.prototype.error.call(this, err2);
            return;
          }
          this._unsubscribeAndRecycle();
          var innerSubscriber = new SimpleInnerSubscriber(this);
          this.add(innerSubscriber);
          var innerSubscription = innerSubscribe(result, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            this.add(innerSubscription);
          }
        }
      };
      return CatchSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/combineAll.js
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
var init_combineAll = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/combineAll.js"() {
    init_combineLatest();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
  };
}
var init_combineLatest2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/combineLatest.js"() {
    init_isArray();
    init_combineLatest();
    init_from();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concat.js
function concat3() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat2.apply(void 0, [source].concat(observables)));
  };
}
var init_concat2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concat.js"() {
    init_concat();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
var init_concatMap = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concatMap.js"() {
    init_mergeMap();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concatMapTo.js
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
var init_concatMapTo = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/concatMapTo.js"() {
    init_concatMap();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/count.js
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator, CountSubscriber;
var init_count = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/count.js"() {
    init_tslib_es6();
    init_Subscriber();
    CountOperator = function() {
      function CountOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      CountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
      };
      return CountOperator2;
    }();
    CountSubscriber = function(_super) {
      __extends(CountSubscriber2, _super);
      function CountSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
      }
      CountSubscriber2.prototype._next = function(value) {
        if (this.predicate) {
          this._tryPredicate(value);
        } else {
          this.count++;
        }
      };
      CountSubscriber2.prototype._tryPredicate = function(value) {
        var result;
        try {
          result = this.predicate(value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.count++;
        }
      };
      CountSubscriber2.prototype._complete = function() {
        this.destination.next(this.count);
        this.destination.complete();
      };
      return CountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator, DebounceSubscriber;
var init_debounce = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/debounce.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DebounceOperator = function() {
      function DebounceOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      DebounceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
      };
      return DebounceOperator2;
    }();
    DebounceSubscriber = function(_super) {
      __extends(DebounceSubscriber2, _super);
      function DebounceSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      DebounceSubscriber2.prototype._next = function(value) {
        try {
          var result = this.durationSelector.call(this, value);
          if (result) {
            this._tryNext(value, result);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DebounceSubscriber2.prototype._complete = function() {
        this.emitValue();
        this.destination.complete();
      };
      DebounceSubscriber2.prototype._tryNext = function(value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
          subscription.unsubscribe();
          this.remove(subscription);
        }
        subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
          this.add(this.durationSubscription = subscription);
        }
      };
      DebounceSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          var value = this.value;
          var subscription = this.durationSubscription;
          if (subscription) {
            this.durationSubscription = void 0;
            subscription.unsubscribe();
            this.remove(subscription);
          }
          this.value = void 0;
          this.hasValue = false;
          _super.prototype._next.call(this, value);
        }
      };
      return DebounceSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
function dispatchNext3(subscriber) {
  subscriber.debouncedNext();
}
var DebounceTimeOperator, DebounceTimeSubscriber;
var init_debounceTime = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/debounceTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    DebounceTimeOperator = function() {
      function DebounceTimeOperator2(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
      }
      DebounceTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      };
      return DebounceTimeOperator2;
    }();
    DebounceTimeSubscriber = function(_super) {
      __extends(DebounceTimeSubscriber2, _super);
      function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
      }
      DebounceTimeSubscriber2.prototype._next = function(value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext3, this.dueTime, this));
      };
      DebounceTimeSubscriber2.prototype._complete = function() {
        this.debouncedNext();
        this.destination.complete();
      };
      DebounceTimeSubscriber2.prototype.debouncedNext = function() {
        this.clearDebounce();
        if (this.hasValue) {
          var lastValue = this.lastValue;
          this.lastValue = null;
          this.hasValue = false;
          this.destination.next(lastValue);
        }
      };
      DebounceTimeSubscriber2.prototype.clearDebounce = function() {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
          this.remove(debouncedSubscription);
          debouncedSubscription.unsubscribe();
          this.debouncedSubscription = null;
        }
      };
      return DebounceTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator, DefaultIfEmptySubscriber;
var init_defaultIfEmpty = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    DefaultIfEmptyOperator = function() {
      function DefaultIfEmptyOperator2(defaultValue) {
        this.defaultValue = defaultValue;
      }
      DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      };
      return DefaultIfEmptyOperator2;
    }();
    DefaultIfEmptySubscriber = function(_super) {
      __extends(DefaultIfEmptySubscriber2, _super);
      function DefaultIfEmptySubscriber2(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
      }
      DefaultIfEmptySubscriber2.prototype._next = function(value) {
        this.isEmpty = false;
        this.destination.next(value);
      };
      DefaultIfEmptySubscriber2.prototype._complete = function() {
        if (this.isEmpty) {
          this.destination.next(this.defaultValue);
        }
        this.destination.complete();
      };
      return DefaultIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isDate.js
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
var init_isDate = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/util/isDate.js"() {
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/delay.js
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator, DelaySubscriber, DelayMessage;
var init_delay = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/delay.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_Subscriber();
    init_Notification();
    DelayOperator = function() {
      function DelayOperator2(delay2, scheduler) {
        this.delay = delay2;
        this.scheduler = scheduler;
      }
      DelayOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      };
      return DelayOperator2;
    }();
    DelaySubscriber = function(_super) {
      __extends(DelaySubscriber2, _super);
      function DelaySubscriber2(destination, delay2, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay2;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
      }
      DelaySubscriber2.dispatch = function(state) {
        var source = state.source;
        var queue2 = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
          queue2.shift().notification.observe(destination);
        }
        if (queue2.length > 0) {
          var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
          this.schedule(state, delay_1);
        } else {
          this.unsubscribe();
          source.active = false;
        }
      };
      DelaySubscriber2.prototype._schedule = function(scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
          source: this,
          destination: this.destination,
          scheduler
        }));
      };
      DelaySubscriber2.prototype.scheduleNotification = function(notification) {
        if (this.errored === true) {
          return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
          this._schedule(scheduler);
        }
      };
      DelaySubscriber2.prototype._next = function(value) {
        this.scheduleNotification(Notification.createNext(value));
      };
      DelaySubscriber2.prototype._error = function(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
      };
      DelaySubscriber2.prototype._complete = function() {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
      };
      return DelaySubscriber2;
    }(Subscriber);
    DelayMessage = function() {
      function DelayMessage2(time, notification) {
        this.time = time;
        this.notification = notification;
      }
      return DelayMessage2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator, DelayWhenSubscriber, SubscriptionDelayObservable, SubscriptionDelaySubscriber;
var init_delayWhen = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/delayWhen.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_OuterSubscriber();
    init_subscribeToResult();
    DelayWhenOperator = function() {
      function DelayWhenOperator2(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
      }
      DelayWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
      };
      return DelayWhenOperator2;
    }();
    DelayWhenSubscriber = function(_super) {
      __extends(DelayWhenSubscriber2, _super);
      function DelayWhenSubscriber2(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
      }
      DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
        this._error(error);
      };
      DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
          this.destination.next(value);
        }
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        try {
          var delayNotifier = this.delayDurationSelector(value, index);
          if (delayNotifier) {
            this.tryDelay(delayNotifier, value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DelayWhenSubscriber2.prototype._complete = function() {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
      };
      DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
          this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
      };
      DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
          var destination = this.destination;
          destination.add(notifierSubscription);
          this.delayNotifierSubscriptions.push(notifierSubscription);
        }
      };
      DelayWhenSubscriber2.prototype.tryComplete = function() {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
          this.destination.complete();
        }
      };
      return DelayWhenSubscriber2;
    }(OuterSubscriber);
    SubscriptionDelayObservable = function(_super) {
      __extends(SubscriptionDelayObservable2, _super);
      function SubscriptionDelayObservable2(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
      }
      SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
      };
      return SubscriptionDelayObservable2;
    }(Observable);
    SubscriptionDelaySubscriber = function(_super) {
      __extends(SubscriptionDelaySubscriber2, _super);
      function SubscriptionDelaySubscriber2(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
      }
      SubscriptionDelaySubscriber2.prototype._next = function(unused) {
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype._error = function(err) {
        this.unsubscribe();
        this.parent.error(err);
      };
      SubscriptionDelaySubscriber2.prototype._complete = function() {
        this.unsubscribe();
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
        if (!this.sourceSubscribed) {
          this.sourceSubscribed = true;
          this.unsubscribe();
          this.source.subscribe(this.parent);
        }
      };
      return SubscriptionDelaySubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/dematerialize.js
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator, DeMaterializeSubscriber;
var init_dematerialize = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/dematerialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    DeMaterializeOperator = function() {
      function DeMaterializeOperator2() {
      }
      DeMaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
      };
      return DeMaterializeOperator2;
    }();
    DeMaterializeSubscriber = function(_super) {
      __extends(DeMaterializeSubscriber2, _super);
      function DeMaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      DeMaterializeSubscriber2.prototype._next = function(value) {
        value.observe(this.destination);
      };
      return DeMaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator, DistinctSubscriber;
var init_distinct = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/distinct.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DistinctOperator = function() {
      function DistinctOperator2(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
      }
      DistinctOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
      };
      return DistinctOperator2;
    }();
    DistinctSubscriber = function(_super) {
      __extends(DistinctSubscriber2, _super);
      function DistinctSubscriber2(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
          _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
        }
        return _this;
      }
      DistinctSubscriber2.prototype.notifyNext = function() {
        this.values.clear();
      };
      DistinctSubscriber2.prototype.notifyError = function(error) {
        this._error(error);
      };
      DistinctSubscriber2.prototype._next = function(value) {
        if (this.keySelector) {
          this._useKeySelector(value);
        } else {
          this._finalizeNext(value, value);
        }
      };
      DistinctSubscriber2.prototype._useKeySelector = function(value) {
        var key2;
        var destination = this.destination;
        try {
          key2 = this.keySelector(value);
        } catch (err) {
          destination.error(err);
          return;
        }
        this._finalizeNext(key2, value);
      };
      DistinctSubscriber2.prototype._finalizeNext = function(key2, value) {
        var values = this.values;
        if (!values.has(key2)) {
          values.add(key2);
          this.destination.next(value);
        }
      };
      return DistinctSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(compare, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}
var DistinctUntilChangedOperator, DistinctUntilChangedSubscriber;
var init_distinctUntilChanged = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js"() {
    init_tslib_es6();
    init_Subscriber();
    DistinctUntilChangedOperator = function() {
      function DistinctUntilChangedOperator2(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
      }
      DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      };
      return DistinctUntilChangedOperator2;
    }();
    DistinctUntilChangedSubscriber = function(_super) {
      __extends(DistinctUntilChangedSubscriber2, _super);
      function DistinctUntilChangedSubscriber2(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === "function") {
          _this.compare = compare;
        }
        return _this;
      }
      DistinctUntilChangedSubscriber2.prototype.compare = function(x5, y5) {
        return x5 === y5;
      };
      DistinctUntilChangedSubscriber2.prototype._next = function(value) {
        var key2;
        try {
          var keySelector = this.keySelector;
          key2 = keySelector ? keySelector(value) : value;
        } catch (err) {
          return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
          try {
            var compare = this.compare;
            result = compare(this.key, key2);
          } catch (err) {
            return this.destination.error(err);
          }
        } else {
          this.hasKey = true;
        }
        if (!result) {
          this.key = key2;
          this.destination.next(value);
        }
      };
      return DistinctUntilChangedSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key2, compare) {
  return distinctUntilChanged(function(x5, y5) {
    return compare ? compare(x5[key2], y5[key2]) : x5[key2] === y5[key2];
  });
}
var init_distinctUntilKeyChanged = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js"() {
    init_distinctUntilChanged();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
function defaultErrorFactory() {
  return new EmptyError();
}
var ThrowIfEmptyOperator, ThrowIfEmptySubscriber;
var init_throwIfEmpty = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js"() {
    init_tslib_es6();
    init_EmptyError();
    init_Subscriber();
    ThrowIfEmptyOperator = function() {
      function ThrowIfEmptyOperator2(errorFactory) {
        this.errorFactory = errorFactory;
      }
      ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
      };
      return ThrowIfEmptyOperator2;
    }();
    ThrowIfEmptySubscriber = function(_super) {
      __extends(ThrowIfEmptySubscriber2, _super);
      function ThrowIfEmptySubscriber2(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
      }
      ThrowIfEmptySubscriber2.prototype._next = function(value) {
        this.hasValue = true;
        this.destination.next(value);
      };
      ThrowIfEmptySubscriber2.prototype._complete = function() {
        if (!this.hasValue) {
          var err = void 0;
          try {
            err = this.errorFactory();
          } catch (e5) {
            err = e5;
          }
          this.destination.error(err);
        } else {
          return this.destination.complete();
        }
      };
      return ThrowIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/take.js
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator, TakeSubscriber;
var init_take = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/take.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeOperator = function() {
      function TakeOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator2;
    }();
    TakeSubscriber = function(_super) {
      __extends(TakeSubscriber2, _super);
      function TakeSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      TakeSubscriber2.prototype._next = function(value) {
        var total = this.total;
        var count2 = ++this.count;
        if (count2 <= total) {
          this.destination.next(value);
          if (count2 === total) {
            this.destination.complete();
            this.unsubscribe();
          }
        }
      };
      return TakeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/elementAt.js
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v8, i5) {
      return i5 === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
var init_elementAt = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/elementAt.js"() {
    init_ArgumentOutOfRangeError();
    init_filter();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_take();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/endWith.js
function endWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  return function(source) {
    return concat2(source, of.apply(void 0, array2));
  };
}
var init_endWith = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/endWith.js"() {
    init_concat();
    init_of();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/every.js
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator, EverySubscriber;
var init_every = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/every.js"() {
    init_tslib_es6();
    init_Subscriber();
    EveryOperator = function() {
      function EveryOperator2(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
      }
      EveryOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
      };
      return EveryOperator2;
    }();
    EverySubscriber = function(_super) {
      __extends(EverySubscriber2, _super);
      function EverySubscriber2(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
      };
      EverySubscriber2.prototype._next = function(value) {
        var result = false;
        try {
          result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (!result) {
          this.notifyComplete(false);
        }
      };
      EverySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return EverySubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/exhaust.js
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator, SwitchFirstSubscriber;
var init_exhaust = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/exhaust.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SwitchFirstOperator = function() {
      function SwitchFirstOperator2() {
      }
      SwitchFirstOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
      };
      return SwitchFirstOperator2;
    }();
    SwitchFirstSubscriber = function(_super) {
      __extends(SwitchFirstSubscriber2, _super);
      function SwitchFirstSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
      }
      SwitchFirstSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.hasSubscription = true;
          this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
        }
      };
      SwitchFirstSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
      };
      SwitchFirstSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return SwitchFirstSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a5, i5) {
        return from(project(a5, i5)).pipe(map(function(b4, ii) {
          return resultSelector(a5, b4, i5, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator, ExhaustMapSubscriber;
var init_exhaustMap = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/exhaustMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    ExhaustMapOperator = function() {
      function ExhaustMapOperator2(project) {
        this.project = project;
      }
      ExhaustMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
      };
      return ExhaustMapOperator2;
    }();
    ExhaustMapSubscriber = function(_super) {
      __extends(ExhaustMapSubscriber2, _super);
      function ExhaustMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
      }
      ExhaustMapSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.tryNext(value);
        }
      };
      ExhaustMapSubscriber2.prototype.tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
      };
      ExhaustMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      ExhaustMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      ExhaustMapSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      ExhaustMapSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return ExhaustMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/expand.js
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator, ExpandSubscriber;
var init_expand = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/expand.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    ExpandOperator = function() {
      function ExpandOperator2(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
      }
      ExpandOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
      };
      return ExpandOperator2;
    }();
    ExpandSubscriber = function(_super) {
      __extends(ExpandSubscriber2, _super);
      function ExpandSubscriber2(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
          _this.buffer = [];
        }
        return _this;
      }
      ExpandSubscriber2.dispatch = function(arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
      };
      ExpandSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (destination.closed) {
          this._complete();
          return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
          destination.next(value);
          try {
            var project = this.project;
            var result = project(value, index);
            if (!this.scheduler) {
              this.subscribeToProjection(result, value, index);
            } else {
              var state = { subscriber: this, result, value, index };
              var destination_1 = this.destination;
              destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state));
            }
          } catch (e5) {
            destination.error(e5);
          }
        } else {
          this.buffer.push(value);
        }
      };
      ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
      };
      ExpandSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
        this._next(innerValue);
      };
      ExpandSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2 && buffer2.length > 0) {
          this._next(buffer2.shift());
        }
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
      };
      return ExpandSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/finalize.js
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator, FinallySubscriber;
var init_finalize = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/finalize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    FinallyOperator = function() {
      function FinallyOperator2(callback) {
        this.callback = callback;
      }
      FinallyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
      };
      return FinallyOperator2;
    }();
    FinallySubscriber = function(_super) {
      __extends(FinallySubscriber2, _super);
      function FinallySubscriber2(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
      }
      return FinallySubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/find.js
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator, FindValueSubscriber;
var init_find = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/find.js"() {
    init_tslib_es6();
    init_Subscriber();
    FindValueOperator = function() {
      function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
      }
      FindValueOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
      };
      return FindValueOperator2;
    }();
    FindValueSubscriber = function(_super) {
      __extends(FindValueSubscriber2, _super);
      function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
      }
      FindValueSubscriber2.prototype.notifyComplete = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
      };
      FindValueSubscriber2.prototype._next = function(value) {
        var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
        var index = this.index++;
        try {
          var result = predicate.call(thisArg || this, value, index, this.source);
          if (result) {
            this.notifyComplete(this.yieldIndex ? index : value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      FindValueSubscriber2.prototype._complete = function() {
        this.notifyComplete(this.yieldIndex ? -1 : void 0);
      };
      return FindValueSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/findIndex.js
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
var init_findIndex = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/findIndex.js"() {
    init_find();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v8, i5) {
      return predicate(v8, i5, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_first = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/first.js"() {
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator, IgnoreElementsSubscriber;
var init_ignoreElements = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/ignoreElements.js"() {
    init_tslib_es6();
    init_Subscriber();
    IgnoreElementsOperator = function() {
      function IgnoreElementsOperator2() {
      }
      IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
      };
      return IgnoreElementsOperator2;
    }();
    IgnoreElementsSubscriber = function(_super) {
      __extends(IgnoreElementsSubscriber2, _super);
      function IgnoreElementsSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IgnoreElementsSubscriber2.prototype._next = function(unused) {
      };
      return IgnoreElementsSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/isEmpty.js
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator, IsEmptySubscriber;
var init_isEmpty = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/isEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    IsEmptyOperator = function() {
      function IsEmptyOperator2() {
      }
      IsEmptyOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
      };
      return IsEmptyOperator2;
    }();
    IsEmptySubscriber = function(_super) {
      __extends(IsEmptySubscriber2, _super);
      function IsEmptySubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
        var destination = this.destination;
        destination.next(isEmpty2);
        destination.complete();
      };
      IsEmptySubscriber2.prototype._next = function(value) {
        this.notifyComplete(false);
      };
      IsEmptySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return IsEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator, TakeLastSubscriber;
var init_takeLast = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/takeLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeLastOperator = function() {
      function TakeLastOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeLastOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
      };
      return TakeLastOperator2;
    }();
    TakeLastSubscriber = function(_super) {
      __extends(TakeLastSubscriber2, _super);
      function TakeLastSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
      }
      TakeLastSubscriber2.prototype._next = function(value) {
        var ring = this.ring;
        var total = this.total;
        var count2 = this.count++;
        if (ring.length < total) {
          ring.push(value);
        } else {
          var index = count2 % total;
          ring[index] = value;
        }
      };
      TakeLastSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        var count2 = this.count;
        if (count2 > 0) {
          var total = this.count >= this.total ? this.total : this.count;
          var ring = this.ring;
          for (var i5 = 0; i5 < total; i5++) {
            var idx = count2++ % total;
            destination.next(ring[idx]);
          }
        }
        destination.complete();
      };
      return TakeLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/last.js
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v8, i5) {
      return predicate(v8, i5, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_last = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/last.js"() {
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mapTo.js
function mapTo(value) {
  return function(source) {
    return source.lift(new MapToOperator(value));
  };
}
var MapToOperator, MapToSubscriber;
var init_mapTo = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mapTo.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapToOperator = function() {
      function MapToOperator2(value) {
        this.value = value;
      }
      MapToOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
      };
      return MapToOperator2;
    }();
    MapToSubscriber = function(_super) {
      __extends(MapToSubscriber2, _super);
      function MapToSubscriber2(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
      }
      MapToSubscriber2.prototype._next = function(x5) {
        this.destination.next(this.value);
      };
      return MapToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/materialize.js
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator, MaterializeSubscriber;
var init_materialize = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/materialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    MaterializeOperator = function() {
      function MaterializeOperator2() {
      }
      MaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
      };
      return MaterializeOperator2;
    }();
    MaterializeSubscriber = function(_super) {
      __extends(MaterializeSubscriber2, _super);
      function MaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      MaterializeSubscriber2.prototype._next = function(value) {
        this.destination.next(Notification.createNext(value));
      };
      MaterializeSubscriber2.prototype._error = function(err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
      };
      MaterializeSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
      };
      return MaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator, ScanSubscriber;
var init_scan = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/scan.js"() {
    init_tslib_es6();
    init_Subscriber();
    ScanOperator = function() {
      function ScanOperator2(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
          hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
      }
      ScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
      };
      return ScanOperator2;
    }();
    ScanSubscriber = function(_super) {
      __extends(ScanSubscriber2, _super);
      function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
      }
      Object.defineProperty(ScanSubscriber2.prototype, "seed", {
        get: function() {
          return this._seed;
        },
        set: function(value) {
          this.hasSeed = true;
          this._seed = value;
        },
        enumerable: true,
        configurable: true
      });
      ScanSubscriber2.prototype._next = function(value) {
        if (!this.hasSeed) {
          this.seed = value;
          this.destination.next(value);
        } else {
          return this._tryNext(value);
        }
      };
      ScanSubscriber2.prototype._tryNext = function(value) {
        var index = this.index++;
        var result;
        try {
          result = this.accumulator(this.seed, value, index);
        } catch (err) {
          this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
      };
      return ScanSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), takeLast(1))(source);
  };
}
var init_reduce = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/reduce.js"() {
    init_scan();
    init_takeLast();
    init_defaultIfEmpty();
    init_pipe();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/max.js
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x5, y5) {
    return comparer(x5, y5) > 0 ? x5 : y5;
  } : function(x5, y5) {
    return x5 > y5 ? x5 : y5;
  };
  return reduce(max2);
}
var init_max = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/max.js"() {
    init_reduce();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/merge.js
function merge2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge.apply(void 0, [source].concat(observables)));
  };
}
var init_merge2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/merge.js"() {
    init_merge();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
var init_mergeMapTo = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js"() {
    init_mergeMap();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeScan.js
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator, MergeScanSubscriber;
var init_mergeScan = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/mergeScan.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    MergeScanOperator = function() {
      function MergeScanOperator2(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
      }
      MergeScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
      };
      return MergeScanOperator2;
    }();
    MergeScanSubscriber = function(_super) {
      __extends(MergeScanSubscriber2, _super);
      function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeScanSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          var index = this.index++;
          var destination = this.destination;
          var ish = void 0;
          try {
            var accumulator = this.accumulator;
            ish = accumulator(this.acc, value, index);
          } catch (e5) {
            return destination.error(e5);
          }
          this.active++;
          this._innerSub(ish);
        } else {
          this.buffer.push(value);
        }
      };
      MergeScanSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeScanSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
      };
      MergeScanSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
      };
      return MergeScanSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/min.js
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x5, y5) {
    return comparer(x5, y5) < 0 ? x5 : y5;
  } : function(x5, y5) {
    return x5 < y5 ? x5 : y5;
  };
  return reduce(min2);
}
var init_min = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/min.js"() {
    init_reduce();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator;
var init_multicast = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/multicast.js"() {
    init_ConnectableObservable();
    MulticastOperator = function() {
      function MulticastOperator2(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }
      MulticastOperator2.prototype.call = function(subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
      };
      return MulticastOperator2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js
function onErrorResumeNext2() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator, OnErrorResumeNextSubscriber;
var init_onErrorResumeNext2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js"() {
    init_tslib_es6();
    init_from();
    init_isArray();
    init_innerSubscribe();
    OnErrorResumeNextOperator = function() {
      function OnErrorResumeNextOperator2(nextSources) {
        this.nextSources = nextSources;
      }
      OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
      };
      return OnErrorResumeNextOperator2;
    }();
    OnErrorResumeNextSubscriber = function(_super) {
      __extends(OnErrorResumeNextSubscriber2, _super);
      function OnErrorResumeNextSubscriber2(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
      }
      OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype._error = function(err) {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype._complete = function() {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
        var next = this.nextSources.shift();
        if (!!next) {
          var innerSubscriber = new SimpleInnerSubscriber(this);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = innerSubscribe(next, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        } else {
          this.destination.complete();
        }
      };
      return OnErrorResumeNextSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/pairwise.js
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator, PairwiseSubscriber;
var init_pairwise = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/pairwise.js"() {
    init_tslib_es6();
    init_Subscriber();
    PairwiseOperator = function() {
      function PairwiseOperator2() {
      }
      PairwiseOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
      };
      return PairwiseOperator2;
    }();
    PairwiseSubscriber = function(_super) {
      __extends(PairwiseSubscriber2, _super);
      function PairwiseSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
      }
      PairwiseSubscriber2.prototype._next = function(value) {
        var pair;
        if (this.hasPrev) {
          pair = [this.prev, value];
        } else {
          this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
          this.destination.next(pair);
        }
      };
      return PairwiseSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/partition.js
function partition2(predicate, thisArg) {
  return function(source) {
    return [
      filter(predicate, thisArg)(source),
      filter(not(predicate, thisArg))(source)
    ];
  };
}
var init_partition2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/partition.js"() {
    init_not();
    init_filter();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x5) {
    var currentProp = x5;
    for (var i5 = 0; i5 < length; i5++) {
      var p5 = currentProp != null ? currentProp[props[i5]] : void 0;
      if (p5 !== void 0) {
        currentProp = p5;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
var init_pluck = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/pluck.js"() {
    init_map();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
var init_publish = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publish.js"() {
    init_Subject();
    init_multicast();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publishBehavior.js
function publishBehavior(value) {
  return function(source) {
    return multicast(new BehaviorSubject(value))(source);
  };
}
var init_publishBehavior = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publishBehavior.js"() {
    init_BehaviorSubject();
    init_multicast();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publishLast.js
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
var init_publishLast = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publishLast.js"() {
    init_AsyncSubject();
    init_multicast();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
var init_publishReplay = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/publishReplay.js"() {
    init_ReplaySubject();
    init_multicast();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/race.js
function race2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race.apply(void 0, [source].concat(observables)));
  };
}
var init_race2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/race.js"() {
    init_isArray();
    init_race();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/repeat.js
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator, RepeatSubscriber;
var init_repeat = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/repeat.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_empty();
    RepeatOperator = function() {
      function RepeatOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RepeatOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
      };
      return RepeatOperator2;
    }();
    RepeatSubscriber = function(_super) {
      __extends(RepeatSubscriber2, _super);
      function RepeatSubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RepeatSubscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          var _a2 = this, source = _a2.source, count2 = _a2.count;
          if (count2 === 0) {
            return _super.prototype.complete.call(this);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RepeatSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/repeatWhen.js
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator, RepeatWhenSubscriber;
var init_repeatWhen = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/repeatWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RepeatWhenOperator = function() {
      function RepeatWhenOperator2(notifier) {
        this.notifier = notifier;
      }
      RepeatWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
      };
      return RepeatWhenOperator2;
    }();
    RepeatWhenSubscriber = function(_super) {
      __extends(RepeatWhenSubscriber2, _super);
      function RepeatWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
      }
      RepeatWhenSubscriber2.prototype.notifyNext = function() {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
      };
      RepeatWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.sourceIsBeingSubscribedTo === false) {
          return _super.prototype.complete.call(this);
        }
      };
      RepeatWhenSubscriber2.prototype.complete = function() {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
          if (!this.retries) {
            this.subscribeToRetries();
          }
          if (!this.retriesSubscription || this.retriesSubscription.closed) {
            return _super.prototype.complete.call(this);
          }
          this._unsubscribeAndRecycle();
          this.notifications.next(void 0);
        }
      };
      RepeatWhenSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
        if (notifications) {
          notifications.unsubscribe();
          this.notifications = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
      };
      RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
        this.notifications = new Subject();
        var retries;
        try {
          var notifier = this.notifier;
          retries = notifier(this.notifications);
        } catch (e5) {
          return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      };
      return RepeatWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/retry.js
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator, RetrySubscriber;
var init_retry = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/retry.js"() {
    init_tslib_es6();
    init_Subscriber();
    RetryOperator = function() {
      function RetryOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RetryOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
      };
      return RetryOperator2;
    }();
    RetrySubscriber = function(_super) {
      __extends(RetrySubscriber2, _super);
      function RetrySubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RetrySubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _a2 = this, source = _a2.source, count2 = _a2.count;
          if (count2 === 0) {
            return _super.prototype.error.call(this, err);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RetrySubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/retryWhen.js
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator, RetryWhenSubscriber;
var init_retryWhen = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/retryWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RetryWhenOperator = function() {
      function RetryWhenOperator2(notifier, source) {
        this.notifier = notifier;
        this.source = source;
      }
      RetryWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
      };
      return RetryWhenOperator2;
    }();
    RetryWhenSubscriber = function(_super) {
      __extends(RetryWhenSubscriber2, _super);
      function RetryWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
      }
      RetryWhenSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var errors = this.errors;
          var retries = this.retries;
          var retriesSubscription = this.retriesSubscription;
          if (!retries) {
            errors = new Subject();
            try {
              var notifier = this.notifier;
              retries = notifier(errors);
            } catch (e5) {
              return _super.prototype.error.call(this, e5);
            }
            retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
          } else {
            this.errors = void 0;
            this.retriesSubscription = void 0;
          }
          this._unsubscribeAndRecycle();
          this.errors = errors;
          this.retries = retries;
          this.retriesSubscription = retriesSubscription;
          errors.next(err);
        }
      };
      RetryWhenSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, errors = _a2.errors, retriesSubscription = _a2.retriesSubscription;
        if (errors) {
          errors.unsubscribe();
          this.errors = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RetryWhenSubscriber2.prototype.notifyNext = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
      };
      return RetryWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/sample.js
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator, SampleSubscriber;
var init_sample = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/sample.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SampleOperator = function() {
      function SampleOperator2(notifier) {
        this.notifier = notifier;
      }
      SampleOperator2.prototype.call = function(subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
      };
      return SampleOperator2;
    }();
    SampleSubscriber = function(_super) {
      __extends(SampleSubscriber2, _super);
      function SampleSubscriber2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
      }
      SampleSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
      };
      SampleSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.value);
        }
      };
      return SampleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/sampleTime.js
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
function dispatchNotification(state) {
  var subscriber = state.subscriber, period = state.period;
  subscriber.notifyNext();
  this.schedule(state, period);
}
var SampleTimeOperator, SampleTimeSubscriber;
var init_sampleTime = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/sampleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    SampleTimeOperator = function() {
      function SampleTimeOperator2(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
      }
      SampleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
      };
      return SampleTimeOperator2;
    }();
    SampleTimeSubscriber = function(_super) {
      __extends(SampleTimeSubscriber2, _super);
      function SampleTimeSubscriber2(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
        return _this;
      }
      SampleTimeSubscriber2.prototype._next = function(value) {
        this.lastValue = value;
        this.hasValue = true;
      };
      SampleTimeSubscriber2.prototype.notifyNext = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.lastValue);
        }
      };
      return SampleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js
function sequenceEqual(compareTo, comparator) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator, SequenceEqualSubscriber, SequenceEqualCompareToSubscriber;
var init_sequenceEqual = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js"() {
    init_tslib_es6();
    init_Subscriber();
    SequenceEqualOperator = function() {
      function SequenceEqualOperator2(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
      }
      SequenceEqualOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
      };
      return SequenceEqualOperator2;
    }();
    SequenceEqualSubscriber = function(_super) {
      __extends(SequenceEqualSubscriber2, _super);
      function SequenceEqualSubscriber2(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
      }
      SequenceEqualSubscriber2.prototype._next = function(value) {
        if (this._oneComplete && this._b.length === 0) {
          this.emit(false);
        } else {
          this._a.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype._complete = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
        this.unsubscribe();
      };
      SequenceEqualSubscriber2.prototype.checkValues = function() {
        var _c = this, _a2 = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a2.length > 0 && _b.length > 0) {
          var a5 = _a2.shift();
          var b4 = _b.shift();
          var areEqual = false;
          try {
            areEqual = comparator ? comparator(a5, b4) : a5 === b4;
          } catch (e5) {
            this.destination.error(e5);
          }
          if (!areEqual) {
            this.emit(false);
          }
        }
      };
      SequenceEqualSubscriber2.prototype.emit = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
      };
      SequenceEqualSubscriber2.prototype.nextB = function(value) {
        if (this._oneComplete && this._a.length === 0) {
          this.emit(false);
        } else {
          this._b.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype.completeB = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
      };
      return SequenceEqualSubscriber2;
    }(Subscriber);
    SequenceEqualCompareToSubscriber = function(_super) {
      __extends(SequenceEqualCompareToSubscriber2, _super);
      function SequenceEqualCompareToSubscriber2(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
      }
      SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
        this.parent.nextB(value);
      };
      SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
        this.parent.error(err);
        this.unsubscribe();
      };
      SequenceEqualCompareToSubscriber2.prototype._complete = function() {
        this.parent.completeB();
        this.unsubscribe();
      };
      return SequenceEqualCompareToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/share.js
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
var init_share = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/share.js"() {
    init_multicast();
    init_refCount();
    init_Subject();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b = _a2.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a2.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
var init_shareReplay = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/shareReplay.js"() {
    init_ReplaySubject();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/single.js
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator, SingleSubscriber;
var init_single = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/single.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_EmptyError();
    SingleOperator = function() {
      function SingleOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      SingleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
      };
      return SingleOperator2;
    }();
    SingleSubscriber = function(_super) {
      __extends(SingleSubscriber2, _super);
      function SingleSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
      }
      SingleSubscriber2.prototype.applySingleValue = function(value) {
        if (this.seenValue) {
          this.destination.error("Sequence contains more than one element");
        } else {
          this.seenValue = true;
          this.singleValue = value;
        }
      };
      SingleSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        if (this.predicate) {
          this.tryNext(value, index);
        } else {
          this.applySingleValue(value);
        }
      };
      SingleSubscriber2.prototype.tryNext = function(value, index) {
        try {
          if (this.predicate(value, index, this.source)) {
            this.applySingleValue(value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      SingleSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        if (this.index > 0) {
          destination.next(this.seenValue ? this.singleValue : void 0);
          destination.complete();
        } else {
          destination.error(new EmptyError());
        }
      };
      return SingleSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skip.js
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator, SkipSubscriber;
var init_skip = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skip.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipOperator = function() {
      function SkipOperator2(total) {
        this.total = total;
      }
      SkipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
      };
      return SkipOperator2;
    }();
    SkipSubscriber = function(_super) {
      __extends(SkipSubscriber2, _super);
      function SkipSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      SkipSubscriber2.prototype._next = function(x5) {
        if (++this.count > this.total) {
          this.destination.next(x5);
        }
      };
      return SkipSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skipLast.js
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator, SkipLastSubscriber;
var init_skipLast = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skipLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    SkipLastOperator = function() {
      function SkipLastOperator2(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      SkipLastOperator2.prototype.call = function(subscriber, source) {
        if (this._skipCount === 0) {
          return source.subscribe(new Subscriber(subscriber));
        } else {
          return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
      };
      return SkipLastOperator2;
    }();
    SkipLastSubscriber = function(_super) {
      __extends(SkipLastSubscriber2, _super);
      function SkipLastSubscriber2(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
      }
      SkipLastSubscriber2.prototype._next = function(value) {
        var skipCount = this._skipCount;
        var count2 = this._count++;
        if (count2 < skipCount) {
          this._ring[count2] = value;
        } else {
          var currentIndex = count2 % skipCount;
          var ring = this._ring;
          var oldValue = ring[currentIndex];
          ring[currentIndex] = value;
          this.destination.next(oldValue);
        }
      };
      return SkipLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skipUntil.js
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator, SkipUntilSubscriber;
var init_skipUntil = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skipUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SkipUntilOperator = function() {
      function SkipUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      SkipUntilOperator2.prototype.call = function(destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
      };
      return SkipUntilOperator2;
    }();
    SkipUntilSubscriber = function(_super) {
      __extends(SkipUntilSubscriber2, _super);
      function SkipUntilSubscriber2(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          _this.add(innerSubscription);
          _this.innerSubscription = innerSubscription;
        }
        return _this;
      }
      SkipUntilSubscriber2.prototype._next = function(value) {
        if (this.hasValue) {
          _super.prototype._next.call(this, value);
        }
      };
      SkipUntilSubscriber2.prototype.notifyNext = function() {
        this.hasValue = true;
        if (this.innerSubscription) {
          this.innerSubscription.unsubscribe();
        }
      };
      SkipUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return SkipUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skipWhile.js
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator, SkipWhileSubscriber;
var init_skipWhile = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/skipWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipWhileOperator = function() {
      function SkipWhileOperator2(predicate) {
        this.predicate = predicate;
      }
      SkipWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      };
      return SkipWhileOperator2;
    }();
    SkipWhileSubscriber = function(_super) {
      __extends(SkipWhileSubscriber2, _super);
      function SkipWhileSubscriber2(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
      }
      SkipWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (this.skipping) {
          this.tryCallPredicate(value);
        }
        if (!this.skipping) {
          destination.next(value);
        }
      };
      SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
        try {
          var result = this.predicate(value, this.index++);
          this.skipping = Boolean(result);
        } catch (err) {
          this.destination.error(err);
        }
      };
      return SkipWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/startWith.js
function startWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  var scheduler = array2[array2.length - 1];
  if (isScheduler(scheduler)) {
    array2.pop();
    return function(source) {
      return concat2(array2, source, scheduler);
    };
  } else {
    return function(source) {
      return concat2(array2, source);
    };
  }
}
var init_startWith = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/startWith.js"() {
    init_concat();
    init_isScheduler();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
var SubscribeOnObservable;
var init_SubscribeOnObservable = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js"() {
    init_tslib_es6();
    init_Observable();
    init_asap();
    init_isNumeric();
    SubscribeOnObservable = function(_super) {
      __extends(SubscribeOnObservable2, _super);
      function SubscribeOnObservable2(source, delayTime, scheduler) {
        if (delayTime === void 0) {
          delayTime = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
          _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
          _this.scheduler = asap;
        }
        return _this;
      }
      SubscribeOnObservable2.create = function(source, delay2, scheduler) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        return new SubscribeOnObservable2(source, delay2, scheduler);
      };
      SubscribeOnObservable2.dispatch = function(arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
      };
      SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
        var delay2 = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
          source,
          subscriber
        });
      };
      return SubscribeOnObservable2;
    }(Observable);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator;
var init_subscribeOn = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/subscribeOn.js"() {
    init_SubscribeOnObservable();
    SubscribeOnOperator = function() {
      function SubscribeOnOperator2(scheduler, delay2) {
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      SubscribeOnOperator2.prototype.call = function(subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
      };
      return SubscribeOnOperator2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a5, i5) {
        return from(project(a5, i5)).pipe(map(function(b4, ii) {
          return resultSelector(a5, b4, i5, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator, SwitchMapSubscriber;
var init_switchMap = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/switchMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    SwitchMapOperator = function() {
      function SwitchMapOperator2(project) {
        this.project = project;
      }
      SwitchMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      };
      return SwitchMapOperator2;
    }();
    SwitchMapSubscriber = function(_super) {
      __extends(SwitchMapSubscriber2, _super);
      function SwitchMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
      }
      SwitchMapSubscriber2.prototype._next = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (error) {
          this.destination.error(error);
          return;
        }
        this._innerSub(result);
      };
      SwitchMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
          innerSubscription.unsubscribe();
        }
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
          destination.add(this.innerSubscription);
        }
      };
      SwitchMapSubscriber2.prototype._complete = function() {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
          _super.prototype._complete.call(this);
        }
        this.unsubscribe();
      };
      SwitchMapSubscriber2.prototype._unsubscribe = function() {
        this.innerSubscription = void 0;
      };
      SwitchMapSubscriber2.prototype.notifyComplete = function() {
        this.innerSubscription = void 0;
        if (this.isStopped) {
          _super.prototype._complete.call(this);
        }
      };
      SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      return SwitchMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity);
}
var init_switchAll = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/switchAll.js"() {
    init_switchMap();
    init_identity();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
var init_switchMapTo = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/switchMapTo.js"() {
    init_switchMap();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator, TakeUntilSubscriber;
var init_takeUntil = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/takeUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    TakeUntilOperator = function() {
      function TakeUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      TakeUntilOperator2.prototype.call = function(subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
          takeUntilSubscriber.add(notifierSubscription);
          return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
      };
      return TakeUntilOperator2;
    }();
    TakeUntilSubscriber = function(_super) {
      __extends(TakeUntilSubscriber2, _super);
      function TakeUntilSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
      }
      TakeUntilSubscriber2.prototype.notifyNext = function() {
        this.seenValue = true;
        this.complete();
      };
      TakeUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return TakeUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator, TakeWhileSubscriber;
var init_takeWhile = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/takeWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    TakeWhileOperator = function() {
      function TakeWhileOperator2(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
      }
      TakeWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
      };
      return TakeWhileOperator2;
    }();
    TakeWhileSubscriber = function(_super) {
      __extends(TakeWhileSubscriber2, _super);
      function TakeWhileSubscriber2(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
      }
      TakeWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        var result;
        try {
          result = this.predicate(value, this.index++);
        } catch (err) {
          destination.error(err);
          return;
        }
        this.nextOrComplete(value, result);
      };
      TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
          destination.next(value);
        } else {
          if (this.inclusive) {
            destination.next(value);
          }
          destination.complete();
        }
      };
      return TakeWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/tap.js
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator, TapSubscriber;
var init_tap = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/tap.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_noop();
    init_isFunction();
    DoOperator = function() {
      function DoOperator2(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
      }
      DoOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator2;
    }();
    TapSubscriber = function(_super) {
      __extends(TapSubscriber2, _super);
      function TapSubscriber2(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
          _this._context = _this;
          _this._tapNext = observerOrNext;
        } else if (observerOrNext) {
          _this._context = observerOrNext;
          _this._tapNext = observerOrNext.next || noop;
          _this._tapError = observerOrNext.error || noop;
          _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
      }
      TapSubscriber2.prototype._next = function(value) {
        try {
          this._tapNext.call(this._context, value);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(value);
      };
      TapSubscriber2.prototype._error = function(err) {
        try {
          this._tapError.call(this._context, err);
        } catch (err2) {
          this.destination.error(err2);
          return;
        }
        this.destination.error(err);
      };
      TapSubscriber2.prototype._complete = function() {
        try {
          this._tapComplete.call(this._context);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        return this.destination.complete();
      };
      return TapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var defaultThrottleConfig, ThrottleOperator, ThrottleSubscriber;
var init_throttle = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/throttle.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
    ThrottleOperator = function() {
      function ThrottleOperator2(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
      };
      return ThrottleOperator2;
    }();
    ThrottleSubscriber = function(_super) {
      __extends(ThrottleSubscriber2, _super);
      function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
      }
      ThrottleSubscriber2.prototype._next = function(value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
          if (this._leading) {
            this.send();
          } else {
            this.throttle(value);
          }
        }
      };
      ThrottleSubscriber2.prototype.send = function() {
        var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
        if (_hasValue) {
          this.destination.next(_sendValue);
          this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = void 0;
      };
      ThrottleSubscriber2.prototype.throttle = function(value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
          this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
        }
      };
      ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
        try {
          return this.durationSelector(value);
        } catch (err) {
          this.destination.error(err);
          return null;
        }
      };
      ThrottleSubscriber2.prototype.throttlingDone = function() {
        var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
        if (_throttled) {
          _throttled.unsubscribe();
        }
        this._throttled = void 0;
        if (_trailing) {
          this.send();
        }
      };
      ThrottleSubscriber2.prototype.notifyNext = function() {
        this.throttlingDone();
      };
      ThrottleSubscriber2.prototype.notifyComplete = function() {
        this.throttlingDone();
      };
      return ThrottleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
function dispatchNext4(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
var ThrottleTimeOperator, ThrottleTimeSubscriber;
var init_throttleTime = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/throttleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    init_throttle();
    ThrottleTimeOperator = function() {
      function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
      };
      return ThrottleTimeOperator2;
    }();
    ThrottleTimeSubscriber = function(_super) {
      __extends(ThrottleTimeSubscriber2, _super);
      function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
      }
      ThrottleTimeSubscriber2.prototype._next = function(value) {
        if (this.throttled) {
          if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        } else {
          this.add(this.throttled = this.scheduler.schedule(dispatchNext4, this.duration, { subscriber: this }));
          if (this.leading) {
            this.destination.next(value);
          } else if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        }
      };
      ThrottleTimeSubscriber2.prototype._complete = function() {
        if (this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this.destination.complete();
        } else {
          this.destination.complete();
        }
      };
      ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
        var throttled = this.throttled;
        if (throttled) {
          if (this.trailing && this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
          }
          throttled.unsubscribe();
          this.remove(throttled);
          this.throttled = null;
        }
      };
      return ThrottleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timeInterval.js
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a2, value) {
        var current = _a2.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value = _a2.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval;
var init_timeInterval = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timeInterval.js"() {
    init_async();
    init_scan();
    init_defer();
    init_map();
    TimeInterval = function() {
      function TimeInterval2(value, interval2) {
        this.value = value;
        this.interval = interval2;
      }
      return TimeInterval2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator, TimeoutWithSubscriber;
var init_timeoutWith = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timeoutWith.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_innerSubscribe();
    TimeoutWithOperator = function() {
      function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
      }
      TimeoutWithOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
      };
      return TimeoutWithOperator2;
    }();
    TimeoutWithSubscriber = function(_super) {
      __extends(TimeoutWithSubscriber2, _super);
      function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
      }
      TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
      };
      TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
        var action = this.action;
        if (action) {
          this.action = action.schedule(this, this.waitFor);
        } else {
          this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
        }
      };
      TimeoutWithSubscriber2.prototype._next = function(value) {
        if (!this.absoluteTimeout) {
          this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
      };
      TimeoutWithSubscriber2.prototype._unsubscribe = function() {
        this.action = void 0;
        this.scheduler = null;
        this.withObservable = null;
      };
      return TimeoutWithSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timeout.js
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
var init_timeout = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timeout.js"() {
    init_async();
    init_TimeoutError();
    init_timeoutWith();
    init_throwError();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timestamp.js
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp;
var init_timestamp = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/timestamp.js"() {
    init_async();
    init_map();
    Timestamp = function() {
      function Timestamp2(value, timestamp2) {
        this.value = value;
        this.timestamp = timestamp2;
      }
      return Timestamp2;
    }();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/toArray.js
function toArrayReducer(arr, item, index) {
  if (index === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray2() {
  return reduce(toArrayReducer, []);
}
var init_toArray = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/toArray.js"() {
    init_reduce();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/window.js
function window2(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator(windowBoundaries));
  };
}
var WindowOperator, WindowSubscriber;
var init_window = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/window.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    WindowOperator = function() {
      function WindowOperator3(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
          windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
      };
      return WindowOperator3;
    }();
    WindowSubscriber = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function() {
        this.openWindow();
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function() {
        this._complete();
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
      };
      WindowSubscriber3.prototype._unsubscribe = function() {
        this.window = null;
      };
      WindowSubscriber3.prototype.openWindow = function() {
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
      };
      return WindowSubscriber3;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowCount.js
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator, WindowCountSubscriber;
var init_windowCount = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subject();
    WindowCountOperator = function() {
      function WindowCountOperator2(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
      }
      WindowCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
      };
      return WindowCountOperator2;
    }();
    WindowCountSubscriber = function(_super) {
      __extends(WindowCountSubscriber2, _super);
      function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
      }
      WindowCountSubscriber2.prototype._next = function(value) {
        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i5 = 0; i5 < len && !this.closed; i5++) {
          windows[i5].next(value);
        }
        var c5 = this.count - windowSize + 1;
        if (c5 >= 0 && c5 % startWindowEvery === 0 && !this.closed) {
          windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
          var window_1 = new Subject();
          windows.push(window_1);
          destination.next(window_1);
        }
      };
      WindowCountSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().error(err);
          }
        }
        this.destination.error(err);
      };
      WindowCountSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().complete();
          }
        }
        this.destination.complete();
      };
      WindowCountSubscriber2.prototype._unsubscribe = function() {
        this.count = 0;
        this.windows = null;
      };
      return WindowCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowTime.js
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
function dispatchWindowTimeSpanOnly(state) {
  var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window3 = state.window;
  if (window3) {
    subscriber.closeWindow(window3);
  }
  state.window = subscriber.openWindow();
  this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
  var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
  var window3 = subscriber.openWindow();
  var action = this;
  var context = { action, subscription: null };
  var timeSpanState = { subscriber, window: window3, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
  var subscriber = state.subscriber, window3 = state.window, context = state.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window3);
}
var WindowTimeOperator, CountedSubject, WindowTimeSubscriber;
var init_windowTime = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowTime.js"() {
    init_tslib_es6();
    init_Subject();
    init_async();
    init_Subscriber();
    init_isNumeric();
    init_isScheduler();
    WindowTimeOperator = function() {
      function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
      }
      WindowTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
      };
      return WindowTimeOperator2;
    }();
    CountedSubject = function(_super) {
      __extends(CountedSubject2, _super);
      function CountedSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
      }
      CountedSubject2.prototype.next = function(value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
      };
      Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
        get: function() {
          return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
      });
      return CountedSubject2;
    }(Subject);
    WindowTimeSubscriber = function(_super) {
      __extends(WindowTimeSubscriber2, _super);
      function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window3 = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          var closeState = { subscriber: _this, window: window3, context: null };
          var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
          _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
          var timeSpanOnlyState = { subscriber: _this, window: window3, windowTimeSpan };
          _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
      }
      WindowTimeSubscriber2.prototype._next = function(value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i5 = 0; i5 < len; i5++) {
          var window_1 = windows[i5];
          if (!window_1.closed) {
            window_1.next(value);
            if (window_1.numberOfNextedValues >= this.maxWindowSize) {
              this.closeWindow(window_1);
            }
          }
        }
      };
      WindowTimeSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        this.destination.error(err);
      };
      WindowTimeSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        while (windows.length > 0) {
          var window_2 = windows.shift();
          if (!window_2.closed) {
            window_2.complete();
          }
        }
        this.destination.complete();
      };
      WindowTimeSubscriber2.prototype.openWindow = function() {
        var window3 = new CountedSubject();
        this.windows.push(window3);
        var destination = this.destination;
        destination.next(window3);
        return window3;
      };
      WindowTimeSubscriber2.prototype.closeWindow = function(window3) {
        window3.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window3), 1);
      };
      return WindowTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowToggle.js
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator, WindowToggleSubscriber;
var init_windowToggle = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowToggle.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowToggleOperator = function() {
      function WindowToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      WindowToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return WindowToggleOperator2;
    }();
    WindowToggleSubscriber = function(_super) {
      __extends(WindowToggleSubscriber2, _super);
      function WindowToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
      }
      WindowToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        if (contexts) {
          var len = contexts.length;
          for (var i5 = 0; i5 < len; i5++) {
            contexts[i5].window.next(value);
          }
        }
      };
      WindowToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_1 = contexts[index];
            context_1.window.error(err);
            context_1.subscription.unsubscribe();
          }
        }
        _super.prototype._error.call(this, err);
      };
      WindowToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_2 = contexts[index];
            context_2.window.complete();
            context_2.subscription.unsubscribe();
          }
        }
        _super.prototype._complete.call(this);
      };
      WindowToggleSubscriber2.prototype._unsubscribe = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_3 = contexts[index];
            context_3.window.unsubscribe();
            context_3.subscription.unsubscribe();
          }
        }
      };
      WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
          var closingNotifier = void 0;
          try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector(innerValue);
          } catch (e5) {
            return this.error(e5);
          }
          var window_1 = new Subject();
          var subscription = new Subscription();
          var context_4 = { window: window_1, subscription };
          this.contexts.push(context_4);
          var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
          if (innerSubscription.closed) {
            this.closeWindow(this.contexts.length - 1);
          } else {
            innerSubscription.context = context_4;
            subscription.add(innerSubscription);
          }
          this.destination.next(window_1);
        } else {
          this.closeWindow(this.contexts.indexOf(outerValue));
        }
      };
      WindowToggleSubscriber2.prototype.notifyError = function(err) {
        this.error(err);
      };
      WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
        if (inner !== this.openSubscription) {
          this.closeWindow(this.contexts.indexOf(inner.context));
        }
      };
      WindowToggleSubscriber2.prototype.closeWindow = function(index) {
        if (index === -1) {
          return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window3 = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window3.complete();
        subscription.unsubscribe();
      };
      return WindowToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowWhen.js
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator2(closingSelector));
  };
}
var WindowOperator2, WindowSubscriber2;
var init_windowWhen = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/windowWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowOperator2 = function() {
      function WindowOperator3(closingSelector) {
        this.closingSelector = closingSelector;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowSubscriber2(subscriber, this.closingSelector));
      };
      return WindowOperator3;
    }();
    WindowSubscriber2 = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function(innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype.unsubscribeClosingNotification = function() {
        if (this.closingNotification) {
          this.closingNotification.unsubscribe();
        }
      };
      WindowSubscriber3.prototype.openWindow = function(innerSub) {
        if (innerSub === void 0) {
          innerSub = null;
        }
        if (innerSub) {
          this.remove(innerSub);
          innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var window3 = this.window = new Subject();
        this.destination.next(window3);
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (e5) {
          this.destination.error(e5);
          this.window.error(e5);
          return;
        }
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
      };
      return WindowSubscriber3;
    }(OuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator, WithLatestFromSubscriber;
var init_withLatestFrom = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js"() {
    init_tslib_es6();
    init_OuterSubscriber();
    init_subscribeToResult();
    WithLatestFromOperator = function() {
      function WithLatestFromOperator2(observables, project) {
        this.observables = observables;
        this.project = project;
      }
      WithLatestFromOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
      };
      return WithLatestFromOperator2;
    }();
    WithLatestFromSubscriber = function(_super) {
      __extends(WithLatestFromSubscriber2, _super);
      function WithLatestFromSubscriber2(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i5 = 0; i5 < len; i5++) {
          _this.toRespond.push(i5);
        }
        for (var i5 = 0; i5 < len; i5++) {
          var observable2 = observables[i5];
          _this.add(subscribeToResult(_this, observable2, void 0, i5));
        }
        return _this;
      }
      WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
          var found = toRespond.indexOf(outerIndex);
          if (found !== -1) {
            toRespond.splice(found, 1);
          }
        }
      };
      WithLatestFromSubscriber2.prototype.notifyComplete = function() {
      };
      WithLatestFromSubscriber2.prototype._next = function(value) {
        if (this.toRespond.length === 0) {
          var args = [value].concat(this.values);
          if (this.project) {
            this._tryProject(args);
          } else {
            this.destination.next(args);
          }
        }
      };
      WithLatestFromSubscriber2.prototype._tryProject = function(args) {
        var result;
        try {
          result = this.project.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return WithLatestFromSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/zip.js
function zip2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip.apply(void 0, [source].concat(observables)));
  };
}
var init_zip2 = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/zip.js"() {
    init_zip();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/zipAll.js
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
var init_zipAll = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/internal/operators/zipAll.js"() {
    init_zip();
  }
});

// node_modules/walletlink/node_modules/rxjs/_esm5/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  audit: () => audit,
  auditTime: () => auditTime,
  buffer: () => buffer,
  bufferCount: () => bufferCount,
  bufferTime: () => bufferTime,
  bufferToggle: () => bufferToggle,
  bufferWhen: () => bufferWhen,
  catchError: () => catchError,
  combineAll: () => combineAll,
  combineLatest: () => combineLatest2,
  concat: () => concat3,
  concatAll: () => concatAll,
  concatMap: () => concatMap,
  concatMapTo: () => concatMapTo,
  count: () => count,
  debounce: () => debounce,
  debounceTime: () => debounceTime,
  defaultIfEmpty: () => defaultIfEmpty,
  delay: () => delay,
  delayWhen: () => delayWhen,
  dematerialize: () => dematerialize,
  distinct: () => distinct,
  distinctUntilChanged: () => distinctUntilChanged,
  distinctUntilKeyChanged: () => distinctUntilKeyChanged,
  elementAt: () => elementAt,
  endWith: () => endWith,
  every: () => every,
  exhaust: () => exhaust,
  exhaustMap: () => exhaustMap,
  expand: () => expand,
  filter: () => filter,
  finalize: () => finalize,
  find: () => find,
  findIndex: () => findIndex,
  first: () => first,
  flatMap: () => flatMap,
  groupBy: () => groupBy,
  ignoreElements: () => ignoreElements,
  isEmpty: () => isEmpty,
  last: () => last,
  map: () => map,
  mapTo: () => mapTo,
  materialize: () => materialize,
  max: () => max,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeMap: () => mergeMap,
  mergeMapTo: () => mergeMapTo,
  mergeScan: () => mergeScan,
  min: () => min,
  multicast: () => multicast,
  observeOn: () => observeOn,
  onErrorResumeNext: () => onErrorResumeNext2,
  pairwise: () => pairwise,
  partition: () => partition2,
  pluck: () => pluck,
  publish: () => publish,
  publishBehavior: () => publishBehavior,
  publishLast: () => publishLast,
  publishReplay: () => publishReplay,
  race: () => race2,
  reduce: () => reduce,
  refCount: () => refCount,
  repeat: () => repeat,
  repeatWhen: () => repeatWhen,
  retry: () => retry,
  retryWhen: () => retryWhen,
  sample: () => sample,
  sampleTime: () => sampleTime,
  scan: () => scan,
  sequenceEqual: () => sequenceEqual,
  share: () => share,
  shareReplay: () => shareReplay,
  single: () => single,
  skip: () => skip,
  skipLast: () => skipLast,
  skipUntil: () => skipUntil,
  skipWhile: () => skipWhile,
  startWith: () => startWith,
  subscribeOn: () => subscribeOn,
  switchAll: () => switchAll,
  switchMap: () => switchMap,
  switchMapTo: () => switchMapTo,
  take: () => take,
  takeLast: () => takeLast,
  takeUntil: () => takeUntil,
  takeWhile: () => takeWhile,
  tap: () => tap,
  throttle: () => throttle,
  throttleTime: () => throttleTime,
  throwIfEmpty: () => throwIfEmpty,
  timeInterval: () => timeInterval,
  timeout: () => timeout,
  timeoutWith: () => timeoutWith,
  timestamp: () => timestamp,
  toArray: () => toArray2,
  window: () => window2,
  windowCount: () => windowCount,
  windowTime: () => windowTime,
  windowToggle: () => windowToggle,
  windowWhen: () => windowWhen,
  withLatestFrom: () => withLatestFrom,
  zip: () => zip2,
  zipAll: () => zipAll
});
var init_operators = __esm({
  "node_modules/walletlink/node_modules/rxjs/_esm5/operators/index.js"() {
    init_audit();
    init_auditTime();
    init_buffer2();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatest2();
    init_concat2();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_merge2();
    init_mergeAll();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNext2();
    init_pairwise();
    init_partition2();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_race2();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zip2();
    init_zipAll();
  }
});

// node_modules/walletlink/dist/types.js
var require_types2 = __commonJS({
  "node_modules/walletlink/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RegExpString = exports.IntNumber = exports.BigIntString = exports.AddressString = exports.HexString = exports.OpaqueType = void 0;
    function OpaqueType() {
      return (value) => value;
    }
    exports.OpaqueType = OpaqueType;
    exports.HexString = OpaqueType();
    exports.AddressString = OpaqueType();
    exports.BigIntString = OpaqueType();
    function IntNumber(num) {
      return Math.floor(num);
    }
    exports.IntNumber = IntNumber;
    exports.RegExpString = OpaqueType();
  }
});

// node_modules/walletlink/dist/util.js
var require_util2 = __commonJS({
  "node_modules/walletlink/dist/util.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFavicon = exports.range = exports.isBigNumber = exports.ensureParsedJSONObject = exports.ensureBN = exports.ensureRegExpString = exports.ensureIntNumber = exports.ensureBuffer = exports.ensureAddressString = exports.ensureEvenLengthHexString = exports.ensureHexString = exports.isHexString = exports.prepend0x = exports.strip0x = exports.has0xPrefix = exports.hexStringFromIntNumber = exports.intNumberFromHexString = exports.bigIntStringFromBN = exports.hexStringFromBuffer = exports.hexStringToUint8Array = exports.uint8ArrayToHex = exports.randomBytesHex = void 0;
    var bn_js_1 = __importDefault(require_bn5());
    var types_1 = require_types2();
    var INT_STRING_REGEX = /^[0-9]*$/;
    var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
    function randomBytesHex(length) {
      return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
    }
    exports.randomBytesHex = randomBytesHex;
    function uint8ArrayToHex(value) {
      return [...value].map((b4) => b4.toString(16).padStart(2, "0")).join("");
    }
    exports.uint8ArrayToHex = uint8ArrayToHex;
    function hexStringToUint8Array(hexString) {
      return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    }
    exports.hexStringToUint8Array = hexStringToUint8Array;
    function hexStringFromBuffer(buf, includePrefix = false) {
      const hex = buf.toString("hex");
      return (0, types_1.HexString)(includePrefix ? "0x" + hex : hex);
    }
    exports.hexStringFromBuffer = hexStringFromBuffer;
    function bigIntStringFromBN(bn) {
      return (0, types_1.BigIntString)(bn.toString(10));
    }
    exports.bigIntStringFromBN = bigIntStringFromBN;
    function intNumberFromHexString(hex) {
      return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
    }
    exports.intNumberFromHexString = intNumberFromHexString;
    function hexStringFromIntNumber(num) {
      return (0, types_1.HexString)("0x" + new bn_js_1.default(num).toString(16));
    }
    exports.hexStringFromIntNumber = hexStringFromIntNumber;
    function has0xPrefix(str) {
      return str.startsWith("0x") || str.startsWith("0X");
    }
    exports.has0xPrefix = has0xPrefix;
    function strip0x(hex) {
      if (has0xPrefix(hex)) {
        return hex.slice(2);
      }
      return hex;
    }
    exports.strip0x = strip0x;
    function prepend0x(hex) {
      if (has0xPrefix(hex)) {
        return "0x" + hex.slice(2);
      }
      return "0x" + hex;
    }
    exports.prepend0x = prepend0x;
    function isHexString5(hex) {
      if (typeof hex !== "string") {
        return false;
      }
      const s6 = strip0x(hex).toLowerCase();
      return HEXADECIMAL_STRING_REGEX.test(s6);
    }
    exports.isHexString = isHexString5;
    function ensureHexString(hex, includePrefix = false) {
      if (typeof hex === "string") {
        const s6 = strip0x(hex).toLowerCase();
        if (HEXADECIMAL_STRING_REGEX.test(s6)) {
          return (0, types_1.HexString)(includePrefix ? "0x" + s6 : s6);
        }
      }
      throw new Error(`"${String(hex)}" is not a hexadecimal string`);
    }
    exports.ensureHexString = ensureHexString;
    function ensureEvenLengthHexString(hex, includePrefix = false) {
      let h5 = ensureHexString(hex, false);
      if (h5.length % 2 === 1) {
        h5 = (0, types_1.HexString)("0" + h5);
      }
      return includePrefix ? (0, types_1.HexString)("0x" + h5) : h5;
    }
    exports.ensureEvenLengthHexString = ensureEvenLengthHexString;
    function ensureAddressString(str) {
      if (typeof str === "string") {
        const s6 = strip0x(str).toLowerCase();
        if (isHexString5(s6) && s6.length === 40) {
          return (0, types_1.AddressString)(prepend0x(s6));
        }
      }
      throw new Error(`Invalid Ethereum address: ${String(str)}`);
    }
    exports.ensureAddressString = ensureAddressString;
    function ensureBuffer(str) {
      if (Buffer.isBuffer(str)) {
        return str;
      }
      if (typeof str === "string") {
        if (isHexString5(str)) {
          const s6 = ensureEvenLengthHexString(str, false);
          return Buffer.from(s6, "hex");
        } else {
          return Buffer.from(str, "utf8");
        }
      }
      throw new Error(`Not binary data: ${String(str)}`);
    }
    exports.ensureBuffer = ensureBuffer;
    function ensureIntNumber(num) {
      if (typeof num === "number" && Number.isInteger(num)) {
        return (0, types_1.IntNumber)(num);
      }
      if (typeof num === "string") {
        if (INT_STRING_REGEX.test(num)) {
          return (0, types_1.IntNumber)(Number(num));
        }
        if (isHexString5(num)) {
          return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
        }
      }
      throw new Error(`Not an integer: ${String(num)}`);
    }
    exports.ensureIntNumber = ensureIntNumber;
    function ensureRegExpString(regExp) {
      if (regExp instanceof RegExp) {
        return (0, types_1.RegExpString)(regExp.toString());
      }
      throw new Error(`Not a RegExp: ${String(regExp)}`);
    }
    exports.ensureRegExpString = ensureRegExpString;
    function ensureBN(val) {
      if (val !== null && (bn_js_1.default.isBN(val) || isBigNumber(val))) {
        return new bn_js_1.default(val.toString(10), 10);
      }
      if (typeof val === "number") {
        return new bn_js_1.default(ensureIntNumber(val));
      }
      if (typeof val === "string") {
        if (INT_STRING_REGEX.test(val)) {
          return new bn_js_1.default(val, 10);
        }
        if (isHexString5(val)) {
          return new bn_js_1.default(ensureEvenLengthHexString(val, false), 16);
        }
      }
      throw new Error(`Not an integer: ${String(val)}`);
    }
    exports.ensureBN = ensureBN;
    function ensureParsedJSONObject(val) {
      if (typeof val === "string") {
        return JSON.parse(val);
      }
      if (typeof val === "object") {
        return val;
      }
      throw new Error(`Not a JSON string or an object: ${String(val)}`);
    }
    exports.ensureParsedJSONObject = ensureParsedJSONObject;
    function isBigNumber(val) {
      if (val == null || typeof val.constructor !== "function") {
        return false;
      }
      const { constructor } = val;
      return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
    }
    exports.isBigNumber = isBigNumber;
    function range2(start, stop) {
      return Array.from({ length: stop - start }, (_10, i5) => start + i5);
    }
    exports.range = range2;
    function getFavicon() {
      const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
      const { protocol, host } = document.location;
      const href = el ? el.getAttribute("href") : null;
      if (!href || href.startsWith("javascript:")) {
        return null;
      }
      if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
        return href;
      }
      if (href.startsWith("//")) {
        return protocol + href;
      }
      return `${protocol}//${host}${href}`;
    }
    exports.getFavicon = getFavicon;
  }
});

// node_modules/walletlink/dist/relay/Session.js
var require_Session = __commonJS({
  "node_modules/walletlink/dist/relay/Session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var js_sha256_1 = require_sha256();
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var util_1 = require_util2();
    var STORAGE_KEY_SESSION_ID = "session:id";
    var STORAGE_KEY_SESSION_SECRET = "session:secret";
    var STORAGE_KEY_SESSION_LINKED = "session:linked";
    var Session = class {
      constructor(storage, id2, secret, linked) {
        this._storage = storage;
        this._id = id2 || (0, util_1.randomBytesHex)(16);
        this._secret = secret || (0, util_1.randomBytesHex)(32);
        const hash4 = js_sha256_1.sha256.create();
        hash4.update(`${this._id}, ${this._secret} WalletLink`);
        this._key = hash4.hex();
        this._linked = !!linked;
      }
      static load(storage) {
        const id2 = storage.getItem(STORAGE_KEY_SESSION_ID);
        const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
        const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
        if (id2 && secret) {
          return new Session(storage, id2, secret, linked === "1");
        }
        return null;
      }
      static get persistedSessionIdChange$() {
        return (0, rxjs_1.fromEvent)(window, "storage").pipe((0, operators_1.filter)((evt) => evt.key === STORAGE_KEY_SESSION_ID), (0, operators_1.map)((evt) => ({
          oldValue: evt.oldValue || null,
          newValue: evt.newValue || null
        })));
      }
      static hash(sessionId) {
        const hash4 = js_sha256_1.sha256.create();
        return hash4.update(sessionId).hex();
      }
      get id() {
        return this._id;
      }
      get secret() {
        return this._secret;
      }
      get key() {
        return this._key;
      }
      get linked() {
        return this._linked;
      }
      set linked(val) {
        this._linked = val;
        this.persistLinked();
      }
      save() {
        this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
        this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
        this.persistLinked();
        return this;
      }
      persistLinked() {
        this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
      }
    };
    exports.Session = Session;
  }
});

// node_modules/walletlink/dist/relay/WalletLinkRelayAbstract.js
var require_WalletLinkRelayAbstract = __commonJS({
  "node_modules/walletlink/dist/relay/WalletLinkRelayAbstract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkRelayAbstract = exports.APP_VERSION_KEY = exports.LOCAL_STORAGE_ADDRESSES_KEY = exports.WALLET_USER_NAME_KEY = void 0;
    var eth_rpc_errors_1 = require_dist9();
    exports.WALLET_USER_NAME_KEY = "walletUsername";
    exports.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
    exports.APP_VERSION_KEY = "AppVersion";
    var WalletLinkRelayAbstract = class {
      async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
        if (!jsonRpcUrl)
          throw new Error("Error: No jsonRpcUrl provided");
        return window.fetch(jsonRpcUrl, {
          method: "POST",
          body: JSON.stringify(request),
          mode: "cors",
          headers: { "Content-Type": "application/json" }
        }).then((res) => res.json()).then((json) => {
          if (!json) {
            throw eth_rpc_errors_1.ethErrors.rpc.parse({});
          }
          const response = json;
          const { error } = response;
          if (error) {
            throw (0, eth_rpc_errors_1.serializeError)(error);
          }
          return response;
        });
      }
    };
    exports.WalletLinkRelayAbstract = WalletLinkRelayAbstract;
  }
});

// node_modules/walletlink/dist/vendor-js/eth-eip712-util/util.js
var require_util3 = __commonJS({
  "node_modules/walletlink/dist/vendor-js/eth-eip712-util/util.js"(exports, module) {
    var createKeccakHash = require_js2();
    var BN6 = require_bn5();
    function zeros2(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    }
    function setLength(msg, length, right) {
      const buf = zeros2(length);
      msg = toBuffer2(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer2(v8) {
      if (!Buffer.isBuffer(v8)) {
        if (Array.isArray(v8)) {
          v8 = Buffer.from(v8);
        } else if (typeof v8 === "string") {
          if (isHexString5(v8)) {
            v8 = Buffer.from(padToEven(stripHexPrefix2(v8)), "hex");
          } else {
            v8 = Buffer.from(v8);
          }
        } else if (typeof v8 === "number") {
          v8 = intToBuffer(v8);
        } else if (v8 === null || v8 === void 0) {
          v8 = Buffer.allocUnsafe(0);
        } else if (BN6.isBN(v8)) {
          v8 = v8.toArrayLike(Buffer);
        } else if (v8.toArray) {
          v8 = Buffer.from(v8.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v8;
    }
    function bufferToHex2(buf) {
      buf = toBuffer2(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a5, bits) {
      a5 = toBuffer2(a5);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a5).digest();
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString5(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix2(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros: zeros2,
      setLength,
      setLengthRight,
      isHexString: isHexString5,
      stripHexPrefix: stripHexPrefix2,
      toBuffer: toBuffer2,
      bufferToHex: bufferToHex2,
      keccak
    };
  }
});

// node_modules/walletlink/dist/vendor-js/eth-eip712-util/abi.js
var require_abi = __commonJS({
  "node_modules/walletlink/dist/vendor-js/eth-eip712-util/abi.js"(exports, module) {
    var util = require_util3();
    var BN6 = require_bn5();
    function elementaryName(name2) {
      if (name2.startsWith("int[")) {
        return "int256" + name2.slice(3);
      } else if (name2 === "int") {
        return "int256";
      } else if (name2.startsWith("uint[")) {
        return "uint256" + name2.slice(4);
      } else if (name2 === "uint") {
        return "uint256";
      } else if (name2.startsWith("fixed[")) {
        return "fixed128x128" + name2.slice(5);
      } else if (name2 === "fixed") {
        return "fixed128x128";
      } else if (name2.startsWith("ufixed[")) {
        return "ufixed128x128" + name2.slice(6);
      } else if (name2 === "ufixed") {
        return "ufixed128x128";
      }
      return name2;
    }
    function parseTypeN(type2) {
      return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
    }
    function parseTypeNxM(type2) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type2) {
      var tmp = type2.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type2 = typeof arg;
      if (type2 === "string") {
        if (util.isHexString(arg)) {
          return new BN6(util.stripHexPrefix(arg), 16);
        } else {
          return new BN6(arg, 10);
        }
      } else if (type2 === "number") {
        return new BN6(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type2, arg) {
      var size, num, ret, i5;
      if (type2 === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type2 === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type2 === "string") {
        return encodeSingle("bytes", new Buffer(arg, "utf8"));
      } else if (isArray2(type2)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type2);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type2 = type2.slice(0, type2.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i5 in arg) {
          ret.push(encodeSingle(type2, arg[i5]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type2 === "bytes") {
        arg = new Buffer(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return util.setLengthRight(arg, 32);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type2.startsWith("ufixed")) {
        size = parseTypeNxM(type2);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN6(2).pow(new BN6(size[1]))));
      } else if (type2.startsWith("fixed")) {
        size = parseTypeNxM(type2);
        return encodeSingle("int256", parseNumber(arg).mul(new BN6(2).pow(new BN6(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type2);
    }
    function isDynamic(type2) {
      return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
    }
    function isArray2(type2) {
      return type2.lastIndexOf("]") === type2.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data = [];
      var headLength = 32 * types.length;
      for (var i5 in types) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        var cur = encodeSingle(type2, value);
        if (isDynamic(type2)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size, num;
      var ret = [];
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        if (type2 === "bytes") {
          ret.push(value);
        } else if (type2 === "string") {
          ret.push(new Buffer(value, "utf8"));
        } else if (type2 === "bool") {
          ret.push(new Buffer(value ? "01" : "00", "hex"));
        } else if (type2 === "address") {
          ret.push(util.setLength(value, 20));
        } else if (type2.startsWith("bytes")) {
          size = parseTypeN(type2);
          if (size < 1 || size > 32) {
            throw new Error("Invalid bytes<N> width: " + size);
          }
          ret.push(util.setLengthRight(value, size));
        } else if (type2.startsWith("uint")) {
          size = parseTypeN(type2);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid uint<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toArrayLike(Buffer, "be", size / 8));
        } else if (type2.startsWith("int")) {
          size = parseTypeN(type2);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid int<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toTwos(size).toArrayLike(Buffer, "be", size / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return Buffer.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util.keccak(solidityPack(types, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/walletlink/dist/vendor-js/eth-eip712-util/index.js
var require_eth_eip712_util = __commonJS({
  "node_modules/walletlink/dist/vendor-js/eth-eip712-util/index.js"(exports, module) {
    var util = require_util3();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name2, type2, value) => {
            if (types[type2] !== void 0) {
              return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type2, value, types, useV4))];
            }
            if (value === void 0)
              throw new Error(`missing value for field ${name2} of type ${type2}`);
            if (type2 === "bytes") {
              return ["bytes32", util.keccak(value)];
            }
            if (type2 === "string") {
              if (typeof value === "string") {
                value = Buffer.from(value, "utf8");
              }
              return ["bytes32", util.keccak(value)];
            }
            if (type2.lastIndexOf("]") === type2.length - 1) {
              const parsedType = type2.slice(0, type2.lastIndexOf("["));
              const typeValuePairs = value.map((item) => encodeField(name2, parsedType, item));
              return ["bytes32", util.keccak(abi.rawEncode(typeValuePairs.map(([type3]) => type3), typeValuePairs.map(([, value2]) => value2)))];
            }
            return [type2, value];
          };
          for (const field of types[primaryType]) {
            const [type2, value] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type2);
            encodedValues.push(value);
          }
        } else {
          for (const field of types[primaryType]) {
            let value = data[field.name];
            if (value !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value === "string") {
                  value = Buffer.from(value, "utf8");
                }
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value = util.keccak(this.encodeData(field.type, value, types, useV4));
                encodedValues.push(value);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type2 of deps) {
          const children = types[type2];
          if (!children) {
            throw new Error("No type definition specified: " + type2);
          }
          result += type2 + "(" + types[type2].map(({ name: name2, type: type3 }) => type3 + " " + name2).join(",") + ")";
        }
        return result;
      },
      findTypeDependencies(primaryType, types, results2 = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results2.includes(primaryType) || types[primaryType] === void 0) {
          return results2;
        }
        results2.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results2)) {
            !results2.includes(dep) && results2.push(dep);
          }
        }
        return results2;
      },
      hashStruct(primaryType, data, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types, useV4));
      },
      hashType(primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types));
      },
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key2 in TYPED_MESSAGE_SCHEMA.properties) {
          data[key2] && (sanitizedData[key2] = data[key2]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer.from("1901", "hex")];
        parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer.concat(parts));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error;
      const data = typedData.map(function(e5) {
        return e5.type === "bytes" ? util.toBuffer(e5.value) : e5.value;
      });
      const types = typedData.map(function(e5) {
        return e5.type;
      });
      const schema = typedData.map(function(e5) {
        if (!e5.name)
          throw error;
        return e5.type + " " + e5.name;
      });
      return abi.soliditySHA3(["bytes32", "bytes32"], [
        abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
        abi.soliditySHA3(types, data)
      ]);
    }
  }
});

// node_modules/walletlink/dist/provider/FilterPolyfill.js
var require_FilterPolyfill = __commonJS({
  "node_modules/walletlink/dist/provider/FilterPolyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterFromParam = exports.FilterPolyfill = void 0;
    var types_1 = require_types2();
    var util_1 = require_util2();
    var TIMEOUT = 5 * 60 * 1e3;
    var JSONRPC_TEMPLATE = {
      jsonrpc: "2.0",
      id: 0
    };
    var FilterPolyfill = class {
      constructor(provider) {
        this.logFilters = new Map();
        this.blockFilters = new Set();
        this.pendingTransactionFilters = new Set();
        this.cursors = new Map();
        this.timeouts = new Map();
        this.nextFilterId = (0, types_1.IntNumber)(1);
        this.provider = provider;
      }
      async newFilter(param) {
        const filter2 = filterFromParam(param);
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, filter2.fromBlock);
        console.log(`Installing new log filter(${id2}):`, filter2, "initial cursor position:", cursor);
        this.logFilters.set(id2, filter2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      async newBlockFilter() {
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, "latest");
        console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
        this.blockFilters.add(id2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      async newPendingTransactionFilter() {
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, "latest");
        console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
        this.pendingTransactionFilters.add(id2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      uninstallFilter(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        console.log(`Uninstalling filter (${id2})`);
        this.deleteFilter(id2);
        return true;
      }
      getFilterChanges(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        if (this.timeouts.has(id2)) {
          this.setFilterTimeout(id2);
        }
        if (this.logFilters.has(id2)) {
          return this.getLogFilterChanges(id2);
        } else if (this.blockFilters.has(id2)) {
          return this.getBlockFilterChanges(id2);
        } else if (this.pendingTransactionFilters.has(id2)) {
          return this.getPendingTransactionFilterChanges(id2);
        }
        return Promise.resolve(filterNotFoundError());
      }
      async getFilterLogs(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        const filter2 = this.logFilters.get(id2);
        if (!filter2) {
          return filterNotFoundError();
        }
        return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter2)] }));
      }
      makeFilterId() {
        return (0, types_1.IntNumber)(++this.nextFilterId);
      }
      sendAsyncPromise(request) {
        return new Promise((resolve, reject) => {
          this.provider.sendAsync(request, (err, response) => {
            if (err) {
              return reject(err);
            }
            if (Array.isArray(response) || response == null) {
              return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
            }
            resolve(response);
          });
        });
      }
      deleteFilter(id2) {
        console.log(`Deleting filter (${id2})`);
        this.logFilters.delete(id2);
        this.blockFilters.delete(id2);
        this.pendingTransactionFilters.delete(id2);
        this.cursors.delete(id2);
        this.timeouts.delete(id2);
      }
      async getLogFilterChanges(id2) {
        const filter2 = this.logFilters.get(id2);
        const cursorPosition = this.cursors.get(id2);
        if (!cursorPosition || !filter2) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        if (cursorPosition > filter2.toBlock) {
          return emptyResult();
        }
        console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id2}`);
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
          paramFromFilter(Object.assign(Object.assign({}, filter2), { fromBlock: cursorPosition, toBlock }))
        ] }));
        if (Array.isArray(response.result)) {
          const blocks = response.result.map((log) => (0, util_1.intNumberFromHexString)(log.blockNumber || "0x0"));
          const highestBlock = Math.max(...blocks);
          if (highestBlock && highestBlock > cursorPosition) {
            const newCursorPosition = (0, types_1.IntNumber)(highestBlock + 1);
            console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
            this.cursors.set(id2, newCursorPosition);
          }
        }
        return response;
      }
      async getBlockFilterChanges(id2) {
        const cursorPosition = this.cursors.get(id2);
        if (!cursorPosition) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id2})`);
        const blocks = (await Promise.all((0, util_1.range)(cursorPosition, currentBlockHeight + 1).map((i5) => this.getBlockHashByNumber((0, types_1.IntNumber)(i5))))).filter((hash4) => !!hash4);
        const newCursorPosition = (0, types_1.IntNumber)(cursorPosition + blocks.length);
        console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id2, newCursorPosition);
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks });
      }
      async getPendingTransactionFilterChanges(_id) {
        return Promise.resolve(emptyResult());
      }
      async setInitialCursorPosition(id2, startBlock) {
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
        this.cursors.set(id2, initialCursorPosition);
        return initialCursorPosition;
      }
      setFilterTimeout(id2) {
        const existing = this.timeouts.get(id2);
        if (existing) {
          window.clearTimeout(existing);
        }
        const timeout2 = window.setTimeout(() => {
          console.log(`Filter (${id2}) timed out`);
          this.deleteFilter(id2);
        }, TIMEOUT);
        this.timeouts.set(id2, timeout2);
      }
      async getCurrentBlockHeight() {
        const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
        return (0, util_1.intNumberFromHexString)((0, util_1.ensureHexString)(result));
      }
      async getBlockHashByNumber(blockNumber) {
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1.hexStringFromIntNumber)(blockNumber), false] }));
        if (response.result && typeof response.result.hash === "string") {
          return (0, util_1.ensureHexString)(response.result.hash);
        }
        return null;
      }
    };
    exports.FilterPolyfill = FilterPolyfill;
    function filterFromParam(param) {
      return {
        fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
        toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
        addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
        topics: param.topics || []
      };
    }
    exports.filterFromParam = filterFromParam;
    function paramFromFilter(filter2) {
      const param = {
        fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
        toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
        topics: filter2.topics
      };
      if (filter2.addresses !== null) {
        param.address = filter2.addresses;
      }
      return param;
    }
    function intBlockHeightFromHexBlockHeight(value) {
      if (value === void 0 || value === "latest" || value === "pending") {
        return "latest";
      } else if (value === "earliest") {
        return (0, types_1.IntNumber)(0);
      } else if ((0, util_1.isHexString)(value)) {
        return (0, util_1.intNumberFromHexString)(value);
      }
      throw new Error(`Invalid block option: ${String(value)}`);
    }
    function hexBlockHeightFromIntBlockHeight(value) {
      if (value === "latest") {
        return value;
      }
      return (0, util_1.hexStringFromIntNumber)(value);
    }
    function filterNotFoundError() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
    }
    function emptyResult() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
    }
  }
});

// node_modules/walletlink/dist/provider/JSONRPC.js
var require_JSONRPC = __commonJS({
  "node_modules/walletlink/dist/provider/JSONRPC.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONRPCMethod = void 0;
    var JSONRPCMethod;
    (function(JSONRPCMethod2) {
      JSONRPCMethod2["eth_accounts"] = "eth_accounts";
      JSONRPCMethod2["eth_coinbase"] = "eth_coinbase";
      JSONRPCMethod2["net_version"] = "net_version";
      JSONRPCMethod2["eth_chainId"] = "eth_chainId";
      JSONRPCMethod2["eth_uninstallFilter"] = "eth_uninstallFilter";
      JSONRPCMethod2["eth_requestAccounts"] = "eth_requestAccounts";
      JSONRPCMethod2["eth_sign"] = "eth_sign";
      JSONRPCMethod2["eth_ecRecover"] = "eth_ecRecover";
      JSONRPCMethod2["personal_sign"] = "personal_sign";
      JSONRPCMethod2["personal_ecRecover"] = "personal_ecRecover";
      JSONRPCMethod2["eth_signTransaction"] = "eth_signTransaction";
      JSONRPCMethod2["eth_sendRawTransaction"] = "eth_sendRawTransaction";
      JSONRPCMethod2["eth_sendTransaction"] = "eth_sendTransaction";
      JSONRPCMethod2["eth_signTypedData_v1"] = "eth_signTypedData_v1";
      JSONRPCMethod2["eth_signTypedData_v2"] = "eth_signTypedData_v2";
      JSONRPCMethod2["eth_signTypedData_v3"] = "eth_signTypedData_v3";
      JSONRPCMethod2["eth_signTypedData_v4"] = "eth_signTypedData_v4";
      JSONRPCMethod2["eth_signTypedData"] = "eth_signTypedData";
      JSONRPCMethod2["walletlink_arbitrary"] = "walletlink_arbitrary";
      JSONRPCMethod2["wallet_addEthereumChain"] = "wallet_addEthereumChain";
      JSONRPCMethod2["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
      JSONRPCMethod2["eth_subscribe"] = "eth_subscribe";
      JSONRPCMethod2["eth_unsubscribe"] = "eth_unsubscribe";
      JSONRPCMethod2["eth_newFilter"] = "eth_newFilter";
      JSONRPCMethod2["eth_newBlockFilter"] = "eth_newBlockFilter";
      JSONRPCMethod2["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
      JSONRPCMethod2["eth_getFilterChanges"] = "eth_getFilterChanges";
      JSONRPCMethod2["eth_getFilterLogs"] = "eth_getFilterLogs";
    })(JSONRPCMethod = exports.JSONRPCMethod || (exports.JSONRPCMethod = {}));
  }
});

// node_modules/walletlink/dist/provider/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/walletlink/dist/provider/SubscriptionManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionManager = void 0;
    var PollingBlockTracker = require_polling();
    var createSubscriptionManager = require_subscriptionManager();
    var noop2 = () => {
    };
    var SubscriptionManager = class {
      constructor(provider) {
        const blockTracker = new PollingBlockTracker({
          provider,
          pollingInterval: 15 * 1e3,
          setSkipCacheFlag: true
        });
        const { events, middleware } = createSubscriptionManager({
          blockTracker,
          provider
        });
        this.events = events;
        this.subscriptionMiddleware = middleware;
      }
      async handleRequest(request) {
        const result = {};
        await this.subscriptionMiddleware(request, result, noop2, noop2);
        return result;
      }
      destroy() {
        this.subscriptionMiddleware.destroy();
      }
    };
    exports.SubscriptionManager = SubscriptionManager;
  }
});

// node_modules/walletlink/dist/provider/WalletLinkProvider.js
var require_WalletLinkProvider = __commonJS({
  "node_modules/walletlink/dist/provider/WalletLinkProvider.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkProvider = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter2());
    var bn_js_1 = __importDefault(require_bn5());
    var eth_rpc_errors_1 = require_dist9();
    var WalletLinkAnalytics_1 = require_WalletLinkAnalytics();
    var EthereumChain_1 = require_EthereumChain();
    var init_1 = require_init();
    var Session_1 = require_Session();
    var WalletLinkRelayAbstract_1 = require_WalletLinkRelayAbstract();
    var util_1 = require_util2();
    var eth_eip712_util_1 = __importDefault(require_eth_eip712_util());
    var FilterPolyfill_1 = require_FilterPolyfill();
    var JSONRPC_1 = require_JSONRPC();
    var SubscriptionManager_1 = require_SubscriptionManager();
    var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
    var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
    var HAS_CHAIN_BEEN_SWITCHED_KEY = "HasChainBeenSwitched";
    var HAS_CHAIN_OVERRIDDEN_FROM_RELAY = "HasChainOverriddenFromRelay";
    var WalletLinkProvider = class extends safe_event_emitter_1.default {
      constructor(options) {
        var _a2;
        super();
        this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
        this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
        this._relay = null;
        this._addresses = [];
        this.hasMadeFirstChainChangedEmission = false;
        this._send = this.send.bind(this);
        this._sendAsync = this.sendAsync.bind(this);
        this.setProviderInfo = this.setProviderInfo.bind(this);
        this.updateProviderInfo = this.updateProviderInfo.bind(this);
        this.getChainId = this.getChainId.bind(this);
        this.setAppInfo = this.setAppInfo.bind(this);
        this.enable = this.enable.bind(this);
        this.close = this.close.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.request = this.request.bind(this);
        this._setAddresses = this._setAddresses.bind(this);
        this.scanQRCode = this.scanQRCode.bind(this);
        this.genericRequest = this.genericRequest.bind(this);
        this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
        this._overrideIsMetaMask = options.overrideIsMetaMask;
        this._relayProvider = options.relayProvider;
        this._storage = options.storage;
        this._relayEventManager = options.relayEventManager;
        this._walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1.WalletLinkAnalytics();
        this.isCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
        const chainId = this.getChainId();
        const chainIdStr = (0, util_1.prepend0x)(chainId.toString(16));
        this.emit("connect", { chainIdStr });
        const cachedAddresses = this._storage.getItem(WalletLinkRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
        if (cachedAddresses) {
          const addresses = cachedAddresses.split(" ");
          if (addresses[0] !== "") {
            this._addresses = addresses;
            this.emit("accountsChanged", addresses);
          }
        }
        this._subscriptionManager.events.on("notification", (notification) => {
          this.emit("message", {
            type: notification.method,
            data: notification.params
          });
        });
        if (this._addresses.length > 0) {
          void this.initializeRelay();
        }
        window.addEventListener("message", (event) => {
          var _a3;
          if (event.data.type !== "walletLinkMessage")
            return;
          if (event.data.data.action === "defaultChainChanged") {
            const _chainId = event.data.data.chainId;
            const jsonRpcUrl = (_a3 = event.data.data.jsonRpcUrl) !== null && _a3 !== void 0 ? _a3 : this.jsonRpcUrl;
            this.updateProviderInfo(jsonRpcUrl, Number(_chainId), true);
          }
        });
      }
      get selectedAddress() {
        return this._addresses[0] || void 0;
      }
      get networkVersion() {
        return this.getChainId().toString(10);
      }
      get chainId() {
        return (0, util_1.prepend0x)(this.getChainId().toString(16));
      }
      get isWalletLink() {
        return true;
      }
      get isMetaMask() {
        return this._overrideIsMetaMask;
      }
      get host() {
        return this.jsonRpcUrl;
      }
      get connected() {
        return true;
      }
      isConnected() {
        return true;
      }
      get jsonRpcUrl() {
        var _a2;
        return (_a2 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a2 !== void 0 ? _a2 : this._jsonRpcUrlFromOpts;
      }
      set jsonRpcUrl(value) {
        this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
      }
      get isChainOverridden() {
        return this._storage.getItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY) === "true";
      }
      set isChainOverridden(value) {
        this._storage.setItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY, value.toString());
      }
      setProviderInfo(jsonRpcUrl, chainId) {
        if (this.isChainOverridden)
          return;
        this.updateProviderInfo(jsonRpcUrl, this.getChainId(), false);
      }
      updateProviderInfo(jsonRpcUrl, chainId, fromRelay) {
        const hasChainSwitched = this._storage.getItem(HAS_CHAIN_BEEN_SWITCHED_KEY) === "true";
        if (hasChainSwitched && fromRelay)
          return;
        if (fromRelay) {
          this.isChainOverridden = true;
        }
        this.jsonRpcUrl = jsonRpcUrl;
        const originalChainId = this.getChainId();
        this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
        const chainChanged = (0, util_1.ensureIntNumber)(chainId) !== originalChainId;
        if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
          this.emit("chainChanged", this.getChainId());
          this.hasMadeFirstChainChangedEmission = true;
        }
      }
      async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
        var _a2, _b;
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return false;
        }
        const relay = await this.initializeRelay();
        const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
        if (typeof res.result === "boolean") {
          if (res.result === true) {
            this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
            this.updateProviderInfo(rpcUrls[0], chainId, false);
          }
          return res.result === true;
        }
        if (((_a2 = res.result) === null || _a2 === void 0 ? void 0 : _a2.isApproved) === true) {
          this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
          this.updateProviderInfo(rpcUrls[0], chainId, false);
        }
        return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
      }
      async switchEthereumChain(chainId) {
        var _a2;
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return;
        }
        const relay = await this.initializeRelay();
        const res = await relay.switchEthereumChain(chainId.toString(10)).promise;
        if (res.errorCode) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: res.errorCode
          });
        }
        if (typeof res.result !== "boolean") {
          const switchResponse = res.result;
          if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
            this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
            this.updateProviderInfo(switchResponse.rpcUrl, chainId, false);
          }
        } else {
          if (res.result) {
            this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
            const ethereumChain = EthereumChain_1.EthereumChain.fromChainId(BigInt(chainId));
            const rpcUrl = (_a2 = EthereumChain_1.EthereumChain.rpcUrl(ethereumChain)) !== null && _a2 !== void 0 ? _a2 : "";
            this.updateProviderInfo(rpcUrl, chainId, false);
          }
        }
      }
      setAppInfo(appName, appLogoUrl) {
        void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
      }
      async enable() {
        this._walletLinkAnalytics.sendEvent(init_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : null
        });
        if (this._addresses.length > 0) {
          return this._addresses;
        }
        return await this._send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
      }
      close() {
        void this.initializeRelay().then((relay) => relay.resetAndReload());
      }
      send(requestOrMethod, callbackOrParams) {
        if (typeof requestOrMethod === "string") {
          const method = requestOrMethod;
          const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
          const request = {
            jsonrpc: "2.0",
            id: 0,
            method,
            params
          };
          return this._sendRequestAsync(request).then((res) => res.result);
        }
        if (typeof callbackOrParams === "function") {
          const request = requestOrMethod;
          const callback = callbackOrParams;
          return this._sendAsync(request, callback);
        }
        if (Array.isArray(requestOrMethod)) {
          const requests = requestOrMethod;
          return requests.map((r6) => this._sendRequest(r6));
        }
        const req = requestOrMethod;
        return this._sendRequest(req);
      }
      sendAsync(request, callback) {
        if (typeof callback !== "function") {
          throw new Error("callback is required");
        }
        if (Array.isArray(request)) {
          const arrayCb = callback;
          this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
          return;
        }
        const cb = callback;
        this._sendRequestAsync(request).then((response) => cb(null, response)).catch((err) => cb(err, null));
      }
      async request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: args
          });
        }
        const { method, params } = args;
        if (typeof method !== "string" || method.length === 0) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: args
          });
        }
        if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: args
          });
        }
        const newParams = params === void 0 ? [] : params;
        const id2 = this._relayEventManager.makeRequestId();
        const result = await this._sendRequestAsync({
          method,
          params: newParams,
          jsonrpc: "2.0",
          id: id2
        });
        return result.result;
      }
      async scanQRCode(match) {
        const relay = await this.initializeRelay();
        const res = await relay.scanQRCode((0, util_1.ensureRegExpString)(match)).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      async genericRequest(data, action) {
        const relay = await this.initializeRelay();
        const res = await relay.genericRequest(data, action).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      supportsSubscriptions() {
        return false;
      }
      subscribe() {
        throw new Error("Subscriptions are not supported");
      }
      unsubscribe() {
        throw new Error("Subscriptions are not supported");
      }
      disconnect() {
        return true;
      }
      _sendRequest(request) {
        const response = {
          jsonrpc: "2.0",
          id: request.id
        };
        const { method } = request;
        response.result = this._handleSynchronousMethods(request);
        if (response.result === void 0) {
          throw new Error(`WalletLink does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);
        }
        return response;
      }
      _setAddresses(addresses) {
        if (!Array.isArray(addresses)) {
          throw new Error("addresses is not an array");
        }
        const newAddresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
        if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
          return;
        }
        this._addresses = newAddresses;
        this.emit("accountsChanged", this._addresses);
        this._storage.setItem(WalletLinkRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
        window.dispatchEvent(new CustomEvent("walletlink:addresses", { detail: this._addresses }));
      }
      _sendRequestAsync(request) {
        return new Promise((resolve, reject) => {
          try {
            const syncResult = this._handleSynchronousMethods(request);
            if (syncResult !== void 0) {
              return resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: syncResult
              });
            }
            const filterPromise = this._handleAsynchronousFilterMethods(request);
            if (filterPromise !== void 0) {
              filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
              return;
            }
            const subscriptionPromise = this._handleSubscriptionMethods(request);
            if (subscriptionPromise !== void 0) {
              subscriptionPromise.then((res) => resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: res.result
              })).catch((err) => reject(err));
              return;
            }
          } catch (err) {
            return reject(err);
          }
          this._handleAsynchronousMethods(request).then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
        });
      }
      _sendMultipleRequestsAsync(requests) {
        return Promise.all(requests.map((r6) => this._sendRequestAsync(r6)));
      }
      _handleSynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_accounts:
            return this._eth_accounts();
          case JSONRPC_1.JSONRPCMethod.eth_coinbase:
            return this._eth_coinbase();
          case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
            return this._eth_uninstallFilter(params);
          case JSONRPC_1.JSONRPCMethod.net_version:
            return this._net_version();
          case JSONRPC_1.JSONRPCMethod.eth_chainId:
            return this._eth_chainId();
          default:
            return void 0;
        }
      }
      async _handleAsynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
            return this._eth_requestAccounts();
          case JSONRPC_1.JSONRPCMethod.eth_sign:
            return this._eth_sign(params);
          case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
            return this._eth_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.personal_sign:
            return this._personal_sign(params);
          case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
            return this._personal_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
            return this._eth_signTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
            return this._eth_sendRawTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
            return this._eth_sendTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
            return this._eth_signTypedData_v1(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
            return this._throwUnsupportedMethodError();
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
            return this._eth_signTypedData_v3(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
            return this._eth_signTypedData_v4(params);
          case JSONRPC_1.JSONRPCMethod.walletlink_arbitrary:
            return this._walletlink_arbitrary(params);
          case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
            return this._wallet_addEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
            return this._wallet_switchEthereumChain(params);
        }
        const relay = await this.initializeRelay();
        return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
      }
      _handleAsynchronousFilterMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_newFilter:
            return this._eth_newFilter(params);
          case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
            return this._eth_newBlockFilter();
          case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
            return this._eth_newPendingTransactionFilter();
          case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
            return this._eth_getFilterChanges(params);
          case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
            return this._eth_getFilterLogs(params);
        }
        return void 0;
      }
      _handleSubscriptionMethods(request) {
        switch (request.method) {
          case JSONRPC_1.JSONRPCMethod.eth_subscribe:
          case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
            return this._subscriptionManager.handleRequest(request);
        }
        return void 0;
      }
      _isKnownAddress(addressString) {
        try {
          const address = (0, util_1.ensureAddressString)(addressString);
          return this._addresses.includes(address);
        } catch (_a2) {
        }
        return false;
      }
      _ensureKnownAddress(addressString) {
        if (!this._isKnownAddress(addressString)) {
          throw new Error("Unknown Ethereum address");
        }
      }
      _prepareTransactionParams(tx) {
        const fromAddress = tx.from ? (0, util_1.ensureAddressString)(tx.from) : this.selectedAddress;
        if (!fromAddress) {
          throw new Error("Ethereum address is unavailable");
        }
        this._ensureKnownAddress(fromAddress);
        const toAddress = tx.to ? (0, util_1.ensureAddressString)(tx.to) : null;
        const weiValue = tx.value != null ? (0, util_1.ensureBN)(tx.value) : new bn_js_1.default(0);
        const data = tx.data ? (0, util_1.ensureBuffer)(tx.data) : Buffer.alloc(0);
        const nonce = tx.nonce != null ? (0, util_1.ensureIntNumber)(tx.nonce) : null;
        const gasPriceInWei = tx.gasPrice != null ? (0, util_1.ensureBN)(tx.gasPrice) : null;
        const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1.ensureBN)(tx.maxFeePerGas) : null;
        const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1.ensureBN)(tx.maxPriorityFeePerGas) : null;
        const gasLimit = tx.gas != null ? (0, util_1.ensureBN)(tx.gas) : null;
        const chainId = this.getChainId();
        return {
          fromAddress,
          toAddress,
          weiValue,
          data,
          nonce,
          gasPriceInWei,
          maxFeePerGas,
          maxPriorityFeePerGas,
          gasLimit,
          chainId
        };
      }
      _requireAuthorization() {
        if (this._addresses.length === 0) {
          throw eth_rpc_errors_1.ethErrors.provider.unauthorized({});
        }
      }
      _throwUnsupportedMethodError() {
        throw eth_rpc_errors_1.ethErrors.provider.unsupportedMethod({});
      }
      async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
        this._ensureKnownAddress(address);
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied message signature");
          }
          throw err;
        }
      }
      async _ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
        const relay = await this.initializeRelay();
        const res = await relay.ethereumAddressFromSignedMessage(message, signature2, addPrefix).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      _eth_accounts() {
        return this._addresses;
      }
      _eth_coinbase() {
        return this.selectedAddress || null;
      }
      _net_version() {
        return this.getChainId().toString(10);
      }
      _eth_chainId() {
        return (0, util_1.hexStringFromIntNumber)(this.getChainId());
      }
      getChainId() {
        const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY) || "1";
        const chainId = parseInt(chainIdStr, 10);
        return (0, util_1.ensureIntNumber)(chainId);
      }
      async _eth_requestAccounts() {
        this._walletLinkAnalytics.sendEvent(init_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : null
        });
        if (this._addresses.length > 0) {
          return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
          });
        }
        let res;
        try {
          const relay = await this.initializeRelay();
          res = await relay.requestEthereumAccounts().promise;
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied account authorization");
          }
          throw err;
        }
        if (!res.result) {
          throw new Error("accounts received is empty");
        }
        this._setAddresses(res.result);
        return { jsonrpc: "2.0", id: 0, result: this._addresses };
      }
      _eth_sign(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const message = (0, util_1.ensureBuffer)(params[1]);
        return this._signEthereumMessage(message, address, false);
      }
      _eth_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature2 = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature2, false);
      }
      _personal_sign(params) {
        this._requireAuthorization();
        const message = (0, util_1.ensureBuffer)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        return this._signEthereumMessage(message, address, true);
      }
      _personal_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature2 = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature2, true);
      }
      async _eth_signTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_sendRawTransaction(params) {
        const signedTransaction = (0, util_1.ensureBuffer)(params[0]);
        const relay = await this.initializeRelay();
        const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      async _eth_sendTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_signTypedData_v1(params) {
        this._requireAuthorization();
        const typedData = (0, util_1.ensureParsedJSONObject)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v3(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v4(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _walletlink_arbitrary(params) {
        const action = params[0];
        const data = params[1];
        if (typeof data !== "string") {
          throw new Error("parameter must be a string");
        }
        if (typeof action !== "object" || action === null) {
          throw new Error("parameter must be an object");
        }
        const result = await this.genericRequest(action, data);
        return { jsonrpc: "2.0", id: 0, result };
      }
      async _wallet_addEthereumChain(params) {
        var _a2, _b, _c, _d;
        const request = params[0];
        if (((_a2 = request.rpcUrls) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `please pass in at least 1 rpcUrl` }
          };
        }
        if (!request.chainName || request.chainName.trim() === "") {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "chainName is a required field"
          });
        }
        if (!request.nativeCurrency) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "nativeCurrency is a required field"
          });
        }
        const chainIdNumber = parseInt(request.chainId, 16);
        const success = await this.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
        if (success) {
          return { jsonrpc: "2.0", id: 0, result: null };
        } else {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `unable to add ethereum chain` }
          };
        }
      }
      async _wallet_switchEthereumChain(params) {
        const request = params[0];
        await this.switchEthereumChain(parseInt(request.chainId, 16));
        return { jsonrpc: "2.0", id: 0, result: null };
      }
      _eth_uninstallFilter(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.uninstallFilter(filterId);
      }
      async _eth_newFilter(params) {
        const param = params[0];
        const filterId = await this._filterPolyfill.newFilter(param);
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newBlockFilter() {
        const filterId = await this._filterPolyfill.newBlockFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newPendingTransactionFilter() {
        const filterId = await this._filterPolyfill.newPendingTransactionFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      _eth_getFilterChanges(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterChanges(filterId);
      }
      _eth_getFilterLogs(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterLogs(filterId);
      }
      initializeRelay() {
        if (this._relay) {
          return Promise.resolve(this._relay);
        }
        return this._relayProvider().then((relay) => {
          relay.setAccountsCallback((accounts) => this._setAddresses(accounts));
          relay.setChainCallback((chainId, jsonRpcUrl) => {
            this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10), true);
          });
          this._relay = relay;
          return relay;
        });
      }
    };
    exports.WalletLinkProvider = WalletLinkProvider;
  }
});

// node_modules/walletlink/dist/lib/ScopedLocalStorage.js
var require_ScopedLocalStorage = __commonJS({
  "node_modules/walletlink/dist/lib/ScopedLocalStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopedLocalStorage = void 0;
    var ScopedLocalStorage = class {
      constructor(scope) {
        this.scope = scope;
      }
      setItem(key2, value) {
        localStorage.setItem(this.scopedKey(key2), value);
      }
      getItem(key2) {
        return localStorage.getItem(this.scopedKey(key2));
      }
      removeItem(key2) {
        localStorage.removeItem(this.scopedKey(key2));
      }
      clear() {
        const prefix = this.scopedKey("");
        const keysToRemove = [];
        for (let i5 = 0; i5 < localStorage.length; i5++) {
          const key2 = localStorage.key(i5);
          if (typeof key2 === "string" && key2.startsWith(prefix)) {
            keysToRemove.push(key2);
          }
        }
        keysToRemove.forEach((key2) => localStorage.removeItem(key2));
      }
      scopedKey(key2) {
        return `${this.scope}:${key2}`;
      }
    };
    exports.ScopedLocalStorage = ScopedLocalStorage;
  }
});

// node_modules/walletlink/node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => _,
  Fragment: () => d,
  cloneElement: () => B,
  createContext: () => D,
  createElement: () => v,
  createRef: () => p,
  h: () => v,
  hydrate: () => q,
  isValidElement: () => i,
  options: () => l,
  render: () => S,
  toChildArray: () => A
});
function a(n3, l5) {
  for (var u5 in l5)
    n3[u5] = l5[u5];
  return n3;
}
function h(n3) {
  var l5 = n3.parentNode;
  l5 && l5.removeChild(n3);
}
function v(l5, u5, i5) {
  var t5, r6, o5, f7 = {};
  for (o5 in u5)
    o5 == "key" ? t5 = u5[o5] : o5 == "ref" ? r6 = u5[o5] : f7[o5] = u5[o5];
  if (arguments.length > 2 && (f7.children = arguments.length > 3 ? n.call(arguments, 2) : i5), typeof l5 == "function" && l5.defaultProps != null)
    for (o5 in l5.defaultProps)
      f7[o5] === void 0 && (f7[o5] = l5.defaultProps[o5]);
  return y(l5, f7, t5, r6, null);
}
function y(n3, i5, t5, r6, o5) {
  var f7 = { type: n3, props: i5, key: t5, ref: r6, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: o5 == null ? ++u : o5 };
  return o5 == null && l.vnode != null && l.vnode(f7), f7;
}
function p() {
  return { current: null };
}
function d(n3) {
  return n3.children;
}
function _(n3, l5) {
  this.props = n3, this.context = l5;
}
function k(n3, l5) {
  if (l5 == null)
    return n3.__ ? k(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u5; l5 < n3.__k.length; l5++)
    if ((u5 = n3.__k[l5]) != null && u5.__e != null)
      return u5.__e;
  return typeof n3.type == "function" ? k(n3) : null;
}
function b(n3) {
  var l5, u5;
  if ((n3 = n3.__) != null && n3.__c != null) {
    for (n3.__e = n3.__c.base = null, l5 = 0; l5 < n3.__k.length; l5++)
      if ((u5 = n3.__k[l5]) != null && u5.__e != null) {
        n3.__e = n3.__c.base = u5.__e;
        break;
      }
    return b(n3);
  }
}
function m(n3) {
  (!n3.__d && (n3.__d = true) && t.push(n3) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r2)(g);
}
function g() {
  for (var n3; g.__r = t.length; )
    n3 = t.sort(function(n4, l5) {
      return n4.__v.__b - l5.__v.__b;
    }), t = [], n3.some(function(n4) {
      var l5, u5, i5, t5, r6, o5;
      n4.__d && (r6 = (t5 = (l5 = n4).__v).__e, (o5 = l5.__P) && (u5 = [], (i5 = a({}, t5)).__v = t5.__v + 1, j(o5, t5, i5, l5.__n, o5.ownerSVGElement !== void 0, t5.__h != null ? [r6] : null, u5, r6 == null ? k(t5) : r6, t5.__h), z(u5, t5), t5.__e != r6 && b(t5)));
    });
}
function w(n3, l5, u5, i5, t5, r6, o5, f7, s6, a5) {
  var h5, v8, p5, _10, b4, m5, g5, w6 = i5 && i5.__k || c, A6 = w6.length;
  for (u5.__k = [], h5 = 0; h5 < l5.length; h5++)
    if ((_10 = u5.__k[h5] = (_10 = l5[h5]) == null || typeof _10 == "boolean" ? null : typeof _10 == "string" || typeof _10 == "number" || typeof _10 == "bigint" ? y(null, _10, null, null, _10) : Array.isArray(_10) ? y(d, { children: _10 }, null, null, null) : _10.__b > 0 ? y(_10.type, _10.props, _10.key, null, _10.__v) : _10) != null) {
      if (_10.__ = u5, _10.__b = u5.__b + 1, (p5 = w6[h5]) === null || p5 && _10.key == p5.key && _10.type === p5.type)
        w6[h5] = void 0;
      else
        for (v8 = 0; v8 < A6; v8++) {
          if ((p5 = w6[v8]) && _10.key == p5.key && _10.type === p5.type) {
            w6[v8] = void 0;
            break;
          }
          p5 = null;
        }
      j(n3, _10, p5 = p5 || e, t5, r6, o5, f7, s6, a5), b4 = _10.__e, (v8 = _10.ref) && p5.ref != v8 && (g5 || (g5 = []), p5.ref && g5.push(p5.ref, null, _10), g5.push(v8, _10.__c || b4, _10)), b4 != null ? (m5 == null && (m5 = b4), typeof _10.type == "function" && _10.__k === p5.__k ? _10.__d = s6 = x(_10, s6, n3) : s6 = P(n3, _10, p5, w6, b4, s6), typeof u5.type == "function" && (u5.__d = s6)) : s6 && p5.__e == s6 && s6.parentNode != n3 && (s6 = k(p5));
    }
  for (u5.__e = m5, h5 = A6; h5--; )
    w6[h5] != null && (typeof u5.type == "function" && w6[h5].__e != null && w6[h5].__e == u5.__d && (u5.__d = k(i5, h5 + 1)), N2(w6[h5], w6[h5]));
  if (g5)
    for (h5 = 0; h5 < g5.length; h5++)
      M(g5[h5], g5[++h5], g5[++h5]);
}
function x(n3, l5, u5) {
  for (var i5, t5 = n3.__k, r6 = 0; t5 && r6 < t5.length; r6++)
    (i5 = t5[r6]) && (i5.__ = n3, l5 = typeof i5.type == "function" ? x(i5, l5, u5) : P(u5, i5, i5, t5, i5.__e, l5));
  return l5;
}
function A(n3, l5) {
  return l5 = l5 || [], n3 == null || typeof n3 == "boolean" || (Array.isArray(n3) ? n3.some(function(n4) {
    A(n4, l5);
  }) : l5.push(n3)), l5;
}
function P(n3, l5, u5, i5, t5, r6) {
  var o5, f7, e5;
  if (l5.__d !== void 0)
    o5 = l5.__d, l5.__d = void 0;
  else if (u5 == null || t5 != r6 || t5.parentNode == null)
    n:
      if (r6 == null || r6.parentNode !== n3)
        n3.appendChild(t5), o5 = null;
      else {
        for (f7 = r6, e5 = 0; (f7 = f7.nextSibling) && e5 < i5.length; e5 += 2)
          if (f7 == t5)
            break n;
        n3.insertBefore(t5, r6), o5 = r6;
      }
  return o5 !== void 0 ? o5 : t5.nextSibling;
}
function C(n3, l5, u5, i5, t5) {
  var r6;
  for (r6 in u5)
    r6 === "children" || r6 === "key" || r6 in l5 || H(n3, r6, null, u5[r6], i5);
  for (r6 in l5)
    t5 && typeof l5[r6] != "function" || r6 === "children" || r6 === "key" || r6 === "value" || r6 === "checked" || u5[r6] === l5[r6] || H(n3, r6, l5[r6], u5[r6], i5);
}
function $(n3, l5, u5) {
  l5[0] === "-" ? n3.setProperty(l5, u5) : n3[l5] = u5 == null ? "" : typeof u5 != "number" || s2.test(l5) ? u5 : u5 + "px";
}
function H(n3, l5, u5, i5, t5) {
  var r6;
  n:
    if (l5 === "style")
      if (typeof u5 == "string")
        n3.style.cssText = u5;
      else {
        if (typeof i5 == "string" && (n3.style.cssText = i5 = ""), i5)
          for (l5 in i5)
            u5 && l5 in u5 || $(n3.style, l5, "");
        if (u5)
          for (l5 in u5)
            i5 && u5[l5] === i5[l5] || $(n3.style, l5, u5[l5]);
      }
    else if (l5[0] === "o" && l5[1] === "n")
      r6 = l5 !== (l5 = l5.replace(/Capture$/, "")), l5 = l5.toLowerCase() in n3 ? l5.toLowerCase().slice(2) : l5.slice(2), n3.l || (n3.l = {}), n3.l[l5 + r6] = u5, u5 ? i5 || n3.addEventListener(l5, r6 ? T : I2, r6) : n3.removeEventListener(l5, r6 ? T : I2, r6);
    else if (l5 !== "dangerouslySetInnerHTML") {
      if (t5)
        l5 = l5.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if (l5 !== "href" && l5 !== "list" && l5 !== "form" && l5 !== "tabIndex" && l5 !== "download" && l5 in n3)
        try {
          n3[l5] = u5 == null ? "" : u5;
          break n;
        } catch (n4) {
        }
      typeof u5 == "function" || (u5 != null && (u5 !== false || l5[0] === "a" && l5[1] === "r") ? n3.setAttribute(l5, u5) : n3.removeAttribute(l5));
    }
}
function I2(n3) {
  this.l[n3.type + false](l.event ? l.event(n3) : n3);
}
function T(n3) {
  this.l[n3.type + true](l.event ? l.event(n3) : n3);
}
function j(n3, u5, i5, t5, r6, o5, f7, e5, c5) {
  var s6, h5, v8, y5, p5, k5, b4, m5, g5, x5, A6, P4 = u5.type;
  if (u5.constructor !== void 0)
    return null;
  i5.__h != null && (c5 = i5.__h, e5 = u5.__e = i5.__e, u5.__h = null, o5 = [e5]), (s6 = l.__b) && s6(u5);
  try {
    n:
      if (typeof P4 == "function") {
        if (m5 = u5.props, g5 = (s6 = P4.contextType) && t5[s6.__c], x5 = s6 ? g5 ? g5.props.value : s6.__ : t5, i5.__c ? b4 = (h5 = u5.__c = i5.__c).__ = h5.__E : ("prototype" in P4 && P4.prototype.render ? u5.__c = h5 = new P4(m5, x5) : (u5.__c = h5 = new _(m5, x5), h5.constructor = P4, h5.render = O), g5 && g5.sub(h5), h5.props = m5, h5.state || (h5.state = {}), h5.context = x5, h5.__n = t5, v8 = h5.__d = true, h5.__h = []), h5.__s == null && (h5.__s = h5.state), P4.getDerivedStateFromProps != null && (h5.__s == h5.state && (h5.__s = a({}, h5.__s)), a(h5.__s, P4.getDerivedStateFromProps(m5, h5.__s))), y5 = h5.props, p5 = h5.state, v8)
          P4.getDerivedStateFromProps == null && h5.componentWillMount != null && h5.componentWillMount(), h5.componentDidMount != null && h5.__h.push(h5.componentDidMount);
        else {
          if (P4.getDerivedStateFromProps == null && m5 !== y5 && h5.componentWillReceiveProps != null && h5.componentWillReceiveProps(m5, x5), !h5.__e && h5.shouldComponentUpdate != null && h5.shouldComponentUpdate(m5, h5.__s, x5) === false || u5.__v === i5.__v) {
            h5.props = m5, h5.state = h5.__s, u5.__v !== i5.__v && (h5.__d = false), h5.__v = u5, u5.__e = i5.__e, u5.__k = i5.__k, u5.__k.forEach(function(n4) {
              n4 && (n4.__ = u5);
            }), h5.__h.length && f7.push(h5);
            break n;
          }
          h5.componentWillUpdate != null && h5.componentWillUpdate(m5, h5.__s, x5), h5.componentDidUpdate != null && h5.__h.push(function() {
            h5.componentDidUpdate(y5, p5, k5);
          });
        }
        h5.context = x5, h5.props = m5, h5.state = h5.__s, (s6 = l.__r) && s6(u5), h5.__d = false, h5.__v = u5, h5.__P = n3, s6 = h5.render(h5.props, h5.state, h5.context), h5.state = h5.__s, h5.getChildContext != null && (t5 = a(a({}, t5), h5.getChildContext())), v8 || h5.getSnapshotBeforeUpdate == null || (k5 = h5.getSnapshotBeforeUpdate(y5, p5)), A6 = s6 != null && s6.type === d && s6.key == null ? s6.props.children : s6, w(n3, Array.isArray(A6) ? A6 : [A6], u5, i5, t5, r6, o5, f7, e5, c5), h5.base = u5.__e, u5.__h = null, h5.__h.length && f7.push(h5), b4 && (h5.__E = h5.__ = null), h5.__e = false;
      } else
        o5 == null && u5.__v === i5.__v ? (u5.__k = i5.__k, u5.__e = i5.__e) : u5.__e = L(i5.__e, u5, i5, t5, r6, o5, f7, c5);
    (s6 = l.diffed) && s6(u5);
  } catch (n4) {
    u5.__v = null, (c5 || o5 != null) && (u5.__e = e5, u5.__h = !!c5, o5[o5.indexOf(e5)] = null), l.__e(n4, u5, i5);
  }
}
function z(n3, u5) {
  l.__c && l.__c(u5, n3), n3.some(function(u6) {
    try {
      n3 = u6.__h, u6.__h = [], n3.some(function(n4) {
        n4.call(u6);
      });
    } catch (n4) {
      l.__e(n4, u6.__v);
    }
  });
}
function L(l5, u5, i5, t5, r6, o5, f7, c5) {
  var s6, a5, v8, y5 = i5.props, p5 = u5.props, d5 = u5.type, _10 = 0;
  if (d5 === "svg" && (r6 = true), o5 != null) {
    for (; _10 < o5.length; _10++)
      if ((s6 = o5[_10]) && "setAttribute" in s6 == !!d5 && (d5 ? s6.localName === d5 : s6.nodeType === 3)) {
        l5 = s6, o5[_10] = null;
        break;
      }
  }
  if (l5 == null) {
    if (d5 === null)
      return document.createTextNode(p5);
    l5 = r6 ? document.createElementNS("http://www.w3.org/2000/svg", d5) : document.createElement(d5, p5.is && p5), o5 = null, c5 = false;
  }
  if (d5 === null)
    y5 === p5 || c5 && l5.data === p5 || (l5.data = p5);
  else {
    if (o5 = o5 && n.call(l5.childNodes), a5 = (y5 = i5.props || e).dangerouslySetInnerHTML, v8 = p5.dangerouslySetInnerHTML, !c5) {
      if (o5 != null)
        for (y5 = {}, _10 = 0; _10 < l5.attributes.length; _10++)
          y5[l5.attributes[_10].name] = l5.attributes[_10].value;
      (v8 || a5) && (v8 && (a5 && v8.__html == a5.__html || v8.__html === l5.innerHTML) || (l5.innerHTML = v8 && v8.__html || ""));
    }
    if (C(l5, p5, y5, r6, c5), v8)
      u5.__k = [];
    else if (_10 = u5.props.children, w(l5, Array.isArray(_10) ? _10 : [_10], u5, i5, t5, r6 && d5 !== "foreignObject", o5, f7, o5 ? o5[0] : i5.__k && k(i5, 0), c5), o5 != null)
      for (_10 = o5.length; _10--; )
        o5[_10] != null && h(o5[_10]);
    c5 || ("value" in p5 && (_10 = p5.value) !== void 0 && (_10 !== y5.value || _10 !== l5.value || d5 === "progress" && !_10) && H(l5, "value", _10, y5.value, false), "checked" in p5 && (_10 = p5.checked) !== void 0 && _10 !== l5.checked && H(l5, "checked", _10, y5.checked, false));
  }
  return l5;
}
function M(n3, u5, i5) {
  try {
    typeof n3 == "function" ? n3(u5) : n3.current = u5;
  } catch (n4) {
    l.__e(n4, i5);
  }
}
function N2(n3, u5, i5) {
  var t5, r6;
  if (l.unmount && l.unmount(n3), (t5 = n3.ref) && (t5.current && t5.current !== n3.__e || M(t5, null, u5)), (t5 = n3.__c) != null) {
    if (t5.componentWillUnmount)
      try {
        t5.componentWillUnmount();
      } catch (n4) {
        l.__e(n4, u5);
      }
    t5.base = t5.__P = null;
  }
  if (t5 = n3.__k)
    for (r6 = 0; r6 < t5.length; r6++)
      t5[r6] && N2(t5[r6], u5, typeof n3.type != "function");
  i5 || n3.__e == null || h(n3.__e), n3.__e = n3.__d = void 0;
}
function O(n3, l5, u5) {
  return this.constructor(n3, u5);
}
function S(u5, i5, t5) {
  var r6, o5, f7;
  l.__ && l.__(u5, i5), o5 = (r6 = typeof t5 == "function") ? null : t5 && t5.__k || i5.__k, f7 = [], j(i5, u5 = (!r6 && t5 || i5).__k = v(d, null, [u5]), o5 || e, e, i5.ownerSVGElement !== void 0, !r6 && t5 ? [t5] : o5 ? null : i5.firstChild ? n.call(i5.childNodes) : null, f7, !r6 && t5 ? t5 : o5 ? o5.__e : i5.firstChild, r6), z(f7, u5);
}
function q(n3, l5) {
  S(n3, l5, q);
}
function B(l5, u5, i5) {
  var t5, r6, o5, f7 = a({}, l5.props);
  for (o5 in u5)
    o5 == "key" ? t5 = u5[o5] : o5 == "ref" ? r6 = u5[o5] : f7[o5] = u5[o5];
  return arguments.length > 2 && (f7.children = arguments.length > 3 ? n.call(arguments, 2) : i5), y(l5.type, f7, t5 || l5.key, r6 || l5.ref, null);
}
function D(n3, l5) {
  var u5 = { __c: l5 = "__cC" + f3++, __: n3, Consumer: function(n4, l6) {
    return n4.children(l6);
  }, Provider: function(n4) {
    var u6, i5;
    return this.getChildContext || (u6 = [], (i5 = {})[l5] = this, this.getChildContext = function() {
      return i5;
    }, this.shouldComponentUpdate = function(n5) {
      this.props.value !== n5.value && u6.some(m);
    }, this.sub = function(n5) {
      u6.push(n5);
      var l6 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        u6.splice(u6.indexOf(n5), 1), l6 && l6.call(n5);
      };
    }), n4.children;
  } };
  return u5.Provider.__ = u5.Consumer.contextType = u5;
}
var n, l, u, i, t, r2, o, f3, e, c, s2;
var init_preact_module = __esm({
  "node_modules/walletlink/node_modules/preact/dist/preact.module.js"() {
    e = {};
    c = [];
    s2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n = c.slice, l = { __e: function(n3, l5) {
      for (var u5, i5, t5; l5 = l5.__; )
        if ((u5 = l5.__c) && !u5.__)
          try {
            if ((i5 = u5.constructor) && i5.getDerivedStateFromError != null && (u5.setState(i5.getDerivedStateFromError(n3)), t5 = u5.__d), u5.componentDidCatch != null && (u5.componentDidCatch(n3), t5 = u5.__d), t5)
              return u5.__E = u5;
          } catch (l6) {
            n3 = l6;
          }
      throw n3;
    } }, u = 0, i = function(n3) {
      return n3 != null && n3.constructor === void 0;
    }, _.prototype.setState = function(n3, l5) {
      var u5;
      u5 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n3 == "function" && (n3 = n3(a({}, u5), this.props)), n3 && a(u5, n3), n3 != null && this.__v && (l5 && this.__h.push(l5), m(this));
    }, _.prototype.forceUpdate = function(n3) {
      this.__v && (this.__e = true, n3 && this.__h.push(n3), m(this));
    }, _.prototype.render = d, t = [], r2 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g.__r = 0, f3 = 0;
  }
});

// node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  default: () => clsx_m_default
});
function toVal(mix) {
  var k5, y5, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k5 = 0; k5 < mix.length; k5++) {
        if (mix[k5]) {
          if (y5 = toVal(mix[k5])) {
            str && (str += " ");
            str += y5;
          }
        }
      }
    } else {
      for (k5 in mix) {
        if (mix[k5]) {
          str && (str += " ");
          str += k5;
        }
      }
    }
  }
  return str;
}
function clsx_m_default() {
  var i5 = 0, tmp, x5, str = "";
  while (i5 < arguments.length) {
    if (tmp = arguments[i5++]) {
      if (x5 = toVal(tmp)) {
        str && (str += " ");
        str += x5;
      }
    }
  }
  return str;
}
var init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
  }
});

// node_modules/walletlink/node_modules/preact/hooks/dist/hooks.module.js
var hooks_module_exports = {};
__export(hooks_module_exports, {
  useCallback: () => A2,
  useContext: () => F,
  useDebugValue: () => T2,
  useEffect: () => y2,
  useErrorBoundary: () => q2,
  useImperativeHandle: () => _2,
  useLayoutEffect: () => h2,
  useMemo: () => d2,
  useReducer: () => p2,
  useRef: () => s3,
  useState: () => l2
});
function m2(t5, r6) {
  l.__h && l.__h(u2, t5, o2 || r6), o2 = 0;
  var i5 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t5 >= i5.__.length && i5.__.push({}), i5.__[t5];
}
function l2(n3) {
  return o2 = 1, p2(w2, n3);
}
function p2(n3, r6, o5) {
  var i5 = m2(t2++, 2);
  return i5.t = n3, i5.__c || (i5.__ = [o5 ? o5(r6) : w2(void 0, r6), function(n4) {
    var t5 = i5.t(i5.__[0], n4);
    i5.__[0] !== t5 && (i5.__ = [t5, i5.__[1]], i5.__c.setState({}));
  }], i5.__c = u2), i5.__;
}
function y2(r6, o5) {
  var i5 = m2(t2++, 3);
  !l.__s && k2(i5.__H, o5) && (i5.__ = r6, i5.__H = o5, u2.__H.__h.push(i5));
}
function h2(r6, o5) {
  var i5 = m2(t2++, 4);
  !l.__s && k2(i5.__H, o5) && (i5.__ = r6, i5.__H = o5, u2.__h.push(i5));
}
function s3(n3) {
  return o2 = 5, d2(function() {
    return { current: n3 };
  }, []);
}
function _2(n3, t5, u5) {
  o2 = 6, h2(function() {
    typeof n3 == "function" ? n3(t5()) : n3 && (n3.current = t5());
  }, u5 == null ? u5 : u5.concat(n3));
}
function d2(n3, u5) {
  var r6 = m2(t2++, 7);
  return k2(r6.__H, u5) && (r6.__ = n3(), r6.__H = u5, r6.__h = n3), r6.__;
}
function A2(n3, t5) {
  return o2 = 8, d2(function() {
    return n3;
  }, t5);
}
function F(n3) {
  var r6 = u2.context[n3.__c], o5 = m2(t2++, 9);
  return o5.c = n3, r6 ? (o5.__ == null && (o5.__ = true, r6.sub(u2)), r6.props.value) : n3.__;
}
function T2(t5, u5) {
  l.useDebugValue && l.useDebugValue(u5 ? u5(t5) : t5);
}
function q2(n3) {
  var r6 = m2(t2++, 10), o5 = l2();
  return r6.__ = n3, u2.componentDidCatch || (u2.componentDidCatch = function(n4) {
    r6.__ && r6.__(n4), o5[1](n4);
  }), [o5[0], function() {
    o5[1](void 0);
  }];
}
function x2() {
  for (var t5; t5 = i2.shift(); )
    if (t5.__P)
      try {
        t5.__H.__h.forEach(g2), t5.__H.__h.forEach(j2), t5.__H.__h = [];
      } catch (u5) {
        t5.__H.__h = [], l.__e(u5, t5.__v);
      }
}
function g2(n3) {
  var t5 = u2, r6 = n3.__c;
  typeof r6 == "function" && (n3.__c = void 0, r6()), u2 = t5;
}
function j2(n3) {
  var t5 = u2;
  n3.__c = n3.__(), u2 = t5;
}
function k2(n3, t5) {
  return !n3 || n3.length !== t5.length || t5.some(function(t6, u5) {
    return t6 !== n3[u5];
  });
}
function w2(n3, t5) {
  return typeof t5 == "function" ? t5(n3) : t5;
}
var t2, u2, r3, o2, i2, c2, f4, e2, a2, v2, b2;
var init_hooks_module = __esm({
  "node_modules/walletlink/node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o2 = 0;
    i2 = [];
    c2 = l.__b;
    f4 = l.__r;
    e2 = l.diffed;
    a2 = l.__c;
    v2 = l.unmount;
    l.__b = function(n3) {
      u2 = null, c2 && c2(n3);
    }, l.__r = function(n3) {
      f4 && f4(n3), t2 = 0;
      var r6 = (u2 = n3.__c).__H;
      r6 && (r6.__h.forEach(g2), r6.__h.forEach(j2), r6.__h = []);
    }, l.diffed = function(t5) {
      e2 && e2(t5);
      var o5 = t5.__c;
      o5 && o5.__H && o5.__H.__h.length && (i2.push(o5) !== 1 && r3 === l.requestAnimationFrame || ((r3 = l.requestAnimationFrame) || function(n3) {
        var t6, u5 = function() {
          clearTimeout(r6), b2 && cancelAnimationFrame(t6), setTimeout(n3);
        }, r6 = setTimeout(u5, 100);
        b2 && (t6 = requestAnimationFrame(u5));
      })(x2)), u2 = null;
    }, l.__c = function(t5, u5) {
      u5.some(function(t6) {
        try {
          t6.__h.forEach(g2), t6.__h = t6.__h.filter(function(n3) {
            return !n3.__ || j2(n3);
          });
        } catch (r6) {
          u5.some(function(n3) {
            n3.__h && (n3.__h = []);
          }), u5 = [], l.__e(r6, t6.__v);
        }
      }), a2 && a2(t5, u5);
    }, l.unmount = function(t5) {
      v2 && v2(t5);
      var u5, r6 = t5.__c;
      r6 && r6.__H && (r6.__H.__.forEach(function(n3) {
        try {
          g2(n3);
        } catch (n4) {
          u5 = n4;
        }
      }), u5 && l.__e(u5, r6.__v));
    };
    b2 = typeof requestAnimationFrame == "function";
  }
});

// node_modules/walletlink/dist/components/LinkDialog-css.js
var require_LinkDialog_css = __commonJS({
  "node_modules/walletlink/dist/components/LinkDialog-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-walletlink-link-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-walletlink-css-reset .-walletlink-link-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.33);transition:opacity .25s}.-walletlink-css-reset .-walletlink-link-dialog-backdrop-hidden{opacity:0}.-walletlink-css-reset .-walletlink-link-dialog-box{display:flex;position:relative;flex-direction:column;background-color:#f6f6f6;border-radius:16px;box-shadow:0px 16px 24px rgba(0,0,0,.1),0px 0px 8px rgba(0,0,0,.05);transform:scale(1);transition:opacity .25s,transform .25s;overflow:hidden}.-walletlink-css-reset .-walletlink-link-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-walletlink-css-reset .-walletlink-link-dialog-box-content{padding:24px;text-align:center}.-walletlink-css-reset .-walletlink-link-dialog-box-content h3{display:block;margin-bottom:24px;text-align:left;text-transform:uppercase;font-size:22px;font-weight:bold;line-height:1.2;color:#000}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode{position:relative;display:block;margin-bottom:24px;background-color:#f6f6f6;padding:16px;border-radius:16px;box-shadow:4px 4px 8px rgba(0,0,0,.15),-8px -8px 8px #fff;overflow:hidden}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-wrapper{display:block;width:232px;height:232px;padding:4px;border-radius:4px;background:#f4f4f4;margin-bottom:16px}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-wrapper img{display:block;width:224px;height:224px}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode>p{display:block;color:gray;font-weight:bold;font-size:12px;text-align:center}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-connecting{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(246,246,246,.98)}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-connecting p{margin-top:16px;color:#333;font-size:12px;font-weight:bold}.-walletlink-css-reset .-walletlink-link-dialog-box-content a{text-align:center;cursor:pointer;transition:color .1s;font-size:14px}.-walletlink-css-reset .-walletlink-link-dialog-box-content a,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:link,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:visited{color:#999}.-walletlink-css-reset .-walletlink-link-dialog-box-content a:hover,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:active{color:#666;text-decoration:underline}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:24px;right:24px;width:24px;height:24px;border-radius:12px;background-color:#e7e7e7;cursor:pointer}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x{position:relative;display:block}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:2px;background-color:#999;transition:background-color .2s}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::before{transform:rotate(45deg)}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::after{transform:rotate(135deg)}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-a,.-walletlink-css-reset .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-b{background-color:#000}.-walletlink-css-reset .-walletlink-link-dialog-container{display:block}.-walletlink-css-reset .-walletlink-link-dialog-container-hidden{display:none}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box{background-color:#2a2a2a}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content h3{color:#ccc}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode{background-color:#2a2a2a;box-shadow:4px 4px 8px rgba(0,0,0,.5),-8px -8px 8px #343434}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode>p{color:#999}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode-connecting{background:rgba(42,42,42,.98)}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode-connecting p{color:#ddd}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:link,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:visited{color:#888}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:hover,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:active{color:#aaa}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel{background-color:#333}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel-x::after{background-color:#aaa}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x::after{background-color:#eee}`;
  }
});

// node_modules/walletlink/dist/vendor-js/qrcode-svg/index.js
var require_qrcode_svg = __commonJS({
  "node_modules/walletlink/dist/vendor-js/qrcode-svg/index.js"(exports, module) {
    function QR8bitByte(data) {
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data;
      this.parsedData = [];
      for (var i6 = 0, l5 = this.data.length; i6 < l5; i6++) {
        var byteArray = [];
        var code = this.data.charCodeAt(i6);
        if (code > 65536) {
          byteArray[0] = 240 | (code & 1835008) >>> 18;
          byteArray[1] = 128 | (code & 258048) >>> 12;
          byteArray[2] = 128 | (code & 4032) >>> 6;
          byteArray[3] = 128 | code & 63;
        } else if (code > 2048) {
          byteArray[0] = 224 | (code & 61440) >>> 12;
          byteArray[1] = 128 | (code & 4032) >>> 6;
          byteArray[2] = 128 | code & 63;
        } else if (code > 128) {
          byteArray[0] = 192 | (code & 1984) >>> 6;
          byteArray[1] = 128 | code & 63;
        } else {
          byteArray[0] = code;
        }
        this.parsedData.push(byteArray);
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData);
      if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
      }
    }
    QR8bitByte.prototype = {
      getLength: function(buffer2) {
        return this.parsedData.length;
      },
      write: function(buffer2) {
        for (var i6 = 0, l5 = this.parsedData.length; i6 < l5; i6++) {
          buffer2.put(this.parsedData[i6], 8);
        }
      }
    };
    function QRCodeModel(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    QRCodeModel.prototype = { addData: function(data) {
      var newData = new QR8bitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    }, isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    }, getModuleCount: function() {
      return this.moduleCount;
    }, make: function() {
      this.makeImpl(false, this.getBestMaskPattern());
    }, makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0; col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache == null) {
        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    }, setupPositionProbePattern: function(row, col) {
      for (var r6 = -1; r6 <= 7; r6++) {
        if (row + r6 <= -1 || this.moduleCount <= row + r6)
          continue;
        for (var c5 = -1; c5 <= 7; c5++) {
          if (col + c5 <= -1 || this.moduleCount <= col + c5)
            continue;
          if (0 <= r6 && r6 <= 6 && (c5 == 0 || c5 == 6) || 0 <= c5 && c5 <= 6 && (r6 == 0 || r6 == 6) || 2 <= r6 && r6 <= 4 && 2 <= c5 && c5 <= 4) {
            this.modules[row + r6][col + c5] = true;
          } else {
            this.modules[row + r6][col + c5] = false;
          }
        }
      }
    }, getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i6 = 0; i6 < 8; i6++) {
        this.makeImpl(true, i6);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i6 == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i6;
        }
      }
      return pattern;
    }, createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs = 1;
      this.make();
      for (var row = 0; row < this.modules.length; row++) {
        var y5 = row * cs;
        for (var col = 0; col < this.modules[row].length; col++) {
          var x5 = col * cs;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x5, y5);
            qr_mc.lineTo(x5 + cs, y5);
            qr_mc.lineTo(x5 + cs, y5 + cs);
            qr_mc.lineTo(x5, y5 + cs);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    }, setupTimingPattern: function() {
      for (var r6 = 8; r6 < this.moduleCount - 8; r6++) {
        if (this.modules[r6][6] != null) {
          continue;
        }
        this.modules[r6][6] = r6 % 2 == 0;
      }
      for (var c5 = 8; c5 < this.moduleCount - 8; c5++) {
        if (this.modules[6][c5] != null) {
          continue;
        }
        this.modules[6][c5] = c5 % 2 == 0;
      }
    }, setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i6 = 0; i6 < pos.length; i6++) {
        for (var j5 = 0; j5 < pos.length; j5++) {
          var row = pos[i6];
          var col = pos[j5];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r6 = -2; r6 <= 2; r6++) {
            for (var c5 = -2; c5 <= 2; c5++) {
              if (r6 == -2 || r6 == 2 || c5 == -2 || c5 == 2 || r6 == 0 && c5 == 0) {
                this.modules[row + r6][col + c5] = true;
              } else {
                this.modules[row + r6][col + c5] = false;
              }
            }
          }
        }
      }
    }, setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (var i6 = 0; i6 < 18; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        this.modules[Math.floor(i6 / 3)][i6 % 3 + this.moduleCount - 8 - 3] = mod;
      }
      for (var i6 = 0; i6 < 18; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        this.modules[i6 % 3 + this.moduleCount - 8 - 3][Math.floor(i6 / 3)] = mod;
      }
    }, setupTypeInfo: function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      for (var i6 = 0; i6 < 15; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        if (i6 < 6) {
          this.modules[i6][8] = mod;
        } else if (i6 < 8) {
          this.modules[i6 + 1][8] = mod;
        } else {
          this.modules[this.moduleCount - 15 + i6][8] = mod;
        }
      }
      for (var i6 = 0; i6 < 15; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        if (i6 < 8) {
          this.modules[8][this.moduleCount - i6 - 1] = mod;
        } else if (i6 < 9) {
          this.modules[8][15 - i6 - 1 + 1] = mod;
        } else {
          this.modules[8][15 - i6 - 1] = mod;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    }, mapData: function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (this.modules[row][col - c5] == null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask2 = QRUtil.getMask(maskPattern, row, col - c5);
              if (mask2) {
                dark = !dark;
              }
              this.modules[row][col - c5] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    } };
    QRCodeModel.PAD0 = 236;
    QRCodeModel.PAD1 = 17;
    QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer2 = new QRBitBuffer();
      for (var i6 = 0; i6 < dataList.length; i6++) {
        var data = dataList[i6];
        buffer2.put(data.mode, 4);
        buffer2.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
        data.write(buffer2);
      }
      var totalDataCount = 0;
      for (var i6 = 0; i6 < rsBlocks.length; i6++) {
        totalDataCount += rsBlocks[i6].dataCount;
      }
      if (buffer2.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
      }
      if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 != 0) {
        buffer2.putBit(false);
      }
      while (true) {
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD0, 8);
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD1, 8);
      }
      return QRCodeModel.createBytes(buffer2, rsBlocks);
    };
    QRCodeModel.createBytes = function(buffer2, rsBlocks) {
      var offset2 = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r6 = 0; r6 < rsBlocks.length; r6++) {
        var dcCount = rsBlocks[r6].dataCount;
        var ecCount = rsBlocks[r6].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r6] = new Array(dcCount);
        for (var i6 = 0; i6 < dcdata[r6].length; i6++) {
          dcdata[r6][i6] = 255 & buffer2.buffer[i6 + offset2];
        }
        offset2 += dcCount;
        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new QRPolynomial(dcdata[r6], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r6] = new Array(rsPoly.getLength() - 1);
        for (var i6 = 0; i6 < ecdata[r6].length; i6++) {
          var modIndex = i6 + modPoly.getLength() - ecdata[r6].length;
          ecdata[r6][i6] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var totalCodeCount = 0;
      for (var i6 = 0; i6 < rsBlocks.length; i6++) {
        totalCodeCount += rsBlocks[i6].totalCount;
      }
      var data = new Array(totalCodeCount);
      var index = 0;
      for (var i6 = 0; i6 < maxDcCount; i6++) {
        for (var r6 = 0; r6 < rsBlocks.length; r6++) {
          if (i6 < dcdata[r6].length) {
            data[index++] = dcdata[r6][i6];
          }
        }
      }
      for (var i6 = 0; i6 < maxEcCount; i6++) {
        for (var r6 = 0; r6 < rsBlocks.length; r6++) {
          if (i6 < ecdata[r6].length) {
            data[index++] = ecdata[r6][i6];
          }
        }
      }
      return data;
    };
    var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
    var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
    var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
    var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data) {
      var d5 = data << 10;
      while (QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d5 ^= QRUtil.G15 << QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d5) ^ QRUtil.G15_MASK;
    }, getBCHTypeNumber: function(data) {
      var d5 = data << 12;
      while (QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d5 ^= QRUtil.G18 << QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d5;
    }, getBCHDigit: function(data) {
      var digit = 0;
      while (data != 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    }, getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    }, getMask: function(maskPattern, i6, j5) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i6 + j5) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i6 % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j5 % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i6 + j5) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i6 / 2) + Math.floor(j5 / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i6 * j5 % 2 + i6 * j5 % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i6 * j5 % 2 + i6 * j5 % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i6 * j5 % 3 + (i6 + j5) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }, getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a5 = new QRPolynomial([1], 0);
      for (var i6 = 0; i6 < errorCorrectLength; i6++) {
        a5 = a5.multiply(new QRPolynomial([1, QRMath.gexp(i6)], 0));
      }
      return a5;
    }, getLengthInBits: function(mode, type2) {
      if (1 <= type2 && type2 < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type2 < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type2 < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type2);
      }
    }, getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r6 = -1; r6 <= 1; r6++) {
            if (row + r6 < 0 || moduleCount <= row + r6) {
              continue;
            }
            for (var c5 = -1; c5 <= 1; c5++) {
              if (col + c5 < 0 || moduleCount <= col + c5) {
                continue;
              }
              if (r6 == 0 && c5 == 0) {
                continue;
              }
              if (dark == qrCode.isDark(row + r6, col + c5)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count2 = 0;
          if (qrCode.isDark(row, col))
            count2++;
          if (qrCode.isDark(row + 1, col))
            count2++;
          if (qrCode.isDark(row, col + 1))
            count2++;
          if (qrCode.isDark(row + 1, col + 1))
            count2++;
          if (count2 == 0 || count2 == 4) {
            lostPoint += 3;
          }
        }
      }
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    } };
    var QRMath = { glog: function(n3) {
      if (n3 < 1) {
        throw new Error("glog(" + n3 + ")");
      }
      return QRMath.LOG_TABLE[n3];
    }, gexp: function(n3) {
      while (n3 < 0) {
        n3 += 255;
      }
      while (n3 >= 256) {
        n3 -= 255;
      }
      return QRMath.EXP_TABLE[n3];
    }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
    for (i5 = 0; i5 < 8; i5++) {
      QRMath.EXP_TABLE[i5] = 1 << i5;
    }
    var i5;
    for (i5 = 8; i5 < 256; i5++) {
      QRMath.EXP_TABLE[i5] = QRMath.EXP_TABLE[i5 - 4] ^ QRMath.EXP_TABLE[i5 - 5] ^ QRMath.EXP_TABLE[i5 - 6] ^ QRMath.EXP_TABLE[i5 - 8];
    }
    var i5;
    for (i5 = 0; i5 < 255; i5++) {
      QRMath.LOG_TABLE[QRMath.EXP_TABLE[i5]] = i5;
    }
    var i5;
    function QRPolynomial(num, shift) {
      if (num.length == void 0) {
        throw new Error(num.length + "/" + shift);
      }
      var offset2 = 0;
      while (offset2 < num.length && num[offset2] == 0) {
        offset2++;
      }
      this.num = new Array(num.length - offset2 + shift);
      for (var i6 = 0; i6 < num.length - offset2; i6++) {
        this.num[i6] = num[i6 + offset2];
      }
    }
    QRPolynomial.prototype = { get: function(index) {
      return this.num[index];
    }, getLength: function() {
      return this.num.length;
    }, multiply: function(e5) {
      var num = new Array(this.getLength() + e5.getLength() - 1);
      for (var i6 = 0; i6 < this.getLength(); i6++) {
        for (var j5 = 0; j5 < e5.getLength(); j5++) {
          num[i6 + j5] ^= QRMath.gexp(QRMath.glog(this.get(i6)) + QRMath.glog(e5.get(j5)));
        }
      }
      return new QRPolynomial(num, 0);
    }, mod: function(e5) {
      if (this.getLength() - e5.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e5.get(0));
      var num = new Array(this.getLength());
      for (var i6 = 0; i6 < this.getLength(); i6++) {
        num[i6] = this.get(i6);
      }
      for (var i6 = 0; i6 < e5.getLength(); i6++) {
        num[i6] ^= QRMath.gexp(QRMath.glog(e5.get(i6)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e5);
    } };
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
    QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == void 0) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var list = [];
      for (var i6 = 0; i6 < length; i6++) {
        var count2 = rsBlock[i6 * 3 + 0];
        var totalCount = rsBlock[i6 * 3 + 1];
        var dataCount = rsBlock[i6 * 3 + 2];
        for (var j5 = 0; j5 < count2; j5++) {
          list.push(new QRRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    function QRBitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    QRBitBuffer.prototype = { get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    }, put: function(num, length) {
      for (var i6 = 0; i6 < length; i6++) {
        this.putBit((num >>> length - i6 - 1 & 1) == 1);
      }
    }, getLengthInBits: function() {
      return this.length;
    }, putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    } };
    var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    function QRCode(options) {
      var instance2 = this;
      this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image: {
          svg: "",
          width: 0,
          height: 0
        }
      };
      if (typeof options === "string") {
        options = {
          content: options
        };
      }
      if (options) {
        for (var i6 in options) {
          this.options[i6] = options[i6];
        }
      }
      if (typeof this.options.content !== "string") {
        throw new Error("Expected 'content' as string!");
      }
      if (this.options.content.length === 0) {
        throw new Error("Expected 'content' to be non-empty!");
      }
      if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
      }
      if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
      }
      function _getErrorCorrectLevel(ecl2) {
        switch (ecl2) {
          case "L":
            return QRErrorCorrectLevel.L;
          case "M":
            return QRErrorCorrectLevel.M;
          case "Q":
            return QRErrorCorrectLevel.Q;
          case "H":
            return QRErrorCorrectLevel.H;
          default:
            throw new Error("Unknwon error correction level: " + ecl2);
        }
      }
      function _getTypeNumber(content2, ecl2) {
        var length = _getUTF8Length(content2);
        var type3 = 1;
        var limit = 0;
        for (var i7 = 0, len = QRCodeLimitLength.length; i7 <= len; i7++) {
          var table = QRCodeLimitLength[i7];
          if (!table) {
            throw new Error("Content too long: expected " + limit + " but got " + length);
          }
          switch (ecl2) {
            case "L":
              limit = table[0];
              break;
            case "M":
              limit = table[1];
              break;
            case "Q":
              limit = table[2];
              break;
            case "H":
              limit = table[3];
              break;
            default:
              throw new Error("Unknwon error correction level: " + ecl2);
          }
          if (length <= limit) {
            break;
          }
          type3++;
        }
        if (type3 > QRCodeLimitLength.length) {
          throw new Error("Content too long");
        }
        return type3;
      }
      function _getUTF8Length(content2) {
        var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
        return result.length + (result.length != content2 ? 3 : 0);
      }
      var content = this.options.content;
      var type2 = _getTypeNumber(content, this.options.ecl);
      var ecl = _getErrorCorrectLevel(this.options.ecl);
      this.qrcode = new QRCodeModel(type2, ecl);
      this.qrcode.addData(content);
      this.qrcode.make();
    }
    QRCode.prototype.svg = function(opt) {
      var options = this.options || {};
      var modules = this.qrcode.modules;
      if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
      }
      var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
      var indent = pretty ? "  " : "";
      var EOL = pretty ? "\r\n" : "";
      var width = options.width;
      var height = options.height;
      var length = modules.length;
      var xsize = width / (length + 2 * options.padding);
      var ysize = height / (length + 2 * options.padding);
      var join = typeof options.join != "undefined" ? !!options.join : false;
      var swap = typeof options.swap != "undefined" ? !!options.swap : false;
      var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
      var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
      var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
      var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
      var modrect = "";
      var pathdata = "";
      for (var y5 = 0; y5 < length; y5++) {
        for (var x5 = 0; x5 < length; x5++) {
          var module2 = modules[x5][y5];
          if (module2) {
            var px = x5 * xsize + options.padding * xsize;
            var py = y5 * ysize + options.padding * ysize;
            if (swap) {
              var t5 = px;
              px = py;
              py = t5;
            }
            if (join) {
              var w6 = xsize + px;
              var h5 = ysize + py;
              px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
              py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
              w6 = Number.isInteger(w6) ? Number(w6) : w6.toFixed(2);
              h5 = Number.isInteger(h5) ? Number(h5) : h5.toFixed(2);
              pathdata += "M" + px + "," + py + " V" + h5 + " H" + w6 + " V" + py + " H" + px + " Z ";
            } else if (predefined) {
              modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
            } else {
              modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
            }
          }
        }
      }
      if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
      }
      let imgSvg = "";
      if (this.options.image !== void 0 && this.options.image.svg) {
        const imgWidth = width * this.options.image.width / 100;
        const imgHeight = height * this.options.image.height / 100;
        const imgX = width / 2 - imgWidth / 2;
        const imgY = height / 2 - imgHeight / 2;
        imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
        imgSvg += this.options.image.svg + EOL;
        imgSvg += "</svg>";
      }
      var svg = "";
      switch (opt.container) {
        case "svg":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "svg-viewbox":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "g":
          svg += '<g width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</g>";
          break;
        default:
          svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
          break;
      }
      return svg;
    };
    module.exports = QRCode;
  }
});

// node_modules/walletlink/dist/components/QRCode.js
var require_QRCode = __commonJS({
  "node_modules/walletlink/dist/components/QRCode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCode = void 0;
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var qrcode_svg_1 = __importDefault(require_qrcode_svg());
    var QRCode = (props) => {
      const [svg, setSvg] = (0, hooks_1.useState)("");
      (0, hooks_1.useEffect)(() => {
        var _a2, _b;
        const qrcode = new qrcode_svg_1.default({
          content: props.content,
          background: props.bgColor || "#ffffff",
          color: props.fgColor || "#000000",
          container: "svg",
          ecl: "M",
          width: (_a2 = props.width) !== null && _a2 !== void 0 ? _a2 : 256,
          height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
          padding: 0,
          image: props.image
        });
        const base64 = Buffer.from(qrcode.svg(), "utf8").toString("base64");
        setSvg(`data:image/svg+xml;base64,${base64}`);
      });
      return svg ? (0, preact_1.h)("img", { src: svg, alt: "QR Code" }) : null;
    };
    exports.QRCode = QRCode;
  }
});

// node_modules/walletlink/dist/components/Spinner-css.js
var require_Spinner_css = __commonJS({
  "node_modules/walletlink/dist/components/Spinner-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-walletlink-spinner{display:inline-block}.-walletlink-css-reset .-walletlink-spinner svg{display:inline-block;animation:2s linear infinite -walletlink-spinner-svg}.-walletlink-css-reset .-walletlink-spinner svg circle{animation:1.9s ease-in-out infinite both -walletlink-spinner-circle;display:block;fill:transparent;stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -walletlink-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -walletlink-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
  }
});

// node_modules/walletlink/dist/components/Spinner.js
var require_Spinner = __commonJS({
  "node_modules/walletlink/dist/components/Spinner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Spinner = void 0;
    var preact_1 = (init_preact_module(), preact_module_exports);
    var Spinner_css_1 = __importDefault(require_Spinner_css());
    var Spinner = (props) => {
      var _a2;
      const size = (_a2 = props.size) !== null && _a2 !== void 0 ? _a2 : 64;
      const color = props.color || "#000";
      return (0, preact_1.h)("div", { class: "-walletlink-spinner" }, (0, preact_1.h)("style", null, Spinner_css_1.default), (0, preact_1.h)("svg", { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size, height: size } }, (0, preact_1.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })));
    };
    exports.Spinner = Spinner;
  }
});

// node_modules/walletlink/dist/components/LinkDialog.js
var require_LinkDialog = __commonJS({
  "node_modules/walletlink/dist/components/LinkDialog.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkDialog = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), clsx_m_exports));
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var LinkDialog_css_1 = __importDefault(require_LinkDialog_css());
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var LinkDialog = (props) => {
      const [isContainerHidden, setContainerHidden] = (0, hooks_1.useState)(!props.isOpen);
      const [isDialogHidden, setDialogHidden] = (0, hooks_1.useState)(!props.isOpen);
      (0, hooks_1.useEffect)(() => {
        const { isOpen } = props;
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      return (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-link-dialog-container", props.darkMode && "-walletlink-link-dialog-container-dark", isContainerHidden && "-walletlink-link-dialog-container-hidden") }, (0, preact_1.h)("style", null, LinkDialog_css_1.default), (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-link-dialog-backdrop", isDialogHidden && "-walletlink-link-dialog-backdrop-hidden") }), (0, preact_1.h)("div", { class: "-walletlink-link-dialog" }, (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-link-dialog-box", isDialogHidden && "-walletlink-link-dialog-box-hidden") }, (0, preact_1.h)(ScanQRCode, { darkMode: props.darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, walletLinkUrl: props.walletLinkUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection }), props.onCancel && (0, preact_1.h)(CancelButton, { onClick: props.onCancel }))));
    };
    exports.LinkDialog = LinkDialog;
    var ScanQRCode = (props) => {
      const serverUrl = window.encodeURIComponent(props.walletLinkUrl);
      const sessionIdKey = props.isParentConnection ? "parent-id" : "id";
      const qrUrl = `${props.walletLinkUrl}/#/link?${sessionIdKey}=${props.sessionId}&secret=${props.sessionSecret}&server=${serverUrl}&v=1`;
      return (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content" }, (0, preact_1.h)("h3", null, "Scan to", (0, preact_1.h)("br", null), " Connect"), (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode" }, (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode-wrapper" }, (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 224, height: 224, fgColor: "#000", bgColor: "transparent" })), (0, preact_1.h)("input", { type: "hidden", value: qrUrl }), !props.isConnected && (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode-connecting" }, (0, preact_1.h)(Spinner_1.Spinner, { size: 128, color: props.darkMode ? "#fff" : "#000" }), (0, preact_1.h)("p", null, "Connecting...")), (0, preact_1.h)("p", { title: `WalletLink v${props.version}` }, "Powered by WalletLink")), (0, preact_1.h)("a", { href: `${props.walletLinkUrl}/#/wallets`, target: "_blank", rel: "noopener" }, "Don\u2019t have a wallet app?"));
    };
    var CancelButton = (props) => (0, preact_1.h)("button", { class: "-walletlink-link-dialog-box-cancel", onClick: props.onClick }, (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-cancel-x" }));
  }
});

// node_modules/walletlink/dist/components/icons/globe-icon-svg.js
var require_globe_icon_svg = __commonJS({
  "node_modules/walletlink/dist/components/icons/globe-icon-svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOHMzLjU4IDggOCA4IDgtMy41OCA4LTgtMy41OC04LTgtOFptNS45MSA3aC0xLjk0Yy0uMS0xLjU3LS40Mi0zLS45MS00LjE1IDEuNDguODggMi41NSAyLjM4IDIuODUgNC4xNVpNOCAxNGMtLjQ1IDAtMS43Mi0xLjc3LTEuOTUtNWgzLjljLS4yMyAzLjIzLTEuNSA1LTEuOTUgNVpNNi4wNSA3QzYuMjggMy43NyA3LjU1IDIgOCAyYy40NSAwIDEuNzIgMS43NyAxLjk1IDVoLTMuOVpNNC45NCAyLjg1QzQuNDYgNCA0LjEzIDUuNDMgNC4wMyA3SDIuMDljLjMtMS43NyAxLjM3LTMuMjcgMi44NS00LjE1Wk0yLjA5IDloMS45NGMuMSAxLjU3LjQyIDMgLjkxIDQuMTVBNS45OTggNS45OTggMCAwIDEgMi4wOSA5Wm04Ljk3IDQuMTVjLjQ4LTEuMTUuODEtMi41OC45MS00LjE1aDEuOTRhNS45OTggNS45OTggMCAwIDEtMi44NSA0LjE1WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/walletlink/dist/components/icons/link-icon-svg.js
var require_link_icon_svg = __commonJS({
  "node_modules/walletlink/dist/components/icons/link-icon-svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE1LjYzNSAyLjExN2EzLjg4OSAzLjg4OSAwIDAgMC01LjUyMSAwTDYuODkgNS4zMzVBMy44OTQgMy44OTQgMCAwIDAgNS44IDguNzM5Yy4wODMuNTA2LjI2OCAxLjAxMS41NTMgMS40NjYuMTUxLjI1My4zMzYuNDcyLjUzNy42OTFsLjYyMS42MjQgMS4xNDEtMS4xNDYtLjYyLS42MjRhMi4xMDUgMi4xMDUgMCAwIDEtLjQ4Ny0uNzQxIDIuMzQgMi4zNCAwIDAgMSAuNTAzLTIuNTFsMy4yMDYtMy4yMmEyLjI5MyAyLjI5MyAwIDAgMSAzLjIzOSAwYy44OS44OTQuODkgMi4zNDMgMCAzLjI1M2wtMS41MjcgMS41MzNjLjIzNC42NC4zMzUgMS4zMzEuMzAyIDIuMDA1bDIuMzgzLTIuMzkyYzEuNTEtMS41MzQgMS40OTMtNC4wMjgtLjAxNy01LjU2MVoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBkPSJNMTEuMjcxIDcuNzQ1YTMuMTMgMy4xMyAwIDAgMC0uNTU0LS42OWwtLjYyLS42MjQtMS4xNDIgMS4xNDYuNjIxLjYyM2MuMjE4LjIyLjM4Ni40ODkuNDg3Ljc1OC4zMzUuODI2LjE2NyAxLjgyLS41MDQgMi40OTRsLTMuMjA1IDMuMjE5YTIuMjkzIDIuMjkzIDAgMCAxLTMuMjQgMCAyLjMxNiAyLjMxNiAwIDAgMSAwLTMuMjUybDEuNTI4LTEuNTM0YTQuODE1IDQuODE1IDAgMCAxLS4yODUtMi4wMDVsLTIuMzgzIDIuMzkzYTMuOTI3IDMuOTI3IDAgMCAwIDAgNS41NDQgMy45MDkgMy45MDkgMCAwIDAgNS41MzggMGwzLjIwNS0zLjIxOWEzLjk1OCAzLjk1OCAwIDAgMCAxLjA5MS0zLjQwNCA0LjIxMSA0LjIxMSAwIDAgMC0uNTM3LTEuNDQ5WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/walletlink/dist/components/icons/lock-icon-svg.js
var require_lock_icon_svg = __commonJS({
  "node_modules/walletlink/dist/components/icons/lock-icon-svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEgN3Y5aDE0VjdIMVptNy41IDQuMzlWMTRoLTF2LTIuNjFjLS40NC0uMTktLjc1LS42My0uNzUtMS4xNGExLjI1IDEuMjUgMCAwIDEgMi41IDBjMCAuNTEtLjMxLjk1LS43NSAxLjE0Wk01LjY3IDZWNC4zM0M1LjY3IDMuMDUgNi43MSAyIDggMnMyLjMzIDEuMDUgMi4zMyAyLjMzVjZoMlY0LjMzQzEyLjMzIDEuOTQgMTAuMzkgMCA4IDBTMy42NyAxLjk0IDMuNjcgNC4zM1Y2aDJaIiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
  }
});

// node_modules/walletlink/dist/components/icons/QRLogo.js
var require_QRLogo = __commonJS({
  "node_modules/walletlink/dist/components/icons/QRLogo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="50" cy="50" r="50" fill="white"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
</svg>

`;
  }
});

// node_modules/walletlink/dist/components/TryExtensionLinkDialog-css.js
var require_TryExtensionLinkDialog_css = __commonJS({
  "node_modules/walletlink/dist/components/TryExtensionLinkDialog-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-walletlink-extension-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-walletlink-css-reset .-walletlink-extension-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);transition:opacity .25s}.-walletlink-css-reset .-walletlink-extension-dialog-backdrop-hidden{opacity:0}.-walletlink-css-reset .-walletlink-extension-dialog-box{display:flex;position:relative;max-width:500px;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-walletlink-css-reset .-walletlink-extension-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-walletlink-css-reset .-walletlink-extension-dialog-box-top{display:flex;flex-direction:row;background-color:#fff;border-radius:8px;overflow:hidden;min-height:300px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-install-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;padding:32px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-install-region button{display:block;border-radius:8px;background-color:#1652f0;color:#fff;width:90%;min-width:fit-content;height:44px;margin-top:16px;font-size:16px;padding-left:16px;padding-right:16px;cursor:pointer;font-weight:500;text-align:center}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-info-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;background-color:#fafbfc}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description{display:flex;flex-direction:row;align-items:center;padding-top:14px;padding-bottom:14px;padding-left:24px;padding-right:32px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-icon-wrapper{display:block;position:relative;width:40px;height:40px;flex-shrink:0;flex-grow:0;border-radius:20px;background-color:#fff;box-shadow:0px 0px 8px rgba(0,0,0,.04),0px 16px 24px rgba(0,0,0,.06)}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-icon-wrapper img{position:absolute;top:0;bottom:0;left:0;right:0;margin:auto}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-text{margin-left:16px;flex-grow:1;font-size:13px;line-height:19px;color:#000;align-self:center}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom{display:flex;flex-direction:row;overflow:hidden;border-radius:8px;background-color:#fff;margin-top:8px}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description-region{display:flex;flex-direction:column;justify-content:center;padding:32px;flex-grow:1}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description{font-size:13px;line-height:19px;margin-top:12px;color:#aaa}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description a{font-size:inherit;line-height:inherit;color:#1652f0;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-region{position:relative;flex-shrink:0;display:flex;flex-direction:column;justify-content:center;padding-left:24px;padding-right:24px;padding-top:16px;padding-bottom:16px}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-wrapper{position:relative;display:block;padding:8px;border-radius:8px;box-shadow:0px 4px 12px rgba(0,0,0,.1)}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-wrapper img{display:block}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background-color:rgba(255,255,255,.95)}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-connecting>p{font-size:12px;font-weight:bold;color:#000;margin-top:16px}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:16px;right:16px;width:24px;height:24px;border-radius:12px;background-color:#fafbfc;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x{position:relative;display:block;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:1px;background-color:#000;transition:background-color .2s}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::before{transform:rotate(45deg)}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::after{transform:rotate(135deg)}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-a,.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-b{background-color:#000}.-walletlink-css-reset .-walletlink-extension-dialog-container{display:block}.-walletlink-css-reset .-walletlink-extension-dialog-container-hidden{display:none}.-walletlink-css-reset .-walletlink-extension-dialog h2{display:block;text-align:left;font-size:22px;font-weight:600;line-height:28px;color:#000}`;
  }
});

// node_modules/walletlink/dist/components/TryExtensionLinkDialog.js
var require_TryExtensionLinkDialog = __commonJS({
  "node_modules/walletlink/dist/components/TryExtensionLinkDialog.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TryExtensionLinkDialog = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), clsx_m_exports));
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var globe_icon_svg_1 = __importDefault(require_globe_icon_svg());
    var link_icon_svg_1 = __importDefault(require_link_icon_svg());
    var lock_icon_svg_1 = __importDefault(require_lock_icon_svg());
    var QRLogo_1 = __importDefault(require_QRLogo());
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var TryExtensionLinkDialog_css_1 = __importDefault(require_TryExtensionLinkDialog_css());
    var TryExtensionLinkDialog = (props) => {
      const [isContainerHidden, setContainerHidden] = (0, hooks_1.useState)(!props.isOpen);
      const [isDialogHidden, setDialogHidden] = (0, hooks_1.useState)(!props.isOpen);
      (0, hooks_1.useEffect)(() => {
        const { isOpen } = props;
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      return (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-extension-dialog-container", isContainerHidden && "-walletlink-extension-dialog-container-hidden") }, (0, preact_1.h)("style", null, TryExtensionLinkDialog_css_1.default), (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-extension-dialog-backdrop", isDialogHidden && "-walletlink-extension-dialog-backdrop-hidden") }), (0, preact_1.h)("div", { class: "-walletlink-extension-dialog" }, (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-extension-dialog-box", isDialogHidden && "-walletlink-extension-dialog-box-hidden") }, (0, preact_1.h)(TryExtensionBox, { onInstallClick: () => {
        window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
      } }), !props.connectDisabled ? (0, preact_1.h)(ScanQRBox, { darkMode: props.darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, walletLinkUrl: props.walletLinkUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection }) : null, props.onCancel && (0, preact_1.h)(CancelButton, { onClick: props.onCancel }))));
    };
    exports.TryExtensionLinkDialog = TryExtensionLinkDialog;
    var TryExtensionBox = (props) => {
      return (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-install-region" }, (0, preact_1.h)("h2", null, "Try the Coinbase Wallet extension"), (0, preact_1.h)("button", { onClick: props.onInstallClick }, "Install")), (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-info-region" }, (0, preact_1.h)(DescriptionItem, { icon: link_icon_svg_1.default, text: "Connect to crypto apps with one click" }), (0, preact_1.h)(DescriptionItem, { icon: lock_icon_svg_1.default, text: "Your private key is stored securely" }), (0, preact_1.h)(DescriptionItem, { icon: globe_icon_svg_1.default, text: "Works with Ethereum, Polygon, and more" })));
    };
    var ScanQRBox = (props) => {
      const serverUrl = window.encodeURIComponent(props.walletLinkUrl);
      const sessionIdKey = props.isParentConnection ? "parent-id" : "id";
      const qrUrl = `${props.walletLinkUrl}/#/link?${sessionIdKey}=${props.sessionId}&secret=${props.sessionSecret}&server=${serverUrl}&v=1`;
      return (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-description-region" }, (0, preact_1.h)("h2", null, "Or scan to connect"), (0, preact_1.h)("body", { class: "-walletlink-extension-dialog-box-bottom-description" }, "Open ", (0, preact_1.h)("a", { href: "https://wallet.coinbase.com/" }, "Coinbase Wallet"), " on your mobile phone and scan")), (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-region" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-wrapper" }, (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 150, height: 150, fgColor: "#000", bgColor: "transparent", image: {
        svg: QRLogo_1.default,
        width: 34,
        height: 34
      } })), (0, preact_1.h)("input", { type: "hidden", value: qrUrl }), !props.isConnected && (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-connecting" }, (0, preact_1.h)(Spinner_1.Spinner, { size: 36, color: "#000" }), (0, preact_1.h)("p", null, "Connecting..."))));
    };
    var DescriptionItem = (props) => {
      return (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-description" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-description-icon-wrapper" }, (0, preact_1.h)("img", { src: props.icon })), (0, preact_1.h)("body", { class: "-walletlink-extension-dialog-box-top-description-text" }, props.text));
    };
    var CancelButton = (props) => (0, preact_1.h)("button", { class: "-walletlink-extension-dialog-box-cancel", onClick: props.onClick }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-cancel-x" }));
  }
});

// node_modules/walletlink/dist/components/LinkFlow.js
var require_LinkFlow = __commonJS({
  "node_modules/walletlink/dist/components/LinkFlow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkFlow = void 0;
    var preact_1 = (init_preact_module(), preact_module_exports);
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var LinkDialog_1 = require_LinkDialog();
    var TryExtensionLinkDialog_1 = require_TryExtensionLinkDialog();
    var LinkFlow = class {
      constructor(options) {
        this.extensionUI$ = new rxjs_1.BehaviorSubject({});
        this.subscriptions = new rxjs_1.Subscription();
        this.isConnected = false;
        this.isOpen = false;
        this.onCancel = null;
        this.root = null;
        this.connectDisabled = false;
        this.darkMode = options.darkMode;
        this.version = options.version;
        this.sessionId = options.sessionId;
        this.sessionSecret = options.sessionSecret;
        this.walletLinkUrl = options.walletLinkUrl;
        this.isParentConnection = options.isParentConnection;
        this.connected$ = options.connected$;
        fetch("https://api.wallet.coinbase.com/rpc/v2/getFeatureFlags").then((res) => res.json()).then((json) => {
          const enabled = json.result.desktop.extension_ui;
          if (typeof enabled === "undefined") {
            this.extensionUI$.next({ value: false });
          } else {
            this.extensionUI$.next({ value: enabled });
          }
        }).catch((err) => {
          console.error("Couldn't fetch feature flags - ", err);
          this.extensionUI$.next({ value: false });
        });
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-walletlink-link-flow-root";
        el.appendChild(this.root);
        this.render();
        this.subscriptions.add(this.connected$.subscribe((v8) => {
          if (this.isConnected !== v8) {
            this.isConnected = v8;
            this.render();
          }
        }));
      }
      detach() {
        var _a2;
        if (!this.root) {
          return;
        }
        this.subscriptions.unsubscribe();
        (0, preact_1.render)(null, this.root);
        (_a2 = this.root.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.root);
      }
      setConnectDisabled(connectDisabled) {
        this.connectDisabled = connectDisabled;
      }
      open(options) {
        this.isOpen = true;
        this.onCancel = options.onCancel;
        this.render();
      }
      close() {
        this.isOpen = false;
        this.onCancel = null;
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        const subscription = this.extensionUI$.pipe((0, operators_1.first)((enabled) => enabled.value !== void 0)).subscribe((enabled) => {
          if (!this.root) {
            return;
          }
          (0, preact_1.render)(enabled.value ? (0, preact_1.h)(TryExtensionLinkDialog_1.TryExtensionLinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, walletLinkUrl: this.walletLinkUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, onCancel: this.onCancel, connectDisabled: this.connectDisabled }) : (0, preact_1.h)(LinkDialog_1.LinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, walletLinkUrl: this.walletLinkUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, onCancel: this.onCancel }), this.root);
        });
        this.subscriptions.add(subscription);
      }
    };
    exports.LinkFlow = LinkFlow;
  }
});

// node_modules/walletlink/dist/components/Snackbar-css.js
var require_Snackbar_css = __commonJS({
  "node_modules/walletlink/dist/components/Snackbar-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-walletlink-css-reset .-gear-container *{user-select:none}.-walletlink-css-reset .-gear-container svg{opacity:0;position:absolute}.-walletlink-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-walletlink-css-reset .-walletlink-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-walletlink-css-reset .-walletlink-snackbar *{user-select:none}.-walletlink-css-reset .-walletlink-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-walletlink-css-reset .-walletlink-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-walletlink-css-reset .-walletlink-snackbar-instance-header *{cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-walletlink-css-reset .-walletlink-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-walletlink-css-reset .-walletlink-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-walletlink-css-reset .-walletlink-snackbar-instance-expanded .-walletlink-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
  }
});

// node_modules/walletlink/dist/components/Snackbar.js
var require_Snackbar = __commonJS({
  "node_modules/walletlink/dist/components/Snackbar.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Snackbar = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), clsx_m_exports));
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var Snackbar_css_1 = __importDefault(require_Snackbar_css());
    var cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
    var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
    var Snackbar = class {
      constructor(options) {
        this.items = new Map();
        this.nextItemKey = 0;
        this.root = null;
        this.darkMode = options.darkMode;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-walletlink-snackbar-root";
        el.appendChild(this.root);
        this.render();
      }
      presentItem(itemProps) {
        const key2 = this.nextItemKey++;
        this.items.set(key2, itemProps);
        this.render();
        return () => {
          this.items.delete(key2);
          this.render();
        };
      }
      clear() {
        this.items.clear();
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        (0, preact_1.render)((0, preact_1.h)("div", null, (0, preact_1.h)(SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key2, itemProps]) => (0, preact_1.h)(SnackbarInstance, Object.assign({}, itemProps, { key: key2 }))))), this.root);
      }
    };
    exports.Snackbar = Snackbar;
    var SnackbarContainer = (props) => (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-container") }, (0, preact_1.h)("style", null, Snackbar_css_1.default), (0, preact_1.h)("div", { class: "-walletlink-snackbar" }, props.children));
    var SnackbarInstance = ({ autoExpand, message, menuItems }) => {
      const [hidden, setHidden] = (0, hooks_1.useState)(true);
      const [expanded, setExpanded] = (0, hooks_1.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setHidden(false);
          }, 1),
          window.setTimeout(() => {
            setExpanded(true);
          }, 1e4)
        ];
        return () => {
          timers.forEach(window.clearTimeout);
        };
      });
      const toggleExpanded = () => {
        setExpanded(!expanded);
      };
      return (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-instance", hidden && "-walletlink-snackbar-instance-hidden", expanded && "-walletlink-snackbar-instance-expanded") }, (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-header", onClick: toggleExpanded }, (0, preact_1.h)("img", { src: cblogo, class: "-walletlink-snackbar-instance-header-cblogo" }), (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-header-message" }, message), (0, preact_1.h)("div", { class: "-gear-container" }, !expanded && (0, preact_1.h)("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })), (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" }))), menuItems && menuItems.length > 0 && (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-menu" }, menuItems.map((action, i5) => (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-instance-menu-item", action.isRed && "-walletlink-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i5 }, (0, preact_1.h)("svg", { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })), (0, preact_1.h)("span", { class: (0, clsx_1.default)("-walletlink-snackbar-instance-menu-item-info", action.isRed && "-walletlink-snackbar-instance-menu-item-info-is-red") }, action.info)))));
    };
  }
});

// node_modules/walletlink/dist/lib/cssReset-css.js
var require_cssReset_css = __commonJS({
  "node_modules/walletlink/dist/lib/cssReset-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `@namespace svg "http://www.w3.org/2000/svg";.-walletlink-css-reset,.-walletlink-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;bottom:auto;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:block;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;left:auto;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";right:auto;tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;top:auto;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;width:auto;word-spacing:normal;z-index:auto}.-walletlink-css-reset *{box-sizing:border-box;display:initial;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-walletlink-css-reset [class*=container]{margin:0;padding:0}.-walletlink-css-reset style{display:none}`;
  }
});

// node_modules/walletlink/dist/lib/cssReset.js
var require_cssReset = __commonJS({
  "node_modules/walletlink/dist/lib/cssReset.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectCssReset = void 0;
    var cssReset_css_1 = __importDefault(require_cssReset_css());
    function injectCssReset() {
      const styleEl = document.createElement("style");
      styleEl.type = "text/css";
      styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
      document.documentElement.appendChild(styleEl);
    }
    exports.injectCssReset = injectCssReset;
  }
});

// node_modules/walletlink/dist/provider/WalletLinkUI.js
var require_WalletLinkUI = __commonJS({
  "node_modules/walletlink/dist/provider/WalletLinkUI.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkUI = void 0;
    var WalletLinkUI = class {
      constructor(_10) {
      }
      setConnectDisabled(_10) {
      }
    };
    exports.WalletLinkUI = WalletLinkUI;
  }
});

// node_modules/walletlink/dist/provider/WalletLinkSdkUI.js
var require_WalletLinkSdkUI = __commonJS({
  "node_modules/walletlink/dist/provider/WalletLinkSdkUI.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkSdkUI = void 0;
    var LinkFlow_1 = require_LinkFlow();
    var Snackbar_1 = require_Snackbar();
    var cssReset_1 = require_cssReset();
    var WalletLinkUI_1 = require_WalletLinkUI();
    var WalletLinkSdkUI = class extends WalletLinkUI_1.WalletLinkUI {
      constructor(options) {
        super(options);
        this.attached = false;
        this.snackbar = new Snackbar_1.Snackbar({
          darkMode: options.darkMode
        });
        this.linkFlow = new LinkFlow_1.LinkFlow({
          darkMode: options.darkMode,
          version: options.version,
          sessionId: options.session.id,
          sessionSecret: options.session.secret,
          walletLinkUrl: options.walletLinkUrl,
          connected$: options.connected$,
          isParentConnection: false
        });
      }
      attach() {
        if (this.attached) {
          throw new Error("WalletLinkUI is already attached");
        }
        const el = document.documentElement;
        const container = document.createElement("div");
        container.className = "-walletlink-css-reset";
        el.appendChild(container);
        this.linkFlow.attach(container);
        this.snackbar.attach(container);
        this.attached = true;
        (0, cssReset_1.injectCssReset)();
      }
      setConnectDisabled(connectDisabled) {
        this.linkFlow.setConnectDisabled(connectDisabled);
      }
      addEthereumChain(options) {
      }
      switchEthereumChain(options) {
      }
      requestEthereumAccounts(options) {
        this.linkFlow.open({ onCancel: options.onCancel });
      }
      hideRequestEthereumAccounts() {
        this.linkFlow.close();
      }
      signEthereumMessage(_10) {
      }
      signEthereumTransaction(_10) {
      }
      submitEthereumTransaction(_10) {
      }
      ethereumAddressFromSignedMessage(_10) {
      }
      showConnecting(options) {
        let snackbarProps;
        if (options.isUnlinkedErrorState) {
          snackbarProps = {
            autoExpand: true,
            message: "Connection lost",
            menuItems: [
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        } else {
          snackbarProps = {
            message: "Confirm on phone",
            menuItems: [
              {
                isRed: true,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: options.onCancel
              },
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        }
        return this.snackbar.presentItem(snackbarProps);
      }
      reloadUI() {
        document.location.reload();
      }
      inlineAccountsResponse() {
        return false;
      }
      inlineAddEthereumChain(chainId) {
        return false;
      }
      inlineSwitchEthereumChain() {
        return false;
      }
      isStandalone() {
        return false;
      }
    };
    exports.WalletLinkSdkUI = WalletLinkSdkUI;
  }
});

// node_modules/bind-decorator/index.js
var require_bind_decorator = __commonJS({
  "node_modules/bind-decorator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants;
    (function(constants2) {
      constants2.typeOfFunction = "function";
      constants2.boolTrue = true;
    })(constants || (constants = {}));
    function bind(target, propertyKey, descriptor) {
      if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
        throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
      }
      return {
        configurable: constants.boolTrue,
        get: function() {
          var bound = descriptor.value.bind(this);
          Object.defineProperty(this, propertyKey, {
            value: bound,
            configurable: constants.boolTrue,
            writable: constants.boolTrue
          });
          return bound;
        }
      };
    }
    exports.bind = bind;
    exports.default = bind;
  }
});

// node_modules/walletlink/dist/connection/ClientMessage.js
var require_ClientMessage = __commonJS({
  "node_modules/walletlink/dist/connection/ClientMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientMessagePublishEvent = exports.ClientMessageSetSessionConfig = exports.ClientMessageGetSessionConfig = exports.ClientMessageIsLinked = exports.ClientMessageHostSession = void 0;
    function ClientMessageHostSession(params) {
      return Object.assign({ type: "HostSession" }, params);
    }
    exports.ClientMessageHostSession = ClientMessageHostSession;
    function ClientMessageIsLinked(params) {
      return Object.assign({ type: "IsLinked" }, params);
    }
    exports.ClientMessageIsLinked = ClientMessageIsLinked;
    function ClientMessageGetSessionConfig(params) {
      return Object.assign({ type: "GetSessionConfig" }, params);
    }
    exports.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
    function ClientMessageSetSessionConfig(params) {
      return Object.assign({ type: "SetSessionConfig" }, params);
    }
    exports.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
    function ClientMessagePublishEvent(params) {
      return Object.assign({ type: "PublishEvent" }, params);
    }
    exports.ClientMessagePublishEvent = ClientMessagePublishEvent;
  }
});

// node_modules/walletlink/dist/connection/RxWebSocket.js
var require_RxWebSocket = __commonJS({
  "node_modules/walletlink/dist/connection/RxWebSocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RxWebSocket = exports.ConnectionState = void 0;
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
      ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
    })(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
    var RxWebSocket = class {
      constructor(url, WebSocketClass = WebSocket) {
        this.WebSocketClass = WebSocketClass;
        this.webSocket = null;
        this.connectionStateSubject = new rxjs_1.BehaviorSubject(ConnectionState.DISCONNECTED);
        this.incomingDataSubject = new rxjs_1.Subject();
        this.url = url.replace(/^http/, "ws");
      }
      connect() {
        if (this.webSocket) {
          return (0, rxjs_1.throwError)(new Error("webSocket object is not null"));
        }
        return new rxjs_1.Observable((obs) => {
          let webSocket;
          try {
            this.webSocket = webSocket = new this.WebSocketClass(this.url);
          } catch (err) {
            obs.error(err);
            return;
          }
          this.connectionStateSubject.next(ConnectionState.CONNECTING);
          webSocket.onclose = (evt) => {
            this.clearWebSocket();
            obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
            this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
          };
          webSocket.onopen = (_10) => {
            obs.next();
            obs.complete();
            this.connectionStateSubject.next(ConnectionState.CONNECTED);
          };
          webSocket.onmessage = (evt) => {
            this.incomingDataSubject.next(evt.data);
          };
        }).pipe((0, operators_1.take)(1));
      }
      disconnect() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.clearWebSocket();
        this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        try {
          webSocket.close();
        } catch (_a2) {
        }
      }
      get connectionState$() {
        return this.connectionStateSubject.asObservable();
      }
      get incomingData$() {
        return this.incomingDataSubject.asObservable();
      }
      get incomingJSONData$() {
        return this.incomingData$.pipe((0, operators_1.flatMap)((m5) => {
          let j5;
          try {
            j5 = JSON.parse(m5);
          } catch (err) {
            return (0, rxjs_1.empty)();
          }
          return (0, rxjs_1.of)(j5);
        }));
      }
      sendData(data) {
        const { webSocket } = this;
        if (!webSocket) {
          throw new Error("websocket is not connected");
        }
        webSocket.send(data);
      }
      clearWebSocket() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.webSocket = null;
        webSocket.onclose = null;
        webSocket.onerror = null;
        webSocket.onmessage = null;
        webSocket.onopen = null;
      }
    };
    exports.RxWebSocket = RxWebSocket;
  }
});

// node_modules/walletlink/dist/connection/ServerMessage.js
var require_ServerMessage = __commonJS({
  "node_modules/walletlink/dist/connection/ServerMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isServerMessageFail = void 0;
    function isServerMessageFail(msg) {
      return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
    }
    exports.isServerMessageFail = isServerMessageFail;
  }
});

// node_modules/walletlink/dist/connection/WalletLinkConnection.js
var require_WalletLinkConnection = __commonJS({
  "node_modules/walletlink/dist/connection/WalletLinkConnection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkConnection = void 0;
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var init_1 = require_init();
    var Session_1 = require_Session();
    var types_1 = require_types2();
    var ClientMessage_1 = require_ClientMessage();
    var RxWebSocket_1 = require_RxWebSocket();
    var ServerMessage_1 = require_ServerMessage();
    var HEARTBEAT_INTERVAL = 1e4;
    var REQUEST_TIMEOUT = 6e4;
    var WalletLinkConnection = class {
      constructor(sessionId, sessionKey, serverUrl, walletLinkAnalytics, WebSocketClass = WebSocket) {
        this.sessionId = sessionId;
        this.sessionKey = sessionKey;
        this.subscriptions = new rxjs_1.Subscription();
        this.destroyed = false;
        this.lastHeartbeatResponse = 0;
        this.nextReqId = (0, types_1.IntNumber)(1);
        this.connectedSubject = new rxjs_1.BehaviorSubject(false);
        this.linkedSubject = new rxjs_1.BehaviorSubject(false);
        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);
        const ws = new RxWebSocket_1.RxWebSocket(serverUrl + "/rpc", WebSocketClass);
        this.ws = ws;
        this.walletLinkAnalytics = walletLinkAnalytics;
        this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)((state) => this.walletLinkAnalytics.sendEvent(init_1.EVENTS.CONNECTED_STATE_CHANGE, {
          state,
          sessionIdHash: Session_1.Session.hash(sessionId)
        })), (0, operators_1.skip)(1), (0, operators_1.filter)((cs) => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), (0, operators_1.delay)(5e3), (0, operators_1.filter)((_10) => !this.destroyed), (0, operators_1.flatMap)((_10) => ws.connect()), (0, operators_1.retry)()).subscribe());
        this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.skip)(2), (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, this.authenticate().pipe((0, operators_1.tap)((_10) => this.sendIsLinked()), (0, operators_1.tap)((_10) => this.sendGetSessionConfig()), (0, operators_1.map)((_10) => true)), (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)((_10) => (0, rxjs_1.of)(false))).subscribe((connected) => this.connectedSubject.next(connected)));
        this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.skip)(1), (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)))).subscribe((i5) => i5 === 0 ? this.updateLastHeartbeat() : this.heartbeat()));
        this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)((m5) => m5 === "h")).subscribe((_10) => this.updateLastHeartbeat()));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m5) => ["IsLinkedOK", "Linked"].includes(m5.type))).subscribe((m5) => {
          const msg = m5;
          this.walletLinkAnalytics.sendEvent(init_1.EVENTS.LINKED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            linked: msg.linked,
            type: m5.type,
            onlineGuests: msg.onlineGuests
          });
          this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
        }));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m5) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m5.type))).subscribe((m5) => {
          const msg = m5;
          this.walletLinkAnalytics.sendEvent(init_1.EVENTS.SESSION_CONFIG_RECEIVED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
          });
          this.sessionConfigSubject.next({
            webhookId: msg.webhookId,
            webhookUrl: msg.webhookUrl,
            metadata: msg.metadata
          });
        }));
      }
      connect() {
        if (this.destroyed) {
          throw new Error("instance is destroyed");
        }
        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.STARTED_CONNECTING, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.ws.connect().subscribe();
      }
      destroy() {
        this.subscriptions.unsubscribe();
        this.ws.disconnect();
        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.DISCONNECTED, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.destroyed = true;
      }
      get isDestroyed() {
        return this.destroyed;
      }
      get connected$() {
        return this.connectedSubject.asObservable();
      }
      get onceConnected$() {
        return this.connected$.pipe((0, operators_1.filter)((v8) => v8), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get linked$() {
        return this.linkedSubject.asObservable();
      }
      get onceLinked$() {
        return this.linked$.pipe((0, operators_1.filter)((v8) => v8), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get sessionConfig$() {
        return this.sessionConfigSubject.asObservable();
      }
      get incomingEvent$() {
        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)((m5) => {
          if (m5.type !== "Event") {
            return false;
          }
          const sme = m5;
          return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
        }), (0, operators_1.map)((m5) => m5));
      }
      setSessionMetadata(key2, value) {
        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          metadata: { [key2]: value }
        });
        return this.onceConnected$.pipe((0, operators_1.flatMap)((_10) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to set session metadata");
          }
        }));
      }
      publishEvent(event, data, callWebhook = false) {
        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          event,
          data,
          callWebhook
        });
        return this.onceLinked$.pipe((0, operators_1.flatMap)((_10) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to publish event");
          }
          return res.eventId;
        }));
      }
      sendData(message) {
        this.ws.sendData(JSON.stringify(message));
      }
      updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now();
      }
      heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
          this.ws.disconnect();
          return;
        }
        try {
          this.ws.sendData("h");
        } catch (_a2) {
        }
      }
      makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
        const reqId = message.id;
        try {
          this.sendData(message);
        } catch (err) {
          return (0, rxjs_1.throwError)(err);
        }
        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout2, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)((m5) => m5.id === reqId), (0, operators_1.take)(1));
      }
      authenticate() {
        const msg = (0, ClientMessage_1.ClientMessageHostSession)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          sessionKey: this.sessionKey
        });
        return this.makeRequest(msg).pipe((0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to authentcate");
          }
        }));
      }
      sendIsLinked() {
        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
      sendGetSessionConfig() {
        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
    };
    exports.WalletLinkConnection = WalletLinkConnection;
  }
});

// node_modules/walletlink/dist/relay/aes256gcm.js
var require_aes256gcm = __commonJS({
  "node_modules/walletlink/dist/relay/aes256gcm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = void 0;
    var rxjs_1 = (init_esm5(), esm5_exports);
    var util_1 = require_util2();
    async function encrypt3(plainText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      const ivBytes = crypto.getRandomValues(new Uint8Array(12));
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { "name": "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const enc = new TextEncoder();
      const encryptedResult = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: ivBytes
      }, secretKey, enc.encode(plainText));
      const tagLength = 16;
      const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
      const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
      const authTagBytes = new Uint8Array(authTag);
      const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
      const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
      return (0, util_1.uint8ArrayToHex)(concatted);
    }
    exports.encrypt = encrypt3;
    function decrypt4(cipherText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      return new rxjs_1.Observable((subscriber) => {
        void async function() {
          const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { "name": "aes-gcm" }, false, ["encrypt", "decrypt"]);
          const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);
          const ivBytes = encrypted.slice(0, 12);
          const authTagBytes = encrypted.slice(12, 28);
          const encryptedPlaintextBytes = encrypted.slice(28);
          const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
          const algo = {
            name: "AES-GCM",
            iv: new Uint8Array(ivBytes)
          };
          try {
            const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
            const decoder = new TextDecoder();
            subscriber.next(decoder.decode(decrypted));
            subscriber.complete();
          } catch (err) {
            subscriber.error(err);
          }
        }();
      });
    }
    exports.decrypt = decrypt4;
  }
});

// node_modules/walletlink/dist/relay/Web3Method.js
var require_Web3Method = __commonJS({
  "node_modules/walletlink/dist/relay/Web3Method.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Method = void 0;
    var Web3Method;
    (function(Web3Method2) {
      Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
      Web3Method2["signEthereumMessage"] = "signEthereumMessage";
      Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
      Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
      Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
      Web3Method2["scanQRCode"] = "scanQRCode";
      Web3Method2["generic"] = "generic";
      Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
      Web3Method2["addEthereumChain"] = "addEthereumChain";
      Web3Method2["switchEthereumChain"] = "switchEthereumChain";
      Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
    })(Web3Method = exports.Web3Method || (exports.Web3Method = {}));
  }
});

// node_modules/walletlink/dist/relay/RelayMessage.js
var require_RelayMessage = __commonJS({
  "node_modules/walletlink/dist/relay/RelayMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelayMessageType = void 0;
    var RelayMessageType;
    (function(RelayMessageType2) {
      RelayMessageType2["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
      RelayMessageType2["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
      RelayMessageType2["LINKED"] = "LINKED";
      RelayMessageType2["UNLINKED"] = "UNLINKED";
      RelayMessageType2["WEB3_REQUEST"] = "WEB3_REQUEST";
      RelayMessageType2["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
      RelayMessageType2["WEB3_RESPONSE"] = "WEB3_RESPONSE";
    })(RelayMessageType = exports.RelayMessageType || (exports.RelayMessageType = {}));
  }
});

// node_modules/walletlink/dist/relay/Web3RequestCanceledMessage.js
var require_Web3RequestCanceledMessage = __commonJS({
  "node_modules/walletlink/dist/relay/Web3RequestCanceledMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestCanceledMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestCanceledMessage(id2) {
      return { type: RelayMessage_1.RelayMessageType.WEB3_REQUEST_CANCELED, id: id2 };
    }
    exports.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
  }
});

// node_modules/walletlink/dist/relay/Web3RequestMessage.js
var require_Web3RequestMessage = __commonJS({
  "node_modules/walletlink/dist/relay/Web3RequestMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_REQUEST }, params);
    }
    exports.Web3RequestMessage = Web3RequestMessage;
  }
});

// node_modules/walletlink/dist/relay/Web3Response.js
var require_Web3Response = __commonJS({
  "node_modules/walletlink/dist/relay/Web3Response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumAddressFromSignedMessageResponse = exports.SubmitEthereumTransactionResponse = exports.SignEthereumTransactionResponse = exports.SignEthereumMessageResponse = exports.isRequestEthereumAccountsResponse = exports.RequestEthereumAccountsResponse = exports.SwitchEthereumChainResponse = exports.AddEthereumChainResponse = exports.ErrorResponse = void 0;
    var Web3Method_1 = require_Web3Method();
    function ErrorResponse(method, errorMessage, errorCode) {
      return { method, errorMessage, errorCode };
    }
    exports.ErrorResponse = ErrorResponse;
    function AddEthereumChainResponse(addResponse) {
      return {
        method: Web3Method_1.Web3Method.addEthereumChain,
        result: addResponse
      };
    }
    exports.AddEthereumChainResponse = AddEthereumChainResponse;
    function SwitchEthereumChainResponse(switchResponse) {
      return {
        method: Web3Method_1.Web3Method.switchEthereumChain,
        result: switchResponse
      };
    }
    exports.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
    function RequestEthereumAccountsResponse(addresses) {
      return { method: Web3Method_1.Web3Method.requestEthereumAccounts, result: addresses };
    }
    exports.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
    function isRequestEthereumAccountsResponse(res) {
      return res && res.method === Web3Method_1.Web3Method.requestEthereumAccounts;
    }
    exports.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
    function SignEthereumMessageResponse(signature2) {
      return { method: Web3Method_1.Web3Method.signEthereumMessage, result: signature2 };
    }
    exports.SignEthereumMessageResponse = SignEthereumMessageResponse;
    function SignEthereumTransactionResponse(signedData) {
      return { method: Web3Method_1.Web3Method.signEthereumTransaction, result: signedData };
    }
    exports.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
    function SubmitEthereumTransactionResponse(txHash) {
      return { method: Web3Method_1.Web3Method.submitEthereumTransaction, result: txHash };
    }
    exports.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
    function EthereumAddressFromSignedMessageResponse(address) {
      return {
        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
        result: address
      };
    }
    exports.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
  }
});

// node_modules/walletlink/dist/relay/Web3ResponseMessage.js
var require_Web3ResponseMessage = __commonJS({
  "node_modules/walletlink/dist/relay/Web3ResponseMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWeb3ResponseMessage = exports.Web3ResponseMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3ResponseMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
    }
    exports.Web3ResponseMessage = Web3ResponseMessage;
    function isWeb3ResponseMessage(msg) {
      return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
    }
    exports.isWeb3ResponseMessage = isWeb3ResponseMessage;
  }
});

// node_modules/walletlink/dist/relay/WalletLinkRelay.js
var require_WalletLinkRelay = __commonJS({
  "node_modules/walletlink/dist/relay/WalletLinkRelay.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o5, v8) {
      Object.defineProperty(o5, "default", { enumerable: true, value: v8 });
    } : function(o5, v8) {
      o5["default"] = v8;
    });
    var __decorate = exports && exports.__decorate || function(decorators, target, key2, desc) {
      var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d5;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r6 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i5 = decorators.length - 1; i5 >= 0; i5--)
          if (d5 = decorators[i5])
            r6 = (c5 < 3 ? d5(r6) : c5 > 3 ? d5(target, key2, r6) : d5(target, key2)) || r6;
      return c5 > 3 && r6 && Object.defineProperty(target, key2, r6), r6;
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k5 in mod)
          if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
            __createBinding(result, mod, k5);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkRelay = void 0;
    var bind_decorator_1 = __importDefault(require_bind_decorator());
    var eth_rpc_errors_1 = require_dist9();
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var WalletLinkAnalytics_1 = require_WalletLinkAnalytics();
    var WalletLinkConnection_1 = require_WalletLinkConnection();
    var init_1 = require_init();
    var util_1 = require_util2();
    var aes256gcm = __importStar(require_aes256gcm());
    var Session_1 = require_Session();
    var WalletLinkRelayAbstract_1 = require_WalletLinkRelayAbstract();
    var Web3Method_1 = require_Web3Method();
    var Web3RequestCanceledMessage_1 = require_Web3RequestCanceledMessage();
    var Web3RequestMessage_1 = require_Web3RequestMessage();
    var Web3Response_1 = require_Web3Response();
    var Web3ResponseMessage_1 = require_Web3ResponseMessage();
    var WalletLinkRelay = class extends WalletLinkRelayAbstract_1.WalletLinkRelayAbstract {
      constructor(options) {
        super();
        this.accountsCallback = null;
        this.chainCallback = null;
        this.appName = "";
        this.appLogoUrl = null;
        this.subscriptions = new rxjs_1.Subscription();
        this.walletLinkUrl = options.walletLinkUrl;
        this.storage = options.storage;
        this._session = Session_1.Session.load(options.storage) || new Session_1.Session(options.storage).save();
        this.relayEventManager = options.relayEventManager;
        this.walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1.WalletLinkAnalytics();
        this.connection = new WalletLinkConnection_1.WalletLinkConnection(this._session.id, this._session.key, this.walletLinkUrl, this.walletLinkAnalytics);
        this.subscriptions.add(this.connection.incomingEvent$.pipe((0, operators_1.filter)((m5) => m5.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
        this.subscriptions.add(this.connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
          var _a2;
          this.isLinked = linked;
          const cachedAddresses = this.storage.getItem(WalletLinkRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
          this.isUnlinkedErrorState = false;
          if (cachedAddresses) {
            const addresses = cachedAddresses.split(" ");
            const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
            if (addresses[0] !== "" && !linked) {
              if (!wasConnectedViaStandalone) {
                this.isUnlinkedErrorState = true;
                const sessionIdHash = this.getSessionIdHash();
                (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.UNLINKED_ERROR_STATE, { sessionIdHash });
              }
            }
          }
        })).subscribe());
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => !!c5.metadata && c5.metadata.__destroyed === "1")).subscribe(() => {
          var _a2;
          const alreadyDestroyed = this.connection.isDestroyed;
          (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.METADATA_DESTROYED, {
            alreadyDestroyed,
            sessionIdHash: this.getSessionIdHash()
          });
          return this.resetAndReload();
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.WalletUsername, this._session.secret))).subscribe({
          next: (walletUsername) => {
            this.storage.setItem(WalletLinkRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
          },
          error: () => {
            var _a2;
            (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "username"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.AppVersion, this._session.secret))).subscribe({
          next: (appVersion) => {
            this.storage.setItem(WalletLinkRelayAbstract_1.APP_VERSION_KEY, appVersion);
          },
          error: () => {
            var _a2;
            (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appversion"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.ChainId !== void 0 && c5.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c5) => (0, rxjs_1.zip)(aes256gcm.decrypt(c5.metadata.ChainId, this._session.secret), aes256gcm.decrypt(c5.metadata.JsonRpcUrl, this._session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
          next: ([chainId, jsonRpcUrl]) => {
            if (this.chainCallback) {
              this.chainCallback(chainId, jsonRpcUrl);
            }
          },
          error: () => {
            var _a2;
            (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "chainId|jsonRpcUrl"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.EthereumAddress, this._session.secret))).subscribe({
          next: (selectedAddress) => {
            if (this.accountsCallback) {
              this.accountsCallback([selectedAddress]);
            }
            if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {
              Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id2) => {
                const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
                  id: id2,
                  response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                    selectedAddress
                  ])
                });
                this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 }));
              });
              WalletLinkRelay.accountRequestCallbackIds.clear();
            }
          },
          error: () => {
            var _a2;
            (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "selectedAddress"
            });
          }
        }));
        this.ui = options.walletLinkUIConstructor({
          walletLinkUrl: options.walletLinkUrl,
          version: options.version,
          darkMode: options.darkMode,
          session: this._session,
          connected$: this.connection.connected$
        });
        this.connection.connect();
      }
      attachUI() {
        this.ui.attach();
      }
      resetAndReload() {
        this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_10) => (0, rxjs_1.of)(null))).subscribe((_10) => {
          var _a2, _b, _c;
          try {
            this.subscriptions.unsubscribe();
          } catch (err) {
            (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error unsubscribing"
            });
          }
          (_b = this.walletLinkAnalytics) === null || _b === void 0 ? void 0 : _b.sendEvent(init_1.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash()
          });
          this.connection.destroy();
          const storedSession = Session_1.Session.load(this.storage);
          if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
            this.storage.clear();
          } else if (storedSession) {
            (_c = this.walletLinkAnalytics) === null || _c === void 0 ? void 0 : _c.sendEvent(init_1.EVENTS.SKIPPED_CLEARING_SESSION, {
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: Session_1.Session.hash(storedSession.id)
            });
          }
          this.ui.reloadUI();
        }, (err) => {
          var _a2;
          (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${err}`,
            sessionIdHash: this.getSessionIdHash()
          });
        });
      }
      setAppInfo(appName, appLogoUrl) {
        this.appName = appName;
        this.appLogoUrl = appLogoUrl;
      }
      getStorageItem(key2) {
        return this.storage.getItem(key2);
      }
      get session() {
        return this._session;
      }
      setStorageItem(key2, value) {
        this.storage.setItem(key2, value);
      }
      signEthereumMessage(message, address, addPrefix, typedDataJson) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            address,
            addPrefix,
            typedDataJson: typedDataJson || null
          }
        });
      }
      ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            signature: (0, util_1.hexStringFromBuffer)(signature2, true),
            addPrefix
          }
        });
      }
      signEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: false
          }
        });
      }
      signAndSubmitEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,
            maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: true
          }
        });
      }
      submitEthereumTransaction(signedTransaction, chainId) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.submitEthereumTransaction,
          params: {
            signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),
            chainId
          }
        });
      }
      scanQRCode(regExp) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.scanQRCode,
          params: { regExp }
        });
      }
      genericRequest(data, action) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.generic,
          params: {
            action,
            data
          }
        });
      }
      sendGenericMessage(request) {
        return this.sendRequest(request);
      }
      sendRequest(request) {
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          if (!this.ui.isStandalone()) {
            hideSnackbarItem = this.ui.showConnecting({
              isUnlinkedErrorState: this.isUnlinkedErrorState,
              onCancel: cancel,
              onResetConnection: this.resetAndReload
            });
          }
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          if (this.ui.isStandalone()) {
            this.sendRequestStandalone(id2, request);
          } else {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      setConnectDisabled(disabled) {
        this.ui.setConnectDisabled(disabled);
      }
      setAccountsCallback(accountsCallback) {
        this.accountsCallback = accountsCallback;
      }
      setChainCallback(chainCallback) {
        this.chainCallback = chainCallback;
      }
      publishWeb3RequestEvent(id2, request) {
        var _a2;
        const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id: id2, request });
        const storedSession = Session_1.Session.load(this.storage);
        (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.WEB3_REQUEST, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
        });
        this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
          error: (err) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: message.id,
              response: {
                method: message.request.method,
                errorMessage: err.message
              }
            }));
          }
        }));
      }
      publishWeb3RequestCanceledEvent(id2) {
        const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id2);
        this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
      }
      publishEvent(event, message, callWebhook) {
        const secret = this.session.secret;
        return new rxjs_1.Observable((subscriber) => {
          void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
            subscriber.next(encrypted);
            subscriber.complete();
          });
        }).pipe((0, operators_1.mergeMap)((encrypted) => {
          return this.connection.publishEvent(event, encrypted, callWebhook);
        }));
      }
      handleIncomingEvent(event) {
        try {
          this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)((c5) => JSON.parse(c5))).subscribe({
            next: (json) => {
              const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;
              if (!message) {
                return;
              }
              this.handleWeb3ResponseMessage(message);
            },
            error: () => {
              var _a2;
              (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "incomingEvent"
              });
            }
          }));
        } catch (_a2) {
          return;
        }
      }
      handleWeb3ResponseMessage(message) {
        var _a2;
        const { response } = message;
        (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.WEB3_RESPONSE, {
          eventId: message.id,
          method: `relay::${response.method}`,
          sessionIdHash: this.getSessionIdHash()
        });
        if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
          Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id2) => this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 })));
          WalletLinkRelay.accountRequestCallbackIds.clear();
          return;
        }
        this.invokeCallback(message);
      }
      invokeCallback(message) {
        const callback = this.relayEventManager.callbacks.get(message.id);
        if (callback) {
          callback(message.response);
          this.relayEventManager.callbacks.delete(message.id);
        }
      }
      requestEthereumAccounts() {
        let request = {
          method: Web3Method_1.Web3Method.requestEthereumAccounts,
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl || null
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          var _a2;
          this.relayEventManager.callbacks.set(id2, (response) => {
            this.ui.hideRequestEthereumAccounts();
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const userAgent = ((_a2 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) || null;
          if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
            window.location.href = `https://go.cb-w.com/xoXnYwQimhb?cb_url=${window.location.href}`;
            return;
          }
          if (this.ui.inlineAccountsResponse()) {
            const onAccounts = (accounts) => {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
              }));
            };
            this.ui.requestEthereumAccounts({
              onCancel: cancel,
              onAccounts
            });
          } else {
            this.ui.requestEthereumAccounts({
              onCancel: cancel
            });
          }
          WalletLinkRelay.accountRequestCallbackIds.add(id2);
          if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
        let request = {
          method: Web3Method_1.Web3Method.addEthereumChain,
          params: {
            chainId,
            rpcUrls,
            blockExplorerUrls,
            chainName,
            iconUrls,
            nativeCurrency
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineAddEthereumChain(chainId)) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.AddEthereumChainResponse)({
                isApproved: false,
                rpcUrl: ""
              })
            }));
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
            }));
          };
          if (this.ui.inlineAddEthereumChain(chainId)) {
            this.ui.addEthereumChain({
              onCancel: _cancel,
              onApprove: approve,
              chainId: request.params.chainId,
              rpcUrls: request.params.rpcUrls,
              blockExplorerUrls: request.params.blockExplorerUrls,
              chainName: request.params.chainName,
              iconUrls: request.params.iconUrls,
              nativeCurrency: request.params.nativeCurrency
            });
          }
          if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      switchEthereumChain(chainId) {
        let request = {
          method: Web3Method_1.Web3Method.switchEthereumChain,
          params: {
            chainId
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineSwitchEthereumChain()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage && response.errorCode) {
              return reject(eth_rpc_errors_1.ethErrors.provider.custom({
                code: response.errorCode,
                message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
              }));
            } else if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (errorCode) => {
            if (errorCode) {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, "unsupported chainId", errorCode)
              }));
            } else {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                  isApproved: false,
                  rpcUrl: ""
                })
              }));
            }
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                isApproved: true,
                rpcUrl
              })
            }));
          };
          this.ui.switchEthereumChain({
            onCancel: _cancel,
            onApprove: approve,
            chainId: request.params.chainId
          });
          if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      getSessionIdHash() {
        return Session_1.Session.hash(this._session.id);
      }
      sendRequestStandalone(id2, request) {
        const _cancel = () => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
        };
        const onSuccess = (response) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response
          }));
        };
        switch (request.method) {
          case Web3Method_1.Web3Method.signEthereumMessage:
            this.ui.signEthereumMessage({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.signEthereumTransaction:
            this.ui.signEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.submitEthereumTransaction:
            this.ui.submitEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
            this.ui.ethereumAddressFromSignedMessage({
              request,
              onSuccess
            });
            break;
          default:
            _cancel();
            break;
        }
      }
    };
    WalletLinkRelay.accountRequestCallbackIds = new Set();
    __decorate([
      bind_decorator_1.default
    ], WalletLinkRelay.prototype, "resetAndReload", null);
    __decorate([
      bind_decorator_1.default
    ], WalletLinkRelay.prototype, "handleIncomingEvent", null);
    exports.WalletLinkRelay = WalletLinkRelay;
  }
});

// node_modules/walletlink/dist/relay/WalletLinkRelayEventManager.js
var require_WalletLinkRelayEventManager = __commonJS({
  "node_modules/walletlink/dist/relay/WalletLinkRelayEventManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkRelayEventManager = void 0;
    var util_1 = require_util2();
    var WalletLinkRelayEventManager = class {
      constructor() {
        this._nextRequestId = 0;
        this.callbacks = new Map();
      }
      makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const id2 = this._nextRequestId;
        const idStr = (0, util_1.prepend0x)(id2.toString(16));
        const callback = this.callbacks.get(idStr);
        if (callback) {
          this.callbacks.delete(idStr);
        }
        return id2;
      }
    };
    exports.WalletLinkRelayEventManager = WalletLinkRelayEventManager;
  }
});

// node_modules/walletlink/package.json
var require_package2 = __commonJS({
  "node_modules/walletlink/package.json"(exports, module) {
    module.exports = {
      name: "walletlink",
      version: "2.4.6",
      description: "WalletLink JavaScript SDK",
      keywords: [
        "cipher",
        "cipherbrowser",
        "coinbase",
        "coinbasewallet",
        "eth",
        "ether",
        "ethereum",
        "etherium",
        "injection",
        "toshi",
        "wallet",
        "walletlink",
        "web3"
      ],
      main: "dist/index.js",
      types: "dist/index.d.ts",
      repository: "https://github.com/walletlink/walletlink.git",
      author: "Coinbase, Inc.",
      license: "Apache-2.0",
      scripts: {
        tsc: "tsc --noEmit --pretty",
        test: "yarn build-npm && karma start",
        build: "node compile-assets.js && webpack --config webpack.config.js",
        "build-chrome": "webpack --config webpack.config.chrome.js",
        "build-npm": "tsc -p ./tsconfig.build.json",
        "build:dev": "export WALLETLINK_URL='http://localhost:3000'; yarn build && yarn build-chrome",
        "build:dev:watch": "nodemon -e 'ts,tsx,js,json,css,scss,svg' --ignore 'src/**/*-css.ts' --ignore 'src/**/*-svg.ts' --watch src/ --watch chrome/ --exec 'yarn build:dev'",
        "build:prod": `yarn build && yarn build-chrome && yarn build-npm && cp ./package.json ../README.md ../LICENSE build/npm && cp -a src/vendor-js build/npm/dist && sed -i.bak 's|  "private": true,||g' build/npm/package.json && rm -f build/npm/package.json.bak`,
        lint: "eslint ./src --ext .ts,.tsx",
        "lint:watch": "nodemon -e ts,tsx,js,json,css,scss,svg --watch src/ --exec 'yarn tsc && yarn lint'"
      },
      dependencies: {
        "@metamask/safe-event-emitter": "2.0.0",
        "bind-decorator": "^1.0.11",
        "bn.js": "^5.1.1",
        clsx: "^1.1.0",
        "eth-block-tracker": "4.4.3",
        "eth-json-rpc-filters": "4.2.2",
        "eth-rpc-errors": "4.0.2",
        "js-sha256": "0.9.0",
        "json-rpc-engine": "6.1.0",
        keccak: "^3.0.1",
        preact: "^10.5.9",
        rxjs: "^6.6.3",
        "stream-browserify": "^3.0.0"
      },
      devDependencies: {
        "@types/bn.js": "^4.11.6",
        "@types/node": "^14.14.20",
        "@typescript-eslint/eslint-plugin": "^5.7.0",
        "@typescript-eslint/eslint-plugin-tslint": "^5.7.0",
        "@typescript-eslint/parser": "^5.7.0",
        browserify: "17.0.0",
        "copy-webpack-plugin": "^6.4.1",
        "core-js": "^3.8.2",
        eslint: "^8.4.1",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.25.3",
        "eslint-plugin-preact": "^0.1.0",
        "eslint-plugin-prettier": "^4.0.0",
        "eslint-plugin-simple-import-sort": "^7.0.0",
        jasmine: "3.8.0",
        karma: "^6.3.2",
        "karma-browserify": "8.1.0",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        nodemon: "^2.0.6",
        prettier: "^2.5.1",
        "raw-loader": "^4.0.2",
        "regenerator-runtime": "^0.13.7",
        sass: "^1.32.0",
        svgo: "^2.8.0",
        "ts-jest": "^26.4.4",
        "ts-loader": "^8.0.13",
        tslib: "^2.0.3",
        typescript: "^4.1.3",
        watchify: "4.0.0",
        webpack: "^5.49.0",
        "webpack-cli": "^3.3.12",
        "whatwg-fetch": "^3.5.0"
      },
      engines: {
        node: ">= 10.0.0"
      },
      jest: {
        transform: {
          "^.+\\.tsx?$": "ts-jest"
        },
        testEnvironment: "node",
        testPathIgnorePatterns: [
          "<rootDir>/dist/",
          "<rootDir>/node_modules/"
        ],
        testRegex: "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        moduleFileExtensions: [
          "ts",
          "js",
          "json"
        ]
      }
    };
  }
});

// node_modules/walletlink/dist/WalletLink.js
var require_WalletLink = __commonJS({
  "node_modules/walletlink/dist/WalletLink.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLink = void 0;
    var WalletLinkAnalytics_1 = require_WalletLinkAnalytics();
    var ScopedLocalStorage_1 = require_ScopedLocalStorage();
    var WalletLinkProvider_1 = require_WalletLinkProvider();
    var WalletLinkSdkUI_1 = require_WalletLinkSdkUI();
    var WalletLinkRelay_1 = require_WalletLinkRelay();
    var WalletLinkRelayEventManager_1 = require_WalletLinkRelayEventManager();
    var util_1 = require_util2();
    var WALLETLINK_URL = process.env.WALLETLINK_URL || "https://www.walletlink.org";
    var WALLETLINK_VERSION = process.env.WALLETLINK_VERSION || require_package2().version || "unknown";
    var WalletLink = class {
      constructor(options) {
        var _a2;
        this._appName = "";
        this._appLogoUrl = null;
        this._relay = null;
        this._relayEventManager = null;
        const walletLinkUrl = options.walletLinkUrl || WALLETLINK_URL;
        let walletLinkUIConstructor;
        if (!options.walletLinkUIConstructor) {
          walletLinkUIConstructor = (opts) => new WalletLinkSdkUI_1.WalletLinkSdkUI(opts);
        } else {
          walletLinkUIConstructor = options.walletLinkUIConstructor;
        }
        if (typeof options.overrideIsMetaMask === "undefined") {
          this._overrideIsMetaMask = false;
        } else {
          this._overrideIsMetaMask = options.overrideIsMetaMask;
        }
        this._overrideIsCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
        this._walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1.WalletLinkAnalytics();
        const u5 = new URL(walletLinkUrl);
        const walletLinkOrigin = `${u5.protocol}//${u5.host}`;
        this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${walletLinkOrigin}`);
        this._storage.setItem("version", WalletLink.VERSION);
        if (typeof window.walletLinkExtension !== "undefined") {
          return;
        }
        this._relayEventManager = new WalletLinkRelayEventManager_1.WalletLinkRelayEventManager();
        this._relay = new WalletLinkRelay_1.WalletLinkRelay({
          walletLinkUrl,
          version: WALLETLINK_VERSION,
          darkMode: !!options.darkMode,
          walletLinkUIConstructor,
          storage: this._storage,
          relayEventManager: this._relayEventManager,
          walletLinkAnalytics: this._walletLinkAnalytics
        });
        this.setAppInfo(options.appName, options.appLogoUrl);
        this._relay.attachUI();
      }
      makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
        if (typeof window.walletLinkExtension !== "undefined") {
          if (typeof window.walletLinkExtension.isCipher !== "boolean" || !window.walletLinkExtension.isCipher) {
            window.walletLinkExtension.setProviderInfo(jsonRpcUrl, chainId);
          }
          return window.walletLinkExtension;
        }
        const relay = this._relay;
        if (!relay || !this._relayEventManager || !this._storage) {
          throw new Error("Relay not initialized, should never happen");
        }
        if (!jsonRpcUrl)
          relay.setConnectDisabled(true);
        return new WalletLinkProvider_1.WalletLinkProvider({
          relayProvider: () => Promise.resolve(relay),
          relayEventManager: this._relayEventManager,
          storage: this._storage,
          jsonRpcUrl,
          chainId,
          walletLinkAnalytics: this._walletLinkAnalytics,
          overrideIsMetaMask: this._overrideIsMetaMask,
          overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet
        });
      }
      setAppInfo(appName, appLogoUrl) {
        var _a2;
        this._appName = appName || "DApp";
        this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
        if (typeof window.walletLinkExtension !== "undefined") {
          if (typeof window.walletLinkExtension.isCipher !== "boolean" || !window.walletLinkExtension.isCipher) {
            window.walletLinkExtension.setAppInfo(this._appName, this._appLogoUrl);
          }
        } else {
          (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.setAppInfo(this._appName, this._appLogoUrl);
        }
      }
      disconnect() {
        var _a2;
        if (typeof window.walletLinkExtension !== "undefined") {
          window.walletLinkExtension.close();
        } else {
          (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.resetAndReload();
        }
      }
    };
    exports.WalletLink = WalletLink;
    WalletLink.VERSION = WALLETLINK_VERSION;
  }
});

// node_modules/walletlink/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/walletlink/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLink = exports.WalletLinkProvider = void 0;
    var WalletLinkProvider_1 = require_WalletLinkProvider();
    var WalletLink_1 = require_WalletLink();
    var WalletLinkProvider_2 = require_WalletLinkProvider();
    Object.defineProperty(exports, "WalletLinkProvider", { enumerable: true, get: function() {
      return WalletLinkProvider_2.WalletLinkProvider;
    } });
    var WalletLink_2 = require_WalletLink();
    Object.defineProperty(exports, "WalletLink", { enumerable: true, get: function() {
      return WalletLink_2.WalletLink;
    } });
    exports.default = WalletLink_1.WalletLink;
    if (typeof window !== "undefined") {
      window.WalletLink = WalletLink_1.WalletLink;
      window.WalletLinkProvider = WalletLinkProvider_1.WalletLinkProvider;
    }
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name2) {
      const res = getFromWindow3(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e5) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i5 = 0; i5 < links.length; i5++) {
          const link = links[i5];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i5 = 0; i5 < metaTags.length; i5++) {
          const tag = metaTags[i5];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version29 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version29, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version29, os);
}
function detectOS(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a2 = operatingSystemRules[ii], os = _a2[0], regex = _a2[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii = 0; ii < count2; ii++) {
    output.push("0");
  }
  return output;
}
var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/detect-browser/es/index.js"() {
    __spreadArrays = function() {
      for (var s6 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)
        s6 += arguments[i5].length;
      for (var r6 = Array(s6), k5 = 0, i5 = 0; i5 < il; i5++)
        for (var a5 = arguments[i5], j5 = 0, jl = a5.length; j5 < jl; j5++, k5++)
          r6[k5] = a5[j5];
      return r6;
    };
    BrowserInfo = function() {
      function BrowserInfo2(name2, version29, os) {
        this.name = name2;
        this.version = version29;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = function() {
      function NodeInfo2(version29) {
        this.version = version29;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = function() {
      function SearchBotDeviceInfo2(name2, version29, os, bot) {
        this.name = name2;
        this.version = version29;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env3 = detectEnv();
  return env3 && env3.os ? env3.os : void 0;
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env3 = detectEnv();
  const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_browser = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
    windowMetadata = __toModule(require_cjs2());
    windowGetters = __toModule(require_cjs());
    init_es();
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
var init_esm = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
    init_esm();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key2, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key2, raw);
  }
}
function getLocal(key2) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key2);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key2) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key2);
  }
}
var init_local = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
    init_json();
    init_browser();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name2) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name2.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name2) => getMobileRegistryEntry(registry, name2)).filter(Boolean);
  }
  return links;
}
var mobileLinkChoiceKey;
var init_mobile = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
    init_local();
    mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/data/wallets.json";
}
function getDappRegistryUrl() {
  return API_URL + "/data/dapps.json";
}
function getAppLogoUrl(id2) {
  return API_URL + "/logo/sm/" + id2 + ".jpeg";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: entry.id ? getAppLogoUrl(entry.id) : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var API_URL;
var init_registry = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
    API_URL = "https://registry.walletconnect.org";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  getAppLogoUrl: () => getAppLogoUrl,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser,
  isIOS: () => isIOS,
  isMobile: () => isMobile,
  isNode: () => isNode,
  mobileLinkChoiceKey: () => mobileLinkChoiceKey,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
    init_browser();
    init_json();
    init_local();
    init_mobile();
    init_registry();
  }
});

// node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
var require_bn6 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number2, base2, endian) {
        if (BN6.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer3;
      try {
        Buffer3 = (init_buffer(), buffer_exports).Buffer;
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert5(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number2, start);
        } else {
          this._parseBase(number2, base2, start);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number2, base2, endian) {
        assert5(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i5 = number2.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number2[i5] | number2[i5 - 1] << 8 | number2[i5 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number2.length; i5 += 3) {
            w6 = number2[i5] | number2[i5 + 1] << 8 | number2[i5 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 <<= 4;
          if (c5 >= 49 && c5 <= 54) {
            r6 |= c5 - 49 + 10;
          } else if (c5 >= 17 && c5 <= 22) {
            r6 |= c5 - 17 + 10;
          } else {
            r6 |= c5 & 15;
          }
        }
        return r6;
      }
      BN6.prototype._parseHex = function _parseHex(number2, start) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off = 0;
        for (i5 = number2.length - 6, j5 = 0; i5 >= start; i5 -= 6) {
          w6 = parseHex(number2, i5, i5 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j5++;
          }
        }
        if (i5 + 6 !== start) {
          w6 = parseHex(number2, start, i5 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul3) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul3;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN6.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number2, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i5, number2.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN6.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r6 = new BN6(null);
        this.copy(r6);
        return r6;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer2(endian, length) {
        assert5(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN6.prototype.toArray = function toArray3(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN6.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN6.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t5 = new Array(N5);
        var l5 = BN6.prototype._countBits(N5) - 1;
        for (var i5 = 0; i5 < N5; i5++) {
          t5[i5] = this.revBin(i5, l5, N5);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N5) {
        if (x5 === 0 || x5 === N5 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i5 = 0; i5 < N5; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s6 = 1; s6 < N5; s6 <<= 1) {
          var l5 = s6 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N5; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s6; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s6];
              var io = itws[p5 + j5 + s6];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s6] = re - ro;
              itws[p5 + j5 + s6] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N5 = Math.max(m5, n3) | 1;
        var odd = N5 & 1;
        var i5 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1)
          return;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N5 - i5 - 1];
          rws[N5 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N5 - i5 - 1];
          iws[N5 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < N5 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N5) * 8192 + Math.round(ws[2 * i5] / N5) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N5) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N5; ++i5) {
          rws[i5] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i5 = 0; i5 < N5; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N5 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N5);
        var _10 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x5.words, x5.length, rws, N5);
        this.convert13b(y5.words, y5.length, nrws, N5);
        this.transform(rws, _10, rwst, iwst, N5, rbt);
        this.transform(nrws, _10, nrwst, niwst, N5, rbt);
        for (var i5 = 0; i5 < N5; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _10, N5, rbt);
        this.conjugate(rmws, _10, N5);
        this.normalize13b(rmws, N5);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul3(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s6 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s6] = this.words[i5];
          }
          for (i5 = 0; i5 < s6; i5++) {
            this.words[i5] = 0;
          }
          this.length += s6;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s6 = Math.min((bits - r6) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s6;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s6; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s6;
        }
        if (s6 === 0) {
        } else if (this.length > s6) {
          this.length -= s6;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s6];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6)
          return false;
        var w6 = this.words[s6];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s6 = (bits - r6) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s6) {
          return this;
        }
        if (r6 !== 0) {
          s6++;
        }
        this.length = Math.min(s6, this.length);
        if (r6 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask2;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul3;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert5(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert5(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert5(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert5(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B3.isOdd()) {
                A6.iadd(yp);
                B3.isub(xp);
              }
              A6.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g5)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert5(p5.negative === 0);
        assert5(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r6 = bit % 26;
        var s6 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s6) {
          this._expand(s6 + 1);
          this.words[s6] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s6; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert5(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert5(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p5) {
        this.name = name2;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          r6.strip();
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert5(a5.negative === 0, "red works only with positives");
        assert5(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert5((a5.negative | b4.negative) === 0, "red works only with positives");
        assert5(a5.red && a5.red === b4.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg3(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add3(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul3(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s6 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s6++;
          q5.iushrn(1);
        }
        assert5(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c5 = this.pow(z4, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s6;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert5(i5 < m5);
          var b4 = this.pow(c5, new BN6(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    module.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString2 = Object.prototype.toString;
    var names2 = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names2[toString2.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    var isTypedArray2 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/@walletconnect/encoding/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/encoding/dist/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeHexLeadingZeros = exports.sanitizeHex = exports.addHexPrefix = exports.removeHexPrefix = exports.padRight = exports.padLeft = exports.sanitizeBytes = exports.swapHex = exports.swapBytes = exports.splitBytes = exports.calcByteLength = exports.trimRight = exports.trimLeft = exports.concatArrays = exports.concatBuffers = exports.getEncoding = exports.getType = exports.isArrayBuffer = exports.isTypedArray = exports.isBuffer = exports.isHexString = exports.isBinaryString = exports.binaryToNumber = exports.binaryToUtf8 = exports.binaryToHex = exports.binaryToArray = exports.binaryToBuffer = exports.numberToBinary = exports.numberToUtf8 = exports.numberToHex = exports.numberToArray = exports.numberToBuffer = exports.utf8ToBinary = exports.utf8ToNumber = exports.utf8ToHex = exports.utf8ToArray = exports.utf8ToBuffer = exports.hexToBinary = exports.hexToNumber = exports.hexToUtf8 = exports.hexToArray = exports.hexToBuffer = exports.arrayToBinary = exports.arrayToNumber = exports.arrayToUtf8 = exports.arrayToHex = exports.arrayToBuffer = exports.bufferToBinary = exports.bufferToNumber = exports.bufferToUtf8 = exports.bufferToHex = exports.bufferToArray = void 0;
    var is_typedarray_1 = __importDefault(require_is_typedarray());
    var typedarray_to_buffer_1 = __importDefault(require_typedarray_to_buffer());
    var ENC_HEX = "hex";
    var ENC_UTF8 = "utf8";
    var ENC_BIN = "binary";
    var TYPE_BUFFER = "buffer";
    var TYPE_ARRAY = "array";
    var TYPE_TYPED_ARRAY = "typed-array";
    var TYPE_ARRAY_BUFFER = "array-buffer";
    var STRING_ZERO = "0";
    function bufferToArray3(buf) {
      return new Uint8Array(buf);
    }
    exports.bufferToArray = bufferToArray3;
    function bufferToHex2(buf, prefixed = false) {
      const hex = buf.toString(ENC_HEX);
      return prefixed ? addHexPrefix5(hex) : hex;
    }
    exports.bufferToHex = bufferToHex2;
    function bufferToUtf82(buf) {
      return buf.toString(ENC_UTF8);
    }
    exports.bufferToUtf8 = bufferToUtf82;
    function bufferToNumber2(buf) {
      return buf.readUIntBE(0, buf.length);
    }
    exports.bufferToNumber = bufferToNumber2;
    function bufferToBinary(buf) {
      return arrayToBinary(bufferToArray3(buf));
    }
    exports.bufferToBinary = bufferToBinary;
    function arrayToBuffer3(arr) {
      return typedarray_to_buffer_1.default(arr);
    }
    exports.arrayToBuffer = arrayToBuffer3;
    function arrayToHex3(arr, prefixed = false) {
      return bufferToHex2(arrayToBuffer3(arr), prefixed);
    }
    exports.arrayToHex = arrayToHex3;
    function arrayToUtf83(arr) {
      return bufferToUtf82(arrayToBuffer3(arr));
    }
    exports.arrayToUtf8 = arrayToUtf83;
    function arrayToNumber2(arr) {
      return bufferToNumber2(arrayToBuffer3(arr));
    }
    exports.arrayToNumber = arrayToNumber2;
    function arrayToBinary(arr) {
      return Array.from(arr).map(numberToBinary).join("");
    }
    exports.arrayToBinary = arrayToBinary;
    function hexToBuffer2(hex) {
      return Buffer.from(removeHexPrefix5(hex), ENC_HEX);
    }
    exports.hexToBuffer = hexToBuffer2;
    function hexToArray3(hex) {
      return bufferToArray3(hexToBuffer2(hex));
    }
    exports.hexToArray = hexToArray3;
    function hexToUtf82(hex) {
      return bufferToUtf82(hexToBuffer2(hex));
    }
    exports.hexToUtf8 = hexToUtf82;
    function hexToNumber(hex) {
      return arrayToNumber2(hexToArray3(hex));
    }
    exports.hexToNumber = hexToNumber;
    function hexToBinary(hex) {
      return arrayToBinary(hexToArray3(hex));
    }
    exports.hexToBinary = hexToBinary;
    function utf8ToBuffer2(utf8) {
      return Buffer.from(utf8, ENC_UTF8);
    }
    exports.utf8ToBuffer = utf8ToBuffer2;
    function utf8ToArray3(utf8) {
      return bufferToArray3(utf8ToBuffer2(utf8));
    }
    exports.utf8ToArray = utf8ToArray3;
    function utf8ToHex2(utf8, prefixed = false) {
      return bufferToHex2(utf8ToBuffer2(utf8), prefixed);
    }
    exports.utf8ToHex = utf8ToHex2;
    function utf8ToNumber(utf8) {
      const num = parseInt(utf8, 10);
      assert5(isDefined(num), "Number can only safely store up to 53 bits");
      return num;
    }
    exports.utf8ToNumber = utf8ToNumber;
    function utf8ToBinary(utf8) {
      return arrayToBinary(utf8ToArray3(utf8));
    }
    exports.utf8ToBinary = utf8ToBinary;
    function numberToBuffer2(num) {
      return binaryToBuffer(numberToBinary(num));
    }
    exports.numberToBuffer = numberToBuffer2;
    function numberToArray2(num) {
      return binaryToArray(numberToBinary(num));
    }
    exports.numberToArray = numberToArray2;
    function numberToHex(num, prefixed) {
      return binaryToHex(numberToBinary(num), prefixed);
    }
    exports.numberToHex = numberToHex;
    function numberToUtf8(num) {
      return `${num}`;
    }
    exports.numberToUtf8 = numberToUtf8;
    function numberToBinary(num) {
      const bin = (num >>> 0).toString(2);
      return sanitizeBytes(bin);
    }
    exports.numberToBinary = numberToBinary;
    function binaryToBuffer(bin) {
      return arrayToBuffer3(binaryToArray(bin));
    }
    exports.binaryToBuffer = binaryToBuffer;
    function binaryToArray(bin) {
      return new Uint8Array(splitBytes(bin).map((x5) => parseInt(x5, 2)));
    }
    exports.binaryToArray = binaryToArray;
    function binaryToHex(bin, prefixed) {
      return arrayToHex3(binaryToArray(bin), prefixed);
    }
    exports.binaryToHex = binaryToHex;
    function binaryToUtf8(bin) {
      return arrayToUtf83(binaryToArray(bin));
    }
    exports.binaryToUtf8 = binaryToUtf8;
    function binaryToNumber(bin) {
      return arrayToNumber2(binaryToArray(bin));
    }
    exports.binaryToNumber = binaryToNumber;
    function isBinaryString(str) {
      if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
        return false;
      }
      if (str.length % 8 !== 0) {
        return false;
      }
      return true;
    }
    exports.isBinaryString = isBinaryString;
    function isHexString5(str, length) {
      if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && str.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    exports.isHexString = isHexString5;
    function isBuffer2(val) {
      return Buffer.isBuffer(val);
    }
    exports.isBuffer = isBuffer2;
    function isTypedArray2(val) {
      return is_typedarray_1.default.strict(val) && !isBuffer2(val);
    }
    exports.isTypedArray = isTypedArray2;
    function isArrayBuffer2(val) {
      return !isTypedArray2(val) && !isBuffer2(val) && typeof val.byteLength !== "undefined";
    }
    exports.isArrayBuffer = isArrayBuffer2;
    function getType2(val) {
      if (isBuffer2(val)) {
        return TYPE_BUFFER;
      } else if (isTypedArray2(val)) {
        return TYPE_TYPED_ARRAY;
      } else if (isArrayBuffer2(val)) {
        return TYPE_ARRAY_BUFFER;
      } else if (Array.isArray(val)) {
        return TYPE_ARRAY;
      } else {
        return typeof val;
      }
    }
    exports.getType = getType2;
    function getEncoding2(str) {
      if (isBinaryString(str)) {
        return ENC_BIN;
      }
      if (isHexString5(str)) {
        return ENC_HEX;
      }
      return ENC_UTF8;
    }
    exports.getEncoding = getEncoding2;
    function concatBuffers2(...args) {
      const result = Buffer.concat(args);
      return result;
    }
    exports.concatBuffers = concatBuffers2;
    function concatArrays2(...args) {
      let result = [];
      args.forEach((arg) => result = result.concat(Array.from(arg)));
      return new Uint8Array([...result]);
    }
    exports.concatArrays = concatArrays2;
    function trimLeft(data, length) {
      const diff = data.length - length;
      if (diff > 0) {
        data = data.slice(diff);
      }
      return data;
    }
    exports.trimLeft = trimLeft;
    function trimRight(data, length) {
      return data.slice(0, length);
    }
    exports.trimRight = trimRight;
    function calcByteLength(length, byteSize = 8) {
      const remainder = length % byteSize;
      return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
    }
    exports.calcByteLength = calcByteLength;
    function splitBytes(str, byteSize = 8) {
      const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, "gi"));
      return Array.from(bytes || []);
    }
    exports.splitBytes = splitBytes;
    function swapBytes(str) {
      return splitBytes(str).map(reverseString).join("");
    }
    exports.swapBytes = swapBytes;
    function swapHex(str) {
      return binaryToHex(swapBytes(hexToBinary(str)));
    }
    exports.swapHex = swapHex;
    function sanitizeBytes(str, byteSize = 8, padding2 = STRING_ZERO) {
      return padLeft(str, calcByteLength(str.length, byteSize), padding2);
    }
    exports.sanitizeBytes = sanitizeBytes;
    function padLeft(str, length, padding2 = STRING_ZERO) {
      return padString(str, length, true, padding2);
    }
    exports.padLeft = padLeft;
    function padRight(str, length, padding2 = STRING_ZERO) {
      return padString(str, length, false, padding2);
    }
    exports.padRight = padRight;
    function removeHexPrefix5(hex) {
      return hex.replace(/^0x/, "");
    }
    exports.removeHexPrefix = removeHexPrefix5;
    function addHexPrefix5(hex) {
      return hex.startsWith("0x") ? hex : `0x${hex}`;
    }
    exports.addHexPrefix = addHexPrefix5;
    function sanitizeHex4(hex) {
      hex = removeHexPrefix5(hex);
      hex = sanitizeBytes(hex, 2);
      if (hex) {
        hex = addHexPrefix5(hex);
      }
      return hex;
    }
    exports.sanitizeHex = sanitizeHex4;
    function removeHexLeadingZeros3(hex) {
      const prefixed = hex.startsWith("0x");
      hex = removeHexPrefix5(hex);
      hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
      return prefixed ? addHexPrefix5(hex) : hex;
    }
    exports.removeHexLeadingZeros = removeHexLeadingZeros3;
    function isUndefined(value) {
      return typeof value === "undefined";
    }
    function isDefined(value) {
      return !isUndefined(value);
    }
    function assert5(assertion, errorMessage) {
      if (!assertion) {
        throw new Error(errorMessage);
      }
    }
    function reverseString(str) {
      return str.split("").reverse().join("");
    }
    function padString(str, length, left, padding2 = STRING_ZERO) {
      const diff = length - str.length;
      let result = str;
      if (diff > 0) {
        const pad2 = padding2.repeat(diff);
        result = left ? pad2 + str : str + pad2;
      }
      return result;
    }
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser2() {
      return !isReactNative() && !isNode3();
    }
    exports.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !exports2.hasOwnProperty(p5))
          __createBinding(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_crypto(), exports);
    __exportStar(require_env(), exports);
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x5) => `%${x5.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode4(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i5 = 1; i5 < tokens.length; i5++) {
          input = decodeComponents(tokens, i5).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode4(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i5 = 0; i5 < entries.length; i5++) {
        var key2 = entries[i5];
        input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string2, separator) => {
      if (!(typeof string2 === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string2];
      }
      const separatorIndex = string2.indexOf(separator);
      if (separatorIndex === -1) {
        return [string2];
      }
      return [
        string2.slice(0, separatorIndex),
        string2.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key2) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key2, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode5(key2, options), "[", encode5(index, options), "]=", encode5(value, options)].join("")
            ];
          };
        case "bracket":
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key2, options), "[]"].join("")];
            }
            return [...result, [encode5(key2, options), "[]=", encode5(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key2) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode5(key2, options), "=", encode5(value, options)].join("")];
            }
            return [[result, encode5(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode5(key2, options)];
            }
            return [...result, [encode5(key2, options), "=", encode5(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key2, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key2);
            key2 = key2.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = {};
            }
            accumulator[key2][result[1]] = value;
          };
        case "bracket":
          return (key2, value, accumulator) => {
            result = /(\[\])$/.exec(key2);
            key2 = key2.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = [value];
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
        case "comma":
        case "separator":
          return (key2, value, accumulator) => {
            const isArray2 = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray2 ? value.split(options.arrayFormatSeparator).map((item) => decode4(item, options)) : value === null ? value : decode4(value, options);
            accumulator[key2] = newValue;
          };
        default:
          return (key2, value, accumulator) => {
            if (accumulator[key2] === void 0) {
              accumulator[key2] = value;
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode5(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode4(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a5, b4) => Number(a5) - Number(b4)).map((key2) => input[key2]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash4 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash4 = url.slice(hashStart);
      }
      return hash4;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse4(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key2, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode4(value, options);
        formatter(decode4(key2, options), value, ret);
      }
      for (const key2 of Object.keys(ret)) {
        const value = ret[key2];
        if (typeof value === "object" && value !== null) {
          for (const k5 of Object.keys(value)) {
            value[k5] = parseValue(value[k5], options);
          }
        } else {
          ret[key2] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
        const value = ret[key2];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key2] = keysSorter(value);
        } else {
          result[key2] = value;
        }
        return result;
      }, Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse4;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object[key2]) || options.skipEmptyString && object[key2] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key2 of Object.keys(object)) {
        if (!shouldFilter(key2)) {
          objectCopy[key2] = object[key2];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key2) => {
        const value = object[key2];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode5(key2, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key2), []).join("&");
        }
        return encode5(key2, options) + "=" + encode5(value, options);
      }).filter((x5) => x5.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash4] = splitOnFirst(input, "#");
      return Object.assign({
        url: url.split("?")[0] || "",
        query: parse4(extract(input), options)
      }, options && options.parseFragmentIdentifier && hash4 ? { fragmentIdentifier: decode4(hash4, options) } : {});
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash4 = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash4 = `#${encode5(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash4}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
var require_browser5 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
    };
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/qrcode/node_modules/isarray/index.js"(exports, module) {
    var toString2 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// node_modules/qrcode/lib/utils/typedarray-buffer.js
var require_typedarray_buffer = __commonJS({
  "node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports, module) {
    "use strict";
    var isArray2 = require_isarray();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42;
      } catch (e5) {
        return false;
      }
    }
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    var K_MAX_LENGTH = Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    function Buffer3(arg, offset2, length) {
      if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
        return new Buffer3(arg, offset2, length);
      }
      if (typeof arg === "number") {
        return allocUnsafe(this, arg);
      }
      return from2(this, arg, offset2, length);
    }
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      Buffer3.prototype.__proto__ = Uint8Array.prototype;
      Buffer3.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer3[Symbol.species] === Buffer3) {
        Object.defineProperty(Buffer3, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function isnan(val) {
      return val !== val;
    }
    function createBuffer(that, length) {
      var buf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        buf = new Uint8Array(length);
        buf.__proto__ = Buffer3.prototype;
      } else {
        buf = that;
        if (buf === null) {
          buf = new Buffer3(length);
        }
        buf.length = length;
      }
      return buf;
    }
    function allocUnsafe(that, size) {
      var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer3.TYPED_ARRAY_SUPPORT) {
        for (var i5 = 0; i5 < size; ++i5) {
          buf[i5] = 0;
        }
      }
      return buf;
    }
    function fromString(that, string2) {
      var length = byteLength(string2) | 0;
      var buf = createBuffer(that, length);
      var actual = buf.write(string2);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(that, array2) {
      var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      var buf = createBuffer(that, length);
      for (var i5 = 0; i5 < length; i5 += 1) {
        buf[i5] = array2[i5] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(that, array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        buf.__proto__ = Buffer3.prototype;
      } else {
        buf = fromArrayLike(that, buf);
      }
      return buf;
    }
    function fromObject(that, obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(that, len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i5 = 0; i5 < length; ++i5) {
        codePoint = string2.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function byteLength(string2) {
      if (Buffer3.isBuffer(string2)) {
        return string2.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        string2 = "" + string2;
      }
      var len = string2.length;
      if (len === 0)
        return 0;
      return utf8ToBytes(string2).length;
    }
    function blitBuffer(src, dst, offset2, length) {
      for (var i5 = 0; i5 < length; ++i5) {
        if (i5 + offset2 >= dst.length || i5 >= src.length)
          break;
        dst[i5 + offset2] = src[i5];
      }
      return i5;
    }
    function utf8Write(buf, string2, offset2, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset2), buf, offset2, length);
    }
    function from2(that, value, offset2, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, offset2, length);
      }
      if (typeof value === "string") {
        return fromString(that, value, offset2);
      }
      return fromObject(that, value);
    }
    Buffer3.prototype.write = function write(string2, offset2, length) {
      if (offset2 === void 0) {
        length = this.length;
        offset2 = 0;
      } else if (length === void 0 && typeof offset2 === "string") {
        length = this.length;
        offset2 = 0;
      } else if (isFinite(offset2)) {
        offset2 = offset2 | 0;
        if (isFinite(length)) {
          length = length | 0;
        } else {
          length = void 0;
        }
      }
      var remaining = this.length - offset2;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      return utf8Write(this, string2, offset2, length);
    };
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer3.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer3(sliceLen, void 0);
        for (var i5 = 0; i5 < sliceLen; ++i5) {
          newBuf[i5] = this[i5 + start];
        }
      }
      return newBuf;
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i5;
      if (this === target && start < targetStart && targetStart < end) {
        for (i5 = len - 1; i5 >= 0; --i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
        for (i5 = 0; i5 < len; ++i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : new Buffer3(val);
        var len = bytes.length;
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    Buffer3.concat = function concat4(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return createBuffer(null, 0);
      }
      var i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      var buffer2 = allocUnsafe(null, length);
      var pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        var buf = list[i5];
        if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer2, pos);
        pos += buf.length;
      }
      return buffer2;
    };
    Buffer3.byteLength = byteLength;
    Buffer3.prototype._isBuffer = true;
    Buffer3.isBuffer = function isBuffer2(b4) {
      return !!(b4 != null && b4._isBuffer);
    };
    module.exports.alloc = function(size) {
      var buffer2 = new Buffer3(size);
      buffer2.fill(0);
      return buffer2;
    };
    module.exports.from = function(data) {
      return new Buffer3(data);
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils6 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version29) {
      if (!version29)
        throw new Error('"version" cannot be null or undefined');
      if (version29 < 1 || version29 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version29 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version29) {
      return CODEWORDS_COUNT[version29];
    };
    exports.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f7) {
      if (typeof f7 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f7;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string2);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from2(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e5) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (var i5 = 0; i5 < length; i5++) {
          this.putBit((num >>> length - i5 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    var BufferUtil = require_typedarray_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      var index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils6().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version29) {
      if (version29 === 1)
        return [];
      var posCount = Math.floor(version29 / 7) + 2;
      var size = getSymbolSize(version29);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i5 = 1; i5 < posCount - 1; i5++) {
        positions[i5] = positions[i5 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version29) {
      var coords = [];
      var pos = exports.getRowColCoords(version29);
      var posLength = pos.length;
      for (var i5 = 0; i5 < posLength; i5++) {
        for (var j5 = 0; j5 < posLength; j5++) {
          if (i5 === 0 && j5 === 0 || i5 === 0 && j5 === posLength - 1 || i5 === posLength - 1 && j5 === 0) {
            continue;
          }
          coords.push([pos[i5], pos[j5]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils6().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version29) {
      var size = getSymbolSize(version29);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask2) {
      return mask2 != null && mask2 !== "" && !isNaN(mask2) && mask2 >= 0 && mask2 <= 7;
    };
    exports.from = function from2(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last2 = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last2 === 4 || last2 === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i5 = 0; i5 < modulesCount; i5++)
        darkCount += data.data[i5];
      var k5 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k5 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i5, j5) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i5 + j5) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i5 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j5 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i5 + j5) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i5 / 2) + Math.floor(j5 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i5 * j5 % 2 + i5 * j5 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i5 * j5 % 2 + i5 * j5 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i5 * j5 % 3 + (i5 + j5) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p5 = 0; p5 < numPatterns; p5++) {
        setupFormatFunc(p5);
        exports.applyMask(p5, data);
        var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p5, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p5;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version29, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version29 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version29 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version29 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version29 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version29, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version29 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version29 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version29 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version29 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var BufferUtil = require_typedarray_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x5 = 1;
      for (var i5 = 0; i5 < 255; i5++) {
        EXP_TABLE[i5] = x5;
        LOG_TABLE[x5] = i5;
        x5 <<= 1;
        if (x5 & 256) {
          x5 ^= 285;
        }
      }
      for (i5 = 255; i5 < 512; i5++) {
        EXP_TABLE[i5] = EXP_TABLE[i5 - 255];
      }
    })();
    exports.log = function log(n3) {
      if (n3 < 1)
        throw new Error("log(" + n3 + ")");
      return LOG_TABLE[n3];
    };
    exports.exp = function exp(n3) {
      return EXP_TABLE[n3];
    };
    exports.mul = function mul3(x5, y5) {
      if (x5 === 0 || y5 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x5] + LOG_TABLE[y5]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var BufferUtil = require_typedarray_buffer();
    var GF = require_galois_field();
    exports.mul = function mul3(p1, p22) {
      var coeff = BufferUtil.alloc(p1.length + p22.length - 1);
      for (var i5 = 0; i5 < p1.length; i5++) {
        for (var j5 = 0; j5 < p22.length; j5++) {
          coeff[i5 + j5] ^= GF.mul(p1[i5], p22[j5]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i5 = 0; i5 < divisor.length; i5++) {
          result[i5] ^= GF.mul(divisor[i5], coeff);
        }
        var offset2 = 0;
        while (offset2 < result.length && result[offset2] === 0)
          offset2++;
        result = result.slice(offset2);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i5 = 0; i5 < degree; i5++) {
        poly = exports.mul(poly, [1, GF.exp(i5)]);
      }
      return poly;
    };
  }
});

// node_modules/qrcode/node_modules/buffer/index.js
var require_buffer3 = __commonJS({
  "node_modules/qrcode/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e5) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from2(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      var b4 = fromObject(value);
      if (b4)
        return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding5) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding5 === "string" ? createBuffer(size).fill(fill, encoding5) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding5) {
      return alloc(size, fill, encoding5);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding5) {
      if (typeof encoding5 !== "string" || encoding5 === "") {
        encoding5 = "utf8";
      }
      if (!Buffer3.isEncoding(encoding5)) {
        throw new TypeError("Unknown encoding: " + encoding5);
      }
      var length = byteLength(string2, encoding5) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string2, encoding5);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      var buf = createBuffer(length);
      for (var i5 = 0; i5 < length; i5 += 1) {
        buf[i5] = array2[i5] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer2(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a5, b4) {
      if (isInstance(a5, Uint8Array))
        a5 = Buffer3.from(a5, a5.offset, a5.byteLength);
      if (isInstance(b4, Uint8Array))
        b4 = Buffer3.from(b4, b4.offset, b4.byteLength);
      if (!Buffer3.isBuffer(a5) || !Buffer3.isBuffer(b4)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a5 === b4)
        return 0;
      var x5 = a5.length;
      var y5 = b4.length;
      for (var i5 = 0, len = Math.min(x5, y5); i5 < len; ++i5) {
        if (a5[i5] !== b4[i5]) {
          x5 = a5[i5];
          y5 = b4[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding5) {
      switch (String(encoding5).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat4(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      var buffer2 = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        var buf = list[i5];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer3.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string2, encoding5) {
      if (Buffer3.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
      }
      var len = string2.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding5) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding5 = ("" + encoding5).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding5, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding5)
        encoding5 = "utf8";
      while (true) {
        switch (encoding5) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding5);
            encoding5 = (encoding5 + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b4, n3, m5) {
      var i5 = b4[n3];
      b4[n3] = b4[m5];
      b4[m5] = i5;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString2() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b4) {
      if (!Buffer3.isBuffer(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer3.compare(this, b4) === 0;
    };
    Buffer3.prototype.inspect = function inspect4() {
      var str = "";
      var max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x5 = thisEnd - thisStart;
      var y5 = end - start;
      var len = Math.min(x5, y5);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x5 = thisCopy[i5];
          y5 = targetCopy[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding5, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding5 = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding5);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding5, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding5, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding5, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding5 !== void 0) {
        encoding5 = String(encoding5).toLowerCase();
        if (encoding5 === "ucs2" || encoding5 === "ucs-2" || encoding5 === "utf16le" || encoding5 === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i6) {
        if (indexSize === 1) {
          return buf[i6];
        } else {
          return buf.readUInt16BE(i6 * indexSize);
        }
      }
      var i5;
      if (dir) {
        var foundIndex = -1;
        for (i5 = byteOffset; i5 < arrLength; i5++) {
          if (read(arr, i5) === read(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i5;
            if (i5 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i5 -= i5 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i5 = byteOffset; i5 >= 0; i5--) {
          var found = true;
          for (var j5 = 0; j5 < valLength; j5++) {
            if (read(arr, i5 + j5) !== read(val, j5)) {
              found = false;
              break;
            }
          }
          if (found)
            return i5;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding5) {
      return this.indexOf(val, byteOffset, encoding5) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding5) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding5, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding5) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding5, false);
    };
    function hexWrite(buf, string2, offset2, length) {
      offset2 = Number(offset2) || 0;
      var remaining = buf.length - offset2;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i5 = 0; i5 < length; ++i5) {
        var parsed = parseInt(string2.substr(i5 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i5;
        buf[offset2 + i5] = parsed;
      }
      return i5;
    }
    function utf8Write(buf, string2, offset2, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset2), buf, offset2, length);
    }
    function asciiWrite(buf, string2, offset2, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset2, length);
    }
    function base64Write(buf, string2, offset2, length) {
      return blitBuffer(base64ToBytes(string2), buf, offset2, length);
    }
    function ucs2Write(buf, string2, offset2, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
    }
    Buffer3.prototype.write = function write(string2, offset2, length, encoding5) {
      if (offset2 === void 0) {
        encoding5 = "utf8";
        length = this.length;
        offset2 = 0;
      } else if (length === void 0 && typeof offset2 === "string") {
        encoding5 = offset2;
        length = this.length;
        offset2 = 0;
      } else if (isFinite(offset2)) {
        offset2 = offset2 >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding5 === void 0)
            encoding5 = "utf8";
        } else {
          encoding5 = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset2;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding5)
        encoding5 = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding5) {
          case "hex":
            return hexWrite(this, string2, offset2, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset2, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset2, length);
          case "base64":
            return base64Write(this, string2, offset2, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset2, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding5);
            encoding5 = ("" + encoding5).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i5 = start;
      while (i5 < end) {
        var firstByte = buf[i5];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i5 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i5 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              fourthByte = buf[i5 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i5 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i5 = 0;
      while (i5 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i5 = start; i5 < end; ++i5) {
        out += hexSliceLookupTable[buf[i5]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i5 = 0; i5 < bytes.length - 1; i5 += 2) {
        res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset2, ext, length) {
      if (offset2 % 1 !== 0 || offset2 < 0)
        throw new RangeError("offset is not uint");
      if (offset2 + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      var val = this[offset2];
      var mul3 = 1;
      var i5 = 0;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        val += this[offset2 + i5] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset2, byteLength2, this.length);
      }
      var val = this[offset2 + --byteLength2];
      var mul3 = 1;
      while (byteLength2 > 0 && (mul3 *= 256)) {
        val += this[offset2 + --byteLength2] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 1, this.length);
      return this[offset2];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      return this[offset2] | this[offset2 + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      return this[offset2] << 8 | this[offset2 + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      var val = this[offset2];
      var mul3 = 1;
      var i5 = 0;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        val += this[offset2 + i5] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, byteLength2, this.length);
      var i5 = byteLength2;
      var mul3 = 1;
      var val = this[offset2 + --i5];
      while (i5 > 0 && (mul3 *= 256)) {
        val += this[offset2 + --i5] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 1, this.length);
      if (!(this[offset2] & 128))
        return this[offset2];
      return (255 - this[offset2] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      var val = this[offset2] | this[offset2 + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 2, this.length);
      var val = this[offset2 + 1] | this[offset2] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, false, 52, 8);
    };
    function checkInt(buf, value, offset2, ext, max2, min2) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset2 + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      var mul3 = 1;
      var i5 = 0;
      this[offset2] = value & 255;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        this[offset2 + i5] = value / mul3 & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      var i5 = byteLength2 - 1;
      var mul3 = 1;
      this[offset2 + i5] = value & 255;
      while (--i5 >= 0 && (mul3 *= 256)) {
        this[offset2 + i5] = value / mul3 & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 1, 255, 0);
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2 + 3] = value >>> 24;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 1] = value >>> 8;
      this[offset2] = value & 255;
      return offset2 + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      var i5 = 0;
      var mul3 = 1;
      var sub = 0;
      this[offset2] = value & 255;
      while (++i5 < byteLength2 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i5] = (value / mul3 >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      var i5 = byteLength2 - 1;
      var mul3 = 1;
      var sub = 0;
      this[offset2 + i5] = value & 255;
      while (--i5 >= 0 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i5] = (value / mul3 >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 3] = value >>> 24;
      return offset2 + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    function checkIEEE754(buf, value, offset2, ext, max2, min2) {
      if (offset2 + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset2 < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset2, littleEndian, 23, 4);
      return offset2 + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, false, noAssert);
    };
    function writeDouble(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset2, littleEndian, 52, 8);
      return offset2 + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding5) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding5 = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding5 = end;
          end = this.length;
        }
        if (encoding5 !== void 0 && typeof encoding5 !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding5 === "string" && !Buffer3.isEncoding(encoding5)) {
          throw new TypeError("Unknown encoding: " + encoding5);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding5 === "utf8" && code < 128 || encoding5 === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding5);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i5 = 0; i5 < length; ++i5) {
        codePoint = string2.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i5 = 0; i5 < str.length; ++i5) {
        byteArray.push(str.charCodeAt(i5) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c5, hi, lo;
      var byteArray = [];
      for (var i5 = 0; i5 < str.length; ++i5) {
        if ((units -= 2) < 0)
          break;
        c5 = str.charCodeAt(i5);
        hi = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset2, length) {
      for (var i5 = 0; i5 < length; ++i5) {
        if (i5 + offset2 >= dst.length || i5 >= src.length)
          break;
        dst[i5 + offset2] = src[i5];
      }
      return i5;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i5 = 0; i5 < 16; ++i5) {
        var i16 = i5 * 16;
        for (var j5 = 0; j5 < 16; ++j5) {
          table[i16 + j5] = alphabet[i5] + alphabet[j5];
        }
      }
      return table;
    }();
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var BufferUtil = require_typedarray_buffer();
    var Polynomial = require_polynomial();
    var Buffer3 = require_buffer3().Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode5(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad2 = BufferUtil.alloc(this.degree);
      var paddedData = Buffer3.concat([data, pad2], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version29) {
      return !isNaN(version29) && version29 >= 1 && version29 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version29) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version29)) {
        throw new Error("Invalid version: " + version29);
      }
      if (version29 >= 1 && version29 < 10)
        return mode.ccBits[0];
      else if (version29 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString2(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string2);
      }
    }
    exports.from = function from2(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e5) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils6();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray2 = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version29) {
      return Mode.getCharCountIndicator(mode, version29) + 4;
    }
    function getTotalBitsFromDataArray(segments, version29) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version29);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from2(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version29, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version29)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version29);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version29, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version29);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray2(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version29) {
      if (!VersionCheck.isValid(version29) || version29 < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d5 = version29 << 12;
      while (Utils.getBCHDigit(d5) - G18_BCH >= 0) {
        d5 ^= G18 << Utils.getBCHDigit(d5) - G18_BCH;
      }
      return version29 << 12 | d5;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils6();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask2) {
      var data = errorCorrectionLevel.bit << 3 | mask2;
      var d5 = data << 10;
      while (Utils.getBCHDigit(d5) - G15_BCH >= 0) {
        d5 ^= G15 << Utils.getBCHDigit(d5) - G15_BCH;
      }
      return (data << 10 | d5) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      var i5, group, value;
      for (i5 = 0; i5 + 3 <= this.data.length; i5 += 3) {
        group = this.data.substr(i5, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      var remainingNum = this.data.length - i5;
      if (remainingNum > 0) {
        group = this.data.substr(i5);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      var i5;
      for (i5 = 0; i5 + 2 <= this.data.length; i5 += 2) {
        var value = ALPHA_NUM_CHARS.indexOf(this.data[i5]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i5 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i5]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var BufferUtil = require_typedarray_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i5 = 0, l5 = this.data.length; i5 < l5; i5++) {
        bitBuffer.put(this.data[i5], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils6();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i5;
      for (i5 = 0; i5 < this.data.length; i5++) {
        var value = Utils.toSJIS(this.data[i5]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error("Invalid SJIS character: " + this.data[i5] + "\nMake sure your charset is UTF-8");
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s6, d5) {
        var predecessors = {};
        var costs = {};
        costs[s6] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s6, 0);
        var closest, u5, v8, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u5 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u5] || {};
          for (v8 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v8)) {
              cost_of_e = adjacent_nodes[v8];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v8];
              first_visit = typeof costs[v8] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v8] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v8, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v8] = u5;
              }
            }
          }
        }
        if (typeof d5 !== "undefined" && typeof costs[d5] === "undefined") {
          var msg = ["Could not find a path from ", s6, " to ", d5, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d5) {
        var nodes = [];
        var u5 = d5;
        var predecessor;
        while (u5) {
          nodes.push(u5);
          predecessor = predecessors[u5];
          u5 = predecessors[u5];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s6, d5) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s6, d5);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d5);
      },
      PriorityQueue: {
        make: function(opts) {
          var T6 = dijkstra.PriorityQueue, t5 = {}, key2;
          opts = opts || {};
          for (key2 in T6) {
            if (T6.hasOwnProperty(key2)) {
              t5[key2] = T6[key2];
            }
          }
          t5.queue = [];
          t5.sorter = opts.sorter || T6.default_sorter;
          return t5;
        },
        default_sorter: function(a5, b4) {
          return a5.cost - b4.cost;
        },
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils6();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      var segments = [];
      var result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i5 = 0; i5 < segs.length; i5++) {
        var seg = segs[i5];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version29) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i5 = 0; i5 < nodes.length; i5++) {
        var nodeGroup = nodes[i5];
        var currentNodeIds = [];
        for (var j5 = 0; j5 < nodeGroup.length; j5++) {
          var node = nodeGroup[j5];
          var key2 = "" + i5 + j5;
          currentNodeIds.push(key2);
          table[key2] = { node, lastCount: 0 };
          graph[key2] = {};
          for (var n3 = 0; n3 < prevNodeIds.length; n3++) {
            var prevNodeId = prevNodeIds[n3];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version29);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n3 = 0; n3 < prevNodeIds.length; n3++) {
        graph[prevNodeIds[n3]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray2(array2) {
      return array2.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version29) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version29);
      var path = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i5 = 1; i5 < path.length - 1; i5++) {
        optimizedSegs.push(graph.table[path[i5]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var BufferUtil = require_typedarray_buffer();
    var Utils = require_utils6();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray2 = require_isarray();
    function setupFinderPattern(matrix, version29) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version29);
      for (var i5 = 0; i5 < pos.length; i5++) {
        var row = pos[i5][0];
        var col = pos[i5][1];
        for (var r6 = -1; r6 <= 7; r6++) {
          if (row + r6 <= -1 || size <= row + r6)
            continue;
          for (var c5 = -1; c5 <= 7; c5++) {
            if (col + c5 <= -1 || size <= col + c5)
              continue;
            if (r6 >= 0 && r6 <= 6 && (c5 === 0 || c5 === 6) || c5 >= 0 && c5 <= 6 && (r6 === 0 || r6 === 6) || r6 >= 2 && r6 <= 4 && c5 >= 2 && c5 <= 4) {
              matrix.set(row + r6, col + c5, true, true);
            } else {
              matrix.set(row + r6, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r6 = 8; r6 < size - 8; r6++) {
        var value = r6 % 2 === 0;
        matrix.set(r6, 6, value, true);
        matrix.set(6, r6, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version29) {
      var pos = AlignmentPattern.getPositions(version29);
      for (var i5 = 0; i5 < pos.length; i5++) {
        var row = pos[i5][0];
        var col = pos[i5][1];
        for (var r6 = -2; r6 <= 2; r6++) {
          for (var c5 = -2; c5 <= 2; c5++) {
            if (r6 === -2 || r6 === 2 || c5 === -2 || c5 === 2 || r6 === 0 && c5 === 0) {
              matrix.set(row + r6, col + c5, true, true);
            } else {
              matrix.set(row + r6, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version29) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version29);
      var row, col, mod;
      for (var i5 = 0; i5 < 18; i5++) {
        row = Math.floor(i5 / 3);
        col = i5 % 3 + size - 8 - 3;
        mod = (bits >> i5 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i5, mod;
      for (i5 = 0; i5 < 15; i5++) {
        mod = (bits >> i5 & 1) === 1;
        if (i5 < 6) {
          matrix.set(i5, 8, mod, true);
        } else if (i5 < 8) {
          matrix.set(i5 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i5, 8, mod, true);
        }
        if (i5 < 8) {
          matrix.set(8, size - i5 - 1, mod, true);
        } else if (i5 < 9) {
          matrix.set(8, 15 - i5 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i5 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (!matrix.isReserved(row, col - c5)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c5, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version29, errorCorrectionLevel, segments) {
      var buffer2 = new BitBuffer();
      segments.forEach(function(data) {
        buffer2.put(data.mode.bit, 4);
        buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version29));
        data.write(buffer2);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version29);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version29, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 !== 0) {
        buffer2.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
      for (var i5 = 0; i5 < remainingByte; i5++) {
        buffer2.put(i5 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer2, version29, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version29, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version29);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version29, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version29, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs = new ReedSolomonEncoder(ecCount);
      var offset2 = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer2 = BufferUtil.from(bitBuffer.buffer);
      for (var b4 = 0; b4 < ecTotalBlocks; b4++) {
        var dataSize = b4 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b4] = buffer2.slice(offset2, offset2 + dataSize);
        ecData[b4] = rs.encode(dcData[b4]);
        offset2 += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index = 0;
      var i5, r6;
      for (i5 = 0; i5 < maxDataSize; i5++) {
        for (r6 = 0; r6 < ecTotalBlocks; r6++) {
          if (i5 < dcData[r6].length) {
            data[index++] = dcData[r6][i5];
          }
        }
      }
      for (i5 = 0; i5 < ecCount; i5++) {
        for (r6 = 0; r6 < ecTotalBlocks; r6++) {
          data[index++] = ecData[r6][i5];
        }
      }
      return data;
    }
    function createSymbol(data, version29, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray2(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version29;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version29) {
        version29 = bestVersion;
      } else if (version29 < bestVersion) {
        throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
      }
      var dataBits = createData(version29, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version29);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version29);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version29);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version29 >= 7) {
        setupVersionInfo(modules, version29);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version29,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create2(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version29;
      var mask2;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version29 = Version.from(options.version);
        mask2 = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version29, errorCorrectionLevel, mask2);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils7 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c5) {
          return [c5, c5];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue2 = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue2 >> 24 & 255,
        g: hexValue2 >> 16 & 255,
        b: hexValue2 >> 8 & 255,
        a: hexValue2 & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i5 = 0; i5 < symbolSize; i5++) {
        for (var j5 = 0; j5 < symbolSize; j5++) {
          var posDst = (i5 * symbolSize + j5) * 4;
          var pxColor = opts.color.light;
          if (i5 >= scaledMargin && j5 >= scaledMargin && i5 < symbolSize - scaledMargin && j5 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i5 - scaledMargin) / scale);
            var jSrc = Math.floor((j5 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils7();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e5) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports.render(qrData, canvas, opts);
      var type2 = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type2, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils7();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x5, y5) {
      var str = cmd + x5;
      if (typeof y5 !== "undefined")
        str += " " + y5;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i5 = 0; i5 < data.length; i5++) {
        var col = Math.floor(i5 % size);
        var row = Math.floor(i5 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i5]) {
          lineLength++;
          if (!(i5 > 0 && col > 0 && data[i5 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i5 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser6 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e5) {
            reject(e5);
          }
        });
      }
      try {
        var data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e5) {
        cb(e5);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _10, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i5 = 0; i5 < selection.rangeCount; i5++) {
        ranges.push(selection.getRangeAt(i5));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range2) {
            selection.addRange(range2);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range2, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range2 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e5) {
          e5.stopPropagation();
          if (options.format) {
            e5.preventDefault();
            if (typeof e5.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e5.clipboardData.clearData();
              e5.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e5.preventDefault();
            options.onCopy(e5.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range2.selectNodeContents(mark);
        selection.addRange(range2);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range2);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/preact/dist/preact.module.js
function a3(n3, l5) {
  for (var u5 in l5)
    n3[u5] = l5[u5];
  return n3;
}
function v6(n3) {
  var l5 = n3.parentNode;
  l5 && l5.removeChild(n3);
}
function h3(n3, l5, u5) {
  var i5, t5 = arguments, r6 = {};
  for (i5 in l5)
    i5 !== "key" && i5 !== "ref" && (r6[i5] = l5[i5]);
  if (arguments.length > 3)
    for (u5 = [u5], i5 = 3; i5 < arguments.length; i5++)
      u5.push(t5[i5]);
  if (u5 != null && (r6.children = u5), typeof n3 == "function" && n3.defaultProps != null)
    for (i5 in n3.defaultProps)
      r6[i5] === void 0 && (r6[i5] = n3.defaultProps[i5]);
  return p3(n3, r6, l5 && l5.key, l5 && l5.ref, null);
}
function p3(l5, u5, i5, t5, r6) {
  var o5 = { type: l5, props: u5, key: i5, ref: t5, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r6 };
  return r6 == null && (o5.__v = o5), n2.vnode && n2.vnode(o5), o5;
}
function y3() {
  return {};
}
function d3(n3) {
  return n3.children;
}
function m3(n3, l5) {
  this.props = n3, this.context = l5;
}
function w3(n3, l5) {
  if (l5 == null)
    return n3.__ ? w3(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u5; l5 < n3.__k.length; l5++)
    if ((u5 = n3.__k[l5]) != null && u5.__e != null)
      return u5.__e;
  return typeof n3.type == "function" ? w3(n3) : null;
}
function k3(n3) {
  var l5, u5;
  if ((n3 = n3.__) != null && n3.__c != null) {
    for (n3.__e = n3.__c.base = null, l5 = 0; l5 < n3.__k.length; l5++)
      if ((u5 = n3.__k[l5]) != null && u5.__e != null) {
        n3.__e = n3.__c.base = u5.__e;
        break;
      }
    return k3(n3);
  }
}
function g3(l5) {
  (!l5.__d && (l5.__d = true) && u3.push(l5) && !i3++ || r4 !== n2.debounceRendering) && ((r4 = n2.debounceRendering) || t3)(_5);
}
function _5() {
  for (var n3; i3 = u3.length; )
    n3 = u3.sort(function(n4, l5) {
      return n4.__v.__b - l5.__v.__b;
    }), u3 = [], n3.some(function(n4) {
      var l5, u5, i5, t5, r6, o5, f7;
      n4.__d && (o5 = (r6 = (l5 = n4).__v).__e, (f7 = l5.__P) && (u5 = [], (i5 = a3({}, r6)).__v = i5, t5 = A3(f7, r6, i5, l5.__n, f7.ownerSVGElement !== void 0, null, u5, o5 == null ? w3(r6) : o5), T3(u5, r6), t5 != o5 && k3(r6)));
    });
}
function b3(n3, l5, u5, i5, t5, r6, o5, f7, s6) {
  var a5, h5, p5, y5, d5, m5, k5, g5 = u5 && u5.__k || c3, _10 = g5.length;
  if (f7 == e3 && (f7 = r6 != null ? r6[0] : _10 ? w3(u5, 0) : null), a5 = 0, l5.__k = x3(l5.__k, function(u6) {
    if (u6 != null) {
      if (u6.__ = l5, u6.__b = l5.__b + 1, (p5 = g5[a5]) === null || p5 && u6.key == p5.key && u6.type === p5.type)
        g5[a5] = void 0;
      else
        for (h5 = 0; h5 < _10; h5++) {
          if ((p5 = g5[h5]) && u6.key == p5.key && u6.type === p5.type) {
            g5[h5] = void 0;
            break;
          }
          p5 = null;
        }
      if (y5 = A3(n3, u6, p5 = p5 || e3, i5, t5, r6, o5, f7, s6), (h5 = u6.ref) && p5.ref != h5 && (k5 || (k5 = []), p5.ref && k5.push(p5.ref, null, u6), k5.push(h5, u6.__c || y5, u6)), y5 != null) {
        var c5;
        if (m5 == null && (m5 = y5), u6.__d !== void 0)
          c5 = u6.__d, u6.__d = void 0;
        else if (r6 == p5 || y5 != f7 || y5.parentNode == null) {
          n:
            if (f7 == null || f7.parentNode !== n3)
              n3.appendChild(y5), c5 = null;
            else {
              for (d5 = f7, h5 = 0; (d5 = d5.nextSibling) && h5 < _10; h5 += 2)
                if (d5 == y5)
                  break n;
              n3.insertBefore(y5, f7), c5 = f7;
            }
          l5.type == "option" && (n3.value = "");
        }
        f7 = c5 !== void 0 ? c5 : y5.nextSibling, typeof l5.type == "function" && (l5.__d = f7);
      } else
        f7 && p5.__e == f7 && f7.parentNode != n3 && (f7 = w3(p5));
    }
    return a5++, u6;
  }), l5.__e = m5, r6 != null && typeof l5.type != "function")
    for (a5 = r6.length; a5--; )
      r6[a5] != null && v6(r6[a5]);
  for (a5 = _10; a5--; )
    g5[a5] != null && D2(g5[a5], g5[a5]);
  if (k5)
    for (a5 = 0; a5 < k5.length; a5++)
      j3(k5[a5], k5[++a5], k5[++a5]);
}
function x3(n3, l5, u5) {
  if (u5 == null && (u5 = []), n3 == null || typeof n3 == "boolean")
    l5 && u5.push(l5(null));
  else if (Array.isArray(n3))
    for (var i5 = 0; i5 < n3.length; i5++)
      x3(n3[i5], l5, u5);
  else
    u5.push(l5 ? l5(typeof n3 == "string" || typeof n3 == "number" ? p3(null, n3, null, null, n3) : n3.__e != null || n3.__c != null ? p3(n3.type, n3.props, n3.key, null, n3.__v) : n3) : n3);
  return u5;
}
function P2(n3, l5, u5, i5, t5) {
  var r6;
  for (r6 in u5)
    r6 === "children" || r6 === "key" || r6 in l5 || N3(n3, r6, null, u5[r6], i5);
  for (r6 in l5)
    t5 && typeof l5[r6] != "function" || r6 === "children" || r6 === "key" || r6 === "value" || r6 === "checked" || u5[r6] === l5[r6] || N3(n3, r6, l5[r6], u5[r6], i5);
}
function C2(n3, l5, u5) {
  l5[0] === "-" ? n3.setProperty(l5, u5) : n3[l5] = typeof u5 == "number" && s4.test(l5) === false ? u5 + "px" : u5 == null ? "" : u5;
}
function N3(n3, l5, u5, i5, t5) {
  var r6, o5, f7, e5, c5;
  if (t5 ? l5 === "className" && (l5 = "class") : l5 === "class" && (l5 = "className"), l5 === "style")
    if (r6 = n3.style, typeof u5 == "string")
      r6.cssText = u5;
    else {
      if (typeof i5 == "string" && (r6.cssText = "", i5 = null), i5)
        for (e5 in i5)
          u5 && e5 in u5 || C2(r6, e5, "");
      if (u5)
        for (c5 in u5)
          i5 && u5[c5] === i5[c5] || C2(r6, c5, u5[c5]);
    }
  else
    l5[0] === "o" && l5[1] === "n" ? (o5 = l5 !== (l5 = l5.replace(/Capture$/, "")), f7 = l5.toLowerCase(), l5 = (f7 in n3 ? f7 : l5).slice(2), u5 ? (i5 || n3.addEventListener(l5, z2, o5), (n3.l || (n3.l = {}))[l5] = u5) : n3.removeEventListener(l5, z2, o5)) : l5 !== "list" && l5 !== "tagName" && l5 !== "form" && l5 !== "type" && l5 !== "size" && !t5 && l5 in n3 ? n3[l5] = u5 == null ? "" : u5 : typeof u5 != "function" && l5 !== "dangerouslySetInnerHTML" && (l5 !== (l5 = l5.replace(/^xlink:?/, "")) ? u5 == null || u5 === false ? n3.removeAttributeNS("http://www.w3.org/1999/xlink", l5.toLowerCase()) : n3.setAttributeNS("http://www.w3.org/1999/xlink", l5.toLowerCase(), u5) : u5 == null || u5 === false && !/^ar/.test(l5) ? n3.removeAttribute(l5) : n3.setAttribute(l5, u5));
}
function z2(l5) {
  this.l[l5.type](n2.event ? n2.event(l5) : l5);
}
function A3(l5, u5, i5, t5, r6, o5, f7, e5, c5) {
  var s6, v8, h5, p5, y5, w6, k5, g5, _10, x5, P4 = u5.type;
  if (u5.constructor !== void 0)
    return null;
  (s6 = n2.__b) && s6(u5);
  try {
    n:
      if (typeof P4 == "function") {
        if (g5 = u5.props, _10 = (s6 = P4.contextType) && t5[s6.__c], x5 = s6 ? _10 ? _10.props.value : s6.__ : t5, i5.__c ? k5 = (v8 = u5.__c = i5.__c).__ = v8.__E : ("prototype" in P4 && P4.prototype.render ? u5.__c = v8 = new P4(g5, x5) : (u5.__c = v8 = new m3(g5, x5), v8.constructor = P4, v8.render = E), _10 && _10.sub(v8), v8.props = g5, v8.state || (v8.state = {}), v8.context = x5, v8.__n = t5, h5 = v8.__d = true, v8.__h = []), v8.__s == null && (v8.__s = v8.state), P4.getDerivedStateFromProps != null && (v8.__s == v8.state && (v8.__s = a3({}, v8.__s)), a3(v8.__s, P4.getDerivedStateFromProps(g5, v8.__s))), p5 = v8.props, y5 = v8.state, h5)
          P4.getDerivedStateFromProps == null && v8.componentWillMount != null && v8.componentWillMount(), v8.componentDidMount != null && v8.__h.push(v8.componentDidMount);
        else {
          if (P4.getDerivedStateFromProps == null && g5 !== p5 && v8.componentWillReceiveProps != null && v8.componentWillReceiveProps(g5, x5), !v8.__e && v8.shouldComponentUpdate != null && v8.shouldComponentUpdate(g5, v8.__s, x5) === false || u5.__v === i5.__v && !v8.__) {
            for (v8.props = g5, v8.state = v8.__s, u5.__v !== i5.__v && (v8.__d = false), v8.__v = u5, u5.__e = i5.__e, u5.__k = i5.__k, v8.__h.length && f7.push(v8), s6 = 0; s6 < u5.__k.length; s6++)
              u5.__k[s6] && (u5.__k[s6].__ = u5);
            break n;
          }
          v8.componentWillUpdate != null && v8.componentWillUpdate(g5, v8.__s, x5), v8.componentDidUpdate != null && v8.__h.push(function() {
            v8.componentDidUpdate(p5, y5, w6);
          });
        }
        v8.context = x5, v8.props = g5, v8.state = v8.__s, (s6 = n2.__r) && s6(u5), v8.__d = false, v8.__v = u5, v8.__P = l5, s6 = v8.render(v8.props, v8.state, v8.context), u5.__k = s6 != null && s6.type == d3 && s6.key == null ? s6.props.children : Array.isArray(s6) ? s6 : [s6], v8.getChildContext != null && (t5 = a3(a3({}, t5), v8.getChildContext())), h5 || v8.getSnapshotBeforeUpdate == null || (w6 = v8.getSnapshotBeforeUpdate(p5, y5)), b3(l5, u5, i5, t5, r6, o5, f7, e5, c5), v8.base = u5.__e, v8.__h.length && f7.push(v8), k5 && (v8.__E = v8.__ = null), v8.__e = false;
      } else
        o5 == null && u5.__v === i5.__v ? (u5.__k = i5.__k, u5.__e = i5.__e) : u5.__e = $2(i5.__e, u5, i5, t5, r6, o5, f7, c5);
    (s6 = n2.diffed) && s6(u5);
  } catch (l6) {
    u5.__v = null, n2.__e(l6, u5, i5);
  }
  return u5.__e;
}
function T3(l5, u5) {
  n2.__c && n2.__c(u5, l5), l5.some(function(u6) {
    try {
      l5 = u6.__h, u6.__h = [], l5.some(function(n3) {
        n3.call(u6);
      });
    } catch (l6) {
      n2.__e(l6, u6.__v);
    }
  });
}
function $2(n3, l5, u5, i5, t5, r6, o5, f7) {
  var s6, a5, v8, h5, p5, y5 = u5.props, d5 = l5.props;
  if (t5 = l5.type === "svg" || t5, r6 != null) {
    for (s6 = 0; s6 < r6.length; s6++)
      if ((a5 = r6[s6]) != null && ((l5.type === null ? a5.nodeType === 3 : a5.localName === l5.type) || n3 == a5)) {
        n3 = a5, r6[s6] = null;
        break;
      }
  }
  if (n3 == null) {
    if (l5.type === null)
      return document.createTextNode(d5);
    n3 = t5 ? document.createElementNS("http://www.w3.org/2000/svg", l5.type) : document.createElement(l5.type, d5.is && { is: d5.is }), r6 = null, f7 = false;
  }
  if (l5.type === null)
    y5 !== d5 && n3.data != d5 && (n3.data = d5);
  else {
    if (r6 != null && (r6 = c3.slice.call(n3.childNodes)), v8 = (y5 = u5.props || e3).dangerouslySetInnerHTML, h5 = d5.dangerouslySetInnerHTML, !f7) {
      if (y5 === e3)
        for (y5 = {}, p5 = 0; p5 < n3.attributes.length; p5++)
          y5[n3.attributes[p5].name] = n3.attributes[p5].value;
      (h5 || v8) && (h5 && v8 && h5.__html == v8.__html || (n3.innerHTML = h5 && h5.__html || ""));
    }
    P2(n3, d5, y5, t5, f7), h5 ? l5.__k = [] : (l5.__k = l5.props.children, b3(n3, l5, u5, i5, l5.type !== "foreignObject" && t5, r6, o5, e3, f7)), f7 || ("value" in d5 && (s6 = d5.value) !== void 0 && s6 !== n3.value && N3(n3, "value", s6, y5.value, false), "checked" in d5 && (s6 = d5.checked) !== void 0 && s6 !== n3.checked && N3(n3, "checked", s6, y5.checked, false));
  }
  return n3;
}
function j3(l5, u5, i5) {
  try {
    typeof l5 == "function" ? l5(u5) : l5.current = u5;
  } catch (l6) {
    n2.__e(l6, i5);
  }
}
function D2(l5, u5, i5) {
  var t5, r6, o5;
  if (n2.unmount && n2.unmount(l5), (t5 = l5.ref) && (t5.current && t5.current !== l5.__e || j3(t5, null, u5)), i5 || typeof l5.type == "function" || (i5 = (r6 = l5.__e) != null), l5.__e = l5.__d = void 0, (t5 = l5.__c) != null) {
    if (t5.componentWillUnmount)
      try {
        t5.componentWillUnmount();
      } catch (l6) {
        n2.__e(l6, u5);
      }
    t5.base = t5.__P = null;
  }
  if (t5 = l5.__k)
    for (o5 = 0; o5 < t5.length; o5++)
      t5[o5] && D2(t5[o5], u5, i5);
  r6 != null && v6(r6);
}
function E(n3, l5, u5) {
  return this.constructor(n3, u5);
}
function H2(l5, u5, i5) {
  var t5, r6, f7;
  n2.__ && n2.__(l5, u5), r6 = (t5 = i5 === o3) ? null : i5 && i5.__k || u5.__k, l5 = h3(d3, null, [l5]), f7 = [], A3(u5, (t5 ? u5 : i5 || u5).__k = l5, r6 || e3, e3, u5.ownerSVGElement !== void 0, i5 && !t5 ? [i5] : r6 ? null : c3.slice.call(u5.childNodes), f7, i5 || e3, t5), T3(f7, l5);
}
function I3(n3, l5) {
  H2(n3, l5, o3);
}
function L2(n3, l5) {
  var u5, i5;
  for (i5 in l5 = a3(a3({}, n3.props), l5), arguments.length > 2 && (l5.children = c3.slice.call(arguments, 2)), u5 = {}, l5)
    i5 !== "key" && i5 !== "ref" && (u5[i5] = l5[i5]);
  return p3(n3.type, u5, l5.key || n3.key, l5.ref || n3.ref, null);
}
function M2(n3) {
  var l5 = {}, u5 = { __c: "__cC" + f5++, __: n3, Consumer: function(n4, l6) {
    return n4.children(l6);
  }, Provider: function(n4) {
    var i5, t5 = this;
    return this.getChildContext || (i5 = [], this.getChildContext = function() {
      return l5[u5.__c] = t5, l5;
    }, this.shouldComponentUpdate = function(n5) {
      t5.props.value !== n5.value && i5.some(function(l6) {
        l6.context = n5.value, g3(l6);
      });
    }, this.sub = function(n5) {
      i5.push(n5);
      var l6 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        i5.splice(i5.indexOf(n5), 1), l6 && l6.call(n5);
      };
    }), n4.children;
  } };
  return u5.Consumer.contextType = u5, u5.Provider.__ = u5, u5;
}
var n2, l3, u3, i3, t3, r4, o3, f5, e3, c3, s4;
var init_preact_module2 = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    e3 = {};
    c3 = [];
    s4 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    n2 = { __e: function(n3, l5) {
      for (var u5, i5; l5 = l5.__; )
        if ((u5 = l5.__c) && !u5.__)
          try {
            if (u5.constructor && u5.constructor.getDerivedStateFromError != null && (i5 = true, u5.setState(u5.constructor.getDerivedStateFromError(n3))), u5.componentDidCatch != null && (i5 = true, u5.componentDidCatch(n3)), i5)
              return g3(u5.__E = u5);
          } catch (l6) {
            n3 = l6;
          }
      throw n3;
    } }, l3 = function(n3) {
      return n3 != null && n3.constructor === void 0;
    }, m3.prototype.setState = function(n3, l5) {
      var u5;
      u5 = this.__s !== this.state ? this.__s : this.__s = a3({}, this.state), typeof n3 == "function" && (n3 = n3(u5, this.props)), n3 && a3(u5, n3), n3 != null && this.__v && (l5 && this.__h.push(l5), g3(this));
    }, m3.prototype.forceUpdate = function(n3) {
      this.__v && (this.__e = true, n3 && this.__h.push(n3), g3(this));
    }, m3.prototype.render = d3, u3 = [], i3 = 0, t3 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o3 = e3, f5 = 0;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
function v7(t5, r6) {
  n2.__h && n2.__h(u4, t5, i4 || r6), i4 = 0;
  var o5 = u4.__H || (u4.__H = { __: [], __h: [] });
  return t5 >= o5.__.length && o5.__.push({}), o5.__[t5];
}
function m4(n3) {
  return i4 = 1, p4(E2, n3);
}
function p4(n3, r6, i5) {
  var o5 = v7(t4++, 2);
  return o5.__c || (o5.__c = u4, o5.__ = [i5 ? i5(r6) : E2(void 0, r6), function(t5) {
    var u5 = n3(o5.__[0], t5);
    o5.__[0] !== u5 && (o5.__[0] = u5, o5.__c.setState({}));
  }]), o5.__;
}
function l4(r6, i5) {
  var o5 = v7(t4++, 3);
  !n2.__s && x4(o5.__H, i5) && (o5.__ = r6, o5.__H = i5, u4.__H.__h.push(o5));
}
function y4(r6, i5) {
  var o5 = v7(t4++, 4);
  !n2.__s && x4(o5.__H, i5) && (o5.__ = r6, o5.__H = i5, u4.__h.push(o5));
}
function d4(n3) {
  return i4 = 5, h4(function() {
    return { current: n3 };
  }, []);
}
function s5(n3, t5, u5) {
  i4 = 6, y4(function() {
    typeof n3 == "function" ? n3(t5()) : n3 && (n3.current = t5());
  }, u5 == null ? u5 : u5.concat(n3));
}
function h4(n3, u5) {
  var r6 = v7(t4++, 7);
  return x4(r6.__H, u5) ? (r6.__H = u5, r6.__h = n3, r6.__ = n3()) : r6.__;
}
function T4(n3, t5) {
  return i4 = 8, h4(function() {
    return n3;
  }, t5);
}
function w4(n3) {
  var r6 = u4.context[n3.__c], i5 = v7(t4++, 9);
  return i5.__c = n3, r6 ? (i5.__ == null && (i5.__ = true, r6.sub(u4)), r6.props.value) : n3.__;
}
function A4(t5, u5) {
  n2.useDebugValue && n2.useDebugValue(u5 ? u5(t5) : t5);
}
function F2(n3) {
  var r6 = v7(t4++, 10), i5 = m4();
  return r6.__ = n3, u4.componentDidCatch || (u4.componentDidCatch = function(n4) {
    r6.__ && r6.__(n4), i5[1](n4);
  }), [i5[0], function() {
    i5[1](void 0);
  }];
}
function _8() {
  o4.some(function(t5) {
    if (t5.__P)
      try {
        t5.__H.__h.forEach(g4), t5.__H.__h.forEach(q3), t5.__H.__h = [];
      } catch (u5) {
        return t5.__H.__h = [], n2.__e(u5, t5.__v), true;
      }
  }), o4 = [];
}
function g4(n3) {
  n3.t && n3.t();
}
function q3(n3) {
  var t5 = n3.__();
  typeof t5 == "function" && (n3.t = t5);
}
function x4(n3, t5) {
  return !n3 || t5.some(function(t6, u5) {
    return t6 !== n3[u5];
  });
}
function E2(n3, t5) {
  return typeof t5 == "function" ? t5(n3) : t5;
}
var t4, u4, r5, i4, o4, c4, f6, e4, a4;
var init_hooks_module2 = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module2();
    i4 = 0;
    o4 = [];
    c4 = n2.__r;
    f6 = n2.diffed;
    e4 = n2.__c;
    a4 = n2.unmount;
    n2.__r = function(n3) {
      c4 && c4(n3), t4 = 0, (u4 = n3.__c).__H && (u4.__H.__h.forEach(g4), u4.__H.__h.forEach(q3), u4.__H.__h = []);
    }, n2.diffed = function(t5) {
      f6 && f6(t5);
      var u5 = t5.__c;
      if (u5) {
        var i5 = u5.__H;
        i5 && i5.__h.length && (o4.push(u5) !== 1 && r5 === n2.requestAnimationFrame || ((r5 = n2.requestAnimationFrame) || function(n3) {
          var t6, u6 = function() {
            clearTimeout(r6), cancelAnimationFrame(t6), setTimeout(n3);
          }, r6 = setTimeout(u6, 100);
          typeof window != "undefined" && (t6 = requestAnimationFrame(u6));
        })(_8));
      }
    }, n2.__c = function(t5, u5) {
      u5.some(function(t6) {
        try {
          t6.__h.forEach(g4), t6.__h = t6.__h.filter(function(n3) {
            return !n3.__ || q3(n3);
          });
        } catch (r6) {
          u5.some(function(n3) {
            n3.__h && (n3.__h = []);
          }), u5 = [], n2.__e(r6, t6.__v);
        }
      }), e4 && e4(t5, u5);
    }, n2.unmount = function(t5) {
      a4 && a4(t5);
      var u5 = t5.__c;
      if (u5) {
        var r6 = u5.__H;
        if (r6)
          try {
            r6.__.forEach(function(n3) {
              return n3.t && n3.t();
            });
          } catch (t6) {
            n2.__e(t6, u5.__v);
          }
      }
    };
  }
});

// node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => R,
  Component: () => m3,
  Fragment: () => d3,
  PureComponent: () => C3,
  Suspense: () => U,
  SuspenseList: () => O2,
  cloneElement: () => K2,
  createContext: () => M2,
  createElement: () => h3,
  createFactory: () => G,
  createPortal: () => z3,
  createRef: () => y3,
  default: () => compat_module_default,
  findDOMNode: () => X,
  forwardRef: () => S2,
  hydrate: () => V,
  isValidElement: () => J,
  lazy: () => L3,
  memo: () => _9,
  render: () => T5,
  unmountComponentAtNode: () => Q,
  unstable_batchedUpdates: () => Y,
  useCallback: () => T4,
  useContext: () => w4,
  useDebugValue: () => A4,
  useEffect: () => l4,
  useErrorBoundary: () => F2,
  useImperativeHandle: () => s5,
  useLayoutEffect: () => y4,
  useMemo: () => h4,
  useReducer: () => p4,
  useRef: () => d4,
  useState: () => m4,
  version: () => B2
});
function E3(n3, t5) {
  for (var e5 in t5)
    n3[e5] = t5[e5];
  return n3;
}
function w5(n3, t5) {
  for (var e5 in n3)
    if (e5 !== "__source" && !(e5 in t5))
      return true;
  for (var r6 in t5)
    if (r6 !== "__source" && n3[r6] !== t5[r6])
      return true;
  return false;
}
function _9(n3, t5) {
  function e5(n4) {
    var e6 = this.props.ref, r7 = e6 == n4.ref;
    return !r7 && e6 && (e6.call ? e6(null) : e6.current = null), t5 ? !t5(this.props, n4) || !r7 : w5(this.props, n4);
  }
  function r6(t6) {
    return this.shouldComponentUpdate = e5, h3(n3, E3({}, t6));
  }
  return r6.prototype.isReactComponent = true, r6.displayName = "Memo(" + (n3.displayName || n3.name) + ")", r6.t = true, r6;
}
function S2(n3) {
  function t5(t6) {
    var e5 = E3({}, t6);
    return delete e5.ref, n3(e5, t6.ref);
  }
  return t5.prototype.isReactComponent = t5.t = true, t5.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t5;
}
function N4(n3) {
  return n3 && ((n3 = E3({}, n3)).__c = null, n3.__k = n3.__k && n3.__k.map(N4)), n3;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M3(n3) {
  var t5 = n3.__.__c;
  return t5 && t5.u && t5.u(n3);
}
function L3(n3) {
  var t5, e5, r6;
  function o5(o6) {
    if (t5 || (t5 = n3()).then(function(n4) {
      e5 = n4.default || n4;
    }, function(n4) {
      r6 = n4;
    }), r6)
      throw r6;
    if (!e5)
      throw t5;
    return h3(e5, o6);
  }
  return o5.displayName = "Lazy", o5.t = true, o5;
}
function O2() {
  this.i = null, this.l = null;
}
function j4(n3) {
  var t5 = this, e5 = n3.container, r6 = h3(W, { context: t5.context }, n3.vnode);
  return t5.s && t5.s !== e5 && (t5.v.parentNode && t5.s.removeChild(t5.v), D2(t5.h), t5.p = false), n3.vnode ? t5.p ? (e5.__k = t5.__k, H2(r6, e5), t5.__k = e5.__k) : (t5.v = document.createTextNode(""), I3("", e5), e5.appendChild(t5.v), t5.p = true, t5.s = e5, H2(r6, e5, t5.v), t5.__k = t5.v.__k) : t5.p && (t5.v.parentNode && t5.s.removeChild(t5.v), D2(t5.h)), t5.h = r6, t5.componentWillUnmount = function() {
    t5.v.parentNode && t5.s.removeChild(t5.v), D2(t5.h);
  }, null;
}
function z3(n3, t5) {
  return h3(j4, { vnode: n3, container: t5 });
}
function T5(n3, t5, e5) {
  if (t5.__k == null)
    for (; t5.firstChild; )
      t5.removeChild(t5.firstChild);
  return H2(n3, t5), typeof e5 == "function" && e5(), n3 ? n3.__c : null;
}
function V(n3, t5, e5) {
  return I3(n3, t5), typeof e5 == "function" && e5(), n3 ? n3.__c : null;
}
function I4(n3, t5) {
  n3["UNSAFE_" + t5] && !n3[t5] && Object.defineProperty(n3, t5, { configurable: false, get: function() {
    return this["UNSAFE_" + t5];
  }, set: function(n4) {
    this["UNSAFE_" + t5] = n4;
  } });
}
function G(n3) {
  return h3.bind(null, n3);
}
function J(n3) {
  return !!n3 && n3.$$typeof === H3;
}
function K2(n3) {
  return J(n3) ? L2.apply(null, arguments) : n3;
}
function Q(n3) {
  return !!n3.__k && (H2(null, n3), true);
}
function X(n3) {
  return n3 && (n3.base || n3.nodeType === 1 && n3) || null;
}
var C3, A5, k4, R, F3, P3, W, D3, H3, Z, $3, q4, B2, Y, compat_module_default;
var init_compat_module = __esm({
  "node_modules/preact/compat/dist/compat.module.js"() {
    init_hooks_module2();
    init_hooks_module2();
    init_preact_module2();
    init_preact_module2();
    C3 = function(n3) {
      var t5, e5;
      function r6(t6) {
        var e6;
        return (e6 = n3.call(this, t6) || this).isPureReactComponent = true, e6;
      }
      return e5 = n3, (t5 = r6).prototype = Object.create(e5.prototype), t5.prototype.constructor = t5, t5.__proto__ = e5, r6.prototype.shouldComponentUpdate = function(n4, t6) {
        return w5(this.props, n4) || w5(this.state, t6);
      }, r6;
    }(m3);
    A5 = n2.__b;
    n2.__b = function(n3) {
      n3.type && n3.type.t && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), A5 && A5(n3);
    };
    k4 = function(n3, t5) {
      return n3 ? x3(n3).reduce(function(n4, e5, r6) {
        return n4.concat(t5(e5, r6));
      }, []) : null;
    };
    R = { map: k4, forEach: k4, count: function(n3) {
      return n3 ? x3(n3).length : 0;
    }, only: function(n3) {
      if ((n3 = x3(n3)).length !== 1)
        throw new Error("Children.only() expects only one child.");
      return n3[0];
    }, toArray: x3 };
    F3 = n2.__e;
    n2.__e = function(n3, t5, e5) {
      if (n3.then) {
        for (var r6, o5 = t5; o5 = o5.__; )
          if ((r6 = o5.__c) && r6.__c)
            return r6.__c(n3, t5.__c);
      }
      F3(n3, t5, e5);
    }, (U.prototype = new m3()).__c = function(n3, t5) {
      var e5 = this;
      e5.o == null && (e5.o = []), e5.o.push(t5);
      var r6 = M3(e5.__v), o5 = false, u5 = function() {
        o5 || (o5 = true, r6 ? r6(i5) : i5());
      };
      t5.__c = t5.componentWillUnmount, t5.componentWillUnmount = function() {
        u5(), t5.__c && t5.__c();
      };
      var i5 = function() {
        var n4;
        if (!--e5.__u)
          for (e5.__v.__k[0] = e5.state.u, e5.setState({ u: e5.__b = null }); n4 = e5.o.pop(); )
            n4.forceUpdate();
      };
      e5.__u++ || e5.setState({ u: e5.__b = e5.__v.__k[0] }), n3.then(u5, u5);
    }, U.prototype.render = function(n3, t5) {
      return this.__b && (this.__v.__k[0] = N4(this.__b), this.__b = null), [h3(m3, null, t5.u ? null : n3.children), t5.u && n3.fallback];
    };
    P3 = function(n3, t5, e5) {
      if (++e5[1] === e5[0] && n3.l.delete(t5), n3.props.revealOrder && (n3.props.revealOrder[0] !== "t" || !n3.l.size))
        for (e5 = n3.i; e5; ) {
          for (; e5.length > 3; )
            e5.pop()();
          if (e5[1] < e5[0])
            break;
          n3.i = e5 = e5[2];
        }
    };
    (O2.prototype = new m3()).u = function(n3) {
      var t5 = this, e5 = M3(t5.__v), r6 = t5.l.get(n3);
      return r6[0]++, function(o5) {
        var u5 = function() {
          t5.props.revealOrder ? (r6.push(o5), P3(t5, n3, r6)) : o5();
        };
        e5 ? e5(u5) : u5();
      };
    }, O2.prototype.render = function(n3) {
      this.i = null, this.l = new Map();
      var t5 = x3(n3.children);
      n3.revealOrder && n3.revealOrder[0] === "b" && t5.reverse();
      for (var e5 = t5.length; e5--; )
        this.l.set(t5[e5], this.i = [1, 0, this.i]);
      return n3.children;
    }, O2.prototype.componentDidUpdate = O2.prototype.componentDidMount = function() {
      var n3 = this;
      n3.l.forEach(function(t5, e5) {
        P3(n3, e5, t5);
      });
    };
    W = function() {
      function n3() {
      }
      var t5 = n3.prototype;
      return t5.getChildContext = function() {
        return this.props.context;
      }, t5.render = function(n4) {
        return n4.children;
      }, n3;
    }();
    D3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    m3.prototype.isReactComponent = {};
    H3 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
    Z = n2.event;
    n2.event = function(n3) {
      Z && (n3 = Z(n3)), n3.persist = function() {
      };
      var t5 = false, e5 = false, r6 = n3.stopPropagation;
      n3.stopPropagation = function() {
        r6.call(n3), t5 = true;
      };
      var o5 = n3.preventDefault;
      return n3.preventDefault = function() {
        o5.call(n3), e5 = true;
      }, n3.isPropagationStopped = function() {
        return t5;
      }, n3.isDefaultPrevented = function() {
        return e5;
      }, n3.nativeEvent = n3;
    };
    $3 = { configurable: true, get: function() {
      return this.class;
    } };
    q4 = n2.vnode;
    n2.vnode = function(n3) {
      n3.$$typeof = H3;
      var t5 = n3.type, e5 = n3.props;
      if (t5) {
        if (e5.class != e5.className && ($3.enumerable = "className" in e5, e5.className != null && (e5.class = e5.className), Object.defineProperty(e5, "className", $3)), typeof t5 != "function") {
          var r6, o5, u5;
          for (u5 in e5.defaultValue && e5.value !== void 0 && (e5.value || e5.value === 0 || (e5.value = e5.defaultValue), delete e5.defaultValue), Array.isArray(e5.value) && e5.multiple && t5 === "select" && (x3(e5.children).forEach(function(n4) {
            e5.value.indexOf(n4.props.value) != -1 && (n4.props.selected = true);
          }), delete e5.value), e5)
            if (r6 = D3.test(u5))
              break;
          if (r6)
            for (u5 in o5 = n3.props = {}, e5)
              o5[D3.test(u5) ? u5.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u5] = e5[u5];
        }
        !function(t6) {
          var e6 = n3.type, r7 = n3.props;
          if (r7 && typeof e6 == "string") {
            var o6 = {};
            for (var u6 in r7)
              /^on(Ani|Tra|Tou)/.test(u6) && (r7[u6.toLowerCase()] = r7[u6], delete r7[u6]), o6[u6.toLowerCase()] = u6;
            if (o6.ondoubleclick && (r7.ondblclick = r7[o6.ondoubleclick], delete r7[o6.ondoubleclick]), o6.onbeforeinput && (r7.onbeforeinput = r7[o6.onbeforeinput], delete r7[o6.onbeforeinput]), o6.onchange && (e6 === "textarea" || e6.toLowerCase() === "input" && !/^fil|che|ra/i.test(r7.type))) {
              var i5 = o6.oninput || "oninput";
              r7[i5] || (r7[i5] = r7[o6.onchange], delete r7[o6.onchange]);
            }
          }
        }(), typeof t5 == "function" && !t5.m && t5.prototype && (I4(t5.prototype, "componentWillMount"), I4(t5.prototype, "componentWillReceiveProps"), I4(t5.prototype, "componentWillUpdate"), t5.m = true);
      }
      q4 && q4(n3);
    };
    B2 = "16.8.0";
    Y = function(n3, t5) {
      return n3(t5);
    };
    compat_module_default = { useState: m4, useReducer: p4, useEffect: l4, useLayoutEffect: y4, useRef: d4, useImperativeHandle: s5, useMemo: h4, useCallback: T4, useContext: w4, useDebugValue: A4, version: "16.8.0", Children: R, render: T5, hydrate: T5, unmountComponentAtNode: Q, createPortal: z3, createElement: h3, createContext: M2, createFactory: G, cloneElement: K2, createRef: y3, Fragment: d3, isValidElement: J, findDOMNode: X, Component: m3, PureComponent: C3, memo: _9, forwardRef: S2, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O2, lazy: L3 };
  }
});

// node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js"(exports, module) {
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var browserUtils = (init_esm2(), esm_exports);
    var QRCode = _interopDefault(require_browser6());
    var copy = _interopDefault(require_copy_to_clipboard());
    var React = (init_compat_module(), compat_module_exports);
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
    function _catch(body, recover) {
      try {
        var result = body();
      } catch (e5) {
        return recover(e5);
      }
      if (result && result.then) {
        return result.then(void 0, recover);
      }
      return result;
    }
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='300px' height='185px' viewBox='0 0 300 185' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3EWalletConnect%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='walletconnect-logo-alt' fill='%233B99FC' fill-rule='nonzero'%3E %3Cpath d='M61.4385429,36.2562612 C110.349767,-11.6319051 189.65053,-11.6319051 238.561752,36.2562612 L244.448297,42.0196786 C246.893858,44.4140867 246.893858,48.2961898 244.448297,50.690599 L224.311602,70.406102 C223.088821,71.6033071 221.106302,71.6033071 219.883521,70.406102 L211.782937,62.4749541 C177.661245,29.0669724 122.339051,29.0669724 88.2173582,62.4749541 L79.542302,70.9685592 C78.3195204,72.1657633 76.337001,72.1657633 75.1142214,70.9685592 L54.9775265,51.2530561 C52.5319653,48.8586469 52.5319653,44.9765439 54.9775265,42.5821357 L61.4385429,36.2562612 Z M280.206339,77.0300061 L298.128036,94.5769031 C300.573585,96.9713 300.573599,100.85338 298.128067,103.247793 L217.317896,182.368927 C214.872352,184.763353 210.907314,184.76338 208.461736,182.368989 C208.461726,182.368979 208.461714,182.368967 208.461704,182.368957 L151.107561,126.214385 C150.496171,125.615783 149.504911,125.615783 148.893521,126.214385 C148.893517,126.214389 148.893514,126.214393 148.89351,126.214396 L91.5405888,182.368927 C89.095052,184.763359 85.1300133,184.763399 82.6844276,182.369014 C82.6844133,182.369 82.684398,182.368986 82.6843827,182.36897 L1.87196327,103.246785 C-0.573596939,100.852377 -0.573596939,96.9702735 1.87196327,94.5758653 L19.7936929,77.028998 C22.2392531,74.6345898 26.2042918,74.6345898 28.6498531,77.028998 L86.0048306,133.184355 C86.6162214,133.782957 87.6074796,133.782957 88.2188704,133.184355 C88.2188796,133.184346 88.2188878,133.184338 88.2188969,133.184331 L145.571,77.028998 C148.016505,74.6345347 151.981544,74.6344449 154.427161,77.028798 C154.427195,77.0288316 154.427229,77.0288653 154.427262,77.028899 L211.782164,133.184331 C212.393554,133.782932 213.384814,133.782932 213.996204,133.184331 L271.350179,77.0300061 C273.79574,74.6355969 277.760778,74.6355969 280.206339,77.0300061 Z' id='WalletConnect'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props) {
      return React.createElement("div", {
        className: "walletconnect-modal__header"
      }, React.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props.onClose
      }, React.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props) {
      return React.createElement("a", {
        className: "walletconnect-connect__button",
        href: props.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
        onClick: props.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props.color
        },
        target: "_blank"
      }, props.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg width='8' height='18' viewBox='0 0 8 18' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0.586301 0.213898C0.150354 0.552968 0.0718197 1.18124 0.41089 1.61719L5.2892 7.88931C5.57007 8.25042 5.57007 8.75608 5.2892 9.11719L0.410889 15.3893C0.071819 15.8253 0.150353 16.4535 0.586301 16.7926C1.02225 17.1317 1.65052 17.0531 1.98959 16.6172L6.86791 10.3451C7.7105 9.26174 7.7105 7.74476 6.86791 6.66143L1.98959 0.38931C1.65052 -0.0466374 1.02225 -0.125172 0.586301 0.213898Z' fill='%233C4252'/%3E %3C/svg%3E";
    function WalletButton(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      return React.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name2), React.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      var fontSize = window.innerWidth < 768 ? (name2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name2));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props) {
      var android = browserUtils.isAndroid();
      var ref = React.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React.useState("");
      var filter2 = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter2 ? props.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter2.toLowerCase());
      }) : props.links;
      var errorMessage = props.errorMessage;
      var grid = filter2 || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range2 = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_10, index2) {
        return index2 + 1 >= range2[0] && index2 + 1 <= range2[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e5) {
        setInput(e5.target.value);
        clearTimeout(filterTimeout);
        if (e5.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e5.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name2 = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = browserUtils.formatIOSMobile(props.uri, entry);
        var handleClickIOS = React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: name2,
            href
          });
        }, [pageLinks]);
        return !grid ? React.createElement(WalletButton, {
          color,
          href,
          name: name2,
          logo,
          onClick: handleClickIOS
        }) : React.createElement(WalletIcon, {
          color,
          href,
          name: shortName,
          logo,
          onClick: handleClickIOS
        });
      }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
        name: props.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props.uri,
        onClick: React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props.uri
          });
        }, [])
      })), hasPaging && React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_10, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification2(props) {
      var show = !!props.message.trim();
      return React.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props.message);
    }
    var formatQRCodeImage = function(data) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e5) {
        return Promise.reject(e5);
      }
    };
    function QRCodeDisplay(props) {
      var ref = React.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e5) {
          Promise.reject(e5);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy(props.uri);
        if (success) {
          setNotification(props.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React.createElement("a", {
        onClick: copyToClipboard
      }, props.text.copy_to_clipboard)), React.createElement(Notification2, {
        message: notification
      }));
    }
    function Modal(props) {
      var android = browserUtils.isAndroid();
      var mobile = browserUtils.isMobile();
      var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props.text,
        uri: props.uri,
        qrcodeModalOptions: props.qrcodeModalOptions
      };
      var ref$3 = React.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              var _temp = _catch(function() {
                var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
                return Promise.resolve(fetch(url).then(function(x5) {
                  return x5.json();
                })).then(function(registry) {
                  var platform = mobile ? "mobile" : "desktop";
                  var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
                  setLoading(false);
                  setFetched(true);
                  setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                  setLinks(_links);
                  var hasSingleLink2 = _links.length === 1;
                  if (hasSingleLink2) {
                    setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                    setDisplayQRCode(true);
                  }
                  setHasSingleLink(hasSingleLink2);
                });
              }, function(e5) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props.text.something_went_wrong);
                console.error(e5);
              });
              return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
              }) : void 0);
            } catch (e5) {
              return Promise.reject(e5);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React.createElement("div", {
        className: "walletconnect-modal__base"
      }, React.createElement(Header, {
        onClose: props.onClose
      }), hasSingleLink && displayQRCode ? React.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React.createElement("a", {
        onClick: function() {
          return browserUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.mobile), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
        links,
        errorMessage
      })))));
    }
    var de = {
      choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera m\xF3vil",
      scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo sali\xF3 mal",
      no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr = {
      choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copi\xE9!",
      connect_with: "Connectez-vous \xE0 l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourn\xE9",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouv\xE9"
    };
    var ko = {
      choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
      connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
      scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
      connect: "\uC5F0\uACB0",
      qrcode: "QR \uCF54\uB4DC",
      mobile: "\uBAA8\uBC14\uC77C",
      desktop: "\uB370\uC2A4\uD06C\uD0D1",
      copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
      connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
      loading: "\uB85C\uB4DC \uC911...",
      something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
      no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
    };
    var pt = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
      scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
      connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
      scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
      connect: "\u8FDE\u63A5",
      qrcode: "\u4E8C\u7EF4\u7801",
      mobile: "\u79FB\u52A8",
      desktop: "\u684C\u9762",
      copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
      copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
      connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
      loading: "\u6B63\u5728\u52A0\u8F7D...",
      something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
      no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
      no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
    };
    var fa = {
      choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
      connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
      scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
      connect: "\u0627\u062A\u0635\u0627\u0644",
      qrcode: "\u06A9\u062F QR",
      mobile: "\u0633\u06CC\u0627\u0631",
      desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
      copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
      copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
      connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
      loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
      something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
      no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
      no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
    };
    var languages = {
      de,
      en,
      es,
      fr,
      ko,
      pt,
      zh,
      fa
    };
    function injectStyleSheet() {
      var doc = browserUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style = doc.createElement("style");
      style.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style);
    }
    function renderWrapper() {
      var doc = browserUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = browserUtils.getDocumentOrThrow();
      var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal) {
        modal.className = modal.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React.render(React.createElement(Modal, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode3 = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode3()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode3())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module.exports = index;
  }
});

// browser-external:http
var http_exports = {};
__export(http_exports, {
  default: () => http_default
});
var http_default;
var init_http = __esm({
  "browser-external:http"() {
    http_default = new Proxy({}, {
      get() {
        throw new Error('Module "http" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:https
var https_exports = {};
__export(https_exports, {
  default: () => https_default
});
var https_default;
var init_https = __esm({
  "browser-external:https"() {
    https_default = new Proxy({}, {
      get() {
        throw new Error('Module "https" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:os
var os_exports = {};
__export(os_exports, {
  default: () => os_default
});
var os_default;
var init_os = __esm({
  "browser-external:os"() {
    os_default = new Proxy({}, {
      get() {
        throw new Error('Module "os" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:url
var url_exports = {};
__export(url_exports, {
  default: () => url_default
});
var url_default;
var init_url = __esm({
  "browser-external:url"() {
    url_default = new Proxy({}, {
      get() {
        throw new Error('Module "url" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/xhr2-cookies/dist/progress-event.js
var require_progress_event = __commonJS({
  "node_modules/xhr2-cookies/dist/progress-event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressEvent = function() {
      function ProgressEvent2(type2) {
        this.type = type2;
        this.bubbles = false;
        this.cancelable = false;
        this.loaded = 0;
        this.lengthComputable = false;
        this.total = 0;
      }
      return ProgressEvent2;
    }();
    exports.ProgressEvent = ProgressEvent;
  }
});

// node_modules/xhr2-cookies/dist/errors.js
var require_errors3 = __commonJS({
  "node_modules/xhr2-cookies/dist/errors.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (b4.hasOwnProperty(p5))
            d5[p5] = b4[p5];
      };
      return function(d5, b4) {
        extendStatics2(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SecurityError = function(_super) {
      __extends2(SecurityError2, _super);
      function SecurityError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SecurityError2;
    }(Error);
    exports.SecurityError = SecurityError;
    var InvalidStateError = function(_super) {
      __extends2(InvalidStateError2, _super);
      function InvalidStateError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return InvalidStateError2;
    }(Error);
    exports.InvalidStateError = InvalidStateError;
    var NetworkError = function(_super) {
      __extends2(NetworkError2, _super);
      function NetworkError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NetworkError2;
    }(Error);
    exports.NetworkError = NetworkError;
    var SyntaxError2 = function(_super) {
      __extends2(SyntaxError3, _super);
      function SyntaxError3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SyntaxError3;
    }(Error);
    exports.SyntaxError = SyntaxError2;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-event-target.js
var require_xml_http_request_event_target = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-event-target.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var XMLHttpRequestEventTarget = function() {
      function XMLHttpRequestEventTarget2() {
        this.listeners = {};
      }
      XMLHttpRequestEventTarget2.prototype.addEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        this.listeners[eventType] = this.listeners[eventType] || [];
        this.listeners[eventType].push(listener.handleEvent || listener);
      };
      XMLHttpRequestEventTarget2.prototype.removeEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        if (!this.listeners[eventType]) {
          return;
        }
        var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
        if (index < 0) {
          return;
        }
        this.listeners[eventType].splice(index, 1);
      };
      XMLHttpRequestEventTarget2.prototype.dispatchEvent = function(event) {
        var eventType = event.type.toLowerCase();
        event.target = this;
        if (this.listeners[eventType]) {
          for (var _i = 0, _a2 = this.listeners[eventType]; _i < _a2.length; _i++) {
            var listener_1 = _a2[_i];
            listener_1.call(this, event);
          }
        }
        var listener = this["on" + eventType];
        if (listener) {
          listener.call(this, event);
        }
        return true;
      };
      return XMLHttpRequestEventTarget2;
    }();
    exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-upload.js
var require_xml_http_request_upload = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-upload.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (b4.hasOwnProperty(p5))
            d5[p5] = b4[p5];
      };
      return function(d5, b4) {
        extendStatics2(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var XMLHttpRequestUpload = function(_super) {
      __extends2(XMLHttpRequestUpload2, _super);
      function XMLHttpRequestUpload2() {
        var _this = _super.call(this) || this;
        _this._contentType = null;
        _this._body = null;
        _this._reset();
        return _this;
      }
      XMLHttpRequestUpload2.prototype._reset = function() {
        this._contentType = null;
        this._body = null;
      };
      XMLHttpRequestUpload2.prototype._setData = function(data) {
        if (data == null) {
          return;
        }
        if (typeof data === "string") {
          if (data.length !== 0) {
            this._contentType = "text/plain;charset=UTF-8";
          }
          this._body = new Buffer(data, "utf-8");
        } else if (Buffer.isBuffer(data)) {
          this._body = data;
        } else if (data instanceof ArrayBuffer) {
          var body = new Buffer(data.byteLength);
          var view = new Uint8Array(data);
          for (var i5 = 0; i5 < data.byteLength; i5++) {
            body[i5] = view[i5];
          }
          this._body = body;
        } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
          var body = new Buffer(data.byteLength);
          var offset2 = data.byteOffset;
          var view = new Uint8Array(data.buffer);
          for (var i5 = 0; i5 < data.byteLength; i5++) {
            body[i5] = view[i5 + offset2];
          }
          this._body = body;
        } else {
          throw new Error("Unsupported send() data " + data);
        }
      };
      XMLHttpRequestUpload2.prototype._finalizeHeaders = function(headers, loweredHeaders) {
        if (this._contentType && !loweredHeaders["content-type"]) {
          headers["Content-Type"] = this._contentType;
        }
        if (this._body) {
          headers["Content-Length"] = this._body.length.toString();
        }
      };
      XMLHttpRequestUpload2.prototype._startUpload = function(request) {
        if (this._body) {
          request.write(this._body);
        }
        request.end();
      };
      return XMLHttpRequestUpload2;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequestUpload = XMLHttpRequestUpload;
  }
});

// node_modules/cookiejar/cookiejar.js
var require_cookiejar = __commonJS({
  "node_modules/cookiejar/cookiejar.js"(exports) {
    (function() {
      "use strict";
      function CookieAccessInfo(domain2, path, secure, script) {
        if (this instanceof CookieAccessInfo) {
          this.domain = domain2 || void 0;
          this.path = path || "/";
          this.secure = !!secure;
          this.script = !!script;
          return this;
        }
        return new CookieAccessInfo(domain2, path, secure, script);
      }
      CookieAccessInfo.All = Object.freeze(Object.create(null));
      exports.CookieAccessInfo = CookieAccessInfo;
      function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
          return cookiestr;
        }
        if (this instanceof Cookie) {
          this.name = null;
          this.value = null;
          this.expiration_date = Infinity;
          this.path = String(request_path || "/");
          this.explicit_path = false;
          this.domain = request_domain || null;
          this.explicit_domain = false;
          this.secure = false;
          this.noscript = false;
          if (cookiestr) {
            this.parse(cookiestr, request_domain, request_path);
          }
          return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
      }
      exports.Cookie = Cookie;
      Cookie.prototype.toString = function toString2() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
          str.push("expires=" + new Date(this.expiration_date).toGMTString());
        }
        if (this.domain) {
          str.push("domain=" + this.domain);
        }
        if (this.path) {
          str.push("path=" + this.path);
        }
        if (this.secure) {
          str.push("secure");
        }
        if (this.noscript) {
          str.push("httponly");
        }
        return str.join("; ");
      };
      Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
      };
      var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
      Cookie.prototype.parse = function parse4(str, request_domain, request_path) {
        if (this instanceof Cookie) {
          var parts = str.split(";").filter(function(value2) {
            return !!value2;
          });
          var i5;
          var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
          if (!pair) {
            console.warn("Invalid cookie header encountered. Header: '" + str + "'");
            return;
          }
          var key2 = pair[1];
          var value = pair[2];
          if (typeof key2 !== "string" || key2.length === 0 || typeof value !== "string") {
            console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
            return;
          }
          this.name = key2;
          this.value = value;
          for (i5 = 1; i5 < parts.length; i5 += 1) {
            pair = parts[i5].match(/([^=]+)(?:=([\s\S]*))?/);
            key2 = pair[1].trim().toLowerCase();
            value = pair[2];
            switch (key2) {
              case "httponly":
                this.noscript = true;
                break;
              case "expires":
                this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                break;
              case "path":
                this.path = value ? value.trim() : "";
                this.explicit_path = true;
                break;
              case "domain":
                this.domain = value ? value.trim() : "";
                this.explicit_domain = !!this.domain;
                break;
              case "secure":
                this.secure = true;
                break;
            }
          }
          if (!this.explicit_path) {
            this.path = request_path || "/";
          }
          if (!this.explicit_domain) {
            this.domain = request_domain;
          }
          return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
      };
      Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
          return false;
        }
        return true;
      };
      Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if (this.path && !access_info.path || this.domain && !access_info.domain) {
          return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
        if (cookie_domain === access_domain) {
          return true;
        }
        if (cookie_domain) {
          if (!this.explicit_domain) {
            return false;
          }
          var wildcard = access_domain.indexOf(cookie_domain);
          if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
            return false;
          }
          return true;
        }
        return true;
      };
      function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
          cookies = Object.create(null);
          this.setCookie = function setCookie(cookie, request_domain, request_path) {
            var remove, i5;
            cookie = new Cookie(cookie, request_domain, request_path);
            remove = cookie.expiration_date <= Date.now();
            if (cookies[cookie.name] !== void 0) {
              cookies_list = cookies[cookie.name];
              for (i5 = 0; i5 < cookies_list.length; i5 += 1) {
                collidable_cookie = cookies_list[i5];
                if (collidable_cookie.collidesWith(cookie)) {
                  if (remove) {
                    cookies_list.splice(i5, 1);
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name];
                    }
                    return false;
                  }
                  cookies_list[i5] = cookie;
                  return cookie;
                }
              }
              if (remove) {
                return false;
              }
              cookies_list.push(cookie);
              return cookie;
            }
            if (remove) {
              return false;
            }
            cookies[cookie.name] = [cookie];
            return cookies[cookie.name];
          };
          this.getCookie = function getCookie(cookie_name, access_info) {
            var cookie, i5;
            cookies_list = cookies[cookie_name];
            if (!cookies_list) {
              return;
            }
            for (i5 = 0; i5 < cookies_list.length; i5 += 1) {
              cookie = cookies_list[i5];
              if (cookie.expiration_date <= Date.now()) {
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                continue;
              }
              if (cookie.matches(access_info)) {
                return cookie;
              }
            }
          };
          this.getCookies = function getCookies(access_info) {
            var matches = [], cookie_name, cookie;
            for (cookie_name in cookies) {
              cookie = this.getCookie(cookie_name, access_info);
              if (cookie) {
                matches.push(cookie);
              }
            }
            matches.toString = function toString2() {
              return matches.join(":");
            };
            matches.toValueString = function toValueString() {
              return matches.map(function(c5) {
                return c5.toValueString();
              }).join("; ");
            };
            return matches;
          };
          return this;
        }
        return new CookieJar();
      }
      exports.CookieJar = CookieJar;
      CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
        var successful = [], i5, cookie;
        cookies = cookies.map(function(item) {
          return new Cookie(item, request_domain, request_path);
        });
        for (i5 = 0; i5 < cookies.length; i5 += 1) {
          cookie = cookies[i5];
          if (this.setCookie(cookie, request_domain, request_path)) {
            successful.push(cookie);
          }
        }
        return successful;
      };
    })();
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request.js
var require_xml_http_request = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (b4.hasOwnProperty(p5))
            d5[p5] = b4[p5];
      };
      return function(d5, b4) {
        extendStatics2(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    var __assign2 = exports && exports.__assign || Object.assign || function(t5) {
      for (var s6, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
        s6 = arguments[i5];
        for (var p5 in s6)
          if (Object.prototype.hasOwnProperty.call(s6, p5))
            t5[p5] = s6[p5];
      }
      return t5;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = (init_http(), http_exports);
    var https = (init_https(), https_exports);
    var os = (init_os(), os_exports);
    var url = (init_url(), url_exports);
    var progress_event_1 = require_progress_event();
    var errors_1 = require_errors3();
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var xml_http_request_upload_1 = require_xml_http_request_upload();
    var Cookie = require_cookiejar();
    var XMLHttpRequest3 = function(_super) {
      __extends2(XMLHttpRequest4, _super);
      function XMLHttpRequest4(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this) || this;
        _this.UNSENT = XMLHttpRequest4.UNSENT;
        _this.OPENED = XMLHttpRequest4.OPENED;
        _this.HEADERS_RECEIVED = XMLHttpRequest4.HEADERS_RECEIVED;
        _this.LOADING = XMLHttpRequest4.LOADING;
        _this.DONE = XMLHttpRequest4.DONE;
        _this.onreadystatechange = null;
        _this.readyState = XMLHttpRequest4.UNSENT;
        _this.response = null;
        _this.responseText = "";
        _this.responseType = "";
        _this.status = 0;
        _this.statusText = "";
        _this.timeout = 0;
        _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
        _this.responseUrl = "";
        _this.withCredentials = false;
        _this._method = null;
        _this._url = null;
        _this._sync = false;
        _this._headers = {};
        _this._loweredHeaders = {};
        _this._mimeOverride = null;
        _this._request = null;
        _this._response = null;
        _this._responseParts = null;
        _this._responseHeaders = null;
        _this._aborting = null;
        _this._error = null;
        _this._loadedBytes = 0;
        _this._totalBytes = 0;
        _this._lengthComputable = false;
        _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
        _this._restrictedHeaders = {
          "accept-charset": true,
          "accept-encoding": true,
          "access-control-request-headers": true,
          "access-control-request-method": true,
          connection: true,
          "content-length": true,
          cookie: true,
          cookie2: true,
          date: true,
          dnt: true,
          expect: true,
          host: true,
          "keep-alive": true,
          origin: true,
          referer: true,
          te: true,
          trailer: true,
          "transfer-encoding": true,
          upgrade: true,
          "user-agent": true,
          via: true
        };
        _this._privateHeaders = { "set-cookie": true, "set-cookie2": true };
        _this._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
        _this._anonymous = options.anon || false;
        return _this;
      }
      XMLHttpRequest4.prototype.open = function(method, url2, async2, user, password) {
        if (async2 === void 0) {
          async2 = true;
        }
        method = method.toUpperCase();
        if (this._restrictedMethods[method]) {
          throw new XMLHttpRequest4.SecurityError("HTTP method " + method + " is not allowed in XHR");
        }
        ;
        var xhrUrl = this._parseUrl(url2, user, password);
        if (this.readyState === XMLHttpRequest4.HEADERS_RECEIVED || this.readyState === XMLHttpRequest4.LOADING) {
        }
        this._method = method;
        this._url = xhrUrl;
        this._sync = !async2;
        this._headers = {};
        this._loweredHeaders = {};
        this._mimeOverride = null;
        this._setReadyState(XMLHttpRequest4.OPENED);
        this._request = null;
        this._response = null;
        this.status = 0;
        this.statusText = "";
        this._responseParts = [];
        this._responseHeaders = null;
        this._loadedBytes = 0;
        this._totalBytes = 0;
        this._lengthComputable = false;
      };
      XMLHttpRequest4.prototype.setRequestHeader = function(name2, value) {
        if (this.readyState !== XMLHttpRequest4.OPENED) {
          throw new XMLHttpRequest4.InvalidStateError("XHR readyState must be OPENED");
        }
        var loweredName = name2.toLowerCase();
        if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
          console.warn('Refused to set unsafe header "' + name2 + '"');
          return;
        }
        value = value.toString();
        if (this._loweredHeaders[loweredName] != null) {
          name2 = this._loweredHeaders[loweredName];
          this._headers[name2] = this._headers[name2] + ", " + value;
        } else {
          this._loweredHeaders[loweredName] = name2;
          this._headers[name2] = value;
        }
      };
      XMLHttpRequest4.prototype.send = function(data) {
        if (this.readyState !== XMLHttpRequest4.OPENED) {
          throw new XMLHttpRequest4.InvalidStateError("XHR readyState must be OPENED");
        }
        if (this._request) {
          throw new XMLHttpRequest4.InvalidStateError("send() already called");
        }
        switch (this._url.protocol) {
          case "file:":
            return this._sendFile(data);
          case "http:":
          case "https:":
            return this._sendHttp(data);
          default:
            throw new XMLHttpRequest4.NetworkError("Unsupported protocol " + this._url.protocol);
        }
      };
      XMLHttpRequest4.prototype.abort = function() {
        if (this._request == null) {
          return;
        }
        this._request.abort();
        this._setError();
        this._dispatchProgress("abort");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest4.prototype.getResponseHeader = function(name2) {
        if (this._responseHeaders == null || name2 == null) {
          return null;
        }
        var loweredName = name2.toLowerCase();
        return this._responseHeaders.hasOwnProperty(loweredName) ? this._responseHeaders[name2.toLowerCase()] : null;
      };
      XMLHttpRequest4.prototype.getAllResponseHeaders = function() {
        var _this = this;
        if (this._responseHeaders == null) {
          return "";
        }
        return Object.keys(this._responseHeaders).map(function(key2) {
          return key2 + ": " + _this._responseHeaders[key2];
        }).join("\r\n");
      };
      XMLHttpRequest4.prototype.overrideMimeType = function(mimeType) {
        if (this.readyState === XMLHttpRequest4.LOADING || this.readyState === XMLHttpRequest4.DONE) {
          throw new XMLHttpRequest4.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
        }
        this._mimeOverride = mimeType.toLowerCase();
      };
      XMLHttpRequest4.prototype.nodejsSet = function(options) {
        this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
        this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
        if (options.hasOwnProperty("baseUrl")) {
          if (options.baseUrl != null) {
            var parsedUrl = url.parse(options.baseUrl, false, true);
            if (!parsedUrl.protocol) {
              throw new XMLHttpRequest4.SyntaxError("baseUrl must be an absolute URL");
            }
          }
          this.nodejsBaseUrl = options.baseUrl;
        }
      };
      XMLHttpRequest4.nodejsSet = function(options) {
        XMLHttpRequest4.prototype.nodejsSet(options);
      };
      XMLHttpRequest4.prototype._setReadyState = function(readyState) {
        this.readyState = readyState;
        this.dispatchEvent(new progress_event_1.ProgressEvent("readystatechange"));
      };
      XMLHttpRequest4.prototype._sendFile = function(data) {
        throw new Error("Protocol file: not implemented");
      };
      XMLHttpRequest4.prototype._sendHttp = function(data) {
        if (this._sync) {
          throw new Error("Synchronous XHR processing not implemented");
        }
        if (data && (this._method === "GET" || this._method === "HEAD")) {
          console.warn("Discarding entity body for " + this._method + " requests");
          data = null;
        } else {
          data = data || "";
        }
        this.upload._setData(data);
        this._finalizeHeaders();
        this._sendHxxpRequest();
      };
      XMLHttpRequest4.prototype._sendHxxpRequest = function() {
        var _this = this;
        if (this.withCredentials) {
          var cookie = XMLHttpRequest4.cookieJar.getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
          this._headers.cookie = this._headers.cookie2 = cookie;
        }
        var _a2 = this._url.protocol === "http:" ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a2[0], agent = _a2[1];
        var requestMethod = hxxp.request.bind(hxxp);
        var request = requestMethod({
          hostname: this._url.hostname,
          port: +this._url.port,
          path: this._url.path,
          auth: this._url.auth,
          method: this._method,
          headers: this._headers,
          agent
        });
        this._request = request;
        if (this.timeout) {
          request.setTimeout(this.timeout, function() {
            return _this._onHttpTimeout(request);
          });
        }
        request.on("response", function(response) {
          return _this._onHttpResponse(request, response);
        });
        request.on("error", function(error) {
          return _this._onHttpRequestError(request, error);
        });
        this.upload._startUpload(request);
        if (this._request === request) {
          this._dispatchProgress("loadstart");
        }
      };
      XMLHttpRequest4.prototype._finalizeHeaders = function() {
        this._headers = __assign2({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {});
        this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      };
      XMLHttpRequest4.prototype._onHttpResponse = function(request, response) {
        var _this = this;
        if (this._request !== request) {
          return;
        }
        if (this.withCredentials && (response.headers["set-cookie"] || response.headers["set-cookie2"])) {
          XMLHttpRequest4.cookieJar.setCookies(response.headers["set-cookie"] || response.headers["set-cookie2"]);
        }
        if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
          this._url = this._parseUrl(response.headers.location);
          this._method = "GET";
          if (this._loweredHeaders["content-type"]) {
            delete this._headers[this._loweredHeaders["content-type"]];
            delete this._loweredHeaders["content-type"];
          }
          if (this._headers["Content-Type"] != null) {
            delete this._headers["Content-Type"];
          }
          delete this._headers["Content-Length"];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
        }
        this._response = response;
        this._response.on("data", function(data) {
          return _this._onHttpResponseData(response, data);
        });
        this._response.on("end", function() {
          return _this._onHttpResponseEnd(response);
        });
        this._response.on("close", function() {
          return _this._onHttpResponseClose(response);
        });
        this.responseUrl = this._url.href.split("#")[0];
        this.status = response.statusCode;
        this.statusText = http.STATUS_CODES[this.status];
        this._parseResponseHeaders(response);
        var lengthString = this._responseHeaders["content-length"] || "";
        this._totalBytes = +lengthString;
        this._lengthComputable = !!lengthString;
        this._setReadyState(XMLHttpRequest4.HEADERS_RECEIVED);
      };
      XMLHttpRequest4.prototype._onHttpResponseData = function(response, data) {
        if (this._response !== response) {
          return;
        }
        this._responseParts.push(new Buffer(data));
        this._loadedBytes += data.length;
        if (this.readyState !== XMLHttpRequest4.LOADING) {
          this._setReadyState(XMLHttpRequest4.LOADING);
        }
        this._dispatchProgress("progress");
      };
      XMLHttpRequest4.prototype._onHttpResponseEnd = function(response) {
        if (this._response !== response) {
          return;
        }
        this._parseResponse();
        this._request = null;
        this._response = null;
        this._setReadyState(XMLHttpRequest4.DONE);
        this._dispatchProgress("load");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest4.prototype._onHttpResponseClose = function(response) {
        if (this._response !== response) {
          return;
        }
        var request = this._request;
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest4.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest4.prototype._onHttpTimeout = function(request) {
        if (this._request !== request) {
          return;
        }
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest4.DONE);
        this._dispatchProgress("timeout");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest4.prototype._onHttpRequestError = function(request, error) {
        if (this._request !== request) {
          return;
        }
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest4.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest4.prototype._dispatchProgress = function(eventType) {
        var event = new XMLHttpRequest4.ProgressEvent(eventType);
        event.lengthComputable = this._lengthComputable;
        event.loaded = this._loadedBytes;
        event.total = this._totalBytes;
        this.dispatchEvent(event);
      };
      XMLHttpRequest4.prototype._setError = function() {
        this._request = null;
        this._response = null;
        this._responseHeaders = null;
        this._responseParts = null;
      };
      XMLHttpRequest4.prototype._parseUrl = function(urlString, user, password) {
        var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
        var xhrUrl = url.parse(absoluteUrl, false, true);
        xhrUrl.hash = null;
        var _a2 = (xhrUrl.auth || "").split(":"), xhrUser = _a2[0], xhrPassword = _a2[1];
        if (xhrUser || xhrPassword || user || password) {
          xhrUrl.auth = (user || xhrUser || "") + ":" + (password || xhrPassword || "");
        }
        return xhrUrl;
      };
      XMLHttpRequest4.prototype._parseResponseHeaders = function(response) {
        this._responseHeaders = {};
        for (var name_1 in response.headers) {
          var loweredName = name_1.toLowerCase();
          if (this._privateHeaders[loweredName]) {
            continue;
          }
          this._responseHeaders[loweredName] = response.headers[name_1];
        }
        if (this._mimeOverride != null) {
          this._responseHeaders["content-type"] = this._mimeOverride;
        }
      };
      XMLHttpRequest4.prototype._parseResponse = function() {
        var buffer2 = Buffer.concat(this._responseParts);
        this._responseParts = null;
        switch (this.responseType) {
          case "json":
            this.responseText = null;
            try {
              this.response = JSON.parse(buffer2.toString("utf-8"));
            } catch (_a2) {
              this.response = null;
            }
            return;
          case "buffer":
            this.responseText = null;
            this.response = buffer2;
            return;
          case "arraybuffer":
            this.responseText = null;
            var arrayBuffer = new ArrayBuffer(buffer2.length);
            var view = new Uint8Array(arrayBuffer);
            for (var i5 = 0; i5 < buffer2.length; i5++) {
              view[i5] = buffer2[i5];
            }
            this.response = arrayBuffer;
            return;
          case "text":
          default:
            try {
              this.responseText = buffer2.toString(this._parseResponseEncoding());
            } catch (_b) {
              this.responseText = buffer2.toString("binary");
            }
            this.response = this.responseText;
        }
      };
      XMLHttpRequest4.prototype._parseResponseEncoding = function() {
        return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
      };
      XMLHttpRequest4.ProgressEvent = progress_event_1.ProgressEvent;
      XMLHttpRequest4.InvalidStateError = errors_1.InvalidStateError;
      XMLHttpRequest4.NetworkError = errors_1.NetworkError;
      XMLHttpRequest4.SecurityError = errors_1.SecurityError;
      XMLHttpRequest4.SyntaxError = errors_1.SyntaxError;
      XMLHttpRequest4.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
      XMLHttpRequest4.UNSENT = 0;
      XMLHttpRequest4.OPENED = 1;
      XMLHttpRequest4.HEADERS_RECEIVED = 2;
      XMLHttpRequest4.LOADING = 3;
      XMLHttpRequest4.DONE = 4;
      XMLHttpRequest4.cookieJar = Cookie.CookieJar();
      return XMLHttpRequest4;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequest = XMLHttpRequest3;
    XMLHttpRequest3.prototype.nodejsHttpAgent = http.globalAgent;
    XMLHttpRequest3.prototype.nodejsHttpsAgent = https.globalAgent;
    XMLHttpRequest3.prototype.nodejsBaseUrl = null;
  }
});

// node_modules/xhr2-cookies/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/xhr2-cookies/dist/index.js"(exports) {
    "use strict";
    function __export2(m5) {
      for (var p5 in m5)
        if (!exports.hasOwnProperty(p5))
          exports[p5] = m5[p5];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_xml_http_request());
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    exports.XMLHttpRequestEventTarget = xml_http_request_event_target_1.XMLHttpRequestEventTarget;
  }
});

// node_modules/web3-provider-engine/subproviders/subprovider.js
var require_subprovider2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/subprovider.js"(exports, module) {
    var createPayload = require_create_payload();
    module.exports = SubProvider;
    function SubProvider() {
    }
    SubProvider.prototype.setEngine = function(engine) {
      const self2 = this;
      if (self2.engine)
        return;
      self2.engine = engine;
      engine.on("block", function(block) {
        self2.currentBlock = block;
      });
      engine.on("start", function() {
        self2.start();
      });
      engine.on("stop", function() {
        self2.stop();
      });
    };
    SubProvider.prototype.handleRequest = function(payload, next, end) {
      throw new Error("Subproviders should override `handleRequest`.");
    };
    SubProvider.prototype.emitPayload = function(payload, cb) {
      const self2 = this;
      self2.engine.sendAsync(createPayload(payload), cb);
    };
    SubProvider.prototype.stop = function() {
    };
    SubProvider.prototype.start = function() {
    };
  }
});

// node_modules/web3-provider-engine/subproviders/json-rpc-engine-middleware.js
var require_json_rpc_engine_middleware2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/json-rpc-engine-middleware.js"(exports, module) {
    var Subprovider = require_subprovider2();
    var JsonRpcEngineMiddlewareSubprovider = class extends Subprovider {
      constructor(constructorFn) {
        super();
        if (!constructorFn)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - no constructorFn specified");
        this._constructorFn = constructorFn;
      }
      setEngine(engine) {
        if (this.middleware)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice");
        const blockTracker = engine._blockTracker;
        const middleware = this._constructorFn({ engine, provider: engine, blockTracker });
        if (!middleware)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware");
        if (typeof middleware !== "function")
          throw new Error("JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function");
        this.middleware = middleware;
      }
      handleRequest(req, provEngNext, provEngEnd) {
        const res = { id: req.id };
        this.middleware(req, res, middlewareNext, middlewareEnd);
        function middlewareNext(handler) {
          provEngNext((err, result, cb) => {
            if (err) {
              delete res.result;
              res.error = { message: err.message || err };
            } else {
              res.result = result;
            }
            if (handler) {
              handler(cb);
            } else {
              cb();
            }
          });
        }
        function middlewareEnd(err) {
          if (err)
            return provEngEnd(err);
          provEngEnd(null, res.result);
        }
      }
    };
    module.exports = JsonRpcEngineMiddlewareSubprovider;
  }
});

// node_modules/web3-provider-engine/subproviders/cache.js
var require_cache2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/cache.js"(exports, module) {
    var ProviderSubprovider = require_json_rpc_engine_middleware2();
    var createBlockCacheMiddleware = require_block_cache();
    var BlockCacheSubprovider = class extends ProviderSubprovider {
      constructor(opts) {
        super(({ blockTracker }) => createBlockCacheMiddleware(Object.assign({ blockTracker }, opts)));
      }
    };
    module.exports = BlockCacheSubprovider;
  }
});

// node_modules/web3-provider-engine/subproviders/fixture.js
var require_fixture2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/fixture.js"(exports, module) {
    var inherits2 = require_util().inherits;
    var Subprovider = require_subprovider2();
    module.exports = FixtureProvider;
    inherits2(FixtureProvider, Subprovider);
    function FixtureProvider(staticResponses) {
      const self2 = this;
      staticResponses = staticResponses || {};
      self2.staticResponses = staticResponses;
    }
    FixtureProvider.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      var staticResponse = self2.staticResponses[payload.method];
      if (typeof staticResponse === "function") {
        staticResponse(payload, next, end);
      } else if (staticResponse !== void 0) {
        setTimeout(() => end(null, staticResponse));
      } else {
        next();
      }
    };
  }
});

// node_modules/web3-provider-engine/subproviders/filters.js
var require_filters2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/filters.js"(exports, module) {
    var ProviderSubprovider = require_json_rpc_engine_middleware2();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var SubscriptionsSubprovider3 = class extends ProviderSubprovider {
      constructor() {
        super(({ blockTracker, provider, engine }) => {
          return createFilterMiddleware({ blockTracker, provider });
        });
      }
    };
    module.exports = SubscriptionsSubprovider3;
  }
});

// node_modules/web3-provider-engine/util/estimate-gas.js
var require_estimate_gas2 = __commonJS({
  "node_modules/web3-provider-engine/util/estimate-gas.js"(exports, module) {
    var createPayload = require_create_payload();
    module.exports = estimateGas;
    function estimateGas(provider, txParams, cb) {
      provider.sendAsync(createPayload({
        method: "eth_estimateGas",
        params: [txParams]
      }), function(err, res) {
        if (err) {
          if (err.message === "no contract code at given address") {
            return cb(null, "0xcf08");
          } else {
            return cb(err);
          }
        }
        cb(null, res.result);
      });
    }
  }
});

// node_modules/web3-provider-engine/subproviders/hooked-wallet.js
var require_hooked_wallet2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/hooked-wallet.js"(exports, module) {
    var waterfall = require_waterfall();
    var parallel = require_parallel2();
    var inherits2 = require_util().inherits;
    var ethUtil = require_dist5();
    var sigUtil = require_eth_sig_util();
    var extend = require_immutable();
    var Semaphore = require_semaphore();
    var Subprovider = require_subprovider2();
    var estimateGas = require_estimate_gas2();
    var hexRegex = /^[0-9A-Fa-f]+$/g;
    module.exports = HookedWalletSubprovider3;
    inherits2(HookedWalletSubprovider3, Subprovider);
    function HookedWalletSubprovider3(opts) {
      const self2 = this;
      self2.nonceLock = Semaphore(1);
      if (opts.getAccounts)
        self2.getAccounts = opts.getAccounts;
      if (opts.processTransaction)
        self2.processTransaction = opts.processTransaction;
      if (opts.processMessage)
        self2.processMessage = opts.processMessage;
      if (opts.processPersonalMessage)
        self2.processPersonalMessage = opts.processPersonalMessage;
      if (opts.processTypedMessage)
        self2.processTypedMessage = opts.processTypedMessage;
      self2.approveTransaction = opts.approveTransaction || self2.autoApprove;
      self2.approveMessage = opts.approveMessage || self2.autoApprove;
      self2.approvePersonalMessage = opts.approvePersonalMessage || self2.autoApprove;
      self2.approveDecryptMessage = opts.approveDecryptMessage || self2.autoApprove;
      self2.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self2.autoApprove;
      self2.approveTypedMessage = opts.approveTypedMessage || self2.autoApprove;
      if (opts.signTransaction)
        self2.signTransaction = opts.signTransaction || mustProvideInConstructor("signTransaction");
      if (opts.signMessage)
        self2.signMessage = opts.signMessage || mustProvideInConstructor("signMessage");
      if (opts.signPersonalMessage)
        self2.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor("signPersonalMessage");
      if (opts.decryptMessage)
        self2.decryptMessage = opts.decryptMessage || mustProvideInConstructor("decryptMessage");
      if (opts.encryptionPublicKey)
        self2.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor("encryptionPublicKey");
      if (opts.signTypedMessage)
        self2.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor("signTypedMessage");
      if (opts.recoverPersonalSignature)
        self2.recoverPersonalSignature = opts.recoverPersonalSignature;
      if (opts.publishTransaction)
        self2.publishTransaction = opts.publishTransaction;
      self2.estimateGas = opts.estimateGas || self2.estimateGas;
      self2.getGasPrice = opts.getGasPrice || self2.getGasPrice;
    }
    HookedWalletSubprovider3.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      self2._parityRequests = {};
      self2._parityRequestCount = 0;
      let txParams, msgParams, extraParams;
      let message, address;
      switch (payload.method) {
        case "eth_coinbase":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            let result = accounts[0] || null;
            end(null, result);
          });
          return;
        case "eth_accounts":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            end(null, accounts);
          });
          return;
        case "eth_sendTransaction":
          txParams = payload.params[0];
          waterfall([
            (cb) => self2.validateTransaction(txParams, cb),
            (cb) => self2.processTransaction(txParams, cb)
          ], end);
          return;
        case "eth_signTransaction":
          txParams = payload.params[0];
          waterfall([
            (cb) => self2.validateTransaction(txParams, cb),
            (cb) => self2.processSignTransaction(txParams, cb)
          ], end);
          return;
        case "eth_sign":
          address = payload.params[0];
          message = payload.params[1];
          extraParams = payload.params[2] || {};
          msgParams = extend(extraParams, {
            from: address,
            data: message
          });
          waterfall([
            (cb) => self2.validateMessage(msgParams, cb),
            (cb) => self2.processMessage(msgParams, cb)
          ], end);
          return;
        case "personal_sign":
          return function() {
            const first2 = payload.params[0];
            const second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first2)) {
              let warning = `The eth_personalSign method requires params ordered `;
              warning += `[message, address]. This was previously handled incorrectly, `;
              warning += `and has been corrected automatically. `;
              warning += `Please switch this param order for smooth behavior in the future.`;
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validatePersonalMessage(msgParams, cb),
              (cb) => self2.processPersonalMessage(msgParams, cb)
            ], end);
          }();
        case "eth_decryptMessage":
          return function() {
            const first2 = payload.params[0];
            const second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first2)) {
              let warning = `The eth_decryptMessage method requires params ordered `;
              warning += `[message, address]. This was previously handled incorrectly, `;
              warning += `and has been corrected automatically. `;
              warning += `Please switch this param order for smooth behavior in the future.`;
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validateDecryptMessage(msgParams, cb),
              (cb) => self2.processDecryptMessage(msgParams, cb)
            ], end);
          }();
        case "encryption_public_key":
          return function() {
            const address2 = payload.params[0];
            waterfall([
              (cb) => self2.validateEncryptionPublicKey(address2, cb),
              (cb) => self2.processEncryptionPublicKey(address2, cb)
            ], end);
          }();
        case "personal_ecRecover":
          return function() {
            message = payload.params[0];
            let signature2 = payload.params[1];
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              sig: signature2,
              data: message
            });
            self2.recoverPersonalSignature(msgParams, end);
          }();
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          return function() {
            const first2 = payload.params[0];
            const second = payload.params[1];
            if (resemblesAddress(first2)) {
              address = first2;
              message = second;
            } else {
              message = first2;
              address = second;
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validateTypedMessage(msgParams, cb),
              (cb) => self2.processTypedMessage(msgParams, cb)
            ], end);
          }();
        case "parity_postTransaction":
          txParams = payload.params[0];
          self2.parityPostTransaction(txParams, end);
          return;
        case "parity_postSign":
          address = payload.params[0];
          message = payload.params[1];
          self2.parityPostSign(address, message, end);
          return;
        case "parity_checkRequest":
          return function() {
            const requestId = payload.params[0];
            self2.parityCheckRequest(requestId, end);
          }();
        case "parity_defaultAccount":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            const account = accounts[0] || null;
            end(null, account);
          });
          return;
        default:
          next();
          return;
      }
    };
    HookedWalletSubprovider3.prototype.getAccounts = function(cb) {
      cb(null, []);
    };
    HookedWalletSubprovider3.prototype.processTransaction = function(txParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTransaction(txParams, cb2),
        (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
        (cb2) => self2.finalizeAndSubmitTx(txParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider3.prototype.processSignTransaction = function(txParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTransaction(txParams, cb2),
        (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
        (cb2) => self2.finalizeTx(txParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider3.prototype.processMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider3.prototype.processPersonalMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approvePersonalMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signPersonalMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider3.prototype.processDecryptMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveDecryptMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("decryptMessage", didApprove, cb2),
        (cb2) => self2.decryptMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider3.prototype.processEncryptionPublicKey = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveEncryptionPublicKey(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("encryptionPublicKey", didApprove, cb2),
        (cb2) => self2.encryptionPublicKey(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider3.prototype.processTypedMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTypedMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signTypedMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider3.prototype.autoApprove = function(txParams, cb) {
      cb(null, true);
    };
    HookedWalletSubprovider3.prototype.checkApproval = function(type2, didApprove, cb) {
      cb(didApprove ? null : new Error("User denied " + type2 + " signature."));
    };
    HookedWalletSubprovider3.prototype.parityPostTransaction = function(txParams, cb) {
      const self2 = this;
      const count2 = self2._parityRequestCount;
      const reqId = `0x${count2.toString(16)}`;
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sendTransaction",
        params: [txParams]
      }, function(error, res) {
        if (error) {
          self2._parityRequests[reqId] = { error };
          return;
        }
        const txHash = res.result;
        self2._parityRequests[reqId] = txHash;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider3.prototype.parityPostSign = function(address, message, cb) {
      const self2 = this;
      const count2 = self2._parityRequestCount;
      const reqId = `0x${count2.toString(16)}`;
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sign",
        params: [address, message]
      }, function(error, res) {
        if (error) {
          self2._parityRequests[reqId] = { error };
          return;
        }
        const result = res.result;
        self2._parityRequests[reqId] = result;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider3.prototype.parityCheckRequest = function(reqId, cb) {
      const self2 = this;
      const result = self2._parityRequests[reqId] || null;
      if (!result)
        return cb(null, null);
      if (result.error)
        return cb(result.error);
      cb(null, result);
    };
    HookedWalletSubprovider3.prototype.recoverPersonalSignature = function(msgParams, cb) {
      let senderHex;
      try {
        senderHex = sigUtil.recoverPersonalSignature(msgParams);
      } catch (err) {
        return cb(err);
      }
      cb(null, senderHex);
    };
    HookedWalletSubprovider3.prototype.validateTransaction = function(txParams, cb) {
      const self2 = this;
      if (txParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign transaction.`));
      self2.validateSender(txParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign transaction for this address: "${txParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign message.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validatePersonalMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign personal message.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined message - message required to sign personal message.`));
      if (!isValidHex(msgParams.data))
        return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateDecryptMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to decrypt message.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined message - message required to decrypt message.`));
      if (!isValidHex(msgParams.data))
        return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to decrypt message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateEncryptionPublicKey = function(address, cb) {
      const self2 = this;
      self2.validateSender(address, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: "${address}"`));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateTypedMessage = function(msgParams, cb) {
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign typed data.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined data - message required to sign typed data.`));
      this.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider3.prototype.validateSender = function(senderAddress, cb) {
      const self2 = this;
      if (!senderAddress)
        return cb(null, false);
      self2.getAccounts(function(err, accounts) {
        if (err)
          return cb(err);
        const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;
        cb(null, senderIsValid);
      });
    };
    HookedWalletSubprovider3.prototype.finalizeAndSubmitTx = function(txParams, cb) {
      const self2 = this;
      self2.nonceLock.take(function() {
        waterfall([
          self2.fillInTxExtras.bind(self2, txParams),
          self2.signTransaction.bind(self2),
          self2.publishTransaction.bind(self2)
        ], function(err, txHash) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, txHash);
        });
      });
    };
    HookedWalletSubprovider3.prototype.finalizeTx = function(txParams, cb) {
      const self2 = this;
      self2.nonceLock.take(function() {
        waterfall([
          self2.fillInTxExtras.bind(self2, txParams),
          self2.signTransaction.bind(self2)
        ], function(err, signedTx) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, { raw: signedTx, tx: txParams });
        });
      });
    };
    HookedWalletSubprovider3.prototype.publishTransaction = function(rawTx, cb) {
      const self2 = this;
      self2.emitPayload({
        method: "eth_sendRawTransaction",
        params: [rawTx]
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider3.prototype.estimateGas = function(txParams, cb) {
      const self2 = this;
      estimateGas(self2.engine, txParams, cb);
    };
    HookedWalletSubprovider3.prototype.getGasPrice = function(cb) {
      const self2 = this;
      self2.emitPayload({ method: "eth_gasPrice", params: [] }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider3.prototype.fillInTxExtras = function(txParams, cb) {
      const self2 = this;
      const address = txParams.from;
      const tasks = {};
      if (txParams.gasPrice === void 0) {
        tasks.gasPrice = self2.getGasPrice.bind(self2);
      }
      if (txParams.nonce === void 0) {
        tasks.nonce = self2.emitPayload.bind(self2, { method: "eth_getTransactionCount", params: [address, "pending"] });
      }
      if (txParams.gas === void 0) {
        tasks.gas = self2.estimateGas.bind(self2, cloneTxParams(txParams));
      }
      parallel(tasks, function(err, taskResults) {
        if (err)
          return cb(err);
        const result = {};
        if (taskResults.gasPrice)
          result.gasPrice = taskResults.gasPrice;
        if (taskResults.nonce)
          result.nonce = taskResults.nonce.result;
        if (taskResults.gas)
          result.gas = taskResults.gas;
        cb(null, extend(txParams, result));
      });
    };
    function cloneTxParams(txParams) {
      return {
        from: txParams.from,
        to: txParams.to,
        value: txParams.value,
        data: txParams.data,
        gas: txParams.gas,
        gasPrice: txParams.gasPrice,
        nonce: txParams.nonce
      };
    }
    function toLowerCase(string2) {
      return string2.toLowerCase();
    }
    function resemblesAddress(string2) {
      const fixed = ethUtil.addHexPrefix(string2);
      const isValid = ethUtil.isValidAddress(fixed);
      return isValid;
    }
    function resemblesData(string2) {
      const fixed = ethUtil.addHexPrefix(string2);
      const isValidAddress2 = ethUtil.isValidAddress(fixed);
      return !isValidAddress2 && isValidHex(string2);
    }
    function isValidHex(data) {
      const isString2 = typeof data === "string";
      if (!isString2)
        return false;
      const isHexPrefixed = data.slice(0, 2) === "0x";
      if (!isHexPrefixed)
        return false;
      const nonPrefixed = data.slice(2);
      const isValid = nonPrefixed.match(hexRegex);
      return isValid;
    }
    function mustProvideInConstructor(methodName) {
      return function(params, cb) {
        cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'));
      };
    }
  }
});

// node_modules/web3-provider-engine/subproviders/nonce-tracker.js
var require_nonce_tracker2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/nonce-tracker.js"(exports, module) {
    var inherits2 = require_util().inherits;
    var Transaction2 = require_es5();
    var ethUtil = require_dist5();
    var Subprovider = require_subprovider2();
    var blockTagForPayload = require_rpc_cache_utils().blockTagForPayload;
    module.exports = NonceTrackerSubprovider;
    inherits2(NonceTrackerSubprovider, Subprovider);
    function NonceTrackerSubprovider(opts) {
      const self2 = this;
      self2.nonceCache = {};
    }
    NonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      switch (payload.method) {
        case "eth_getTransactionCount":
          var blockTag = blockTagForPayload(payload);
          var address = payload.params[0].toLowerCase();
          var cachedResult = self2.nonceCache[address];
          if (blockTag === "pending") {
            if (cachedResult) {
              end(null, cachedResult);
            } else {
              next(function(err, result, cb) {
                if (err)
                  return cb();
                if (self2.nonceCache[address] === void 0) {
                  self2.nonceCache[address] = result;
                }
                cb();
              });
            }
          } else {
            next();
          }
          return;
        case "eth_sendRawTransaction":
          next(function(err, result, cb) {
            if (err)
              return cb();
            var rawTx = payload.params[0];
            var stripped = ethUtil.stripHexPrefix(rawTx);
            var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex");
            var tx = new Transaction2(Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex"));
            var address2 = "0x" + tx.getSenderAddress().toString("hex").toLowerCase();
            var nonce = ethUtil.bufferToInt(tx.nonce);
            nonce++;
            var hexNonce = nonce.toString(16);
            if (hexNonce.length % 2)
              hexNonce = "0" + hexNonce;
            hexNonce = "0x" + hexNonce;
            self2.nonceCache[address2] = hexNonce;
            cb();
          });
          return;
        case "evm_revert":
          self2.nonceCache = {};
          next();
          return;
        default:
          next();
          return;
      }
    };
  }
});

// node_modules/web3-provider-engine/subproviders/subscriptions.js
var require_subscriptions2 = __commonJS({
  "node_modules/web3-provider-engine/subproviders/subscriptions.js"(exports, module) {
    var ProviderSubprovider = require_json_rpc_engine_middleware2();
    var createSubscriptionManager = require_subscriptionManager();
    var SubscriptionsSubprovider3 = class extends ProviderSubprovider {
      constructor() {
        super(({ blockTracker, provider, engine }) => {
          const { events, middleware } = createSubscriptionManager({ blockTracker, provider });
          events.on("notification", (data) => engine.emit("data", null, data));
          return middleware;
        });
      }
    };
    module.exports = SubscriptionsSubprovider3;
  }
});

// node_modules/wallet-ethers/lib/wallet/waxio/index.js
var waxjs = __toModule(require_dist2());
var Waxio = class {
  constructor({ pubKeys, rpcEndpoint, userAccount, tryAutoLogin = true }) {
    this.signer = {};
    this.wallet = {};
    this.account = "";
    this.wallet = new waxjs.WaxJS({
      pubKeys,
      rpcEndpoint,
      userAccount,
      tryAutoLogin
    });
  }
  async login() {
    try {
      const account = await this.wallet.login();
      this.account = account;
      this.signer = {};
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
  }
  onAccountsChanged(callBack) {
  }
  onChainChanged(callBack) {
  }
};
var waxio_default = Waxio;

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var index_browser_esm_exports = {};
__export(index_browser_esm_exports, {
  Account: () => Account,
  Authorized: () => Authorized,
  BLOCKHASH_CACHE_TIMEOUT_MS: () => BLOCKHASH_CACHE_TIMEOUT_MS,
  BPF_LOADER_DEPRECATED_PROGRAM_ID: () => BPF_LOADER_DEPRECATED_PROGRAM_ID,
  BPF_LOADER_PROGRAM_ID: () => BPF_LOADER_PROGRAM_ID,
  BpfLoader: () => BpfLoader,
  Connection: () => Connection,
  Ed25519Program: () => Ed25519Program,
  Enum: () => Enum,
  EpochSchedule: () => EpochSchedule,
  FeeCalculatorLayout: () => FeeCalculatorLayout,
  Keypair: () => Keypair,
  LAMPORTS_PER_SOL: () => LAMPORTS_PER_SOL,
  Loader: () => Loader,
  Lockup: () => Lockup,
  MAX_SEED_LENGTH: () => MAX_SEED_LENGTH,
  Message: () => Message,
  NONCE_ACCOUNT_LENGTH: () => NONCE_ACCOUNT_LENGTH,
  NonceAccount: () => NonceAccount,
  PACKET_DATA_SIZE: () => PACKET_DATA_SIZE,
  PublicKey: () => PublicKey,
  SOLANA_SCHEMA: () => SOLANA_SCHEMA,
  STAKE_CONFIG_ID: () => STAKE_CONFIG_ID,
  STAKE_INSTRUCTION_LAYOUTS: () => STAKE_INSTRUCTION_LAYOUTS,
  SYSTEM_INSTRUCTION_LAYOUTS: () => SYSTEM_INSTRUCTION_LAYOUTS,
  SYSVAR_CLOCK_PUBKEY: () => SYSVAR_CLOCK_PUBKEY,
  SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => SYSVAR_EPOCH_SCHEDULE_PUBKEY,
  SYSVAR_INSTRUCTIONS_PUBKEY: () => SYSVAR_INSTRUCTIONS_PUBKEY,
  SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
  SYSVAR_RENT_PUBKEY: () => SYSVAR_RENT_PUBKEY,
  SYSVAR_REWARDS_PUBKEY: () => SYSVAR_REWARDS_PUBKEY,
  SYSVAR_SLOT_HASHES_PUBKEY: () => SYSVAR_SLOT_HASHES_PUBKEY,
  SYSVAR_SLOT_HISTORY_PUBKEY: () => SYSVAR_SLOT_HISTORY_PUBKEY,
  SYSVAR_STAKE_HISTORY_PUBKEY: () => SYSVAR_STAKE_HISTORY_PUBKEY,
  Secp256k1Program: () => Secp256k1Program,
  SendTransactionError: () => SendTransactionError,
  StakeAuthorizationLayout: () => StakeAuthorizationLayout,
  StakeInstruction: () => StakeInstruction,
  StakeProgram: () => StakeProgram,
  Struct: () => Struct2,
  SystemInstruction: () => SystemInstruction,
  SystemProgram: () => SystemProgram,
  Transaction: () => Transaction,
  TransactionInstruction: () => TransactionInstruction,
  VALIDATOR_INFO_KEY: () => VALIDATOR_INFO_KEY,
  VOTE_PROGRAM_ID: () => VOTE_PROGRAM_ID,
  ValidatorInfo: () => ValidatorInfo,
  VoteAccount: () => VoteAccount,
  VoteInit: () => VoteInit,
  VoteInstruction: () => VoteInstruction,
  VoteProgram: () => VoteProgram,
  clusterApiUrl: () => clusterApiUrl,
  sendAndConfirmRawTransaction: () => sendAndConfirmRawTransaction,
  sendAndConfirmTransaction: () => sendAndConfirmTransaction
});
var import_tweetnacl = __toModule(require_nacl_fast());
var import_buffer = __toModule(require_buffer2());
var import_bn = __toModule(require_bn());
var import_bs58 = __toModule(require_bs58());
var import_borsh = __toModule(require_lib());
var BufferLayout = __toModule(require_Layout());

// node_modules/superstruct/lib/index.es.js
var StructError = class extends TypeError {
  constructor(failure, failures) {
    let cached;
    const _a2 = failure, {
      message
    } = _a2, rest = __objRest(_a2, [
      "message"
    ]);
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
    super(msg);
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      var _cached;
      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }
};
function isIterable(x5) {
  return isObject(x5) && typeof x5[Symbol.iterator] === "function";
}
function isObject(x5) {
  return typeof x5 === "object" && x5 != null;
}
function print(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
}
function shiftIterator(input) {
  const {
    done,
    value
  } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct2, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type2
  } = struct2;
  const {
    refinement,
    message = "Expected a value of type `" + type2 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
  } = result;
  return __spreadProps(__spreadValues({
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch
  }, result), {
    message
  });
}
function* toFailures(result, context, struct2, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r6 of result) {
    const failure = toFailure(r6, context, struct2, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct2, options = {}) {
  const {
    path = [],
    branch = [value],
    coerce: coerce2 = false,
    mask: mask2 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce2) {
    value = struct2.coercer(value, ctx);
    if (mask2 && struct2.type !== "type" && isObject(struct2.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key2 in value) {
        if (struct2.schema[key2] === void 0) {
          delete value[key2];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct2.validator(value, ctx)) {
    valid = false;
    yield [failure, void 0];
  }
  for (let [k5, v8, s6] of struct2.entries(value, ctx)) {
    const ts = run(v8, s6, {
      path: k5 === void 0 ? path : [...path, k5],
      branch: k5 === void 0 ? branch : [...branch, v8],
      coerce: coerce2,
      mask: mask2
    });
    for (const t5 of ts) {
      if (t5[0]) {
        valid = false;
        yield [t5[0], void 0];
      } else if (coerce2) {
        v8 = t5[1];
        if (k5 === void 0) {
          value = v8;
        } else if (value instanceof Map) {
          value.set(k5, v8);
        } else if (value instanceof Set) {
          value.add(v8);
        } else if (isObject(value)) {
          value[k5] = v8;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct2.refiner(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
  }
  if (valid) {
    yield [void 0, value];
  }
}
var Struct = class {
  constructor(props) {
    const {
      type: type2,
      schema,
      validator,
      refiner,
      coercer = (value) => value,
      entries = function* () {
      }
    } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value) {
    return assert(value, this);
  }
  create(value) {
    return create(value, this);
  }
  is(value) {
    return is(value, this);
  }
  mask(value) {
    return mask(value, this);
  }
  validate(value, options = {}) {
    return validate(value, this, options);
  }
};
function assert(value, struct2) {
  const result = validate(value, struct2);
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct2) {
  const result = validate(value, struct2, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct2) {
  const result = validate(value, struct2, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct2) {
  const result = validate(value, struct2);
  return !result[0];
}
function validate(value, struct2, options = {}) {
  const tuples = run(value, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t5 of tuples) {
        if (t5[0]) {
          yield t5[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v8 = tuple2[1];
    return [void 0, v8];
  }
}
function define2(name2, validator) {
  return new Struct({
    type: name2,
    schema: null,
    validator
  });
}
function any() {
  return define2("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i5, v8] of value.entries()) {
          yield [i5, v8, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    }
  });
}
function boolean() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance(Class) {
  return define2("instance", (value) => {
    return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
  });
}
function literal(constant) {
  const description = print(constant);
  const t5 = typeof constant;
  return new Struct({
    type: "literal",
    schema: t5 === "string" || t5 === "number" || t5 === "boolean" ? constant : null,
    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct2) {
  return new Struct(__spreadProps(__spreadValues({}, struct2), {
    validator: (value, ctx) => value === null || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
  }));
}
function number() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
  });
}
function optional(struct2) {
  return new Struct(__spreadProps(__spreadValues({}, struct2), {
    validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)
  }));
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k5 in value) {
          const v8 = value[k5];
          yield [k5, k5, Key];
          yield [k5, v8, Value];
        }
      }
    },
    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }
  });
}
function string() {
  return define2("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print(value);
  });
}
function tuple(Elements) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Elements.length, value.length);
        for (let i5 = 0; i5 < length; i5++) {
          yield [i5, value[i5], Elements[i5] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array, but received: " + print(value);
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k5 of keys) {
          yield [k5, value[k5], schema[k5]];
        }
      }
    },
    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }
  });
}
function union(Structs) {
  const description = Structs.map((s6) => s6.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    validator(value, ctx) {
      const failures = [];
      for (const S3 of Structs) {
        const [...tuples] = run(value, S3, ctx);
        const [first2] = tuples;
        if (!first2[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce(struct2, condition, coercer) {
  return new Struct(__spreadProps(__spreadValues({}, struct2), {
    coercer: (value, ctx) => {
      return is(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
    }
  }));
}

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_rpc_websockets = __toModule(require_index_browser());
var import_browser = __toModule(require_browser());
var import_secp256k1 = __toModule(require_elliptic3());
var import_js_sha3 = __toModule(require_sha3());
var toBuffer = (arr) => {
  if (import_buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return import_buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return import_buffer.Buffer.from(arr);
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x5) {
  return x5 && x5.__esModule && Object.prototype.hasOwnProperty.call(x5, "default") ? x5["default"] : x5;
}
var hash$1 = {};
var utils$9 = {};
var minimalisticAssert = assert$6;
function assert$6(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$6.equal = function assertEqual(l5, r6, msg) {
  if (l5 != r6)
    throw new Error(msg || "Assertion failed: " + l5 + " != " + r6);
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var assert$5 = minimalisticAssert;
var inherits = inherits_browser.exports;
utils$9.inherits = inherits;
function isSurrogatePair(msg, i5) {
  if ((msg.charCodeAt(i5) & 64512) !== 55296) {
    return false;
  }
  if (i5 < 0 || i5 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i5 + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p5 = 0;
      for (var i5 = 0; i5 < msg.length; i5++) {
        var c5 = msg.charCodeAt(i5);
        if (c5 < 128) {
          res[p5++] = c5;
        } else if (c5 < 2048) {
          res[p5++] = c5 >> 6 | 192;
          res[p5++] = c5 & 63 | 128;
        } else if (isSurrogatePair(msg, i5)) {
          c5 = 65536 + ((c5 & 1023) << 10) + (msg.charCodeAt(++i5) & 1023);
          res[p5++] = c5 >> 18 | 240;
          res[p5++] = c5 >> 12 & 63 | 128;
          res[p5++] = c5 >> 6 & 63 | 128;
          res[p5++] = c5 & 63 | 128;
        } else {
          res[p5++] = c5 >> 12 | 224;
          res[p5++] = c5 >> 6 & 63 | 128;
          res[p5++] = c5 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i5 = 0; i5 < msg.length; i5 += 2)
        res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
    }
  } else {
    for (i5 = 0; i5 < msg.length; i5++)
      res[i5] = msg[i5] | 0;
  }
  return res;
}
utils$9.toArray = toArray;
function toHex(msg) {
  var res = "";
  for (var i5 = 0; i5 < msg.length; i5++)
    res += zero2(msg[i5].toString(16));
  return res;
}
utils$9.toHex = toHex;
function htonl(w6) {
  var res = w6 >>> 24 | w6 >>> 8 & 65280 | w6 << 8 & 16711680 | (w6 & 255) << 24;
  return res >>> 0;
}
utils$9.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i5 = 0; i5 < msg.length; i5++) {
    var w6 = msg[i5];
    if (endian === "little")
      w6 = htonl(w6);
    res += zero8(w6.toString(16));
  }
  return res;
}
utils$9.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$9.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$9.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$5(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i5 = 0, k5 = start; i5 < res.length; i5++, k5 += 4) {
    var w6;
    if (endian === "big")
      w6 = msg[k5] << 24 | msg[k5 + 1] << 16 | msg[k5 + 2] << 8 | msg[k5 + 3];
    else
      w6 = msg[k5 + 3] << 24 | msg[k5 + 2] << 16 | msg[k5 + 1] << 8 | msg[k5];
    res[i5] = w6 >>> 0;
  }
  return res;
}
utils$9.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i5 = 0, k5 = 0; i5 < msg.length; i5++, k5 += 4) {
    var m5 = msg[i5];
    if (endian === "big") {
      res[k5] = m5 >>> 24;
      res[k5 + 1] = m5 >>> 16 & 255;
      res[k5 + 2] = m5 >>> 8 & 255;
      res[k5 + 3] = m5 & 255;
    } else {
      res[k5 + 3] = m5 >>> 24;
      res[k5 + 2] = m5 >>> 16 & 255;
      res[k5 + 1] = m5 >>> 8 & 255;
      res[k5] = m5 & 255;
    }
  }
  return res;
}
utils$9.split32 = split32;
function rotr32$1(w6, b4) {
  return w6 >>> b4 | w6 << 32 - b4;
}
utils$9.rotr32 = rotr32$1;
function rotl32$2(w6, b4) {
  return w6 << b4 | w6 >>> 32 - b4;
}
utils$9.rotl32 = rotl32$2;
function sum32$3(a5, b4) {
  return a5 + b4 >>> 0;
}
utils$9.sum32 = sum32$3;
function sum32_3$1(a5, b4, c5) {
  return a5 + b4 + c5 >>> 0;
}
utils$9.sum32_3 = sum32_3$1;
function sum32_4$2(a5, b4, c5, d5) {
  return a5 + b4 + c5 + d5 >>> 0;
}
utils$9.sum32_4 = sum32_4$2;
function sum32_5$2(a5, b4, c5, d5, e5) {
  return a5 + b4 + c5 + d5 + e5 >>> 0;
}
utils$9.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$9.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$9.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$9.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$9.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$9.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$9.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$9.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r6 = al << 32 - num | ah >>> num;
  return r6 >>> 0;
}
utils$9.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r6 = ah << 32 - num | al >>> num;
  return r6 >>> 0;
}
utils$9.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$9.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r6 = ah << 32 - num | al >>> num;
  return r6 >>> 0;
}
utils$9.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$8 = utils$9;
var assert$4 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$8.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r6 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r6, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$8.join32(msg, 0, msg.length - r6, this.endian);
    for (var i5 = 0; i5 < msg.length; i5 += this._delta32)
      this._update(msg, i5, i5 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$4(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k5 = bytes - (len + this.padLength) % bytes;
  var res = new Array(k5 + this.padLength);
  res[0] = 128;
  for (var i5 = 1; i5 < k5; i5++)
    res[i5] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t5 = 8; t5 < this.padLength; t5++)
      res[i5++] = 0;
    res[i5++] = 0;
    res[i5++] = 0;
    res[i5++] = 0;
    res[i5++] = 0;
    res[i5++] = len >>> 24 & 255;
    res[i5++] = len >>> 16 & 255;
    res[i5++] = len >>> 8 & 255;
    res[i5++] = len & 255;
  } else {
    res[i5++] = len & 255;
    res[i5++] = len >>> 8 & 255;
    res[i5++] = len >>> 16 & 255;
    res[i5++] = len >>> 24 & 255;
    res[i5++] = 0;
    res[i5++] = 0;
    res[i5++] = 0;
    res[i5++] = 0;
    for (t5 = 8; t5 < this.padLength; t5++)
      res[i5++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$7 = utils$9;
var rotr32 = utils$7.rotr32;
function ft_1$1(s6, x5, y5, z4) {
  if (s6 === 0)
    return ch32$1(x5, y5, z4);
  if (s6 === 1 || s6 === 3)
    return p32(x5, y5, z4);
  if (s6 === 2)
    return maj32$1(x5, y5, z4);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x5, y5, z4) {
  return x5 & y5 ^ ~x5 & z4;
}
common$4.ch32 = ch32$1;
function maj32$1(x5, y5, z4) {
  return x5 & y5 ^ x5 & z4 ^ y5 & z4;
}
common$4.maj32 = maj32$1;
function p32(x5, y5, z4) {
  return x5 ^ y5 ^ z4;
}
common$4.p32 = p32;
function s0_256$1(x5) {
  return rotr32(x5, 2) ^ rotr32(x5, 13) ^ rotr32(x5, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x5) {
  return rotr32(x5, 6) ^ rotr32(x5, 11) ^ rotr32(x5, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x5) {
  return rotr32(x5, 7) ^ rotr32(x5, 18) ^ x5 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x5) {
  return rotr32(x5, 17) ^ rotr32(x5, 19) ^ x5 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$6 = utils$9;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$6.rotl32;
var sum32$2 = utils$6.sum32;
var sum32_5$1 = utils$6.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$6.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i5 = 0; i5 < 16; i5++)
    W2[i5] = msg[start + i5];
  for (; i5 < W2.length; i5++)
    W2[i5] = rotl32$1(W2[i5 - 3] ^ W2[i5 - 8] ^ W2[i5 - 14] ^ W2[i5 - 16], 1);
  var a5 = this.h[0];
  var b4 = this.h[1];
  var c5 = this.h[2];
  var d5 = this.h[3];
  var e5 = this.h[4];
  for (i5 = 0; i5 < W2.length; i5++) {
    var s6 = ~~(i5 / 20);
    var t5 = sum32_5$1(rotl32$1(a5, 5), ft_1(s6, b4, c5, d5), e5, W2[i5], sha1_K[s6]);
    e5 = d5;
    d5 = c5;
    c5 = rotl32$1(b4, 30);
    b4 = a5;
    a5 = t5;
  }
  this.h[0] = sum32$2(this.h[0], a5);
  this.h[1] = sum32$2(this.h[1], b4);
  this.h[2] = sum32$2(this.h[2], c5);
  this.h[3] = sum32$2(this.h[3], d5);
  this.h[4] = sum32$2(this.h[4], e5);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h, "big");
  else
    return utils$6.split32(this.h, "big");
};
var utils$5 = utils$9;
var common$2 = common$5;
var shaCommon = common$4;
var assert$3 = minimalisticAssert;
var sum32$1 = utils$5.sum32;
var sum32_4$1 = utils$5.sum32_4;
var sum32_5 = utils$5.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$5.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i5 = 0; i5 < 16; i5++)
    W2[i5] = msg[start + i5];
  for (; i5 < W2.length; i5++)
    W2[i5] = sum32_4$1(g1_256(W2[i5 - 2]), W2[i5 - 7], g0_256(W2[i5 - 15]), W2[i5 - 16]);
  var a5 = this.h[0];
  var b4 = this.h[1];
  var c5 = this.h[2];
  var d5 = this.h[3];
  var e5 = this.h[4];
  var f7 = this.h[5];
  var g5 = this.h[6];
  var h5 = this.h[7];
  assert$3(this.k.length === W2.length);
  for (i5 = 0; i5 < W2.length; i5++) {
    var T1 = sum32_5(h5, s1_256(e5), ch32(e5, f7, g5), this.k[i5], W2[i5]);
    var T22 = sum32$1(s0_256(a5), maj32(a5, b4, c5));
    h5 = g5;
    g5 = f7;
    f7 = e5;
    e5 = sum32$1(d5, T1);
    d5 = c5;
    c5 = b4;
    b4 = a5;
    a5 = sum32$1(T1, T22);
  }
  this.h[0] = sum32$1(this.h[0], a5);
  this.h[1] = sum32$1(this.h[1], b4);
  this.h[2] = sum32$1(this.h[2], c5);
  this.h[3] = sum32$1(this.h[3], d5);
  this.h[4] = sum32$1(this.h[4], e5);
  this.h[5] = sum32$1(this.h[5], f7);
  this.h[6] = sum32$1(this.h[6], g5);
  this.h[7] = sum32$1(this.h[7], h5);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "big");
  else
    return utils$5.split32(this.h, "big");
};
var utils$4 = utils$9;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$4.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$4.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$4.split32(this.h.slice(0, 7), "big");
};
var utils$3 = utils$9;
var common$1 = common$5;
var assert$2 = minimalisticAssert;
var rotr64_hi = utils$3.rotr64_hi;
var rotr64_lo = utils$3.rotr64_lo;
var shr64_hi = utils$3.shr64_hi;
var shr64_lo = utils$3.shr64_lo;
var sum64 = utils$3.sum64;
var sum64_hi = utils$3.sum64_hi;
var sum64_lo = utils$3.sum64_lo;
var sum64_4_hi = utils$3.sum64_4_hi;
var sum64_4_lo = utils$3.sum64_4_lo;
var sum64_5_hi = utils$3.sum64_5_hi;
var sum64_5_lo = utils$3.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$3.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i5 = 0; i5 < 32; i5++)
    W2[i5] = msg[start + i5];
  for (; i5 < W2.length; i5 += 2) {
    var c0_hi = g1_512_hi(W2[i5 - 4], W2[i5 - 3]);
    var c0_lo = g1_512_lo(W2[i5 - 4], W2[i5 - 3]);
    var c1_hi = W2[i5 - 14];
    var c1_lo = W2[i5 - 13];
    var c2_hi = g0_512_hi(W2[i5 - 30], W2[i5 - 29]);
    var c2_lo = g0_512_lo(W2[i5 - 30], W2[i5 - 29]);
    var c3_hi = W2[i5 - 32];
    var c3_lo = W2[i5 - 31];
    W2[i5] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W2[i5 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};
SHA512$1.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert$2(this.k.length === W2.length);
  for (var i5 = 0; i5 < W2.length; i5 += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i5];
    var c3_lo = this.k[i5 + 1];
    var c4_hi = W2[i5];
    var c4_lo = W2[i5 + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$3.toHex32(this.h, "big");
  else
    return utils$3.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r6 = xh & yh ^ ~xh & zh;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r6 = xl & yl ^ ~xl & zl;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r6 = xh & yh ^ xh & zh ^ yh & zh;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r6 = xl & yl ^ xl & zl ^ yl & zl;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r6 = c0_hi ^ c1_hi ^ c2_hi;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r6 = c0_lo ^ c1_lo ^ c2_lo;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r6 = c0_hi ^ c1_hi ^ c2_hi;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r6 = c0_lo ^ c1_lo ^ c2_lo;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r6 = c0_hi ^ c1_hi ^ c2_hi;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r6 = c0_lo ^ c1_lo ^ c2_lo;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r6 = c0_hi ^ c1_hi ^ c2_hi;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r6 = c0_lo ^ c1_lo ^ c2_lo;
  if (r6 < 0)
    r6 += 4294967296;
  return r6;
}
var utils$2 = utils$9;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$2.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$2.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$2.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$1 = utils$9;
var common = common$5;
var rotl32 = utils$1.rotl32;
var sum32 = utils$1.sum32;
var sum32_3 = utils$1.sum32_3;
var sum32_4 = utils$1.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$1.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A6 = this.h[0];
  var B3 = this.h[1];
  var C4 = this.h[2];
  var D4 = this.h[3];
  var E4 = this.h[4];
  var Ah = A6;
  var Bh = B3;
  var Ch = C4;
  var Dh = D4;
  var Eh = E4;
  for (var j5 = 0; j5 < 80; j5++) {
    var T6 = sum32(rotl32(sum32_4(A6, f2(j5, B3, C4, D4), msg[r[j5] + start], K(j5)), s[j5]), E4);
    A6 = E4;
    E4 = D4;
    D4 = rotl32(C4, 10);
    C4 = B3;
    B3 = T6;
    T6 = sum32(rotl32(sum32_4(Ah, f2(79 - j5, Bh, Ch, Dh), msg[rh[j5] + start], Kh(j5)), sh[j5]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T6;
  }
  T6 = sum32_3(this.h[1], C4, Dh);
  this.h[1] = sum32_3(this.h[2], D4, Eh);
  this.h[2] = sum32_3(this.h[3], E4, Ah);
  this.h[3] = sum32_3(this.h[4], A6, Bh);
  this.h[4] = sum32_3(this.h[0], B3, Ch);
  this.h[0] = T6;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$1.toHex32(this.h, "little");
  else
    return utils$1.split32(this.h, "little");
};
function f2(j5, x5, y5, z4) {
  if (j5 <= 15)
    return x5 ^ y5 ^ z4;
  else if (j5 <= 31)
    return x5 & y5 | ~x5 & z4;
  else if (j5 <= 47)
    return (x5 | ~y5) ^ z4;
  else if (j5 <= 63)
    return x5 & z4 | y5 & ~z4;
  else
    return x5 ^ (y5 | ~z4);
}
function K(j5) {
  if (j5 <= 15)
    return 0;
  else if (j5 <= 31)
    return 1518500249;
  else if (j5 <= 47)
    return 1859775393;
  else if (j5 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j5) {
  if (j5 <= 15)
    return 1352829926;
  else if (j5 <= 31)
    return 1548603684;
  else if (j5 <= 47)
    return 1836072691;
  else if (j5 <= 63)
    return 2053994217;
  else
    return 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils = utils$9;
var assert$1 = minimalisticAssert;
function Hmac(hash4, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash4, key2, enc);
  this.Hash = hash4;
  this.blockSize = hash4.blockSize / 8;
  this.outSize = hash4.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils.toArray(key2, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$1(key2.length <= this.blockSize);
  for (var i5 = key2.length; i5 < this.blockSize; i5++)
    key2.push(0);
  for (i5 = 0; i5 < key2.length; i5++)
    key2[i5] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i5 = 0; i5 < key2.length; i5++)
    key2[i5] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash4 = exports;
  hash4.utils = utils$9;
  hash4.common = common$5;
  hash4.sha = sha;
  hash4.ripemd = ripemd;
  hash4.hmac = hmac;
  hash4.sha1 = hash4.sha.sha1;
  hash4.sha256 = hash4.sha.sha256;
  hash4.sha224 = hash4.sha.sha224;
  hash4.sha384 = hash4.sha.sha384;
  hash4.sha512 = hash4.sha.sha512;
  hash4.ripemd160 = hash4.ripemd.ripemd160;
})(hash$1);
var hash = hash$1;
var version$2 = "logger/5.5.0";
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel3) {
  LogLevel3["DEBUG"] = "DEBUG";
  LogLevel3["INFO"] = "INFO";
  LogLevel3["WARNING"] = "WARNING";
  LogLevel3["ERROR"] = "ERROR";
  LogLevel3["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode3) {
  ErrorCode3["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode3["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode3["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode3["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode3["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode3["TIMEOUT"] = "TIMEOUT";
  ErrorCode3["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode3["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode3["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode3["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode3["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode3["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode3["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode3["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode3["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode3["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode3["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode3["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version29) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version29,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i5 = 0; i5 < value.length; i5++) {
            hex += HEX[value[i5] >> 4];
            hex += HEX[value[i5] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$2);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version29) {
    return new Logger(version29);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
var version$1 = "bytes/5.5.0";
var logger = new Logger(version$1);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i5 = 0; i5 < value.length; i5++) {
    const v8 = value[i5];
    if (!isInteger(v8) || v8 < 0 || v8 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0x0" + hex.substring(2);
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i5 = 0; i5 < hex.length; i5 += 2) {
      result.push(parseInt(hex.substring(i5, i5 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var version2 = "sha2/5.5.0";
new Logger(version2);
function sha256(data) {
  return "0x" + hash.sha256().update(arrayify(data)).digest("hex");
}
var Struct2 = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return import_buffer.Buffer.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
  }
};
var Enum = class extends Struct2 {
  constructor(properties) {
    super(properties);
    this.enum = "";
    if (Object.keys(properties).length !== 1) {
      throw new Error("Enum can only take single value");
    }
    Object.keys(properties).map((key2) => {
      this.enum = key2;
    });
  }
};
var SOLANA_SCHEMA = new Map();
var MAX_SEED_LENGTH = 32;
function isPublicKeyData(value) {
  return value._bn !== void 0;
}
var PublicKey = class extends Struct2 {
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs58.default.decode(value);
        if (decoded.length != 32) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn.default(decoded);
      } else {
        this._bn = new import_bn.default(value);
      }
      if (this._bn.byteLength() > 32) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  equals(publicKey2) {
    return this._bn.eq(publicKey2._bn);
  }
  toBase58() {
    return import_bs58.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    return this.toBuffer();
  }
  toBuffer() {
    const b4 = this._bn.toArrayLike(import_buffer.Buffer);
    if (b4.length === 32) {
      return b4;
    }
    const zeroPad2 = import_buffer.Buffer.alloc(32);
    b4.copy(zeroPad2, 32 - b4.length);
    return zeroPad2;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer2 = import_buffer.Buffer.concat([fromPublicKey.toBuffer(), import_buffer.Buffer.from(seed), programId.toBuffer()]);
    const hash4 = sha256(new Uint8Array(buffer2)).slice(2);
    return new PublicKey(import_buffer.Buffer.from(hash4, "hex"));
  }
  static async createProgramAddress(seeds, programId) {
    let buffer2 = import_buffer.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer2 = import_buffer.Buffer.concat([buffer2, toBuffer(seed)]);
    });
    buffer2 = import_buffer.Buffer.concat([buffer2, programId.toBuffer(), import_buffer.Buffer.from("ProgramDerivedAddress")]);
    let hash4 = sha256(new Uint8Array(buffer2)).slice(2);
    let publicKeyBytes = new import_bn.default(hash4, 16).toArray(void 0, 32);
    if (is_on_curve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  static async findProgramAddress(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(import_buffer.Buffer.from([nonce]));
        address = await this.createProgramAddress(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  static isOnCurve(pubkey) {
    return is_on_curve(pubkey) == 1;
  }
};
PublicKey.default = new PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var naclLowLevel = import_tweetnacl.default.lowlevel;
function is_on_curve(p5) {
  var r6 = [naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf()];
  var t5 = naclLowLevel.gf(), chk = naclLowLevel.gf(), num = naclLowLevel.gf(), den = naclLowLevel.gf(), den2 = naclLowLevel.gf(), den4 = naclLowLevel.gf(), den6 = naclLowLevel.gf();
  naclLowLevel.set25519(r6[2], gf1);
  naclLowLevel.unpack25519(r6[1], p5);
  naclLowLevel.S(num, r6[1]);
  naclLowLevel.M(den, num, naclLowLevel.D);
  naclLowLevel.Z(num, num, r6[2]);
  naclLowLevel.A(den, r6[2], den);
  naclLowLevel.S(den2, den);
  naclLowLevel.S(den4, den2);
  naclLowLevel.M(den6, den4, den2);
  naclLowLevel.M(t5, den6, num);
  naclLowLevel.M(t5, t5, den);
  naclLowLevel.pow2523(t5, t5);
  naclLowLevel.M(t5, t5, num);
  naclLowLevel.M(t5, t5, den);
  naclLowLevel.M(t5, t5, den);
  naclLowLevel.M(r6[0], t5, den);
  naclLowLevel.S(chk, r6[0]);
  naclLowLevel.M(chk, chk, den);
  if (neq25519(chk, num))
    naclLowLevel.M(r6[0], r6[0], I);
  naclLowLevel.S(chk, r6[0]);
  naclLowLevel.M(chk, chk, den);
  if (neq25519(chk, num))
    return 0;
  return 1;
}
var gf1 = naclLowLevel.gf([1]);
var I = naclLowLevel.gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
function neq25519(a5, b4) {
  var c5 = new Uint8Array(32), d5 = new Uint8Array(32);
  naclLowLevel.pack25519(c5, a5);
  naclLowLevel.pack25519(d5, b4);
  return naclLowLevel.crypto_verify_32(c5, 0, d5, 0);
}
var Account = class {
  constructor(secretKey) {
    this._keypair = void 0;
    if (secretKey) {
      this._keypair = import_tweetnacl.default.sign.keyPair.fromSecretKey(toBuffer(secretKey));
    } else {
      this._keypair = import_tweetnacl.default.sign.keyPair();
    }
  }
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  get secretKey() {
    return toBuffer(this._keypair.secretKey);
  }
};
var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
var publicKey = (property = "publicKey") => {
  return BufferLayout.blob(32, property);
};
var rustString = (property = "string") => {
  const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
  const _decode2 = rsl.decode.bind(rsl);
  const _encode3 = rsl.encode.bind(rsl);
  rsl.decode = (buffer2, offset2) => {
    const data = _decode2(buffer2, offset2);
    return data["chars"].toString("utf8");
  };
  rsl.encode = (str, buffer2, offset2) => {
    const data = {
      chars: import_buffer.Buffer.from(str, "utf8")
    };
    return _encode3(data, buffer2, offset2);
  };
  rsl.alloc = (str) => {
    return BufferLayout.u32().span + BufferLayout.u32().span + import_buffer.Buffer.from(str, "utf8").length;
  };
  return rsl;
};
var authorized = (property = "authorized") => {
  return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
var lockup = (property = "lockup") => {
  return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
};
var voteInit = (property = "voteInit") => {
  return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
};
function getAlloc(type2, fields) {
  let alloc = 0;
  type2.layout.fields.forEach((item) => {
    if (item.span >= 0) {
      alloc += item.span;
    } else if (typeof item.alloc === "function") {
      alloc += item.alloc(fields[item.property]);
    }
  });
  return alloc;
}
function decodeLength(bytes) {
  let len = 0;
  let size = 0;
  for (; ; ) {
    let elem = bytes.shift();
    len |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes, len) {
  let rem_len = len;
  for (; ; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 128;
      bytes.push(elem);
    }
  }
}
var PUBKEY_LENGTH = 32;
var Message = class {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    return index < this.header.numRequiredSignatures - this.header.numReadonlySignedAccounts || index >= this.header.numRequiredSignatures && index < this.accountKeys.length - this.header.numReadonlyUnsignedAccounts;
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_10, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = import_bs58.default.decode(instruction.data);
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: import_buffer.Buffer.from(keyIndicesCount),
        keyIndices: import_buffer.Buffer.from(accounts),
        dataLength: import_buffer.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = import_buffer.Buffer.alloc(PACKET_DATA_SIZE);
    import_buffer.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: import_buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: import_buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: import_buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: import_buffer.Buffer.from(keyCount),
      keys: this.accountKeys.map((key2) => toBuffer(key2.toBytes())),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
    };
    let signData = import_buffer.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  static from(buffer2) {
    let byteArray = [...buffer2];
    const numRequiredSignatures = byteArray.shift();
    const numReadonlySignedAccounts = byteArray.shift();
    const numReadonlyUnsignedAccounts = byteArray.shift();
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i5 = 0; i5 < accountCount; i5++) {
      const account = byteArray.slice(0, PUBKEY_LENGTH);
      byteArray = byteArray.slice(PUBKEY_LENGTH);
      accountKeys.push(import_bs58.default.encode(import_buffer.Buffer.from(account)));
    }
    const recentBlockhash = byteArray.slice(0, PUBKEY_LENGTH);
    byteArray = byteArray.slice(PUBKEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i5 = 0; i5 < instructionCount; i5++) {
      const programIdIndex = byteArray.shift();
      const accountCount2 = decodeLength(byteArray);
      const accounts = byteArray.slice(0, accountCount2);
      byteArray = byteArray.slice(accountCount2);
      const dataLength = decodeLength(byteArray);
      const dataSlice = byteArray.slice(0, dataLength);
      const data = import_bs58.default.encode(import_buffer.Buffer.from(dataSlice));
      byteArray = byteArray.slice(dataLength);
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs58.default.encode(import_buffer.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
};
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var DEFAULT_SIGNATURE = import_buffer.Buffer.alloc(64).fill(0);
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var SIGNATURE_LENGTH = 64;
var TransactionInstruction = class {
  constructor(opts) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = import_buffer.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
};
var Transaction = class {
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  constructor(opts) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.nonceInfo = void 0;
    opts && Object.assign(this, opts);
  }
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  compileMessage() {
    const {
      nonceInfo
    } = this;
    if (nonceInfo && this.instructions[0] != nonceInfo.nonceInstruction) {
      this.recentBlockhash = nonceInfo.nonce;
      this.instructions.unshift(nonceInfo.nonceInstruction);
    }
    const {
      recentBlockhash
    } = this;
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (this.instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i5 = 0; i5 < this.instructions.length; i5++) {
      if (this.instructions[i5].programId === void 0) {
        throw new Error(`Transaction instruction index ${i5} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    this.instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push(__spreadValues({}, accountMeta));
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    accountMetas.sort(function(x5, y5) {
      const pubkeySorting = x5.pubkey.toBase58().localeCompare(y5.pubkey.toBase58());
      const checkSigner = x5.isSigner === y5.isSigner ? 0 : x5.isSigner ? -1 : 1;
      const checkWritable = x5.isWritable === y5.isWritable ? pubkeySorting : x5.isWritable ? -1 : 1;
      return checkSigner || checkWritable;
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    const feePayerIndex = uniqueMetas.findIndex((x5) => {
      return x5.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature2 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x5) => {
        return x5.pubkey.equals(signature2.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs58.default.encode(data)
      };
    });
    instructions.forEach((instruction) => {
      assert2(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions
    });
  }
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message;
    }
    this.signatures = signedKeys.map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
    return message;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set();
    this.signatures = signers.filter((publicKey2) => {
      const key2 = publicKey2.toString();
      if (seen.has(key2)) {
        return false;
      } else {
        seen.add(key2);
        return true;
      }
    }).map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
  }
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key2 = signer.publicKey.toString();
      if (seen.has(key2)) {
        continue;
      } else {
        seen.add(key2);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
    this._verifySignatures(message.serialize(), true);
  }
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key2 = signer.publicKey.toString();
      if (seen.has(key2)) {
        continue;
      } else {
        seen.add(key2);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature2 = import_tweetnacl.default.sign.detached(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature2));
    });
  }
  addSignature(pubkey, signature2) {
    this._compile();
    this._addSignature(pubkey, signature2);
  }
  _addSignature(pubkey, signature2) {
    assert2(signature2.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = import_buffer.Buffer.from(signature2);
  }
  verifySignatures() {
    return this._verifySignatures(this.serializeMessage(), true);
  }
  _verifySignatures(signData, requireAllSignatures) {
    for (const {
      signature: signature2,
      publicKey: publicKey2
    } of this.signatures) {
      if (signature2 === null) {
        if (requireAllSignatures) {
          return false;
        }
      } else {
        if (!import_tweetnacl.default.sign.detached.verify(signData, signature2, publicKey2.toBuffer())) {
          return false;
        }
      }
    }
    return true;
  }
  serialize(config2) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config2);
    const signData = this.serializeMessage();
    if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
      throw new Error("Signature verification failed");
    }
    return this._serialize(signData);
  }
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = import_buffer.Buffer.alloc(transactionLength);
    assert2(signatures.length < 256);
    import_buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature2
    }, index) => {
      if (signature2 !== null) {
        assert2(signature2.length === 64, `signature has invalid length`);
        import_buffer.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  get keys() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  get programId() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  get data() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  static from(buffer2) {
    let byteArray = [...buffer2];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i5 = 0; i5 < signatureCount; i5++) {
      const signature2 = byteArray.slice(0, SIGNATURE_LENGTH);
      byteArray = byteArray.slice(SIGNATURE_LENGTH);
      signatures.push(import_bs58.default.encode(import_buffer.Buffer.from(signature2)));
    }
    return Transaction.populate(Message.from(byteArray), signatures);
  }
  static populate(message, signatures = []) {
    const transaction = new Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature2, index) => {
      const sigPubkeyPair = {
        signature: signature2 == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature2),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs58.default.decode(instruction.data)
      }));
    });
    return transaction;
  }
};
var SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries
  };
  const signature2 = await connection.sendTransaction(transaction, signers, sendOptions);
  const status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
  if (status.err) {
    throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function encodeData(type2, fields) {
  const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);
  const data = import_buffer.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type2.index
  }, fields);
  type2.layout.encode(layoutFields, data);
  return data;
}
function decodeData(type2, buffer2) {
  let data;
  try {
    data = type2.layout.decode(buffer2);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (data.instruction !== type2.index) {
    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type2.index}`);
  }
  return data;
}
var FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
var NonceAccount = class {
  constructor(args) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }
  static fromAccountData(buffer2) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer2), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
      nonce: new PublicKey(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
};
var SystemInstruction = class {
  constructor() {
  }
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32("instruction");
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type2 = ixType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Instruction type incorrect; not a SystemInstruction");
    }
    return type2;
  }
  static decodeCreateAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports,
      space,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  static decodeTransfer(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      lamports
    };
  }
  static decodeTransferWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports,
      seed,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      basePubkey: instruction.keys[1].pubkey,
      toPubkey: instruction.keys[2].pubkey,
      lamports,
      seed,
      programId: new PublicKey(programId)
    };
  }
  static decodeAllocate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      space
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      space
    };
  }
  static decodeAllocateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base: base2,
      seed,
      space,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base2),
      seed,
      space,
      programId: new PublicKey(programId)
    };
  }
  static decodeAssign(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      programId: new PublicKey(programId)
    };
  }
  static decodeAssignWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base: base2,
      seed,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base2),
      seed,
      programId: new PublicKey(programId)
    };
  }
  static decodeCreateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      base: base2,
      seed,
      lamports,
      space,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      basePubkey: new PublicKey(base2),
      seed,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  static decodeNonceInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      authorized: authorized2
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: new PublicKey(authorized2)
    };
  }
  static decodeNonceAdvance(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  static decodeNonceWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
  }
  static decodeNonceAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized: authorized2
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[1].pubkey,
      newAuthorizedPubkey: new PublicKey(authorized2)
    };
  }
  static checkProgramId(programId) {
    if (!programId.equals(SystemProgram.programId)) {
      throw new Error("invalid instruction; programId is not SystemProgram");
    }
  }
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
};
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), rustString("seed"), publicKey("programId")])
  }
});
var SystemProgram = class {
  constructor() {
  }
  static createAccount(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type2, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type2, {
        lamports: params.lamports,
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type2, {
        lamports: params.lamports
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type2, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createAccountWithSeed(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type2, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (params.basePubkey != params.fromPubkey) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createNonceAccount(params) {
    const transaction = new Transaction();
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  static nonceInitialize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceAdvance(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type2);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceWithdraw(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type2, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static nonceAuthorize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type2, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
};
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;
var Loader = class {
  constructor() {
  }
  static getMinNumSignatures(dataLength) {
    return 2 * (Math.ceil(dataLength / Loader.chunkSize) + 1 + 1);
  }
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
    const chunkSize = Loader.chunkSize;
    let offset2 = 0;
    let array2 = data;
    let transactions = [];
    while (array2.length > 0) {
      const bytes = array2.slice(0, chunkSize);
      const data2 = import_buffer.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        offset: offset2,
        bytes
      }, data2);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1e3 / REQUESTS_PER_SECOND);
      }
      offset2 += chunkSize;
      array2 = array2.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
      const data2 = import_buffer.Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
      }, data2);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      await sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: "confirmed"
      });
    }
    return true;
  }
};
Loader.chunkSize = CHUNK_SIZE;
var BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
var BpfLoader = class {
  static getMinNumSignatures(dataLength) {
    return Loader.getMinNumSignatures(dataLength);
  }
  static load(connection, payer, program, elf, loaderProgramId) {
    return Loader.load(connection, payer, program, loaderProgramId, elf);
  }
};
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F4() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F4.prototype = global2;
    return new F4();
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e5) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name2) {
        if (typeof name2 !== "string") {
          name2 = String(name2);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name2.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator2 = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator2[Symbol.iterator] = function() {
            return iterator2;
          };
        }
        return iterator2;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name2) {
            this.append(name2, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name2) {
            this.append(name2, headers[name2]);
          }, this);
        }
      }
      Headers.prototype.append = function(name2, value) {
        name2 = normalizeName(name2);
        value = normalizeValue(value);
        var oldValue = this.map[name2];
        this.map[name2] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name2) {
        delete this.map[normalizeName(name2)];
      };
      Headers.prototype.get = function(name2) {
        name2 = normalizeName(name2);
        return this.has(name2) ? this.map[name2] : null;
      };
      Headers.prototype.has = function(name2) {
        return this.map.hasOwnProperty(normalizeName(name2));
      };
      Headers.prototype.set = function(name2, value) {
        this.map[normalizeName(name2)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name2 in this.map) {
          if (this.map.hasOwnProperty(name2)) {
            callback.call(thisArg, this.map[name2], name2, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push(name2);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push([name2, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob2) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob2);
        return promise;
      }
      function readBlobAsText(blob2) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob2);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i5 = 0; i5 < view.length; i5++) {
          chars[i5] = String.fromCharCode(view[i5]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode4);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode4(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name2 = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name2), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key2 = parts.shift().trim();
          if (key2) {
            var value = parts.join(":").trim();
            headers.append(key2, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name2) {
          this.message = message;
          this.name = name2;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch3(input, init3) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init3);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name2) {
            xhr.setRequestHeader(name2, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch3.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch3;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports2.Headers = Headers;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch3;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
var fetch2 = getDefaultExportFromCjs(browserPonyfill.exports);
var MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(n3) {
  let trailingZeros2 = 0;
  while (n3 > 1) {
    n3 /= 2;
    trailingZeros2++;
  }
  return trailingZeros2;
}
function nextPowerOfTwo(n3) {
  if (n3 === 0)
    return 1;
  n3--;
  n3 |= n3 >> 1;
  n3 |= n3 >> 2;
  n3 |= n3 >> 4;
  n3 |= n3 >> 8;
  n3 |= n3 >> 16;
  n3 |= n3 >> 32;
  return n3 + 1;
}
var EpochSchedule = class {
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }
};
var SendTransactionError = class extends Error {
  constructor(message, logs) {
    super(message);
    this.logs = void 0;
    this.logs = logs;
  }
};
var NUM_TICKS_PER_SECOND = 160;
var DEFAULT_TICKS_PER_SLOT = 64;
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
function promiseTimeout(promise, timeoutMs) {
  let timeoutId;
  const timeoutPromise = new Promise((resolve) => {
    timeoutId = setTimeout(() => resolve(null), timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]).then((result) => {
    clearTimeout(timeoutId);
    return result;
  });
}
function makeWebsocketUrl(endpoint2) {
  let url = new URL(endpoint2);
  const useHttps = url.protocol === "https:";
  url.protocol = useHttps ? "wss:" : "ws:";
  url.host = "";
  if (url.port !== "") {
    url.port = String(Number(url.port) + 1);
  }
  return url.toString();
}
var PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
var RawAccountDataResult = tuple([string(), literal("base64")]);
var BufferFromRawAccountData = coerce(instance(import_buffer.Buffer), RawAccountDataResult, (value) => import_buffer.Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return __spreadProps(__spreadValues({}, value), {
        result: create(value.result, schema)
      });
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number()
    }),
    value
  });
}
var GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number()
}))));
var GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});
var GetLeaderScheduleResult = record(string(), array(number()));
var TransactionErrorResult = nullable(union([type({}), string()]));
var SignatureStatusResult = type({
  err: TransactionErrorResult
});
var SignatureReceivedResult = literal("receivedSignature");
var VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  })))),
  unitsConsumed: optional(number())
}));
function createRpcClient(url, useHttps, httpHeaders, fetchMiddleware, disableRetryOnRateLimit) {
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (url2, options) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(url2, options, (modifiedUrl, modifiedOptions) => resolve([modifiedUrl, modifiedOptions]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch2(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new import_browser.default(async (request, callback) => {
    const agent = void 0;
    const options = {
      method: "POST",
      body: request,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {})
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch2(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error)
        callback(err);
    } finally {
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0)
        resolve([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
var SlotRpcResult = jsonRpcResult(number());
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
var TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
})));
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
})));
var AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
});
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce(union([instance(import_buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
var StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
});
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
var SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
});
var SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
});
var SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
var SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
});
var SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
var RootNotificationResult = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
var GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
var ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string()
  })
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult);
  } else {
    return create(value, ParsedInstructionResult);
  }
});
var ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(type({
      pubkey: PublicKeyFromString,
      signer: boolean(),
      writable: boolean()
    })),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string()
  })
});
var TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
});
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult)))
});
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult)))
});
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(type({
    pubkey: string(),
    lamports: number(),
    postBalance: nullable(number()),
    rewardType: nullable(string())
  }))),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(type({
    pubkey: string(),
    lamports: number(),
    postBalance: nullable(number()),
    rewardType: nullable(string())
  }))),
  blockTime: nullable(number())
})));
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult
})));
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number()))
})));
var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number()
  })
}));
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
var PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
var RequestAirdropRpcResult = jsonRpcResult(string());
var SendTransactionRpcResult = jsonRpcResult(string());
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
});
var Connection = class {
  constructor(endpoint2, commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      recentBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._accountChangeSubscriptionCounter = 0;
    this._accountChangeSubscriptions = {};
    this._programAccountChangeSubscriptionCounter = 0;
    this._programAccountChangeSubscriptions = {};
    this._rootSubscriptionCounter = 0;
    this._rootSubscriptions = {};
    this._signatureSubscriptionCounter = 0;
    this._signatureSubscriptions = {};
    this._slotSubscriptionCounter = 0;
    this._slotSubscriptions = {};
    this._logsSubscriptionCounter = 0;
    this._logsSubscriptions = {};
    this._slotUpdateSubscriptionCounter = 0;
    this._slotUpdateSubscriptions = {};
    let url = new URL(endpoint2);
    const useHttps = url.protocol === "https:";
    let wsEndpoint;
    let httpHeaders;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    if (commitmentOrConfig && typeof commitmentOrConfig === "string") {
      this._commitment = commitmentOrConfig;
    } else if (commitmentOrConfig) {
      this._commitment = commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = commitmentOrConfig.wsEndpoint;
      httpHeaders = commitmentOrConfig.httpHeaders;
      fetchMiddleware = commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = commitmentOrConfig.disableRetryOnRateLimit;
    }
    this._rpcEndpoint = endpoint2;
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
    this._rpcClient = createRpcClient(url.toString(), useHttps, httpHeaders, fetchMiddleware, disableRetryOnRateLimit);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new import_rpc_websockets.Client(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
    this._rpcWebSocket.on("error", this._wsOnError.bind(this));
    this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
    this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  get commitment() {
    return this._commitment;
  }
  async getBalanceAndContext(publicKey2, commitment) {
    const args = this._buildArgs([publicKey2.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(number()));
    if ("error" in res) {
      throw new Error("failed to get balance for " + publicKey2.toBase58() + ": " + res.error.message);
    }
    return res.result;
  }
  async getBalance(publicKey2, commitment) {
    return await this.getBalanceAndContext(publicKey2, commitment).then((x5) => x5.value).catch((e5) => {
      throw new Error("failed to get balance of account " + publicKey2.toBase58() + ": " + e5);
    });
  }
  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
    const res = create(unsafeRes, jsonRpcResult(nullable(number())));
    if ("error" in res) {
      throw new Error("failed to get block time for slot " + slot + ": " + res.error.message);
    }
    return res.result;
  }
  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new Error("failed to get minimum ledger slot: " + res.error.message);
    }
    return res.result;
  }
  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
    const res = create(unsafeRes, SlotRpcResult);
    if ("error" in res) {
      throw new Error("failed to get first available block: " + res.error.message);
    }
    return res.result;
  }
  async getSupply(config2) {
    let configArg = {};
    if (typeof config2 === "string") {
      configArg = {
        commitment: config2
      };
    } else if (config2) {
      configArg = __spreadProps(__spreadValues({}, config2), {
        commitment: config2 && config2.commitment || this.commitment
      });
    } else {
      configArg = {
        commitment: this.commitment
      };
    }
    const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
    const res = create(unsafeRes, GetSupplyRpcResult);
    if ("error" in res) {
      throw new Error("failed to get supply: " + res.error.message);
    }
    return res.result;
  }
  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenSupply", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new Error("failed to get token supply: " + res.error.message);
    }
    return res.result;
  }
  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new Error("failed to get token account balance: " + res.error.message);
    }
    return res.result;
  }
  async getTokenAccountsByOwner(ownerAddress, filter2, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter2) {
      _args.push({
        mint: filter2.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter2.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "base64");
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetTokenAccountsByOwner);
    if ("error" in res) {
      throw new Error("failed to get token accounts owned by account " + ownerAddress.toBase58() + ": " + res.error.message);
    }
    return res.result;
  }
  async getParsedTokenAccountsByOwner(ownerAddress, filter2, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter2) {
      _args.push({
        mint: filter2.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter2.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
    if ("error" in res) {
      throw new Error("failed to get token accounts owned by account " + ownerAddress.toBase58() + ": " + res.error.message);
    }
    return res.result;
  }
  async getLargestAccounts(config2) {
    const arg = __spreadProps(__spreadValues({}, config2), {
      commitment: config2 && config2.commitment || this.commitment
    });
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
    const res = create(unsafeRes, GetLargestAccountsRpcResult);
    if ("error" in res) {
      throw new Error("failed to get largest accounts: " + res.error.message);
    }
    return res.result;
  }
  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
    const res = create(unsafeRes, GetTokenLargestAccountsResult);
    if ("error" in res) {
      throw new Error("failed to get token largest accounts: " + res.error.message);
    }
    return res.result;
  }
  async getAccountInfoAndContext(publicKey2, commitment) {
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "base64");
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in res) {
      throw new Error("failed to get info about account " + publicKey2.toBase58() + ": " + res.error.message);
    }
    return res.result;
  }
  async getParsedAccountInfo(publicKey2, commitment) {
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in res) {
      throw new Error("failed to get info about account " + publicKey2.toBase58() + ": " + res.error.message);
    }
    return res.result;
  }
  async getAccountInfo(publicKey2, commitment) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey2, commitment);
      return res.value;
    } catch (e5) {
      throw new Error("failed to get info about account " + publicKey2.toBase58() + ": " + e5);
    }
  }
  async getMultipleAccountsInfo(publicKeys, configOrCommitment) {
    const keys = publicKeys.map((key2) => key2.toBase58());
    let commitment;
    let encoding5 = "base64";
    if (configOrCommitment) {
      if (typeof configOrCommitment === "string") {
        commitment = configOrCommitment;
        encoding5 = "base64";
      } else {
        commitment = configOrCommitment.commitment;
        encoding5 = configOrCommitment.encoding || "base64";
      }
    }
    const args = this._buildArgs([keys], commitment, encoding5);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in res) {
      throw new Error("failed to get info for accounts " + keys + ": " + res.error.message);
    }
    return res.result.value;
  }
  async getStakeActivation(publicKey2, commitment, epoch) {
    const args = this._buildArgs([publicKey2.toBase58()], commitment, void 0, epoch !== void 0 ? {
      epoch
    } : void 0);
    const unsafeRes = await this._rpcRequest("getStakeActivation", args);
    const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
    if ("error" in res) {
      throw new Error(`failed to get Stake Activation ${publicKey2.toBase58()}: ${res.error.message}`);
    }
    return res.result;
  }
  async getProgramAccounts(programId, configOrCommitment) {
    const extra = {};
    let commitment;
    let encoding5;
    if (configOrCommitment) {
      if (typeof configOrCommitment === "string") {
        commitment = configOrCommitment;
      } else {
        commitment = configOrCommitment.commitment;
        encoding5 = configOrCommitment.encoding;
        if (configOrCommitment.dataSlice) {
          extra.dataSlice = configOrCommitment.dataSlice;
        }
        if (configOrCommitment.filters) {
          extra.filters = configOrCommitment.filters;
        }
      }
    }
    const args = this._buildArgs([programId.toBase58()], commitment, encoding5 || "base64", extra);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const res = create(unsafeRes, jsonRpcResult(array(KeyedAccountInfoResult)));
    if ("error" in res) {
      throw new Error("failed to get accounts owned by program " + programId.toBase58() + ": " + res.error.message);
    }
    return res.result;
  }
  async getParsedProgramAccounts(programId, configOrCommitment) {
    const extra = {};
    let commitment;
    if (configOrCommitment) {
      if (typeof configOrCommitment === "string") {
        commitment = configOrCommitment;
      } else {
        commitment = configOrCommitment.commitment;
        if (configOrCommitment.filters) {
          extra.filters = configOrCommitment.filters;
        }
      }
    }
    const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", extra);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in res) {
      throw new Error("failed to get accounts owned by program " + programId.toBase58() + ": " + res.error.message);
    }
    return res.result;
  }
  async confirmTransaction(signature2, commitment) {
    let decodedSignature;
    try {
      decodedSignature = import_bs58.default.decode(signature2);
    } catch (err) {
      throw new Error("signature must be base58 encoded: " + signature2);
    }
    assert2(decodedSignature.length === 64, "signature has invalid length");
    const start = Date.now();
    const subscriptionCommitment = commitment || this.commitment;
    let subscriptionId;
    let response = null;
    const confirmPromise = new Promise((resolve, reject) => {
      try {
        subscriptionId = this.onSignature(signature2, (result, context) => {
          subscriptionId = void 0;
          response = {
            context,
            value: result
          };
          resolve(null);
        }, subscriptionCommitment);
      } catch (err) {
        reject(err);
      }
    });
    let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
    switch (subscriptionCommitment) {
      case "processed":
      case "recent":
      case "single":
      case "confirmed":
      case "singleGossip": {
        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
        break;
      }
    }
    try {
      await promiseTimeout(confirmPromise, timeoutMs);
    } finally {
      if (subscriptionId) {
        this.removeSignatureListener(subscriptionId);
      }
    }
    if (response === null) {
      const duration = (Date.now() - start) / 1e3;
      throw new Error(`Transaction was not confirmed in ${duration.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
    }
    return response;
  }
  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest("getClusterNodes", []);
    const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in res) {
      throw new Error("failed to get cluster nodes: " + res.error.message);
    }
    return res.result;
  }
  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
    const res = create(unsafeRes, GetVoteAccounts);
    if ("error" in res) {
      throw new Error("failed to get vote accounts: " + res.error.message);
    }
    return res.result;
  }
  async getSlot(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getSlot", args);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new Error("failed to get slot: " + res.error.message);
    }
    return res.result;
  }
  async getSlotLeader(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getSlotLeader", args);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new Error("failed to get slot leader: " + res.error.message);
    }
    return res.result;
  }
  async getSlotLeaders(startSlot, limit) {
    const args = [startSlot, limit];
    const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
    const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in res) {
      throw new Error("failed to get slot leaders: " + res.error.message);
    }
    return res.result;
  }
  async getSignatureStatus(signature2, config2) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature2], config2);
    assert2(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }
  async getSignatureStatuses(signatures, config2) {
    const params = [signatures];
    if (config2) {
      params.push(config2);
    }
    const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
    const res = create(unsafeRes, GetSignatureStatusesRpcResult);
    if ("error" in res) {
      throw new Error("failed to get signature status: " + res.error.message);
    }
    return res.result;
  }
  async getTransactionCount(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getTransactionCount", args);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new Error("failed to get transaction count: " + res.error.message);
    }
    return res.result;
  }
  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }
  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
    const res = create(unsafeRes, GetInflationGovernorRpcResult);
    if ("error" in res) {
      throw new Error("failed to get inflation: " + res.error.message);
    }
    return res.result;
  }
  async getInflationReward(addresses, epoch, commitment) {
    const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
      epoch
    });
    const unsafeRes = await this._rpcRequest("getInflationReward", args);
    const res = create(unsafeRes, GetInflationRewardResult);
    if ("error" in res) {
      throw new Error("failed to get inflation reward: " + res.error.message);
    }
    return res.result;
  }
  async getEpochInfo(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getEpochInfo", args);
    const res = create(unsafeRes, GetEpochInfoRpcResult);
    if ("error" in res) {
      throw new Error("failed to get epoch info: " + res.error.message);
    }
    return res.result;
  }
  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
    const res = create(unsafeRes, GetEpochScheduleRpcResult);
    if ("error" in res) {
      throw new Error("failed to get epoch schedule: " + res.error.message);
    }
    const epochSchedule = res.result;
    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }
  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
    const res = create(unsafeRes, GetLeaderScheduleRpcResult);
    if ("error" in res) {
      throw new Error("failed to get leader schedule: " + res.error.message);
    }
    return res.result;
  }
  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);
    const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
    const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
    if ("error" in res) {
      console.warn("Unable to fetch minimum balance for rent exemption");
      return 0;
    }
    return res.result;
  }
  async getRecentBlockhashAndContext(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getRecentBlockhash", args);
    const res = create(unsafeRes, GetRecentBlockhashAndContextRpcResult);
    if ("error" in res) {
      throw new Error("failed to get recent blockhash: " + res.error.message);
    }
    return res.result;
  }
  async getRecentPerformanceSamples(limit) {
    const args = this._buildArgs(limit ? [limit] : []);
    const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", args);
    const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
    if ("error" in res) {
      throw new Error("failed to get recent performance samples: " + res.error.message);
    }
    return res.result;
  }
  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);
    const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
    const res = create(unsafeRes, GetFeeCalculatorRpcResult);
    if ("error" in res) {
      throw new Error("failed to get fee calculator: " + res.error.message);
    }
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }
  async getFeeForMessage(message, commitment) {
    const wireMessage = message.serialize().toString("base64");
    const args = this._buildArgs([wireMessage], commitment);
    const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));
    if ("error" in res) {
      throw new Error("failed to get slot: " + res.error.message);
    }
    if (res.result === null) {
      throw new Error("invalid blockhash");
    }
    return res.result;
  }
  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e5) {
      throw new Error("failed to get recent blockhash: " + e5);
    }
  }
  async getLatestBlockhash(commitment) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitment);
      return res.value;
    } catch (e5) {
      throw new Error("failed to get recent blockhash: " + e5);
    }
  }
  async getLatestBlockhashAndContext(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
    const res = create(unsafeRes, GetLatestBlockhashRpcResult);
    if ("error" in res) {
      throw new Error("failed to get latest blockhash: " + res.error.message);
    }
    return res.result;
  }
  async getVersion() {
    const unsafeRes = await this._rpcRequest("getVersion", []);
    const res = create(unsafeRes, jsonRpcResult(VersionResult));
    if ("error" in res) {
      throw new Error("failed to get version: " + res.error.message);
    }
    return res.result;
  }
  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest("getGenesisHash", []);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new Error("failed to get genesis hash: " + res.error.message);
    }
    return res.result;
  }
  async getBlock(slot, opts) {
    const args = this._buildArgsAtLeastConfirmed([slot], opts && opts.commitment);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockRpcResult);
    if ("error" in res) {
      throw new Error("failed to get confirmed block: " + res.error.message);
    }
    const result = res.result;
    if (!result)
      return result;
    return __spreadProps(__spreadValues({}, result), {
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message(transaction.message);
        return {
          meta,
          transaction: __spreadProps(__spreadValues({}, transaction), {
            message
          })
        };
      })
    });
  }
  async getTransaction(signature2, opts) {
    const args = this._buildArgsAtLeastConfirmed([signature2], opts && opts.commitment);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new Error("failed to get transaction: " + res.error.message);
    }
    const result = res.result;
    if (!result)
      return result;
    return __spreadProps(__spreadValues({}, result), {
      transaction: __spreadProps(__spreadValues({}, result.transaction), {
        message: new Message(result.transaction.message)
      })
    });
  }
  async getParsedTransaction(signature2, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new Error("failed to get transaction: " + res.error.message);
    }
    return res.result;
  }
  async getParsedTransactions(signatures, commitment) {
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new Error("failed to get transactions: " + res2.error.message);
      }
      return res2.result;
    });
    return res;
  }
  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
    const res = create(unsafeRes, GetConfirmedBlockRpcResult);
    if ("error" in res) {
      throw new Error("failed to get confirmed block: " + res.error.message);
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    const block = __spreadProps(__spreadValues({}, result), {
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message(transaction.message);
        return {
          meta,
          transaction: __spreadProps(__spreadValues({}, transaction), {
            message
          })
        };
      })
    });
    return __spreadProps(__spreadValues({}, block), {
      transactions: block.transactions.map(({
        transaction,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction.populate(transaction.message, transaction.signatures)
        };
      })
    });
  }
  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
    const unsafeRes = await this._rpcRequest("getBlocks", args);
    const res = create(unsafeRes, jsonRpcResult(array(number())));
    if ("error" in res) {
      throw new Error("failed to get blocks: " + res.error.message);
    }
    return res.result;
  }
  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new Error("failed to get block: " + res.error.message);
    }
    const result = res.result;
    if (!result) {
      throw new Error("Block " + slot + " not found");
    }
    return result;
  }
  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new Error("failed to get confirmed block: " + res.error.message);
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    return result;
  }
  async getConfirmedTransaction(signature2, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
    const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new Error("failed to get transaction: " + res.error.message);
    }
    const result = res.result;
    if (!result)
      return result;
    const message = new Message(result.transaction.message);
    const signatures = result.transaction.signatures;
    return __spreadProps(__spreadValues({}, result), {
      transaction: Transaction.populate(message, signatures)
    });
  }
  async getParsedConfirmedTransaction(signature2, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new Error("failed to get confirmed transaction: " + res.error.message);
    }
    return res.result;
  }
  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
      return {
        methodName: "getConfirmedTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new Error("failed to get confirmed transactions: " + res2.error.message);
      }
      return res2.result;
    });
    return res;
  }
  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();
    while (!("until" in options)) {
      startSlot--;
      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    let highestConfirmedRoot = await this.getSlot("finalized");
    while (!("before" in options)) {
      endSlot++;
      if (endSlot > highestConfirmedRoot) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);
        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
    return confirmedSignatureInfo.map((info) => info.signature);
  }
  async getConfirmedSignaturesForAddress2(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
    const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in res) {
      throw new Error("failed to get confirmed signatures for address: " + res.error.message);
    }
    return res.result;
  }
  async getSignaturesForAddress(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
    const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
    if ("error" in res) {
      throw new Error("failed to get signatures for address: " + res.error.message);
    }
    return res.result;
  }
  async getNonceAndContext(nonceAccount, commitment) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitment);
    let value = null;
    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }
    return {
      context,
      value
    };
  }
  async getNonce(nonceAccount, commitment) {
    return await this.getNonceAndContext(nonceAccount, commitment).then((x5) => x5.value).catch((e5) => {
      throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e5);
    });
  }
  async requestAirdrop(to, lamports) {
    const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
    const res = create(unsafeRes, RequestAirdropRpcResult);
    if ("error" in res) {
      throw new Error("airdrop to " + to.toBase58() + " failed: " + res.error.message);
    }
    return res.result;
  }
  async _recentBlockhash(disableCache) {
    if (!disableCache) {
      while (this._pollingBlockhash) {
        await sleep(100);
      }
      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.recentBlockhash !== null && !expired) {
        return this._blockhashInfo.recentBlockhash;
      }
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = true;
    try {
      const startTime = Date.now();
      for (let i5 = 0; i5 < 50; i5++) {
        const {
          blockhash
        } = await this.getRecentBlockhash("finalized");
        if (this._blockhashInfo.recentBlockhash != blockhash) {
          this._blockhashInfo = {
            recentBlockhash: blockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return blockhash;
        }
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  async simulateTransaction(transactionOrMessage, signers, includeAccounts) {
    let transaction;
    if (transactionOrMessage instanceof Transaction) {
      transaction = transactionOrMessage;
    } else {
      transaction = Transaction.populate(transactionOrMessage);
    }
    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        transaction.recentBlockhash = await this._recentBlockhash(disableCache);
        if (!signers)
          break;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature2 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
          this._blockhashInfo.simulatedSignatures.push(signature2);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config2 = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key2) => key2.toBase58());
      config2["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config2.sigVerify = true;
    }
    const args = [encodedTransaction, config2];
    const unsafeRes = await this._rpcRequest("simulateTransaction", args);
    const res = create(unsafeRes, SimulatedTransactionResponseStruct);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
    }
    return res.result;
  }
  async sendTransaction(transaction, signers, options) {
    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        transaction.recentBlockhash = await this._recentBlockhash(disableCache);
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature2 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
          this._blockhashInfo.transactionSignatures.push(signature2);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString("base64");
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  async sendEncodedTransaction(encodedTransaction, options) {
    const config2 = {
      encoding: "base64"
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = options && options.preflightCommitment || this.commitment;
    if (options && options.maxRetries) {
      config2.maxRetries = options.maxRetries;
    }
    if (skipPreflight) {
      config2.skipPreflight = skipPreflight;
    }
    if (preflightCommitment) {
      config2.preflightCommitment = preflightCommitment;
    }
    const args = [encodedTransaction, config2];
    const unsafeRes = await this._rpcRequest("sendTransaction", args);
    const res = create(unsafeRes, SendTransactionRpcResult);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError("failed to send transaction: " + res.error.message, logs);
    }
    return res.result;
  }
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      this._rpcWebSocket.notify("ping").catch(() => {
      });
    }, 5e3);
    this._updateSubscriptions();
  }
  _wsOnError(err) {
    console.error("ws error:", err.message);
  }
  _wsOnClose(code) {
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._resetSubscriptions();
  }
  async _subscribe(sub, rpcMethod, rpcArgs) {
    if (sub.subscriptionId == null) {
      sub.subscriptionId = "subscribing";
      try {
        const id2 = await this._rpcWebSocket.call(rpcMethod, rpcArgs);
        if (typeof id2 === "number" && sub.subscriptionId === "subscribing") {
          sub.subscriptionId = id2;
        }
      } catch (err) {
        if (sub.subscriptionId === "subscribing") {
          sub.subscriptionId = null;
        }
        if (err instanceof Error) {
          console.error(`${rpcMethod} error for argument`, rpcArgs, err.message);
        }
      }
    }
  }
  async _unsubscribe(sub, rpcMethod) {
    const subscriptionId = sub.subscriptionId;
    if (subscriptionId != null && typeof subscriptionId != "string") {
      const unsubscribeId = subscriptionId;
      try {
        await this._rpcWebSocket.call(rpcMethod, [unsubscribeId]);
      } catch (err) {
        if (err instanceof Error) {
          console.error(`${rpcMethod} error:`, err.message);
        }
      }
    }
  }
  _resetSubscriptions() {
    Object.values(this._accountChangeSubscriptions).forEach((s6) => s6.subscriptionId = null);
    Object.values(this._programAccountChangeSubscriptions).forEach((s6) => s6.subscriptionId = null);
    Object.values(this._rootSubscriptions).forEach((s6) => s6.subscriptionId = null);
    Object.values(this._signatureSubscriptions).forEach((s6) => s6.subscriptionId = null);
    Object.values(this._slotSubscriptions).forEach((s6) => s6.subscriptionId = null);
    Object.values(this._slotUpdateSubscriptions).forEach((s6) => s6.subscriptionId = null);
  }
  _updateSubscriptions() {
    const accountKeys = Object.keys(this._accountChangeSubscriptions).map(Number);
    const programKeys = Object.keys(this._programAccountChangeSubscriptions).map(Number);
    const slotKeys = Object.keys(this._slotSubscriptions).map(Number);
    const slotUpdateKeys = Object.keys(this._slotUpdateSubscriptions).map(Number);
    const signatureKeys = Object.keys(this._signatureSubscriptions).map(Number);
    const rootKeys = Object.keys(this._rootSubscriptions).map(Number);
    const logsKeys = Object.keys(this._logsSubscriptions).map(Number);
    if (accountKeys.length === 0 && programKeys.length === 0 && slotKeys.length === 0 && slotUpdateKeys.length === 0 && signatureKeys.length === 0 && rootKeys.length === 0 && logsKeys.length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (err) {
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }
    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    for (let id2 of accountKeys) {
      const sub = this._accountChangeSubscriptions[id2];
      this._subscribe(sub, "accountSubscribe", this._buildArgs([sub.publicKey], sub.commitment, "base64"));
    }
    for (let id2 of programKeys) {
      const sub = this._programAccountChangeSubscriptions[id2];
      this._subscribe(sub, "programSubscribe", this._buildArgs([sub.programId], sub.commitment, "base64", {
        filters: sub.filters
      }));
    }
    for (let id2 of slotKeys) {
      const sub = this._slotSubscriptions[id2];
      this._subscribe(sub, "slotSubscribe", []);
    }
    for (let id2 of slotUpdateKeys) {
      const sub = this._slotUpdateSubscriptions[id2];
      this._subscribe(sub, "slotsUpdatesSubscribe", []);
    }
    for (let id2 of signatureKeys) {
      const sub = this._signatureSubscriptions[id2];
      const args = [sub.signature];
      if (sub.options)
        args.push(sub.options);
      this._subscribe(sub, "signatureSubscribe", args);
    }
    for (let id2 of rootKeys) {
      const sub = this._rootSubscriptions[id2];
      this._subscribe(sub, "rootSubscribe", []);
    }
    for (let id2 of logsKeys) {
      const sub = this._logsSubscriptions[id2];
      let filter2;
      if (typeof sub.filter === "object") {
        filter2 = {
          mentions: [sub.filter.toString()]
        };
      } else {
        filter2 = sub.filter;
      }
      this._subscribe(sub, "logsSubscribe", this._buildArgs([filter2], sub.commitment));
    }
  }
  _wsOnAccountNotification(notification) {
    const res = create(notification, AccountNotificationResult);
    for (const sub of Object.values(this._accountChangeSubscriptions)) {
      if (sub.subscriptionId === res.subscription) {
        sub.callback(res.result.value, res.result.context);
        return;
      }
    }
  }
  onAccountChange(publicKey2, callback, commitment) {
    const id2 = ++this._accountChangeSubscriptionCounter;
    this._accountChangeSubscriptions[id2] = {
      publicKey: publicKey2.toBase58(),
      callback,
      commitment,
      subscriptionId: null
    };
    this._updateSubscriptions();
    return id2;
  }
  async removeAccountChangeListener(id2) {
    if (this._accountChangeSubscriptions[id2]) {
      const subInfo = this._accountChangeSubscriptions[id2];
      delete this._accountChangeSubscriptions[id2];
      await this._unsubscribe(subInfo, "accountUnsubscribe");
      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown account change id: ${id2}`);
    }
  }
  _wsOnProgramAccountNotification(notification) {
    const res = create(notification, ProgramAccountNotificationResult);
    for (const sub of Object.values(this._programAccountChangeSubscriptions)) {
      if (sub.subscriptionId === res.subscription) {
        const {
          value,
          context
        } = res.result;
        sub.callback({
          accountId: value.pubkey,
          accountInfo: value.account
        }, context);
        return;
      }
    }
  }
  onProgramAccountChange(programId, callback, commitment, filters) {
    const id2 = ++this._programAccountChangeSubscriptionCounter;
    this._programAccountChangeSubscriptions[id2] = {
      programId: programId.toBase58(),
      callback,
      commitment,
      subscriptionId: null,
      filters
    };
    this._updateSubscriptions();
    return id2;
  }
  async removeProgramAccountChangeListener(id2) {
    if (this._programAccountChangeSubscriptions[id2]) {
      const subInfo = this._programAccountChangeSubscriptions[id2];
      delete this._programAccountChangeSubscriptions[id2];
      await this._unsubscribe(subInfo, "programUnsubscribe");
      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown program account change id: ${id2}`);
    }
  }
  onLogs(filter2, callback, commitment) {
    const id2 = ++this._logsSubscriptionCounter;
    this._logsSubscriptions[id2] = {
      filter: filter2,
      callback,
      commitment,
      subscriptionId: null
    };
    this._updateSubscriptions();
    return id2;
  }
  async removeOnLogsListener(id2) {
    if (!this._logsSubscriptions[id2]) {
      throw new Error(`Unknown logs id: ${id2}`);
    }
    const subInfo = this._logsSubscriptions[id2];
    delete this._logsSubscriptions[id2];
    await this._unsubscribe(subInfo, "logsUnsubscribe");
    this._updateSubscriptions();
  }
  _wsOnLogsNotification(notification) {
    const res = create(notification, LogsNotificationResult);
    const keys = Object.keys(this._logsSubscriptions).map(Number);
    for (let id2 of keys) {
      const sub = this._logsSubscriptions[id2];
      if (sub.subscriptionId === res.subscription) {
        sub.callback(res.result.value, res.result.context);
        return;
      }
    }
  }
  _wsOnSlotNotification(notification) {
    const res = create(notification, SlotNotificationResult);
    for (const sub of Object.values(this._slotSubscriptions)) {
      if (sub.subscriptionId === res.subscription) {
        sub.callback(res.result);
        return;
      }
    }
  }
  onSlotChange(callback) {
    const id2 = ++this._slotSubscriptionCounter;
    this._slotSubscriptions[id2] = {
      callback,
      subscriptionId: null
    };
    this._updateSubscriptions();
    return id2;
  }
  async removeSlotChangeListener(id2) {
    if (this._slotSubscriptions[id2]) {
      const subInfo = this._slotSubscriptions[id2];
      delete this._slotSubscriptions[id2];
      await this._unsubscribe(subInfo, "slotUnsubscribe");
      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown slot change id: ${id2}`);
    }
  }
  _wsOnSlotUpdatesNotification(notification) {
    const res = create(notification, SlotUpdateNotificationResult);
    for (const sub of Object.values(this._slotUpdateSubscriptions)) {
      if (sub.subscriptionId === res.subscription) {
        sub.callback(res.result);
        return;
      }
    }
  }
  onSlotUpdate(callback) {
    const id2 = ++this._slotUpdateSubscriptionCounter;
    this._slotUpdateSubscriptions[id2] = {
      callback,
      subscriptionId: null
    };
    this._updateSubscriptions();
    return id2;
  }
  async removeSlotUpdateListener(id2) {
    if (this._slotUpdateSubscriptions[id2]) {
      const subInfo = this._slotUpdateSubscriptions[id2];
      delete this._slotUpdateSubscriptions[id2];
      await this._unsubscribe(subInfo, "slotsUpdatesUnsubscribe");
      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown slot update id: ${id2}`);
    }
  }
  _buildArgs(args, override, encoding5, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding5 || extra) {
      let options = {};
      if (encoding5) {
        options.encoding = encoding5;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args.push(options);
    }
    return args;
  }
  _buildArgsAtLeastConfirmed(args, override, encoding5, extra) {
    const commitment = override || this._commitment;
    if (commitment && !["confirmed", "finalized"].includes(commitment)) {
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    }
    return this._buildArgs(args, override, encoding5, extra);
  }
  _wsOnSignatureNotification(notification) {
    const res = create(notification, SignatureNotificationResult);
    for (const [id2, sub] of Object.entries(this._signatureSubscriptions)) {
      if (sub.subscriptionId === res.subscription) {
        if (res.result.value === "receivedSignature") {
          sub.callback({
            type: "received"
          }, res.result.context);
        } else {
          delete this._signatureSubscriptions[Number(id2)];
          this._updateSubscriptions();
          sub.callback({
            type: "status",
            result: res.result.value
          }, res.result.context);
        }
        return;
      }
    }
  }
  onSignature(signature2, callback, commitment) {
    const id2 = ++this._signatureSubscriptionCounter;
    this._signatureSubscriptions[id2] = {
      signature: signature2,
      callback: (notification, context) => {
        if (notification.type === "status") {
          callback(notification.result, context);
        }
      },
      options: {
        commitment
      },
      subscriptionId: null
    };
    this._updateSubscriptions();
    return id2;
  }
  onSignatureWithOptions(signature2, callback, options) {
    const id2 = ++this._signatureSubscriptionCounter;
    this._signatureSubscriptions[id2] = {
      signature: signature2,
      callback,
      options,
      subscriptionId: null
    };
    this._updateSubscriptions();
    return id2;
  }
  async removeSignatureListener(id2) {
    if (this._signatureSubscriptions[id2]) {
      const subInfo = this._signatureSubscriptions[id2];
      delete this._signatureSubscriptions[id2];
      await this._unsubscribe(subInfo, "signatureUnsubscribe");
      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown signature result id: ${id2}`);
    }
  }
  _wsOnRootNotification(notification) {
    const res = create(notification, RootNotificationResult);
    for (const sub of Object.values(this._rootSubscriptions)) {
      if (sub.subscriptionId === res.subscription) {
        sub.callback(res.result);
        return;
      }
    }
  }
  onRootChange(callback) {
    const id2 = ++this._rootSubscriptionCounter;
    this._rootSubscriptions[id2] = {
      callback,
      subscriptionId: null
    };
    this._updateSubscriptions();
    return id2;
  }
  async removeRootChangeListener(id2) {
    if (this._rootSubscriptions[id2]) {
      const subInfo = this._rootSubscriptions[id2];
      delete this._rootSubscriptions[id2];
      await this._unsubscribe(subInfo, "rootUnsubscribe");
      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown root change id: ${id2}`);
    }
  }
};
var Keypair = class {
  constructor(keypair) {
    this._keypair = void 0;
    if (keypair) {
      this._keypair = keypair;
    } else {
      this._keypair = import_tweetnacl.default.sign.keyPair();
    }
  }
  static generate() {
    return new Keypair(import_tweetnacl.default.sign.keyPair());
  }
  static fromSecretKey(secretKey, options) {
    const keypair = import_tweetnacl.default.sign.keyPair.fromSecretKey(secretKey);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("@solana/web3.js-validation-v1");
      const signature2 = import_tweetnacl.default.sign.detached(signData, keypair.secretKey);
      if (!import_tweetnacl.default.sign.detached.verify(signData, signature2, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new Keypair(keypair);
  }
  static fromSeed(seed) {
    return new Keypair(import_tweetnacl.default.sign.keyPair.fromSeed(seed));
  }
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  get secretKey() {
    return this._keypair.secretKey;
  }
};
var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;
var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
var Ed25519Program = class {
  constructor() {
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature: signature2,
      instructionIndex
    } = params;
    assert2(publicKey2.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey2.length} bytes`);
    assert2(signature2.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature2.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey2.length;
    const messageDataOffset = signatureOffset + signature2.length;
    const numSignatures = 1;
    const instructionData = import_buffer.Buffer.alloc(messageDataOffset + message.length);
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      publicKeyOffset,
      publicKeyInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex
    }, instructionData);
    instructionData.fill(publicKey2, publicKeyOffset);
    instructionData.fill(signature2, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey2 = keypair.publicKey.toBytes();
      const signature2 = import_tweetnacl.default.sign.detached(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature: signature2,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
var STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
var Authorized = class {
  constructor(staker, withdrawer) {
    this.staker = void 0;
    this.withdrawer = void 0;
    this.staker = staker;
    this.withdrawer = withdrawer;
  }
};
var Lockup = class {
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
};
Lockup.default = new Lockup(0, 0, PublicKey.default);
var StakeInstruction = class {
  constructor() {
  }
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32("instruction");
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type2 = ixType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Instruction type incorrect; not a StakeInstruction");
    }
    return type2;
  }
  static decodeInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized: authorized2,
      lockup: lockup2
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorized: new Authorized(new PublicKey(authorized2.staker), new PublicKey(authorized2.withdrawer)),
      lockup: new Lockup(lockup2.unixTimestamp, lockup2.epoch, new PublicKey(lockup2.custodian))
    };
  }
  static decodeDelegate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 6);
    decodeData(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      votePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[5].pubkey
    };
  }
  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      stakeAuthorizationType
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    const o5 = {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };
    if (instruction.keys.length > 3) {
      o5.custodianPubkey = instruction.keys[3].pubkey;
    }
    return o5;
  }
  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      newAuthorized,
      stakeAuthorizationType,
      authoritySeed,
      authorityOwner
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    const o5 = {
      stakePubkey: instruction.keys[0].pubkey,
      authorityBase: instruction.keys[1].pubkey,
      authoritySeed,
      authorityOwner: new PublicKey(authorityOwner),
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };
    if (instruction.keys.length > 3) {
      o5.custodianPubkey = instruction.keys[3].pubkey;
    }
    return o5;
  }
  static decodeSplit(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      splitStakePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      lamports
    };
  }
  static decodeMerge(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      sourceStakePubKey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey
    };
  }
  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    const o5 = {
      stakePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
    if (instruction.keys.length > 5) {
      o5.custodianPubkey = instruction.keys[5].pubkey;
    }
    return o5;
  }
  static decodeDeactivate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  static checkProgramId(programId) {
    if (!programId.equals(StakeProgram.programId)) {
      throw new Error("invalid instruction; programId is not StakeProgram");
    }
  }
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
};
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var StakeProgram = class {
  constructor() {
  }
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: maybeLockup
    } = params;
    const lockup2 = maybeLockup || Lockup.default;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type2, {
      authorized: {
        staker: toBuffer(authorized2.staker.toBuffer()),
        withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup2.unixTimestamp,
        epoch: lockup2.epoch,
        custodian: toBuffer(lockup2.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccountWithSeed(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static split(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: authorizedPubkey,
      newAccountPubkey: splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    }));
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type2, {
      lamports
    });
    return transaction.add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
};
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
var {
  publicKeyCreate,
  ecdsaSign
} = import_secp256k1.default;
var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
var Secp256k1Program = class {
  constructor() {
  }
  static publicKeyToEthAddress(publicKey2) {
    assert2(publicKey2.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey2.length} bytes`);
    try {
      return import_buffer.Buffer.from(import_js_sha3.default.keccak_256.update(toBuffer(publicKey2)).digest()).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature: signature2,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey2),
      message,
      signature: signature2,
      recoveryId,
      instructionIndex
    });
  }
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature: signature2,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = import_buffer.Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = import_buffer.Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert2(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature2.length + 1;
    const numSignatures = 1;
    const instructionData = import_buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature2),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey2 = publicKeyCreate(privateKey, false).slice(1);
      const messageHash = import_buffer.Buffer.from(import_js_sha3.default.keccak_256.update(toBuffer(message)).digest());
      const {
        signature: signature2,
        recid: recoveryId
      } = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature: signature2,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
var InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});
var ValidatorInfo = class {
  constructor(key2, info) {
    this.key = void 0;
    this.info = void 0;
    this.key = key2;
    this.info = info;
  }
  static fromConfigData(buffer2) {
    const PUBKEY_LENGTH2 = 32;
    let byteArray = [...buffer2];
    const configKeyCount = decodeLength(byteArray);
    if (configKeyCount !== 2)
      return null;
    const configKeys = [];
    for (let i5 = 0; i5 < 2; i5++) {
      const publicKey2 = new PublicKey(byteArray.slice(0, PUBKEY_LENGTH2));
      byteArray = byteArray.slice(PUBKEY_LENGTH2);
      const isSigner = byteArray.slice(0, 1)[0] === 1;
      byteArray = byteArray.slice(1);
      configKeys.push({
        publicKey: publicKey2,
        isSigner
      });
    }
    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
      if (configKeys[1].isSigner) {
        const rawInfo = rustString().decode(import_buffer.Buffer.from(byteArray));
        const info = JSON.parse(rawInfo);
        assert(info, InfoString);
        return new ValidatorInfo(configKeys[1].publicKey, info);
      }
    }
    return null;
  }
};
var VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
var VoteAccountLayout = BufferLayout.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  BufferLayout.u8("commission"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
  BufferLayout.u8("rootSlotValid"),
  BufferLayout.nu64("rootSlot"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
  BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
  BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
]);
var VoteAccount = class {
  constructor(args) {
    this.nodePubkey = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.rootSlot = void 0;
    this.votes = void 0;
    this.authorizedVoters = void 0;
    this.priorVoters = void 0;
    this.epochCredits = void 0;
    this.lastTimestamp = void 0;
    this.nodePubkey = args.nodePubkey;
    this.authorizedWithdrawer = args.authorizedWithdrawer;
    this.commission = args.commission;
    this.rootSlot = args.rootSlot;
    this.votes = args.votes;
    this.authorizedVoters = args.authorizedVoters;
    this.priorVoters = args.priorVoters;
    this.epochCredits = args.epochCredits;
    this.lastTimestamp = args.lastTimestamp;
  }
  static fromAccountData(buffer2) {
    const versionOffset = 4;
    const va = VoteAccountLayout.decode(toBuffer(buffer2), versionOffset);
    let rootSlot = va.rootSlot;
    if (!va.rootSlotValid) {
      rootSlot = null;
    }
    return new VoteAccount({
      nodePubkey: new PublicKey(va.nodePubkey),
      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
      commission: va.commission,
      votes: va.votes,
      rootSlot,
      authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
      priorVoters: getPriorVoters(va.priorVoters),
      epochCredits: va.epochCredits,
      lastTimestamp: va.lastTimestamp
    });
  }
};
function parseAuthorizedVoter({
  epoch,
  authorizedVoter
}) {
  return {
    epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}
function parsePriorVoters({
  authorizedPubkey,
  epochOfLastAuthorizedSwitch,
  targetEpoch
}) {
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch,
    targetEpoch
  };
}
function getPriorVoters({
  buf,
  idx,
  isEmpty: isEmpty2
}) {
  if (isEmpty2) {
    return [];
  }
  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx)];
}
var VoteInit = class {
  constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
    this.nodePubkey = void 0;
    this.authorizedVoter = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.nodePubkey = nodePubkey;
    this.authorizedVoter = authorizedVoter;
    this.authorizedWithdrawer = authorizedWithdrawer;
    this.commission = commission;
  }
};
var VoteInstruction = class {
  constructor() {
  }
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32("instruction");
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type2 = ixType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Instruction type incorrect; not a VoteInstruction");
    }
    return type2;
  }
  static decodeInitializeAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 4);
    const {
      voteInit: voteInit2
    } = decodeData(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      nodePubkey: instruction.keys[3].pubkey,
      voteInit: new VoteInit(new PublicKey(voteInit2.nodePubkey), new PublicKey(voteInit2.authorizedVoter), new PublicKey(voteInit2.authorizedWithdrawer), voteInit2.commission)
    };
  }
  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
      lamports,
      toPubkey: instruction.keys[1].pubkey
    };
  }
  static checkProgramId(programId) {
    if (!programId.equals(VoteProgram.programId)) {
      throw new Error("invalid instruction; programId is not VoteProgram");
    }
  }
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
};
var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  }
});
var VoteProgram = class {
  constructor() {
  }
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit2
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type2, {
      voteInit: {
        nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
        commission: voteInit2.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
};
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3731;
async function sendAndConfirmRawTransaction(connection, rawTransaction, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment
  };
  const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
  if (status.err) {
    throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
var endpoint = {
  http: {
    devnet: "http://api.devnet.solana.com",
    testnet: "http://api.testnet.solana.com",
    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
  },
  https: {
    devnet: "https://api.devnet.solana.com",
    testnet: "https://api.testnet.solana.com",
    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
  }
};
function clusterApiUrl(cluster, tls) {
  const key2 = tls === false ? "http" : "https";
  if (!cluster) {
    return endpoint[key2]["devnet"];
  }
  const url = endpoint[key2][cluster];
  if (!url) {
    throw new Error(`Unknown ${key2} cluster: ${cluster}`);
  }
  return url;
}
var LAMPORTS_PER_SOL = 1e9;

// node_modules/@project-serum/sol-wallet-adapter/dist/esm/index.js
var import_eventemitter3 = __toModule(require_eventemitter3());
var import_bs582 = __toModule(require_bs58());
var __awaiter = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Wallet = class extends import_eventemitter3.default {
  constructor(provider, _network) {
    super();
    this._network = _network;
    this._publicKey = null;
    this._popup = null;
    this._handlerAdded = false;
    this._nextRequestId = 1;
    this._autoApprove = false;
    this._responsePromises = new Map();
    this.handleMessage = (e5) => {
      var _a2;
      if (this._injectedProvider && e5.source === window || e5.origin === ((_a2 = this._providerUrl) === null || _a2 === void 0 ? void 0 : _a2.origin) && e5.source === this._popup) {
        if (e5.data.method === "connected") {
          const newPublicKey = new PublicKey(e5.data.params.publicKey);
          if (!this._publicKey || !this._publicKey.equals(newPublicKey)) {
            if (this._publicKey && !this._publicKey.equals(newPublicKey)) {
              this.handleDisconnect();
            }
            this._publicKey = newPublicKey;
            this._autoApprove = !!e5.data.params.autoApprove;
            this.emit("connect", this._publicKey);
          }
        } else if (e5.data.method === "disconnected") {
          this.handleDisconnect();
        } else if (e5.data.result || e5.data.error) {
          const promises = this._responsePromises.get(e5.data.id);
          if (promises) {
            const [resolve, reject] = promises;
            if (e5.data.result) {
              resolve(e5.data.result);
            } else {
              reject(new Error(e5.data.error));
            }
          }
        }
      }
    };
    this._beforeUnload = () => {
      void this.disconnect();
    };
    if (isInjectedProvider(provider)) {
      this._injectedProvider = provider;
    } else if (isString(provider)) {
      this._providerUrl = new URL(provider);
      this._providerUrl.hash = new URLSearchParams({
        origin: window.location.origin,
        network: this._network
      }).toString();
    } else {
      throw new Error("provider parameter must be an injected provider or a URL string.");
    }
  }
  handleConnect() {
    var _a2;
    if (!this._handlerAdded) {
      this._handlerAdded = true;
      window.addEventListener("message", this.handleMessage);
      window.addEventListener("beforeunload", this._beforeUnload);
    }
    if (this._injectedProvider) {
      return new Promise((resolve) => {
        void this.sendRequest("connect", {});
        resolve();
      });
    } else {
      window.name = "parent";
      this._popup = window.open((_a2 = this._providerUrl) === null || _a2 === void 0 ? void 0 : _a2.toString(), "_blank", "location,resizable,width=460,height=675");
      return new Promise((resolve) => {
        this.once("connect", resolve);
      });
    }
  }
  handleDisconnect() {
    if (this._handlerAdded) {
      this._handlerAdded = false;
      window.removeEventListener("message", this.handleMessage);
      window.removeEventListener("beforeunload", this._beforeUnload);
    }
    if (this._publicKey) {
      this._publicKey = null;
      this.emit("disconnect");
    }
    this._responsePromises.forEach(([, reject], id2) => {
      this._responsePromises.delete(id2);
      reject(new Error("Wallet disconnected"));
    });
  }
  sendRequest(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      if (method !== "connect" && !this.connected) {
        throw new Error("Wallet not connected");
      }
      const requestId = this._nextRequestId;
      ++this._nextRequestId;
      return new Promise((resolve, reject) => {
        var _a2, _b, _c, _d;
        this._responsePromises.set(requestId, [resolve, reject]);
        if (this._injectedProvider) {
          this._injectedProvider.postMessage({
            jsonrpc: "2.0",
            id: requestId,
            method,
            params: Object.assign({ network: this._network }, params)
          });
        } else {
          (_a2 = this._popup) === null || _a2 === void 0 ? void 0 : _a2.postMessage({
            jsonrpc: "2.0",
            id: requestId,
            method,
            params
          }, (_c = (_b = this._providerUrl) === null || _b === void 0 ? void 0 : _b.origin) !== null && _c !== void 0 ? _c : "");
          if (!this.autoApprove) {
            (_d = this._popup) === null || _d === void 0 ? void 0 : _d.focus();
          }
        }
      });
    });
  }
  get publicKey() {
    return this._publicKey;
  }
  get connected() {
    return this._publicKey !== null;
  }
  get autoApprove() {
    return this._autoApprove;
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._popup) {
        this._popup.close();
      }
      yield this.handleConnect();
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._injectedProvider) {
        yield this.sendRequest("disconnect", {});
      }
      if (this._popup) {
        this._popup.close();
      }
      this.handleDisconnect();
    });
  }
  sign(data, display) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!(data instanceof Uint8Array)) {
        throw new Error("Data must be an instance of Uint8Array");
      }
      const response = yield this.sendRequest("sign", {
        data,
        display
      });
      const signature2 = import_bs582.default.decode(response.signature);
      const publicKey2 = new PublicKey(response.publicKey);
      return {
        signature: signature2,
        publicKey: publicKey2
      };
    });
  }
  signTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.sendRequest("signTransaction", {
        message: import_bs582.default.encode(transaction.serializeMessage())
      });
      const signature2 = import_bs582.default.decode(response.signature);
      const publicKey2 = new PublicKey(response.publicKey);
      transaction.addSignature(publicKey2, signature2);
      return transaction;
    });
  }
  signAllTransactions(transactions) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.sendRequest("signAllTransactions", {
        messages: transactions.map((tx) => import_bs582.default.encode(tx.serializeMessage()))
      });
      const signatures = response.signatures.map((s6) => import_bs582.default.decode(s6));
      const publicKey2 = new PublicKey(response.publicKey);
      transactions = transactions.map((tx, idx) => {
        tx.addSignature(publicKey2, signatures[idx]);
        return tx;
      });
      return transactions;
    });
  }
  diffieHellman(publicKey2) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!(publicKey2 instanceof Uint8Array)) {
        throw new Error("Data must be an instance of Uint8Array");
      }
      const response = yield this.sendRequest("diffieHellman", {
        publicKey: publicKey2
      });
      return response;
    });
  }
};
function isString(a5) {
  return typeof a5 === "string";
}
function isInjectedProvider(a5) {
  return isObject2(a5) && "postMessage" in a5 && typeof a5.postMessage === "function";
}
function isObject2(a5) {
  return typeof a5 === "object" && a5 !== null;
}

// node_modules/wallet-ethers/lib/wallet/sollet/index.js
var Sollet = class {
  constructor({ provider, network = "devnet" }) {
    this.signer = {};
    this.wallet = {};
    this.account = "";
    const Window = globalThis;
    const _provider = provider || (Window == null ? void 0 : Window.sollet);
    const _network = clusterApiUrl(network, true);
    this.wallet = new Wallet(_provider, _network);
  }
  async login() {
    var _a2;
    try {
      await this.wallet.connect();
      this.account = (_a2 = this.wallet.publicKey) == null ? void 0 : _a2.toBase58();
      this.signer = index_browser_esm_exports;
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
    return await this.wallet.disconnect();
  }
  onAccountsChanged(callBack) {
  }
  onChainChanged(callBack) {
  }
};
var sollet_default = Sollet;

// node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet2,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode2,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger46,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version28,
  wordlists: () => wordlists
});

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn2 = __toModule(require_bn3());

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version3 = "logger/5.5.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
"use strict";
var _permanentCensorErrors2 = false;
var _censorErrors2 = false;
var LogLevels2 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel2 = LogLevels2["default"];
var _globalLogger2 = null;
function _checkNormalize2() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError2 = _checkNormalize2();
var LogLevel2;
(function(LogLevel3) {
  LogLevel3["DEBUG"] = "DEBUG";
  LogLevel3["INFO"] = "INFO";
  LogLevel3["WARNING"] = "WARNING";
  LogLevel3["ERROR"] = "ERROR";
  LogLevel3["OFF"] = "OFF";
})(LogLevel2 || (LogLevel2 = {}));
var ErrorCode2;
(function(ErrorCode3) {
  ErrorCode3["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode3["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode3["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode3["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode3["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode3["TIMEOUT"] = "TIMEOUT";
  ErrorCode3["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode3["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode3["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode3["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode3["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode3["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode3["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode3["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode3["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode3["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode3["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode3["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode2 || (ErrorCode2 = {}));
var HEX2 = "0123456789abcdef";
var Logger2 = class {
  constructor(version29) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version29,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels2[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel2 > LogLevels2[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger2.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger2.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger2.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors2) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger2.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i5 = 0; i5 < value.length; i5++) {
            hex += HEX2[value[i5] >> 4];
            hex += HEX2[value[i5] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger2.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError2) {
      this.throwError("platform missing String.prototype.normalize", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError2
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger2.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger2.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger2.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger2) {
      _globalLogger2 = new Logger2(version3);
    }
    return _globalLogger2;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors2) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors2 = !!censorship;
    _permanentCensorErrors2 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels2[logLevel.toLowerCase()];
    if (level == null) {
      Logger2.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel2 = level;
  }
  static from(version29) {
    return new Logger2(version29);
  }
};
Logger2.errors = ErrorCode2;
Logger2.levels = LogLevel2;

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version4 = "bytes/5.5.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
"use strict";
var logger2 = new Logger2(version4);
function isHexable2(value) {
  return !!value.toHexString;
}
function addSlice2(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice2(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isBytesLike(value) {
  return isHexString2(value) && !(value.length % 2) || isBytes2(value);
}
function isInteger2(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes2(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger2(value.length) || value.length < 0) {
    return false;
  }
  for (let i5 = 0; i5 < value.length; i5++) {
    const v8 = value[i5];
    if (!isInteger2(v8) || v8 < 0 || v8 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify2(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice2(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    value = value.toHexString();
  }
  if (isHexString2(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0x0" + hex.substring(2);
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i5 = 0; i5 < hex.length; i5 += 2) {
      result.push(parseInt(hex.substring(i5, i5 + 2), 16));
    }
    return addSlice2(new Uint8Array(result));
  }
  if (isBytes2(value)) {
    return addSlice2(new Uint8Array(value));
  }
  return logger2.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify2(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset2, object) => {
    result.set(object, offset2);
    return offset2 + object.length;
  }, 0);
  return addSlice2(result);
}
function stripZeros(value) {
  let result = arrayify2(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify2(value);
  if (value.length > length) {
    logger2.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice2(result);
}
function isHexString2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    return value.toHexString();
  }
  if (isHexString2(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes2(value)) {
    let result = "0x";
    for (let i5 = 0; i5 < value.length; i5++) {
      let v8 = value[i5];
      result += HexCharacters[(v8 & 240) >> 4] + HexCharacters[v8 & 15];
    }
    return result;
  }
  return logger2.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString2(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset2, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString2(data) || data.length % 2) {
    logger2.throwArgumentError("invalid hexData", "value", data);
  }
  offset2 = 2 + 2 * offset2;
  if (endOffset != null) {
    return "0x" + data.substring(offset2, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset2);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString2(value)) {
    logger2.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset2 = 0;
  while (offset2 < value.length && value[offset2] === "0") {
    offset2++;
  }
  return "0x" + value.substring(offset2);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString2(value)) {
    logger2.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger2.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0
  };
  if (isBytesLike(signature2)) {
    const bytes = arrayify2(signature2);
    if (bytes.length !== 65) {
      logger2.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature2);
    }
    result.r = hexlify(bytes.slice(0, 32));
    result.s = hexlify(bytes.slice(32, 64));
    result.v = bytes[64];
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger2.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify2(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger2.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s6 = hexlify(vs2);
      if (result.s == null) {
        result.s = s6;
      } else if (result.s !== s6) {
        logger2.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger2.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger2.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString2(result.r)) {
      logger2.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString2(result.s)) {
      logger2.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify2(result.s);
    if (vs[0] >= 128) {
      logger2.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString2(result._vs)) {
        logger2.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger2.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version5 = "bignumber/5.5.0";

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
"use strict";
var BN2 = import_bn2.default.BN;
var logger3 = new Logger2(version5);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString2(value) || typeof value === "bigint" || isBytes2(value));
}
var _warnedToStringRadix = false;
var BigNumber = class {
  constructor(constructorGuard, hex) {
    logger3.checkNew(new.target, BigNumber);
    if (constructorGuard !== _constructorGuard) {
      logger3.throwError("cannot call constructor directly; use BigNumber.from", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o5 = BigNumber.from(other);
    if (o5.isZero()) {
      throwFault("division by zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot modulo negative values", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot raise to negative values", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'and' negative values", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'or' negative values", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'xor' negative values", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot mask negative values", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e5) {
    }
    return logger3.throwError("this platform does not support BigInt", Logger2.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger3.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger3.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger2.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger3.throwError("BigNumber.toString does not accept parameters", Logger2.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex2(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex2(new BN2(value)));
      }
      return logger3.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes2(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString2(hex) || hex[0] === "-" && isHexString2(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger3.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex2(value) {
  if (typeof value !== "string") {
    return toHex2(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger3.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex2(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex2(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN2("-" + hex.substring(3), 16);
  }
  return new BN2(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger3.throwError(fault, Logger2.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN2(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN2(value, 16).toString(36);
}

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
"use strict";
var logger4 = new Logger2(version5);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger4.throwError(message, Logger2.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e5) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger4.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger4.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger4.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger4.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger4.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger4.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key2, type2, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type2) {
          logger4.throwArgumentError("invalid fixed format (" + key2 + " not " + type2 + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger4.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger4.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard2, signed, width, decimals);
  }
};
var FixedNumber = class {
  constructor(constructorGuard, hex, value, format) {
    logger4.checkNew(new.target, FixedNumber);
    if (constructorGuard !== _constructorGuard2) {
      logger4.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger4.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a5 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a5.add(b4), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a5 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a5.sub(b4), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a5 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a5.mul(b4).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a5 = parseFixed(this._value, this.format.decimals);
    const b4 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a5.mul(this.format._multiplier).div(b4), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger4.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger4.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify2(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes2(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger2.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger4.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version6 = "properties/5.5.0";

// node_modules/@ethersproject/properties/lib.esm/index.js
"use strict";
var __awaiter2 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger5 = new Logger2(version6);
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i5 = 0; i5 < 32; i5++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter2(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v8) => ({ key: key2, value: v8 }));
    });
    const results2 = yield Promise.all(promises);
    return results2.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger5.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger5.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i5 = 0; i5 < keys.length; i5++) {
      let value = null;
      try {
        value = object[keys[i5]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger5.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger5.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
var Description = class {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
};

// node_modules/@ethersproject/abi/lib.esm/_version.js
var version7 = "abi/5.5.0";

// node_modules/@ethersproject/abi/lib.esm/fragments.js
"use strict";
var logger6 = new Logger2(version7);
var _constructorGuard3 = {};
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type2, name2) {
  if (type2 === "bytes" || type2 === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type2 === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type2.indexOf("[") >= 0 || type2 === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger6.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i5) {
    logger6.throwArgumentError(`unexpected character at position ${i5}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i5 = 0; i5 < param.length; i5++) {
    let c5 = param[i5];
    switch (c5) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError2(i5);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i5);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError2(i5);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i5);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i5);
              }
              if (node.indexed) {
                throwError2(i5);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError2(i5);
        }
        node.type += c5;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError2(i5);
        }
        node.type += c5;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c5;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c5;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c5;
        } else {
          throwError2(i5);
        }
    }
  }
  if (node.parent) {
    logger6.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError2(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
var FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger6.throwError("use fromString", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger6.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard3, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
};
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
var Fragment = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger6.throwError("use a static from method", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger6.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger6.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
};
var EventFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger6.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger6.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger6.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger6.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
};
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger6.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger6.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger6.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger6.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger6.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger6.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger6.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
var ConstructorFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger6.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger6.throwError("cannot format a constructor for sighash", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger6.throwArgumentError("invalid constructor object", "value", value);
    }
    let state = verifyState(value);
    if (state.constant) {
      logger6.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger6.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
};
var FunctionFragment = class extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger6.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger6.throwArgumentError("invalid function object", "value", value);
    }
    let state = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger6.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger6.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger6.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
};
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger6.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
var ErrorFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger6.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger6.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard3, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger6.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
};
function verifyType(type2) {
  if (type2.match(/^uint($|[^1-9])/)) {
    type2 = "uint256" + type2.substring(4);
  } else if (type2.match(/^int($|[^1-9])/)) {
    type2 = "int256" + type2.substring(3);
  }
  return type2;
}
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger6.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset2 = 0; offset2 < value.length; offset2++) {
    let c5 = value[offset2];
    if (c5 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c5;
      if (c5 === "(") {
        depth++;
      } else if (c5 === ")") {
        depth--;
        if (depth === -1) {
          logger6.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}

// node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
"use strict";
var logger7 = new Logger2(version7);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var Coder = class {
  constructor(name2, type2, localName, dynamic) {
    this.name = name2;
    this.type = type2;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger7.throwArgumentError(message, this.localName, value);
  }
};
var Writer = class {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat(writer._data));
  }
  writeBytes(value) {
    let bytes = arrayify2(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify2(BigNumber.from(value));
    if (bytes.length > this.wordSize) {
      logger7.throwError("value out-of-bounds", Logger2.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset2 = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset2] = this._getValue(value);
    };
  }
};
var Reader = class {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify2(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset2, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger7.throwError("data out-of-bounds", Logger2.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset2) {
    return new Reader(this._data.slice(this._offset + offset2), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes = this._peekBytes(0, length, !!loose);
    this._offset += bytes.length;
    return bytes.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
};

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha32 = __toModule(require_sha3());
"use strict";
function keccak256(data) {
  return "0x" + import_js_sha32.default.keccak_256(arrayify2(data));
}

// node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  decode: () => decode2,
  encode: () => encode2
});

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version8 = "rlp/5.5.0";

// node_modules/@ethersproject/rlp/lib.esm/index.js
"use strict";
var logger8 = new Logger2(version8);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset2, length) {
  let result = 0;
  for (let i5 = 0; i5 < length; i5++) {
    result = result * 256 + data[offset2 + i5];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger8.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify2(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode2(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset2, childOffset, length) {
  const result = [];
  while (childOffset < offset2 + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset2 + 1 + length) {
      logger8.throwError("child data too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset2) {
  if (data.length === 0) {
    logger8.throwError("data too short", Logger2.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset2] >= 248) {
    const lengthLength = data[offset2] - 247;
    if (offset2 + 1 + lengthLength > data.length) {
      logger8.throwError("data short segment too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length > data.length) {
      logger8.throwError("data long segment too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset2, offset2 + 1 + lengthLength, lengthLength + length);
  } else if (data[offset2] >= 192) {
    const length = data[offset2] - 192;
    if (offset2 + 1 + length > data.length) {
      logger8.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset2, offset2 + 1, length);
  } else if (data[offset2] >= 184) {
    const lengthLength = data[offset2] - 183;
    if (offset2 + 1 + lengthLength > data.length) {
      logger8.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length > data.length) {
      logger8.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset2 + 1 + lengthLength, offset2 + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset2] >= 128) {
    const length = data[offset2] - 128;
    if (offset2 + 1 + length > data.length) {
      logger8.throwError("data too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset2 + 1, offset2 + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset2]) };
}
function decode2(data) {
  const bytes = arrayify2(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger8.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/@ethersproject/address/lib.esm/_version.js
var version9 = "address/5.5.0";

// node_modules/@ethersproject/address/lib.esm/index.js
"use strict";
var logger9 = new Logger2(version9);
function getChecksumAddress(address) {
  if (!isHexString2(address, 20)) {
    logger9.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i5 = 0; i5 < 40; i5++) {
    expanded[i5] = chars[i5].charCodeAt(0);
  }
  const hashed = arrayify2(keccak256(expanded));
  for (let i5 = 0; i5 < 40; i5 += 2) {
    if (hashed[i5 >> 1] >> 4 >= 8) {
      chars[i5] = chars[i5].toUpperCase();
    }
    if ((hashed[i5 >> 1] & 15) >= 8) {
      chars[i5 + 1] = chars[i5 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x5) {
  if (Math.log10) {
    return Math.log10(x5);
  }
  return Math.log(x5) / Math.LN10;
}
var ibanLookup = {};
for (let i5 = 0; i5 < 10; i5++) {
  ibanLookup[String(i5)] = String(i5);
}
for (let i5 = 0; i5 < 26; i5++) {
  ibanLookup[String.fromCharCode(65 + i5)] = String(10 + i5);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c5) => {
    return ibanLookup[c5];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger9.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger9.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger9.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger9.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger9.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify2(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode2([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger9.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger9.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from2), salt, initCodeHash])), 12));
}

// node_modules/@ethersproject/abi/lib.esm/coders/address.js
"use strict";
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
"use strict";
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/array.js
"use strict";
var logger10 = new Logger2(version7);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger10.throwError("cannot encode object for signature with missing names", Logger2.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger10.throwError("cannot encode object for signature with duplicate names", Logger2.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger10.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger10.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset2 = reader.readValue();
      let offsetReader = baseReader.subReader(offset2.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger2.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger2.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i5 = 0; i5 < values.length; i5++) {
    const value = values[i5];
    if (value instanceof Error) {
      Object.defineProperty(values, i5, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var ArrayCoder = class extends Coder {
  constructor(coder, length, localName) {
    const type2 = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type2, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i5 = 0; i5 < this.length; i5++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value.length;
      writer.writeValue(value.length);
    }
    logger10.checkArgumentCount(value.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i5 = 0; i5 < value.length; i5++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader.readValue().toNumber();
      if (count2 * 32 > reader._data.length) {
        logger10.throwError("insufficient data length", Logger2.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count2
        });
      }
    }
    let coders = [];
    for (let i5 = 0; i5 < count2; i5++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
"use strict";
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
"use strict";
var DynamicBytesCoder = class extends Coder {
  constructor(type2, localName) {
    super(type2, type2, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify2(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
"use strict";
var FixedBytesCoder = class extends Coder {
  constructor(size, localName) {
    let name2 = "bytes" + String(size);
    super(name2, name2, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify2(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/null.js
"use strict";
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
};

// node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne2,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero2
});

// node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero = "0x0000000000000000000000000000000000000000";

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2 = BigNumber.from(-1);
var Zero2 = BigNumber.from(0);
var One = BigNumber.from(1);
var Two = BigNumber.from(2);
var WeiPerEther = BigNumber.from("1000000000000000000");
var MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol = "\u039E";

// node_modules/@ethersproject/constants/lib.esm/index.js
"use strict";

// node_modules/@ethersproject/abi/lib.esm/coders/number.js
"use strict";
var NumberCoder = class extends Coder {
  constructor(size, signed, localName) {
    const name2 = (signed ? "int" : "uint") + size * 8;
    super(name2, name2, localName, false);
    this.size = size;
    this.signed = signed;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v8 = BigNumber.from(value);
    let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v8.gt(bounds) || v8.lt(bounds.add(One).mul(NegativeOne2))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v8.lt(Zero2) || v8.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v8 = v8.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v8 = v8.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v8);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
};

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version10 = "strings/5.5.0";

// node_modules/@ethersproject/strings/lib.esm/utf8.js
"use strict";
var logger11 = new Logger2(version10);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset2, bytes, output, badCodepoint) {
  return logger11.throwArgumentError(`invalid codepoint at offset ${offset2}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset2, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i5 = 0;
    for (let o5 = offset2 + 1; o5 < bytes.length; o5++) {
      if (bytes[o5] >> 6 !== 2) {
        break;
      }
      i5++;
    }
    return i5;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset2 - 1;
  }
  return 0;
}
function replaceFunc(reason, offset2, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset2, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify2(bytes);
  const result = [];
  let i5 = 0;
  while (i5 < bytes.length) {
    const c5 = bytes[i5++];
    if (c5 >> 7 === 0) {
      result.push(c5);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c5 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c5 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c5 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c5 & 192) === 128) {
        i5 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i5 - 1, bytes, result);
      } else {
        i5 += onError(Utf8ErrorReason.BAD_PREFIX, i5 - 1, bytes, result);
      }
      continue;
    }
    if (i5 - 1 + extraLength >= bytes.length) {
      i5 += onError(Utf8ErrorReason.OVERRUN, i5 - 1, bytes, result);
      continue;
    }
    let res = c5 & (1 << 8 - extraLength - 1) - 1;
    for (let j5 = 0; j5 < extraLength; j5++) {
      let nextChar = bytes[i5];
      if ((nextChar & 192) != 128) {
        i5 += onError(Utf8ErrorReason.MISSING_CONTINUE, i5, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i5++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i5 += onError(Utf8ErrorReason.OUT_OF_RANGE, i5 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i5 += onError(Utf8ErrorReason.UTF16_SURROGATE, i5 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i5 += onError(Utf8ErrorReason.OVERLONG, i5 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger11.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i5 = 0; i5 < str.length; i5++) {
    const c5 = str.charCodeAt(i5);
    if (c5 < 128) {
      result.push(c5);
    } else if (c5 < 2048) {
      result.push(c5 >> 6 | 192);
      result.push(c5 & 63 | 128);
    } else if ((c5 & 64512) == 55296) {
      i5++;
      const c22 = str.charCodeAt(i5);
      if (i5 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c5 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c5 >> 12 | 224);
      result.push(c5 >> 6 & 63 | 128);
      result.push(c5 & 63 | 128);
    }
  }
  return arrayify2(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

// node_modules/@ethersproject/strings/lib.esm/bytes32.js
"use strict";
function formatBytes32String(text) {
  const bytes = toUtf8Bytes(text);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data = arrayify2(bytes);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}

// node_modules/@ethersproject/strings/lib.esm/idna.js
"use strict";
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i5 = 0; i5 < data.length; i5 += 4) {
    result.push(parseInt(data.substring(i5, i5 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v8) => {
    let comps = v8.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i5 = 0; i5 < ranges.length; i5++) {
    let range2 = ranges[i5];
    lo += range2.l;
    if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v8) => parseInt(v8, 16));
var Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range2 = matchMap(codepoint, Table_B_2_ranges);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code) => {
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}

// node_modules/@ethersproject/strings/lib.esm/index.js
"use strict";

// node_modules/@ethersproject/abi/lib.esm/coders/string.js
"use strict";
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
"use strict";
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type2 = "tuple(" + types.join(",") + ")";
    super("tuple", type2, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/abi-coder.js
"use strict";
var logger12 = new Logger2(version7);
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = class {
  constructor(coerceFunc) {
    logger12.checkNew(new.target, AbiCoder);
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger12.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger12.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger12.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger12.throwError("types/values length mismatch", Logger2.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify2(data), loose));
  }
};
var defaultAbiCoder = new AbiCoder();

// node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak256(toUtf8Bytes(text));
}

// node_modules/@ethersproject/hash/lib.esm/_version.js
var version11 = "hash/5.5.0";

// node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger13 = new Logger2(version11);
var Zeros = new Uint8Array(32);
Zeros.fill(0);
var Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function isValidName(name2) {
  try {
    const comps = name2.split(".");
    for (let i5 = 0; i5 < comps.length; i5++) {
      if (nameprep(comps[i5]).length === 0) {
        throw new Error("empty");
      }
    }
    return true;
  } catch (error) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger13.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros;
  while (current.length) {
    const partition3 = current.match(Partition);
    if (partition3 == null || partition3[2] === "") {
      logger13.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes(nameprep(partition3[3]));
    result = keccak256(concat([result, keccak256(label)]));
    current = partition3[2] || "";
  }
  return hexlify(result);
}

// node_modules/@ethersproject/hash/lib.esm/message.js
var messagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}

// node_modules/@ethersproject/hash/lib.esm/typed-data.js
var __awaiter3 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger14 = new Logger2(version11);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne3 = BigNumber.from(-1);
var Zero3 = BigNumber.from(0);
var One2 = BigNumber.from(1);
var MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify2(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
var hexTrue = hexZeroPad(One2.toHexString(), 32);
var hexFalse = hexZeroPad(Zero3.toHexString(), 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger14.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger14.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger14.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify2(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes);
    } catch (error) {
    }
    return logger14.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type2) {
  {
    const match = type2.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger14.throwArgumentError("invalid numeric width", "type", type2);
      }
      const boundsUpper = MaxUint2562.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
      return function(value) {
        const v8 = BigNumber.from(value);
        if (v8.lt(boundsLower) || v8.gt(boundsUpper)) {
          logger14.throwArgumentError(`value out-of-bounds for ${type2}`, "value", value);
        }
        return hexZeroPad(v8.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type2.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger14.throwArgumentError("invalid bytes width", "type", type2);
      }
      return function(value) {
        const bytes = arrayify2(value);
        if (bytes.length !== width) {
          logger14.throwArgumentError(`invalid length for ${type2}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type2) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type: type2 }) => type2 + " " + name3).join(",")})`;
}
var TypedDataEncoder = class {
  constructor(types) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type2) => {
      links[type2] = {};
      parents[type2] = [];
      subtypes[type2] = {};
    });
    for (const name2 in types) {
      const uniqueNames = {};
      types[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger14.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger14.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger14.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n3) => parents[n3].length === 0);
    if (primaryTypes.length === 0) {
      logger14.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger14.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t5) => JSON.stringify(t5)).join(", ")}`, "types", types);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type2, found) {
      if (found[type2]) {
        logger14.throwArgumentError(`circular type reference to ${JSON.stringify(type2)}`, "types", types);
      }
      found[type2] = true;
      Object.keys(links[type2]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type2];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types[name2]) + st.map((t5) => encodeType(t5, types[t5])).join("");
    }
  }
  getEncoder(type2) {
    let encoder = this._encoderCache[type2];
    if (!encoder) {
      encoder = this._encoderCache[type2] = this._getEncoder(type2);
    }
    return encoder;
  }
  _getEncoder(type2) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return encoder;
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger14.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256);
        }
        return keccak256(hexConcat(result));
      };
    }
    const fields = this.types[type2];
    if (fields) {
      const encodedType = id(this._types[type2]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type3 }) => {
          const result = this.getEncoder(type3)(value[name2]);
          if (this._types[type3]) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger14.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger14.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type2, value) {
    return this.getEncoder(type2)(value);
  }
  hashStruct(name2, value) {
    return keccak256(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type2, value, callback) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return callback(type2, value);
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger14.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v8) => this._visit(subtype, v8, callback));
    }
    const fields = this.types[type2];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type3 }) => {
        accum[name2] = this._visit(type3, value[name2], callback);
        return accum;
      }, {});
    }
    return logger14.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name2, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name2, value);
  }
  static hashDomain(domain2) {
    const domainFields = [];
    for (const name2 in domain2) {
      const type2 = domainFieldTypes[name2];
      if (!type2) {
        logger14.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
      }
      domainFields.push({ name: name2, type: type2 });
    }
    domainFields.sort((a5, b4) => {
      return domainFieldNames.indexOf(a5.name) - domainFieldNames.indexOf(b4.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
  }
  static encode(domain2, types, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain2),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  static hash(domain2, types, value) {
    return keccak256(TypedDataEncoder.encode(domain2, types, value));
  }
  static resolveNames(domain2, types, value, resolveName2) {
    return __awaiter3(this, void 0, void 0, function* () {
      domain2 = shallowCopy(domain2);
      const ensCache = {};
      if (domain2.verifyingContract && !isHexString2(domain2.verifyingContract, 20)) {
        ensCache[domain2.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types);
      encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && !isHexString2(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
        domain2.verifyingContract = ensCache[domain2.verifyingContract];
      }
      value = encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain: domain2, value };
    });
  }
  static getPayload(domain2, types, value) {
    TypedDataEncoder.hashDomain(domain2);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain2[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy(types);
    if (typesWithDomain.EIP712Domain) {
      logger14.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type2, value2) => {
        if (type2.match(/^bytes(\d*)/)) {
          return hexlify(arrayify2(value2));
        }
        if (type2.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type2) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger14.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger14.throwArgumentError("unsupported type", "type", type2);
      })
    };
  }
};

// node_modules/@ethersproject/hash/lib.esm/index.js
"use strict";

// node_modules/@ethersproject/abi/lib.esm/interface.js
"use strict";
var logger15 = new Logger2(version7);
var LogDescription = class extends Description {
};
var TransactionDescription = class extends Description {
};
var ErrorDescription = class extends Description {
};
var Indexed = class extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
};
var BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var Interface = class {
  constructor(fragments) {
    logger15.checkNew(new.target, Interface);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger15.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger15.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger15.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi.map((j5) => JSON.parse(j5)));
    }
    return abi;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString2(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger15.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f7) => f7.split("(")[0] === name2);
      if (matching.length === 0) {
        logger15.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger15.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger15.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString2(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger15.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f7) => f7.split("(")[0] === name2);
      if (matching.length === 0) {
        logger15.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger15.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger15.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  getError(nameOrSignatureOrSighash) {
    if (isHexString2(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger15.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f7) => f7.split("(")[0] === name2);
      if (matching.length === 0) {
        logger15.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger15.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger15.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_10) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify2(data);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger15.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify2(data);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger15.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify2(data);
    let reason = null;
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
            console.log(error);
          }
        }
        break;
      }
    }
    return logger15.throwError("call revert exception", Logger2.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger15.throwError("too many arguments for " + eventFragment.format(), Logger2.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger15.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger15.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger15.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString2(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger15.throwError("fragment/topic mismatch", Logger2.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index]) {
          result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i5 = 0; i5 < result.length; i5++) {
      const value = result[i5];
      if (value instanceof Error) {
        Object.defineProperty(result, i5, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i5}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
};

// node_modules/@ethersproject/abi/lib.esm/index.js
"use strict";

// node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version12 = "abstract-provider/5.5.1";

// node_modules/@ethersproject/abstract-provider/lib.esm/index.js
"use strict";
var __awaiter4 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger16 = new Logger2(version12);
var ForkEvent = class extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
};
var Provider = class {
  constructor() {
    logger16.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter4(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = BigNumber.from("2500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
};

// node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version13 = "abstract-signer/5.5.0";

// node_modules/@ethersproject/abstract-signer/lib.esm/index.js
"use strict";
var __awaiter5 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger17 = new Logger2(version13);
var allowedTransactionKeys = [
  "accessList",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors = [
  Logger2.errors.INSUFFICIENT_FUNDS,
  Logger2.errors.NONCE_EXPIRED,
  Logger2.errors.REPLACEMENT_UNDERPRICED
];
var Signer = class {
  constructor() {
    logger17.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys.indexOf(key2) === -1) {
        logger17.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger17.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter5(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter5(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger17.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger17.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger17.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger17.throwError("network does not support EIP-1559", Logger2.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger17.throwError("failed to get consistent fee data", Logger2.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger17.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger2.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results2) => {
          if (results2[1] !== 0 && results2[0] !== results2[1]) {
            logger17.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results2[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger17.throwError("missing provider", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};
var VoidSigner = class extends Signer {
  constructor(address, provider) {
    logger17.checkNew(new.target, VoidSigner);
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger17.throwError(message, Logger2.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain2, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
};

// node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
var import_bn3 = __toModule(require_bn3());
var import_hash2 = __toModule(require_hash());
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module.path : base2);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert2 = assert3;
function assert3(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert3.equal = function assertEqual2(l5, r6, msg) {
  if (l5 != r6)
    throw new Error(msg || "Assertion failed: " + l5 + " != " + r6);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils2 = exports;
  function toArray3(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i5 = 0; i5 < msg.length; i5++)
        res[i5] = msg[i5] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i5 = 0; i5 < msg.length; i5 += 2)
        res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
    } else {
      for (var i5 = 0; i5 < msg.length; i5++) {
        var c5 = msg.charCodeAt(i5);
        var hi = c5 >> 8;
        var lo = c5 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray3;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i5 = 0; i5 < msg.length; i5++)
      res += zero22(msg[i5].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode5(arr, enc) {
    if (enc === "hex")
      return toHex3(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils2 = exports;
  utils2.assert = minimalisticAssert2;
  utils2.toArray = utils_1.toArray;
  utils2.zero2 = utils_1.zero2;
  utils2.toHex = utils_1.toHex;
  utils2.encode = utils_1.encode;
  function getNAF2(num, w6, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w6 + 1;
    var k5 = num.clone();
    for (var i5 = 0; i5 < naf.length; i5++) {
      var z4;
      var mod = k5.andln(ws - 1);
      if (k5.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z4 = (ws >> 1) - mod;
        else
          z4 = mod;
        k5.isubn(z4);
      } else {
        z4 = 0;
      }
      naf[i5] = z4;
      k5.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k22) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k22 = k22.clone();
    var d1 = 0;
    var d22 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k22.andln(3) + d22 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u22;
      if ((m24 & 1) === 0) {
        u22 = 0;
      } else {
        m8 = k22.andln(7) + d22 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u22 = -m24;
        else
          u22 = m24;
      }
      jsf[1].push(u22);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d22 === u22 + 1)
        d22 = 1 - d22;
      k1.iushrn(1);
      k22.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn3.default(bytes, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$12 = utils_1$1.assert;
function BaseCurve(type2, conf) {
  this.type = type2;
  this.p = new import_bn3.default(conf.p, 16);
  this.red = conf.prime ? import_bn3.default.red(conf.prime) : import_bn3.default.mont(this.p);
  this.zero = new import_bn3.default(0).toRed(this.red);
  this.one = new import_bn3.default(1).toRed(this.red);
  this.two = new import_bn3.default(2).toRed(this.red);
  this.n = conf.n && new import_bn3.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate3() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p5, k5) {
  assert$12(p5.precomputed);
  var doubles = p5._getDoubles();
  var naf = getNAF(k5, 1, this._bitLength);
  var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I5 /= 3;
  var repr = [];
  var j5;
  var nafW;
  for (j5 = 0; j5 < naf.length; j5 += doubles.step) {
    nafW = 0;
    for (var l5 = j5 + doubles.step - 1; l5 >= j5; l5--)
      nafW = (nafW << 1) + naf[l5];
    repr.push(nafW);
  }
  var a5 = this.jpoint(null, null, null);
  var b4 = this.jpoint(null, null, null);
  for (var i5 = I5; i5 > 0; i5--) {
    for (j5 = 0; j5 < repr.length; j5++) {
      nafW = repr[j5];
      if (nafW === i5)
        b4 = b4.mixedAdd(doubles.points[j5]);
      else if (nafW === -i5)
        b4 = b4.mixedAdd(doubles.points[j5].neg());
    }
    a5 = a5.add(b4);
  }
  return a5.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p5, k5) {
  var w6 = 4;
  var nafPoints = p5._getNAFPoints(w6);
  w6 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k5, w6, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i5 = naf.length - 1; i5 >= 0; i5--) {
    for (var l5 = 0; i5 >= 0 && naf[i5] === 0; i5--)
      l5++;
    if (i5 >= 0)
      l5++;
    acc = acc.dblp(l5);
    if (i5 < 0)
      break;
    var z4 = naf[i5];
    assert$12(z4 !== 0);
    if (p5.type === "affine") {
      if (z4 > 0)
        acc = acc.mixedAdd(wnd[z4 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z4 - 1 >> 1].neg());
    } else {
      if (z4 > 0)
        acc = acc.add(wnd[z4 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z4 - 1 >> 1].neg());
    }
  }
  return p5.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i5;
  var j5;
  var p5;
  for (i5 = 0; i5 < len; i5++) {
    p5 = points[i5];
    var nafPoints = p5._getNAFPoints(defW);
    wndWidth[i5] = nafPoints.wnd;
    wnd[i5] = nafPoints.points;
  }
  for (i5 = len - 1; i5 >= 1; i5 -= 2) {
    var a5 = i5 - 1;
    var b4 = i5;
    if (wndWidth[a5] !== 1 || wndWidth[b4] !== 1) {
      naf[a5] = getNAF(coeffs[a5], wndWidth[a5], this._bitLength);
      naf[b4] = getNAF(coeffs[b4], wndWidth[b4], this._bitLength);
      max2 = Math.max(naf[a5].length, max2);
      max2 = Math.max(naf[b4].length, max2);
      continue;
    }
    var comb = [
      points[a5],
      null,
      null,
      points[b4]
    ];
    if (points[a5].y.cmp(points[b4].y) === 0) {
      comb[1] = points[a5].add(points[b4]);
      comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
    } else if (points[a5].y.cmp(points[b4].y.redNeg()) === 0) {
      comb[1] = points[a5].toJ().mixedAdd(points[b4]);
      comb[2] = points[a5].add(points[b4].neg());
    } else {
      comb[1] = points[a5].toJ().mixedAdd(points[b4]);
      comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a5], coeffs[b4]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a5] = new Array(max2);
    naf[b4] = new Array(max2);
    for (j5 = 0; j5 < max2; j5++) {
      var ja = jsf[0][j5] | 0;
      var jb = jsf[1][j5] | 0;
      naf[a5][j5] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b4][j5] = 0;
      wnd[a5] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i5 = max2; i5 >= 0; i5--) {
    var k5 = 0;
    while (i5 >= 0) {
      var zero = true;
      for (j5 = 0; j5 < len; j5++) {
        tmp[j5] = naf[j5][i5] | 0;
        if (tmp[j5] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k5++;
      i5--;
    }
    if (i5 >= 0)
      k5++;
    acc = acc.dblp(k5);
    if (i5 < 0)
      break;
    for (j5 = 0; j5 < len; j5++) {
      var z4 = tmp[j5];
      p5;
      if (z4 === 0)
        continue;
      else if (z4 > 0)
        p5 = wnd[j5][z4 - 1 >> 1];
      else if (z4 < 0)
        p5 = wnd[j5][-z4 - 1 >> 1].neg();
      if (p5.type === "affine")
        acc = acc.mixedAdd(p5);
      else
        acc = acc.add(p5);
    }
  }
  for (i5 = 0; i5 < len; i5++)
    wnd[i5] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type2) {
  this.curve = curve;
  this.type = type2;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate4() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$12(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$12(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x5 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x5);
  return [4].concat(x5, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode3(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k5) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i5 = 0; i5 < power; i5 += step) {
    for (var j5 = 0; j5 < step; j5++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl3 = max2 === 1 ? null : this.dbl();
  for (var i5 = 1; i5 < max2; i5++)
    res[i5] = res[i5 - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k5) {
  var r6 = this;
  for (var i5 = 0; i5 < k5; i5++)
    r6 = r6.dbl();
  return r6;
};
var inherits_browser2 = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$22 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn3.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn3.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser2(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn3.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn3.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$22(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn3.default(vec.a, 16),
        b: new import_bn3.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : import_bn3.default.mont(num);
  var tinv = new import_bn3.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s6 = new import_bn3.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s6).fromRed();
  var l22 = ntinv.redSub(s6).fromRed();
  return [l1, l22];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u5 = lambda;
  var v8 = this.n.clone();
  var x1 = new import_bn3.default(1);
  var y1 = new import_bn3.default(0);
  var x22 = new import_bn3.default(0);
  var y22 = new import_bn3.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a22;
  var b22;
  var prevR;
  var i5 = 0;
  var r6;
  var x5;
  while (u5.cmpn(0) !== 0) {
    var q5 = v8.div(u5);
    r6 = v8.sub(q5.mul(u5));
    x5 = x22.sub(q5.mul(x1));
    var y5 = y22.sub(q5.mul(y1));
    if (!a1 && r6.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r6.neg();
      b1 = x5;
    } else if (a1 && ++i5 === 2) {
      break;
    }
    prevR = r6;
    v8 = u5;
    u5 = r6;
    x22 = x1;
    x1 = x5;
    y22 = y1;
    y1 = y5;
  }
  a22 = r6.neg();
  b22 = x5;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a22.sqr().add(b22.sqr());
  if (len2.cmp(len1) >= 0) {
    a22 = a0;
    b22 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a22.negative) {
    a22 = a22.neg();
    b22 = b22.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a22, b: b22 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k5) {
  var basis = this.endo.basis;
  var v12 = basis[0];
  var v22 = basis[1];
  var c1 = v22.b.mul(k5).divRound(this.n);
  var c22 = v12.b.neg().mul(k5).divRound(this.n);
  var p1 = c1.mul(v12.a);
  var p22 = c22.mul(v22.a);
  var q1 = c1.mul(v12.b);
  var q22 = c22.mul(v22.b);
  var k1 = k5.sub(p1).sub(p22);
  var k22 = q1.add(q22).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x5, odd) {
  x5 = new import_bn3.default(x5, 16);
  if (!x5.red)
    x5 = x5.toRed(this.red);
  var y22 = x5.redSqr().redMul(x5).redIAdd(x5.redMul(this.a)).redIAdd(this.b);
  var y5 = y22.redSqrt();
  if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y5.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y5 = y5.redNeg();
  return this.point(x5, y5);
};
ShortCurve.prototype.validate = function validate5(point3) {
  if (point3.inf)
    return true;
  var x5 = point3.x;
  var y5 = point3.y;
  var ax = this.a.redMul(x5);
  var rhs = x5.redSqr().redMul(x5).redIAdd(ax).redIAdd(this.b);
  return y5.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i5 = 0; i5 < points.length; i5++) {
    var split = this._endoSplit(coeffs[i5]);
    var p5 = points[i5];
    var beta = p5._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p5 = p5.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i5 * 2] = p5;
    npoints[i5 * 2 + 1] = beta;
    ncoeffs[i5 * 2] = split.k1;
    ncoeffs[i5 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i5 * 2, jacobianResult);
  for (var j5 = 0; j5 < i5 * 2; j5++) {
    npoints[j5] = null;
    ncoeffs[j5] = null;
  }
  return res;
};
function Point(curve, x5, y5, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x5 === null && y5 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn3.default(x5, 16);
    this.y = new import_bn3.default(y5, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser2(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x5, y5, isRed) {
  return new Point(this, x5, y5, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p5) {
      return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p5) {
  if (this.inf)
    return p5;
  if (p5.inf)
    return this;
  if (this.eq(p5))
    return this.dbl();
  if (this.neg().eq(p5))
    return this.curve.point(null, null);
  if (this.x.cmp(p5.x) === 0)
    return this.curve.point(null, null);
  var c5 = this.y.redSub(p5.y);
  if (c5.cmpn(0) !== 0)
    c5 = c5.redMul(this.x.redSub(p5.x).redInvm());
  var nx = c5.redSqr().redISub(this.x).redISub(p5.x);
  var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a5 = this.curve.a;
  var x22 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
  var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k5) {
  k5 = new import_bn3.default(k5, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k5))
    return this.curve._fixedNafMul(this, k5);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k5]);
  else
    return this.curve._wnafMul(this, k5);
};
Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p5) {
  return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p5) {
      return p5.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x5, y5, z4) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x5 === null && y5 === null && z4 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn3.default(0);
  } else {
    this.x = new import_bn3.default(x5, 16);
    this.y = new import_bn3.default(y5, 16);
    this.z = new import_bn3.default(z4, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser2(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x5, y5, z4) {
  return new JPoint(this, x5, y5, z4);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p5) {
  if (this.isInfinity())
    return p5;
  if (p5.isInfinity())
    return this;
  var pz2 = p5.z.redSqr();
  var z22 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u22 = p5.x.redMul(z22);
  var s1 = this.y.redMul(pz2.redMul(p5.z));
  var s22 = p5.y.redMul(z22.redMul(this.z));
  var h5 = u1.redSub(u22);
  var r6 = s1.redSub(s22);
  if (h5.cmpn(0) === 0) {
    if (r6.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h5.redSqr();
  var h32 = h22.redMul(h5);
  var v8 = u1.redMul(h22);
  var nx = r6.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
  var ny = r6.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p5.z).redMul(h5);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p5) {
  if (this.isInfinity())
    return p5.toJ();
  if (p5.isInfinity())
    return this;
  var z22 = this.z.redSqr();
  var u1 = this.x;
  var u22 = p5.x.redMul(z22);
  var s1 = this.y;
  var s22 = p5.y.redMul(z22).redMul(this.z);
  var h5 = u1.redSub(u22);
  var r6 = s1.redSub(s22);
  if (h5.cmpn(0) === 0) {
    if (r6.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h5.redSqr();
  var h32 = h22.redMul(h5);
  var v8 = u1.redMul(h22);
  var nx = r6.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
  var ny = r6.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h5);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i5;
  if (this.curve.zeroA || this.curve.threeA) {
    var r6 = this;
    for (i5 = 0; i5 < pow; i5++)
      r6 = r6.dbl();
    return r6;
  }
  var a5 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i5 = 0; i5 < pow; i5++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c5.redSqr().redISub(t1.redAdd(t1));
    var t22 = t1.redISub(nx);
    var dny = c5.redMul(t22);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i5 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s6 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s6 = s6.redIAdd(s6);
    var m5 = xx.redAdd(xx).redIAdd(xx);
    var t5 = m5.redSqr().redISub(s6).redISub(s6);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t5;
    ny = m5.redMul(s6.redISub(t5)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a5 = this.x.redSqr();
    var b4 = this.y.redSqr();
    var c5 = b4.redSqr();
    var d5 = this.x.redAdd(b4).redSqr().redISub(a5).redISub(c5);
    d5 = d5.redIAdd(d5);
    var e5 = a5.redAdd(a5).redIAdd(a5);
    var f7 = e5.redSqr();
    var c8 = c5.redIAdd(c5);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f7.redISub(d5).redISub(d5);
    ny = e5.redMul(d5.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s6 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s6 = s6.redIAdd(s6);
    var m5 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t5 = m5.redSqr().redISub(s6).redISub(s6);
    nx = t5;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m5.redMul(s6.redISub(t5)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a5 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c5.redSqr().redISub(t1.redAdd(t1));
  var t22 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c5.redMul(t22).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m5 = xx.redAdd(xx).redIAdd(xx);
  var mm = m5.redSqr();
  var e5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e5 = e5.redIAdd(e5);
  e5 = e5.redAdd(e5).redIAdd(e5);
  e5 = e5.redISub(mm);
  var ee = e5.redSqr();
  var t5 = yyyy.redIAdd(yyyy);
  t5 = t5.redIAdd(t5);
  t5 = t5.redIAdd(t5);
  t5 = t5.redIAdd(t5);
  var u5 = m5.redIAdd(e5).redSqr().redISub(mm).redISub(ee).redISub(t5);
  var yyu4 = yy.redMul(u5);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u5.redMul(t5.redISub(u5)).redISub(e5.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e5).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k5, kbase) {
  k5 = new import_bn3.default(k5, kbase);
  return this.curve._wnafMul(this, k5);
};
JPoint.prototype.eq = function eq3(p5) {
  if (p5.type === "affine")
    return this.eq(p5.toJ());
  if (this === p5)
    return true;
  var z22 = this.z.redSqr();
  var pz2 = p5.z.redSqr();
  if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
    return false;
  var z32 = z22.redMul(this.z);
  var pz3 = pz2.redMul(p5.z);
  return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x5) {
  var zs = this.z.redSqr();
  var rx = x5.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x5.clone();
  var t5 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t5);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = null;
  curve.edwards = null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert5 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert5(this.g.validate(), "Invalid curve");
    assert5(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash2.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash2.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e5) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash2.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i5 = 0; i5 < this.V.length; i5++) {
    this.K[i5] = 0;
    this.V[i5] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac2() {
  return new import_hash2.default.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add3 = utils_1.toArray(add3, addEnc);
  minimalisticAssert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add3);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$32 = utils_1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate6() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new import_bn3.default(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$32(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$32(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$32(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$42 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$42(options.r && options.s, "Signature without r or s");
  this.r = new import_bn3.default(options.r, 16);
  this.s = new import_bn3.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p5) {
  var initial = buf[p5.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i5 = 0, off = p5.place; i5 < octetLen; i5++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p5.place = off;
  return val;
}
function rmPadding(buf) {
  var i5 = 0;
  var len = buf.length - 1;
  while (!buf[i5] && !(buf[i5 + 1] & 128) && i5 < len) {
    i5++;
  }
  if (i5 === 0) {
    return buf;
  }
  return buf.slice(i5);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p5 = new Position();
  if (data[p5.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p5);
  if (len === false) {
    return false;
  }
  if (len + p5.place !== data.length) {
    return false;
  }
  if (data[p5.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p5);
  if (rlen === false) {
    return false;
  }
  var r6 = data.slice(p5.place, rlen + p5.place);
  p5.place += rlen;
  if (data[p5.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p5);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p5.place) {
    return false;
  }
  var s6 = data.slice(p5.place, slen + p5.place);
  if (r6[0] === 0) {
    if (r6[1] & 128) {
      r6 = r6.slice(1);
    } else {
      return false;
    }
  }
  if (s6[0] === 0) {
    if (s6[1] & 128) {
      s6 = s6.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn3.default(r6);
  this.s = new import_bn3.default(s6);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r6 = this.r.toArray();
  var s6 = this.s.toArray();
  if (r6[0] & 128)
    r6 = [0].concat(r6);
  if (s6[0] & 128)
    s6 = [0].concat(s6);
  r6 = rmPadding(r6);
  s6 = rmPadding(s6);
  while (!s6[0] && !(s6[1] & 128)) {
    s6 = s6.slice(1);
  }
  var arr = [2];
  constructLength(arr, r6.length);
  arr = arr.concat(r6);
  arr.push(2);
  constructLength(arr, s6.length);
  var backHalf = arr.concat(s6);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = function() {
  throw new Error("unsupported");
};
var assert$52 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$52(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn3.default(2));
  for (; ; ) {
    var priv = new import_bn3.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new import_bn3.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn3.default(1));
  for (var iter = 0; ; iter++) {
    var k5 = options.k ? options.k(iter) : new import_bn3.default(drbg.generate(this.n.byteLength()));
    k5 = this._truncateToN(k5, true);
    if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k5);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r6 = kpX.umod(this.n);
    if (r6.cmpn(0) === 0)
      continue;
    var s6 = k5.invm(this.n).mul(r6.mul(key2.getPrivate()).iadd(msg));
    s6 = s6.umod(this.n);
    if (s6.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r6) !== 0 ? 2 : 0);
    if (options.canonical && s6.cmp(this.nh) > 0) {
      s6 = this.n.sub(s6);
      recoveryParam ^= 1;
    }
    return new signature({ r: r6, s: s6, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new import_bn3.default(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r6 = signature$1.r;
  var s6 = signature$1.s;
  if (r6.cmpn(1) < 0 || r6.cmp(this.n) >= 0)
    return false;
  if (s6.cmpn(1) < 0 || s6.cmp(this.n) >= 0)
    return false;
  var sinv = s6.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u22 = sinv.mul(r6).umod(this.n);
  var p5;
  if (!this.curve._maxwellTrick) {
    p5 = this.g.mulAdd(u1, key2.getPublic(), u22);
    if (p5.isInfinity())
      return false;
    return p5.getX().umod(this.n).cmp(r6) === 0;
  }
  p5 = this.g.jmulAdd(u1, key2.getPublic(), u22);
  if (p5.isInfinity())
    return false;
  return p5.eqXToP(r6);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j5, enc) {
  assert$52((3 & j5) === j5, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n3 = this.n;
  var e5 = new import_bn3.default(msg);
  var r6 = signature$1.r;
  var s6 = signature$1.s;
  var isYOdd = j5 & 1;
  var isSecondKey = j5 >> 1;
  if (r6.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r6 = this.curve.pointFromX(r6.add(this.curve.n), isYOdd);
  else
    r6 = this.curve.pointFromX(r6, isYOdd);
  var rInv = signature$1.r.invm(n3);
  var s1 = n3.sub(e5).mul(rInv).umod(n3);
  var s22 = s6.mul(rInv).umod(n3);
  return this.g.mulAdd(s1, r6, s22);
};
EC.prototype.getKeyRecoveryParam = function(e5, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i5 = 0; i5 < 4; i5++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e5, signature$1, i5);
    } catch (e6) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i5;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = null;
});
var EC$1 = elliptic_1.ec;

// node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version14 = "signing-key/5.5.0";

// node_modules/@ethersproject/signing-key/lib.esm/index.js
"use strict";
var logger18 = new Logger2(version14);
var _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
var SigningKey = class {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    const keyPair2 = getCurve().keyFromPrivate(arrayify2(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify2(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify2(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify2(this.privateKey));
    const digestBytes = arrayify2(digest9);
    if (digestBytes.length !== 32) {
      logger18.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify2(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify2(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify2(sig.r), s: arrayify2(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify2(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify2(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger18.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/@ethersproject/transactions/lib.esm/_version.js
var version15 = "transactions/5.5.0";

// node_modules/@ethersproject/transactions/lib.esm/index.js
"use strict";
var logger19 = new Logger2(version15);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero2;
  }
  return BigNumber.from(value);
}
var transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
var allowedTransactionKeys2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key2) {
  const publicKey2 = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey2, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify2(digest9), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger19.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger19.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger19.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a5, b4) => a5.address.localeCompare(b4.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger19.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode2(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode2(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys2);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify2(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger19.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger19.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger19.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode2(raw);
  }
  const sig = splitSignature(signature2);
  let v8 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v8 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v8) {
      logger19.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v8) {
    logger19.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v8));
  raw.push(stripZeros(arrayify2(sig.r)));
  raw.push(stripZeros(arrayify2(sig.s)));
  return encode2(raw);
}
function serialize2(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger19.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
    default:
      break;
  }
  return logger19.throwError(`unsupported transaction type: ${transaction.type}`, Logger2.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize4) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger19.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256(serialize4(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip1559(payload) {
  const transaction = decode2(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger19.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode2(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger19.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode2(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger19.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256(encode2(raw));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse2(rawTransaction) {
  const payload = arrayify2(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger19.throwError(`unsupported transaction type: ${payload[0]}`, Logger2.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

// node_modules/@ethersproject/contracts/lib.esm/_version.js
var version16 = "contracts/5.5.0";

// node_modules/@ethersproject/contracts/lib.esm/index.js
"use strict";
var __awaiter6 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger20 = new Logger2(version16);
var allowedTransactionKeys3 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter6(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger20.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger20.throwError("a provider or signer is needed to resolve ENS names", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger20.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter6(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger20.makeError("invalid value for array", Logger2.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v8) => resolveAddresses(resolver, v8, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter6(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger20.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter6(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger20.throwError("Contract with a Signer cannot override from", Logger2.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify2(data);
      for (let i5 = 0; i5 < bytes.length; i5++) {
        intrinsic += 4;
        if (bytes[i5]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger20.throwError("non-payable method cannot override value", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger20.throwError(`cannot override ${leftovers.map((l5) => JSON.stringify(l5)).join(",")}`, Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger20.throwError("estimate require a provider or signer", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e5) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger2.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger20.throwError("sending a transaction requires a signer", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var RunningEvent = class {
  constructor(tag, filter2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i5) => i5.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  getEmit(event) {
    return [event];
  }
};
var ErrorRunningEvent = class extends RunningEvent {
  constructor() {
    super("error", null);
  }
};
var FragmentRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger20.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag(filter2), filter2);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
};
var WildcardRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
};
var BaseContract = class {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    logger20.checkNew(new.target, Contract);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger20.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger20.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger20.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger20.throwError("provider is required to use ENS name as contract address", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger20.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e5) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
          if (code === "0x") {
            logger20.throwError("contract not deployed", Logger2.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  fallback(overrides) {
    if (!this.signer) {
      logger20.throwError("sending a transactions require a signer", Logger2.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger20.throwError("cannot override " + key2, Logger2.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger20.throwError("events require a provider or a signer with a provider", Logger2.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString2(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger20.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
};
var Contract = class extends BaseContract {
};
var ContractFactory = class {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes2(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString2(bytecodeHex) || bytecodeHex.length % 2) {
      logger20.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger20.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key2 in tx) {
        if (!allowedTransactionKeys3[key2]) {
          throw new Error("unknown transaction override " + key2);
        }
      }
    }
    ["data", "from", "to"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      logger20.throwError("cannot override " + key2, Logger2.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger20.throwError("non-payable constructor cannot override value", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger20.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger20.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger20.throwError("missing compiler output", Logger2.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};

// node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX = class {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    for (let i5 = 0; i5 < alphabet.length; i5++) {
      this._alphabetMap[alphabet.charAt(i5)] = i5;
    }
  }
  encode(value) {
    let source = arrayify2(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i5 = 0; i5 < source.length; ++i5) {
      let carry = source[i5];
      for (let j5 = 0; j5 < digits.length; ++j5) {
        carry += digits[j5] << 8;
        digits[j5] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k5 = 0; source[k5] === 0 && k5 < source.length - 1; ++k5) {
      string2 += this._leader;
    }
    for (let q5 = digits.length - 1; q5 >= 0; --q5) {
      string2 += this.alphabet[digits[q5]];
    }
    return string2;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i5 = 0; i5 < value.length; i5++) {
      let byte = this._alphabetMap[value[i5]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j5 = 0; j5 < bytes.length; ++j5) {
        carry += bytes[j5] * this.base;
        bytes[j5] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k5 = 0; value[k5] === this._leader && k5 < value.length - 1; ++k5) {
      bytes.push(0);
    }
    return arrayify2(new Uint8Array(bytes.reverse()));
  }
};
var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
var import_hash3 = __toModule(require_hash());

// node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

// node_modules/@ethersproject/sha2/lib.esm/_version.js
var version17 = "sha2/5.5.0";

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
"use strict";
var logger21 = new Logger2(version17);
function ripemd160(data) {
  return "0x" + import_hash3.default.ripemd160().update(arrayify2(data)).digest("hex");
}
function sha2562(data) {
  return "0x" + import_hash3.default.sha256().update(arrayify2(data)).digest("hex");
}
function sha512(data) {
  return "0x" + import_hash3.default.sha512().update(arrayify2(data)).digest("hex");
}
function computeHmac(algorithm, key2, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger21.throwError("unsupported algorithm " + algorithm, Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm], arrayify2(key2)).update(arrayify2(data)).digest("hex");
}

// node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
"use strict";
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify2(password);
  salt = arrayify2(salt);
  let hLen;
  let l5 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r6;
  let T6;
  for (let i5 = 1; i5 <= l5; i5++) {
    block1[salt.length] = i5 >> 24 & 255;
    block1[salt.length + 1] = i5 >> 16 & 255;
    block1[salt.length + 2] = i5 >> 8 & 255;
    block1[salt.length + 3] = i5 & 255;
    let U2 = arrayify2(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U2.length;
      T6 = new Uint8Array(hLen);
      l5 = Math.ceil(keylen / hLen);
      r6 = keylen - (l5 - 1) * hLen;
    }
    T6.set(U2);
    for (let j5 = 1; j5 < iterations; j5++) {
      U2 = arrayify2(computeHmac(hashAlgorithm, password, U2));
      for (let k5 = 0; k5 < hLen; k5++)
        T6[k5] ^= U2[k5];
    }
    const destPos = (i5 - 1) * hLen;
    const len = i5 === l5 ? r6 : hLen;
    DK.set(arrayify2(T6).slice(0, len), destPos);
  }
  return hexlify(DK);
}

// node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version18 = "wordlists/5.5.0";

// node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
"use strict";
var exportWordlist = false;
var logger22 = new Logger2(version18);
var Wordlist = class {
  constructor(locale) {
    logger22.checkAbstract(new.target, Wordlist);
    defineReadOnly(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i5 = 0; i5 < 2048; i5++) {
      const word = wordlist2.getWord(i5);
      if (i5 !== wordlist2.getWordIndex(word)) {
        return "0x";
      }
      words2.push(word);
    }
    return id(words2.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist) {
      try {
        const anyGlobal2 = window;
        if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
          if (!anyGlobal2._ethers.wordlists[name2]) {
            defineReadOnly(anyGlobal2._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
"use strict";
var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn = class extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords(this);
    return wordlist[index];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
};
var langEn = new LangEn();
Wordlist.register(langEn);

// node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
"use strict";
var wordlists = {
  en: langEn
};

// node_modules/@ethersproject/wordlists/lib.esm/index.js
"use strict";

// node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version19 = "hdnode/5.5.0";

// node_modules/@ethersproject/hdnode/lib.esm/index.js
"use strict";
var logger23 = new Logger2(version19);
var N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
  return Base58.encode(concat([data, hexDataSlice(sha2562(sha2562(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger23.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
var _constructorGuard4 = {};
var defaultPath = "m/44'/60'/0'/0/0";
var HDNode = class {
  constructor(constructorGuard, privateKey, publicKey2, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
    logger23.checkNew(new.target, HDNode);
    if (constructorGuard !== _constructorGuard4) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey2));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha2562(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index) {
    if (index > 4294967295) {
      throw new Error("invalid index - " + String(index));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify2(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify2(this.publicKey));
    }
    for (let i5 = 24; i5 >= 0; i5 -= 8) {
      data[33 + (i5 >> 3)] = index >> 24 - i5 & 255;
    }
    const I5 = arrayify2(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I5.slice(0, 32);
    const IR = I5.slice(32);
    let ki = null;
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek = new SigningKey(hexlify(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard4, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i5 = 0; i5 < components.length; i5++) {
      const component = components[i5];
      if (component.match(/^[0-9]+'$/)) {
        const index = parseInt(component.substring(0, component.length - 1));
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index);
      } else if (component.match(/^[0-9]+$/)) {
        const index = parseInt(component);
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify2(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I5 = arrayify2(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard4, bytes32(I5.slice(0, 32)), null, "0x00000000", bytes32(I5.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes = Base58.decode(extendedKey);
    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger23.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify(bytes.slice(5, 9));
    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes.slice(13, 45));
    const key2 = bytes.slice(45, 78);
    switch (hexlify(bytes.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard4, null, hexlify(key2), parentFingerprint, chainCode, index, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key2[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard4, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
    }
    return logger23.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
};
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger23.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify2(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset2 = 0;
  for (let i5 = 0; i5 < words2.length; i5++) {
    let index = wordlist2.getWordIndex(words2[i5].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset2 >> 3] |= 1 << 7 - offset2 % 8;
      }
      offset2++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify2(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify2(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i5 = 0; i5 < entropy.length; i5++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i5];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i5] >> 8 - remainingBits;
      indices.push(entropy[i5] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify2(sha2562(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger23.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}

// node_modules/@ethersproject/random/lib.esm/_version.js
var version20 = "random/5.5.1";

// node_modules/@ethersproject/random/lib.esm/random.js
"use strict";
var logger24 = new Logger2(version20);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
var crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto2 || !crypto2.getRandomValues) {
  logger24.warn("WARNING: Missing strong random number source");
  crypto2 = {
    getRandomValues: function(buffer2) {
      return logger24.throwError("no secure random source avaialble", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger24.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto2.getRandomValues(result);
  return arrayify2(result);
}

// node_modules/@ethersproject/random/lib.esm/shuffle.js
"use strict";
function shuffled(array2) {
  array2 = array2.slice();
  for (let i5 = array2.length - 1; i5 > 0; i5--) {
    const j5 = Math.floor(Math.random() * (i5 + 1));
    const tmp = array2[i5];
    array2[i5] = array2[j5];
    array2[j5] = tmp;
  }
  return array2;
}

// node_modules/@ethersproject/random/lib.esm/index.js
"use strict";

// node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
var import_aes_js = __toModule(require_aes_js());

// node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version21 = "json-wallets/5.5.0";

// node_modules/@ethersproject/json-wallets/lib.esm/utils.js
"use strict";
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify2(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify2(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i5 = 0; i5 < comps.length; i5++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i5]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes3) {
  const bytes = arrayify2(randomBytes3);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = hexlify(bytes);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}

// node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
"use strict";
var logger25 = new Logger2(version21);
var CrowdsaleAccount = class extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
};
function decrypt(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger25.throwArgumentError("invalid encseed", "json", json);
  }
  const key2 = arrayify2(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv);
  const seed = import_aes_js.default.padding.pkcs7.strip(arrayify2(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i5 = 0; i5 < seed.length; i5++) {
    seedHex += String.fromCharCode(seed[i5]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}

// node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
"use strict";
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}

// node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
var import_aes_js2 = __toModule(require_aes_js());
var import_scrypt_js = __toModule(require_scrypt());
"use strict";
var __awaiter7 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger26 = new Logger2(version21);
function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
var KeystoreAccount = class extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
};
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter);
    return arrayify2(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256(concat([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger26.throwError("unsupported cipher", Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify2(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger2.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc) {
  return arrayify2(pbkdf2(passwordBytes, salt, count2, dkLen, prfFunc));
}
function pbkdf22(passwordBytes, salt, count2, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError2 = function(name2, value) {
      return logger26.throwArgumentError("invalid key-derivation function parameters", name2, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N5 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r6 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p5 = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N5 || !r6 || !p5) {
        throwError2("kdf", kdf);
      }
      if ((N5 & N5 - 1) !== 0) {
        throwError2("N", N5);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N5, r6, p5, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError2("prf", prf);
      }
      const count2 = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count2, dkLen, prfFunc);
    }
  }
  return logger26.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt2(json, password, progressCallback) {
  return __awaiter7(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key2 = yield _computeKdfKey(data, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e5) {
    return Promise.reject(e5);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify2(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify2(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify2(options.salt);
  } else {
    salt = randomBytes(32);
    ;
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify2(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify2(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N5 = 1 << 17, r6 = 8, p5 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N5 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r6 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p5 = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N5, r6, p5, 64, progressCallback).then((key2) => {
    key2 = arrayify2(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify2(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      Crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N5,
          dklen: 32,
          p: p5,
          r: r6
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify2(mnemonicAesCtr.encrypt(entropy));
      const now2 = new Date();
      const timestamp2 = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp2 + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}

// node_modules/@ethersproject/json-wallets/lib.esm/index.js
"use strict";
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}

// node_modules/@ethersproject/wallet/lib.esm/_version.js
var version22 = "wallet/5.5.0";

// node_modules/@ethersproject/wallet/lib.esm/index.js
"use strict";
var __awaiter8 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger27 = new Logger2(version22);
function isAccount(value) {
  return value != null && isHexString2(value.privateKey, 32) && value.address != null;
}
function hasMnemonic2(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
var Wallet2 = class extends Signer {
  constructor(privateKey, provider) {
    logger27.checkNew(new.target, Wallet2);
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger27.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic2(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger27.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger27.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider && !Provider.isProvider(provider)) {
      logger27.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new Wallet2(this, provider);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger27.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature2 = this._signingKey().signDigest(keccak256(serialize2(tx)));
      return serialize2(tx, signature2);
    });
  }
  signMessage(message) {
    return __awaiter8(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain2, types, value) {
    return __awaiter8(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types, value, (name2) => {
        if (this.provider == null) {
          logger27.throwError("cannot resolve ENS names without a provider", Logger2.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt(this, password, options, progressCallback);
  }
  static createRandom(options) {
    let entropy = randomBytes(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify2(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet2.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json, password, progressCallback) {
    return decryptJsonWallet(json, password, progressCallback).then((account) => {
      return new Wallet2(account);
    });
  }
  static fromEncryptedJsonSync(json, password) {
    return new Wallet2(decryptJsonWalletSync(json, password));
  }
  static fromMnemonic(mnemonic, path, wordlist2) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet2(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
  }
};
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain2, types, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain2, types, value), signature2);
}

// node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});

// node_modules/@ethersproject/networks/lib.esm/_version.js
var version23 = "networks/5.5.2";

// node_modules/@ethersproject/networks/lib.esm/index.js
"use strict";
var logger28 = new Logger2(version23);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider) {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider) {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider) {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider) {
      const skip2 = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider) {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: { chainId: 137, name: "matic" },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: { chainId: 10, name: "optimism" },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger28.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger28.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

// node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  decode: () => decode3,
  encode: () => encode4
});

// node_modules/@ethersproject/base64/lib.esm/base64.js
"use strict";
function decode3(textData) {
  textData = atob(textData);
  const data = [];
  for (let i5 = 0; i5 < textData.length; i5++) {
    data.push(textData.charCodeAt(i5));
  }
  return arrayify2(data);
}
function encode4(data) {
  data = arrayify2(data);
  let textData = "";
  for (let i5 = 0; i5 < data.length; i5++) {
    textData += String.fromCharCode(data[i5]);
  }
  return btoa(textData);
}

// node_modules/@ethersproject/base64/lib.esm/index.js
"use strict";

// node_modules/@ethersproject/web/lib.esm/_version.js
var version24 = "web/5.5.1";

// node_modules/@ethersproject/web/lib.esm/geturl.js
"use strict";
var __awaiter9 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter9(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify2(new Uint8Array(body))
    };
  });
}

// node_modules/@ethersproject/web/lib.esm/index.js
"use strict";
var __awaiter10 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger29 = new Logger2(version24);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type2) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type2 && (type2.split("/")[0] === "text" || type2.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify(value);
  }
  return value;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger29.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger29.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger29.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger29.throwError("basic authentication requires a secure https url", Logger2.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode4(toUtf8Bytes(authorization))
      };
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode3(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger29.throwError("processing response error", Logger2.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer3 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout2) {
        timer3 = setTimeout(() => {
          if (timer3 == null) {
            return;
          }
          timer3 = null;
          reject(logger29.makeError("timeout", Logger2.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer3 == null) {
        return;
      }
      clearTimeout(timer3);
      timer3 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter10(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger29.throwError("missing response", Logger2.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (response.statusCode < 200 || response.statusCode >= 300) {
          runningTimeout.cancel();
          logger29.throwError("bad response", Logger2.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger29.throwError("processing response error", Logger2.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger29.throwError("failed response", Logger2.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger29.throwError("invalid JSON", Logger2.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k5) => k5.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer3 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer3) {
        clearTimeout(timer3);
      }
      return true;
    };
    if (options.timeout) {
      timer3 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check, timeout2);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var import_bech32 = __toModule(require_bech32());

// node_modules/@ethersproject/providers/lib.esm/_version.js
var version25 = "providers/5.5.3";

// node_modules/@ethersproject/providers/lib.esm/formatter.js
"use strict";
var logger30 = new Logger2(version25);
var Formatter = class {
  constructor() {
    logger30.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash4 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type2 = this.type.bind(this);
    const strictData = (v8) => {
      return this.data(v8, true);
    };
    formats.transaction = {
      hash: hash4,
      type: type2,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash4, null),
      blockNumber: Formatter.allowNull(number2, null),
      transactionIndex: Formatter.allowNull(number2, null),
      confirmations: Formatter.allowNull(number2, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number2),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number2),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number2),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash4,
      address,
      topics: Formatter.arrayOf(hash4),
      data,
      logIndex: number2,
      blockHash: hash4
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number2,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash4,
      transactionHash: hash4,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number2),
      type: type2
    };
    formats.block = {
      hash: hash4,
      parentHash: hash4,
      number: number2,
      timestamp: number2,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: address,
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash4)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash4, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number2),
      blockHash: Formatter.allowNull(hash4),
      transactionIndex: number2,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash4),
      transactionHash: hash4,
      logIndex: number2
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  bigNumber(value) {
    return BigNumber.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString2(value)) {
        return value.toLowerCase();
      }
    }
    return logger30.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString2(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }
    if (typeof blockTag === "number" || isHexString2(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger30.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v8 = BigNumber.from(value);
    try {
      return v8.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString2(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString2(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString2(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse2(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger30.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger30.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger30.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v8) => this.topics(v8));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key2 in format) {
      try {
        const value = format[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  static arrayOf(format) {
    return function(array2) {
      if (!Array.isArray(array2)) {
        throw new Error("not an array");
      }
      const result = [];
      array2.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
"use strict";
var __awaiter11 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger31 = new Logger2(version25);
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger31.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger31.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = class {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha2562(sha2562(data)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result) {
  try {
    return toUtf8String(_parseBytes(result));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result) {
  if (result === "0x") {
    return null;
  }
  const offset2 = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset2, offset2 + 32)).toNumber();
  return hexDataSlice(result, offset2 + 32, offset2 + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger31.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
var Resolver = class {
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  _fetchBytes(selector, parameters) {
    return __awaiter11(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      try {
        return _parseBytes(yield this.provider.call(tx));
      } catch (error) {
        if (error.code === Logger2.errors.CALL_EXCEPTION) {
          return null;
        }
        return null;
      }
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger31.throwError(`unsupported coin type: ${coinType}`, Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify2(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version29 = bytes[0];
      if (version29 === 0) {
        if (length !== 20 && length !== 32) {
          version29 = -1;
        }
      } else {
        version29 = -1;
      }
      if (version29 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words2 = import_bech32.default.toWords(bytes.slice(2));
        words2.unshift(version29);
        return import_bech32.default.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const transaction = {
            to: this.address,
            data: "0x3b3b57de" + namehash(this.name).substring(2)
          };
          const hexBytes2 = yield this.provider.call(transaction);
          if (hexBytes2 === "0x" || hexBytes2 === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(hexBytes2);
        } catch (error) {
          if (error.code === Logger2.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger31.throwError(`invalid or unsupported coin data`, Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter11(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i5 = 0; i5 < matchers.length; i5++) {
          const match = avatar.match(matchers[i5]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx));
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter11(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      return logger31.throwError(`invalid or unsupported content hash data`, Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter11(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider {
  constructor(network) {
    logger31.checkNew(new.target, Provider);
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger31.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter11(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger31.throwError("no network detected", Logger2.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger2.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter11(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger31.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger31.makeError("network block skew detected", Logger2.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i5 = this._emitted.block + 1; i5 <= blockNumber; i5++) {
          this.emit("block", i5);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash4 = event.hash;
            let runner = this.getTransactionReceipt(hash4).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash4] = receipt.blockNumber;
              this.emit(hash4, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            const filter2 = event.filter;
            filter2.fromBlock = this._lastBlockNumber + 1;
            filter2.toBlock = blockNumber;
            const runner = this.getLogs(filter2).then((logs) => {
              if (logs.length === 0) {
                return;
              }
              logs.forEach((log) => {
                this._emitted["b:" + log.blockHash] = log.blockNumber;
                this._emitted["t:" + log.transactionHash] = log.blockNumber;
                this.emit(filter2, log);
              });
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter11(this, void 0, void 0, function* () {
      return logger31.throwError("provider does not support network detection", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter11(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger31.makeError("underlying network changed", Logger2.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout2) {
    return __awaiter11(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout2 || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout2, replaceable) {
    return __awaiter11(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter11(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter11(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger31.makeError("transaction was replaced", Logger2.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout2 === "number" && timeout2 > 0) {
          const timer3 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger31.makeError("timeout exceeded", Logger2.errors.TIMEOUT, { timeout: timeout2 }));
          }, timeout2);
          if (timer3.unref) {
            timer3.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer3);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter11(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger31.throwError("bad result from backend", Logger2.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger31.throwError("bad result from backend", Logger2.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger31.throwError("bad result from backend", Logger2.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger31.throwError("bad result from backend", Logger2.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p5) => hexValue(p5))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger31.throwError("bad result from backend", Logger2.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash4, startBlock) {
    if (hash4 != null && hexDataLength(hash4) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash4 != null && tx.hash !== hash4) {
      logger31.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger2.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash4 });
    }
    result.wait = (confirms, timeout2) => __awaiter11(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout2 == null) {
        timeout2 = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout2, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger31.throwError("transaction failed", Logger2.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t5) => hexlify(t5));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash4 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash4, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v8) => v8 ? this._getAddress(v8) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v8) => v8 ? BigNumber.from(v8) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v8) => v8 != null ? v8 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v8) => v8 ? hexlify(v8) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter11(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  call(transaction, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("call", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger31.throwError("bad result from backend", Logger2.errors.SERVER_ERROR, {
          method: "call",
          params,
          result,
          error
        });
      }
    });
  }
  estimateGas(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger31.throwError("bad result from backend", Logger2.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter11(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger31.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger31.throwError("ENS name not configured", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString2(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString2(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger31.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter11(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i5 = 0; i5 < block.transactions.length; i5++) {
            const tx = block.transactions[i5];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter11(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter11(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger31.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter11(this, void 0, void 0, function* () {
      try {
        const address = yield this._getResolver(name2);
        if (address == null) {
          return null;
        }
        return new Resolver(this, address, name2);
      } catch (error) {
        if (error.code === Logger2.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _getResolver(name2) {
    return __awaiter11(this, void 0, void 0, function* () {
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger31.throwError("network does not support ENS", Logger2.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
      }
      const transaction = {
        to: network.ensAddress,
        data: "0x0178b8bf" + namehash(name2).substring(2)
      };
      try {
        return this.formatter.callAddress(yield this.call(transaction));
      } catch (error) {
        if (error.code === Logger2.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  resolveName(name2) {
    return __awaiter11(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString2(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger31.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter11(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddress = yield this._getResolver(reverseName);
      if (!resolverAddress) {
        return null;
      }
      let bytes = arrayify2(yield this.call({
        to: resolverAddress,
        data: "0x691f3431" + namehash(reverseName).substring(2)
      }));
      if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {
        return null;
      }
      bytes = bytes.slice(32);
      if (bytes.length < 32) {
        return null;
      }
      const length = BigNumber.from(bytes.slice(0, 32)).toNumber();
      bytes = bytes.slice(32);
      if (length > bytes.length) {
        return null;
      }
      const name2 = toUtf8String(bytes.slice(0, length));
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter11(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString2(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(reverseName);
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, "_", address);
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger31.throwError(method + " not implemented", Logger2.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e5) => e5.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e5) => e5.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag2(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
"use strict";
var __awaiter12 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger32 = new Logger2(version25);
var errorGas = ["call", "estimateGas"];
function checkError(method, error, params) {
  if (method === "call" && error.code === Logger2.errors.SERVER_ERROR) {
    const e5 = error.error;
    if (e5 && e5.message.match("reverted") && isHexString2(e5.data)) {
      return e5.data;
    }
    logger32.throwError("missing revert data in call exception", Logger2.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  }
  let message = error.message;
  if (error.code === Logger2.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger32.throwError("insufficient funds for intrinsic transaction cost", Logger2.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger32.throwError("nonce has already been used", Logger2.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger32.throwError("replacement fee too low", Logger2.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger32.throwError("legacy pre-eip-155 transactions not supported", Logger2.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger32.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger2.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout2);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var _constructorGuard5 = {};
var JsonRpcSigner = class extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger32.checkNew(new.target, JsonRpcSigner);
    super();
    if (constructorGuard !== _constructorGuard5) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger32.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger32.throwError("cannot alter JSON-RPC Signer connection", Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger32.throwError("unknown account #" + this._index, Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter12(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger32.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger32.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash4) => {
        return hash4;
      }, (error) => {
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger32.throwError("signing transactions is unsupported", Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter12(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash4 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter12(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash4);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash4, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash4;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter12(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
    });
  }
  _legacySignMessage(message) {
    return __awaiter12(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
    });
  }
  _signTypedData(domain2, types, value) {
    return __awaiter12(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        address.toLowerCase(),
        JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
      ]);
    });
  }
  unlock(password) {
    return __awaiter12(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash4) => {
      return {
        hash: hash4,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash4, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys4 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    logger32.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter12(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger32.throwError("could not detect network", Logger2.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger32.throwError("could not detect network", Logger2.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a5) => this.formatter.address(a5));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger32.throwError(method + " not implemented", Logger2.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq2 = Promise.resolve();
          hashes.forEach(function(hash4) {
            self2._emitted["t:" + hash4.toLowerCase()] = "pending";
            seq2 = seq2.then(function() {
              return self2.getTransaction(hash4).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq2.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys4);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(transaction[key2]);
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ws.js
"use strict";
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger47 = new Logger2(version25);
  WS = function() {
    logger47.throwError("WebSockets not supported in this environment", Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
"use strict";
var __awaiter13 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger33 = new Logger2(version25);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger33.throwError("WebSocketProvider does not support 'any' network yet", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    super(url, network);
    this._pollingInterval = -1;
    this._wsReady = false;
    defineReadOnly(this, "_websocket", new WS(this.connection.url));
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this._websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this._websocket.send(this._requests[id2].payload);
      });
    };
    this._websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger33.throwError("cannot reset events block on WebSocketProvider", Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger33.throwError("cannot set polling interval on WebSocketProvider", Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter13(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger33.throwError("cannot set polling on WebSocketProvider", Logger2.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this._websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter13(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash4 = event2.hash;
          this.getTransactionReceipt(hash4).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash4, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e5) => e5.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e5) => e5.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this._websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this._websocket.onopen = function() {
            resolve(true);
          };
          this._websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this._websocket.close(1e3);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
"use strict";
var __awaiter14 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger34 = new Logger2(version25);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter14(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger34.throwError("no network detected", Logger2.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger34.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key2) => {
        defineReadOnly(this, key2, apiKey[key2]);
      });
    }
  }
  _startPending() {
    logger34.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger34.throwError("API provider does not support signing", Logger2.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network, apiKey) {
    return logger34.throwError("not implemented; sub-classes must override getUrl", Logger2.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
"use strict";
var logger35 = new Logger2(version25);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger35.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "ropsten":
        host = "eth-ropsten.alchemyapi.io/v2/";
        break;
      case "rinkeby":
        host = "eth-rinkeby.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.alchemyapi.io/v2/";
        break;
      case "kovan":
        host = "eth-kovan.alchemyapi.io/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-rinkeby":
        host = "arb-rinkeby.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-kovan":
        host = "opt-kovan.g.alchemy.com/v2/";
        break;
      default:
        logger35.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
"use strict";
var __awaiter15 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger36 = new Logger2(version25);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger36.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger36.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter15(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
"use strict";
var __awaiter16 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger37 = new Logger2(version25);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key2 in transaction) {
    if (transaction[key2] == null) {
      continue;
    }
    let value = transaction[key2];
    if (key2 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
      value = hexValue(hexlify(value));
    } else if (key2 === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key2] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || result.message != "OK") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
var defaultApiKey2 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger2.errors.SERVER_ERROR) {
    const e5 = error.error;
    if (e5 && (e5.message.match(/reverted/i) || e5.message.match(/VM execution error/i))) {
      let data = e5.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString2(data)) {
        return data;
      }
      logger37.throwError("missing revert data in call exception", Logger2.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger2.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger37.throwError("insufficient funds for intrinsic transaction cost", Logger2.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger37.throwError("nonce has already been used", Logger2.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger37.throwError("replacement fee too low", Logger2.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger37.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger2.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    logger37.checkNew(new.target, EtherscanProvider);
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || defaultApiKey2);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "ropsten":
        return "https://api-ropsten.etherscan.io";
      case "rinkeby":
        return "https://api-rinkeby.etherscan.io";
      case "kovan":
        return "https://api-kovan.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      default:
    }
    return logger37.throwArgumentError("unsupported network", "network", name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key2) => {
      const value = params[key2];
      if (value != null) {
        accum += `&${key2}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter16(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key2) => {
          return `${key2}=${payload[key2]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter16(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter16(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger37.throwError("unsupported topic count", Logger2.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger37.throwError("unsupported topic format", Logger2.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i5 = 0; i5 < logs.length; i5++) {
            const log = logs[i5];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter16(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key2) {
          if (tx[key2] == "") {
            delete tx[key2];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
};

// node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
"use strict";
var __awaiter17 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger38 = new Logger2(version25);
function now() {
  return new Date().getTime();
}
function checkNetworks(networks3) {
  let result = null;
  for (let i5 = 0; i5 < networks3.length; i5++) {
    const network = networks3[i5];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger38.throwArgumentError("provider mismatch", "networks", networks3);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a5 = values[middle - 1], b4 = values[middle];
  if (maxDelta != null && Math.abs(a5 - b4) > maxDelta) {
    return null;
  }
  return (a5 + b4) / 2;
}
function serialize3(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i5) => serialize3(i5)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key2) => {
      let v8 = value[key2];
      if (typeof v8 === "function") {
        v8 = "[function]";
      } else {
        v8 = serialize3(v8);
      }
      return JSON.stringify(key2) + ":" + v8;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer3 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer3) {
        clearTimeout(timer3);
        timer3 = null;
      }
      resolve();
    };
    timer3 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
var ForwardErrors = [
  Logger2.errors.CALL_EXCEPTION,
  Logger2.errors.INSUFFICIENT_FUNDS,
  Logger2.errors.NONCE_EXPIRED,
  Logger2.errors.REPLACEMENT_UNDERPRICED,
  Logger2.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now2) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now2) {
    result.duration = now2 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c5) => {
      const value = normalize(c5.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c5.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i5 = 0; i5 < keys.length; i5++) {
      const check = tally[keys[i5]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize = serialize3;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c5) => c5.result);
        let blockNumber = median(configs.map((c5) => c5.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c5) => c5.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c5) => c5.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize3(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize3(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize3(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize, provider.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter17(this, void 0, void 0, function* () {
    const provider = config2.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter17(this, void 0, void 0, function* () {
    let provider = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString2(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString2(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString2(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString2(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter2 = params.filter;
        if (filter2.fromBlock && isHexString2(filter2.fromBlock) || filter2.toBlock && isHexString2(filter2.toBlock)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getLogs(filter2);
      }
    }
    return logger38.throwError("unknown method error", Logger2.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    logger38.checkNew(new.target, FallbackProvider);
    if (providers.length === 0) {
      logger38.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger38.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c5) => accum + c5.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger38.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c5) => c5.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter17(this, void 0, void 0, function* () {
      const networks3 = yield Promise.all(this.providerConfigs.map((c5) => c5.provider.getNetwork()));
      return checkNetworks(networks3);
    });
  }
  perform(method, params) {
    return __awaiter17(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results2 = yield Promise.all(this.providerConfigs.map((c5) => {
          return c5.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i6 = 0; i6 < results2.length; i6++) {
          const result = results2[i6];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results2[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a5, b4) => a5.priority - b4.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i5 = 0;
      let first2 = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c5) => c5.runner && t0 - c5.start < c5.stallTimeout).reduce((accum, c5) => accum + c5.weight, 0);
        while (inflightWeight < this.quorum && i5 < configs.length) {
          const config2 = configs[i5++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall2(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c5) => {
          if (c5.done || !c5.runner) {
            return;
          }
          waiting.push(c5.runner);
          if (c5.staller) {
            waiting.push(c5.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results2 = configs.filter((c5) => c5.done && c5.error == null);
        if (results2.length >= this.quorum) {
          const result = processFunc(results2);
          if (result !== void 0) {
            configs.forEach((c5) => {
              if (c5.staller) {
                c5.staller.cancel();
              }
              c5.cancelled = true;
            });
            return result;
          }
          if (!first2) {
            yield stall2(100).getPromise();
          }
          first2 = false;
        }
        const errors = configs.reduce((accum, c5) => {
          if (!c5.done || c5.error == null) {
            return accum;
          }
          const code = c5.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = { error: c5.error, weight: 0 };
            }
            accum[code].weight += c5.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c5) => {
            if (c5.staller) {
              c5.staller.cancel();
            }
            c5.cancelled = true;
          });
          const e5 = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e5[name2] == null) {
              return;
            }
            props[name2] = e5[name2];
          });
          logger38.throwError(e5.reason || e5.message, errorCode, props);
        });
        if (configs.filter((c5) => !c5.done).length === 0) {
          break;
        }
      }
      configs.forEach((c5) => {
        if (c5.staller) {
          c5.staller.cancel();
        }
        c5.cancelled = true;
      });
      return logger38.throwError("failed to meet quorum", Logger2.errors.SERVER_ERROR, {
        method,
        params,
        results: configs.map((c5) => exposeDebugConfig(c5)),
        provider: this
      });
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
"use strict";
var IpcProvider = null;

// node_modules/@ethersproject/providers/lib.esm/infura-provider.js
"use strict";
var logger39 = new Logger2(version25);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger39.throwError("INFURA WebSocket project secrets unsupported", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger39.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger39.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "ropsten":
        host = "ropsten.infura.io";
        break;
      case "rinkeby":
        host = "rinkeby.infura.io";
        break;
      case "kovan":
        host = "kovan.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-kovan":
        host = "optimism-kovan.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-rinkeby":
        host = "arbitrum-rinkeby.infura.io";
        break;
      default:
        logger39.throwError("unsupported network", Logger2.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
};

// node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
"use strict";
var logger40 = new Logger2(version25);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger40.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger40.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger40.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
"use strict";
var logger41 = new Logger2(version25);
var defaultApplicationIds = {
  homestead: "6004bcd10040261633ade990",
  ropsten: "6004bd4d0040261633ade991",
  rinkeby: "6004bda20040261633ade994",
  goerli: "6004bd860040261633ade992"
};
var PocketProvider = class extends UrlJsonRpcProvider {
  constructor(network, apiKey) {
    if (apiKey == null) {
      const n3 = getStatic(new.target, "getNetwork")(network);
      if (n3) {
        const applicationId = defaultApplicationIds[n3.name];
        if (applicationId) {
          apiKey = {
            applicationId,
            loadBalancer: true
          };
        }
      }
      if (apiKey == null) {
        logger41.throwError("unsupported network", Logger2.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
      }
    }
    super(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      logger41.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
    }
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: false,
      applicationSecretKey: null
    };
    if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      logger41.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
      logger41.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else if (apiKey.applicationId) {
      logger41.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else {
      logger41.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      default:
        logger41.throwError("unsupported network", Logger2.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    let url = null;
    if (apiKey.loadBalancer) {
      url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    } else {
      url = `https://${host}/v1/${apiKey.applicationId}`;
    }
    const connection = { url };
    connection.headers = {};
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationIds[this.network.name];
  }
};

// node_modules/@ethersproject/providers/lib.esm/web3-provider.js
"use strict";
var logger42 = new Logger2(version25);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    logger42.checkNew(new.target, Web3Provider);
    if (provider == null) {
      logger42.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger42.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};

// node_modules/@ethersproject/providers/lib.esm/index.js
"use strict";
var logger43 = new Logger2(version25);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          return new JsonRpcProvider(network);
        case "ws":
          return new WebSocketProvider(network);
        default:
          logger43.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n3 = getNetwork(network);
  if (!n3 || !n3._defaultProvider) {
    logger43.throwError("unsupported getDefaultProvider network", Logger2.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n3._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger2,
  ParamType: () => ParamType,
  RLP: () => lib_exports,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify2,
  base58: () => Base58,
  base64: () => lib_exports3,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes2,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString2,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse2,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize2,
  sha256: () => sha2562,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack2,
  soliditySha256: () => sha2563,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});

// node_modules/@ethersproject/solidity/lib.esm/_version.js
var version26 = "solidity/5.5.0";

// node_modules/@ethersproject/solidity/lib.esm/index.js
"use strict";
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
var Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
var logger44 = new Logger2(version26);
function _pack(type2, value, isArray2) {
  switch (type2) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify2(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify2(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify2(value);
  }
  let match = type2.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger44.throwArgumentError("invalid number type", "type", type2);
    }
    if (isArray2) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type2.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger44.throwArgumentError("invalid bytes type", "type", type2);
    }
    if (arrayify2(value).byteLength !== size) {
      logger44.throwArgumentError(`invalid value for ${type2}`, "value", value);
    }
    if (isArray2) {
      return arrayify2((value + Zeros2).substring(0, 66));
    }
    return value;
  }
  match = type2.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count2 = parseInt(match[2] || String(value.length));
    if (count2 != value.length) {
      logger44.throwArgumentError(`invalid array length for ${type2}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger44.throwArgumentError("invalid type", "type", type2);
}
function pack2(types, values) {
  if (types.length != values.length) {
    logger44.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type2, index) {
    tight.push(_pack(type2, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values) {
  return keccak256(pack2(types, values));
}
function sha2563(types, values) {
  return sha2562(pack2(types, values));
}

// node_modules/@ethersproject/units/lib.esm/_version.js
var version27 = "units/5.5.0";

// node_modules/@ethersproject/units/lib.esm/index.js
"use strict";
var logger45 = new Logger2(version27);
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger45.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger45.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}

// node_modules/ethers/lib.esm/utils.js
"use strict";

// node_modules/ethers/lib.esm/_version.js
var version28 = "ethers/5.5.4";

// node_modules/ethers/lib.esm/ethers.js
"use strict";
var logger46 = new Logger2(version28);

// node_modules/ethers/lib.esm/index.js
"use strict";
try {
  const anyGlobal2 = window;
  if (anyGlobal2._ethers == null) {
    anyGlobal2._ethers = ethers_exports;
  }
} catch (error) {
}

// node_modules/@portis/web3/es/networks.js
function networkAdapter(network, gasRelay) {
  var networkObj = typeof network === "string" ? Object.assign({}, networks2[network]) : network;
  if (typeof networkObj !== "object") {
    throw new Error("[Portis] illegal 'network' parameter. Read more about it here: https://docs.portis.io/#/configuration?id=network");
  }
  if (!networkObj.nodeUrl) {
    throw new Error("[Portis] 'nodeUrl' is required. Read more about it here: https://docs.portis.io/#/configuration?id=network");
  }
  if (gasRelay && !networkObj.gasRelayHubAddress) {
    throw new Error("[Portis] can't find default gas relay hub for " + network);
  }
  if (typeof network === "string" && !gasRelay) {
    delete networkObj.gasRelayHubAddress;
  }
  return networkObj;
}
var networks2 = {
  mainnet: {
    nodeUrl: "https://mainnet.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "1",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  ropsten: {
    nodeUrl: "https://ropsten.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "3",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  rinkeby: {
    nodeUrl: "https://rinkeby.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "4",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  goerli: {
    nodeUrl: "https://goerli.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "5"
  },
  ubiq: {
    nodeUrl: "https://rpc1.ubiqscan.io",
    chainId: "8"
  },
  thundercoreTestnet: {
    nodeUrl: "https://testnet-rpc.thundercore.com:8544",
    chainId: "18"
  },
  orchid: {
    nodeUrl: "https://public-node.rsk.co",
    chainId: "30"
  },
  orchidTestnet: {
    nodeUrl: "https://public-node.testnet.rsk.co",
    chainId: "31"
  },
  kovan: {
    nodeUrl: "https://kovan.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "42",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  classic: {
    nodeUrl: "https://ethereumclassic.network",
    chainId: "61"
  },
  sokol: {
    nodeUrl: "https://sokol.poa.network",
    chainId: "77"
  },
  core: {
    nodeUrl: "https://core.poa.network",
    chainId: "99"
  },
  xdai: {
    nodeUrl: "https://dai.poa.network",
    chainId: "100",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  thundercore: {
    nodeUrl: "https://mainnet-rpc.thundercore.com",
    chainId: "108"
  },
  fuse: {
    nodeUrl: "https://rpc.fusenet.io",
    chainId: "122"
  },
  lightstreams: {
    nodeUrl: "https://node.mainnet.lightstreams.io",
    chainId: "163"
  },
  matic: {
    nodeUrl: "https://polygon-rpc.com",
    chainId: "137"
  },
  maticMumbai: {
    nodeUrl: "https://rpc-mumbai.matic.today",
    chainId: "80001"
  },
  maticAlpha: {
    nodeUrl: "https://alpha.ethereum.matic.network",
    chainId: "4626"
  },
  maticTestnet: {
    nodeUrl: "https://testnet2.matic.network",
    chainId: "8995"
  }
};

// node_modules/@portis/web3/es/utils/isClientSide.js
var isClientSide = function() {
  return !!(typeof window !== "undefined" && window.document);
};

// node_modules/@portis/web3/es/utils/onWindowLoad.js
var loaded = false;
function onWindowLoad() {
  return new Promise(function(resolve, reject) {
    if (!isClientSide()) {
      reject();
    } else if (loaded) {
      resolve();
    } else if (["loaded", "interactive", "complete"].indexOf(document.readyState) > -1) {
      loaded = true;
      resolve();
    } else {
      window.addEventListener("load", function() {
        loaded = true;
        resolve();
      }, false);
    }
  });
}

// node_modules/@portis/web3/es/utils/secureOrigin.js
function validateSecureOrigin() {
  var isLocalhost = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  var isSecureOrigin = location.protocol === "https:";
  var isSecure = isLocalhost || isSecureOrigin;
  if (!isSecure) {
    throw "[Portis] Access to the WebCrypto API is restricted to secure origins.\nIf this is a development environment please use http://localhost:" + location.port + " instead.\nOtherwise, please use an SSL certificate.";
  }
}

// node_modules/@portis/web3/es/widget/widgetManager.js
var import_penpal = __toModule(require_lib3());

// node_modules/@portis/web3/es/styles.js
var styles = "\n.por_portis-container {\n  position: fixed;\n  width: 0px;\n  height: 0px;\n  top: 0px;\n  right: 0px;\n  z-index: 2147483647;\n}\n\n@media (max-width: 576px) {\n  .por_portis-container {\n    bottom: 0;\n    top: auto;\n  }\n}\n\n.por_portis-widget-frame {\n  position: fixed;\n  width: 375px;\n  height: 0;\n  top: 20px;\n  right: 20px;\n  box-shadow: 0 5px 40px rgba(0,0,0,.16);\n  border-radius: 8px;\n  overflow: hidden;\n  z-index: 2147483000;\n}\n\n@media (max-width: 576px) {\n  .por_portis-widget-frame {\n    bottom: 0;\n    top: auto;\n    width: 100%;\n    right: 0;\n    left: 0;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n}\n";

// node_modules/@portis/web3/es/widget/widgetManager.js
var __awaiter18 = function(thisArg, _arguments, P4, generator) {
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P4(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _10 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f7, y5, t5, g5;
  return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
    return this;
  }), g5;
  function verb(n3) {
    return function(v8) {
      return step([n3, v8]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_10)
      try {
        if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
          return t5;
        if (y5 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _10.label++;
            return { value: op[1], done: false };
          case 5:
            _10.label++;
            y5 = op[1];
            op = [0];
            continue;
          case 7:
            op = _10.ops.pop();
            _10.trys.pop();
            continue;
          default:
            if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _10 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _10.label = op[1];
              break;
            }
            if (op[0] === 6 && _10.label < t5[1]) {
              _10.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _10.label < t5[2]) {
              _10.label = t5[2];
              _10.ops.push(op);
              break;
            }
            if (t5[2])
              _10.ops.pop();
            _10.trys.pop();
            continue;
        }
        op = body.call(thisArg, _10);
      } catch (e5) {
        op = [6, e5];
        y5 = 0;
      } finally {
        f7 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var WIDGET_URL = process.env.PORTIS_WIDGET_URL || "https://widget.portis.io";
var STAGING_WIDGET_URL = "https://widget-staging.portis.io";
var FEATURE_WIDGET_URL = "https://widget-feature.portis.io";
var PORTIS_IFRAME_CLASS = "por_portis-widget-frame";
var PORTIS_CONTAINER_CLASS = "por_portis-container";
function windowLoadHandler() {
  if (document.getElementsByClassName(PORTIS_IFRAME_CLASS).length) {
    console.warn("Portis script was already loaded. This might cause unexpected behavior. If loading with a <script> tag, please make sure that you only load it once.");
  }
}
var WidgetManager = function() {
  function WidgetManager2(_widgetConfig, _clearProviderSession) {
    this._widgetConfig = _widgetConfig;
    this._clearProviderSession = _clearProviderSession;
    this._widgetUrl = WIDGET_URL;
    this._onLoginCallback = function() {
    };
    this._onLogoutCallback = function() {
    };
    this._onErrorCallback = function() {
    };
    validateSecureOrigin();
    if (_widgetConfig.staging) {
      console.warn("Please note: you are using the Portis STAGING environment.");
      this._widgetUrl = STAGING_WIDGET_URL;
    } else if (_widgetConfig.feature) {
      console.warn("Please note: you are using the Portis FEATURE environment.");
      this._widgetUrl = FEATURE_WIDGET_URL;
    }
    WidgetManager2._checkIfWidgetAlreadyInitialized();
  }
  WidgetManager2.prototype.getWidget = function() {
    return __awaiter18(this, void 0, void 0, function() {
      var _a2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!!this.widgetInstance)
              return [3, 2];
            if (!this.widgetPromise) {
              this.widgetPromise = this._initWidget();
            }
            _a2 = this;
            return [4, this.widgetPromise];
          case 1:
            _a2.widgetInstance = _b.sent();
            _b.label = 2;
          case 2:
            return [2, this.widgetInstance];
        }
      });
    });
  };
  WidgetManager2.prototype.setDefaultEmail = function(email) {
    this._widgetConfig.defaultEmail = email;
  };
  WidgetManager2.prototype.setOnLoginCallback = function(callback) {
    this._onLoginCallback = callback;
  };
  WidgetManager2.prototype.setOnLogoutCallback = function(callback) {
    this._onLogoutCallback = callback;
  };
  WidgetManager2.prototype.setOnActiveWalletChangedCallback = function(callback) {
    this._onActiveWalletChangedCallback = callback;
  };
  WidgetManager2.prototype.setOnErrorCallback = function(callback) {
    this._onErrorCallback = callback;
  };
  WidgetManager2.prototype.showPortis = function() {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.showPortis(this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.getCampaignInfo = function(campaignId) {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.getCampaignInfo(campaignId)];
        }
      });
    });
  };
  WidgetManager2.prototype.claimVoucher = function(voucherId) {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.claimVoucher(voucherId, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.logout = function() {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.logout()];
        }
      });
    });
  };
  WidgetManager2.prototype.getExtendedPublicKey = function(path, coin) {
    if (path === void 0) {
      path = "m/44'/60'/0'/0/0";
    }
    if (coin === void 0) {
      coin = "Ethereum";
    }
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.getExtendedPublicKey(path, coin, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.importWallet = function(mnemonicOrPrivateKey) {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.importWallet(mnemonicOrPrivateKey, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.isLoggedIn = function() {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.isLoggedIn()];
        }
      });
    });
  };
  WidgetManager2.prototype.signBitcoinTransaction = function(params) {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.signBitcoinTransaction(params, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.showBitcoinWallet = function(path) {
    if (path === void 0) {
      path = "m/49'/0'/0'/0/0";
    }
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.showBitcoinWallet(path, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.purchaseERC20 = function(params) {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.purchaseERC20(params, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2._checkIfWidgetAlreadyInitialized = function() {
    if (document.getElementsByClassName(PORTIS_CONTAINER_CLASS).length) {
      console.warn("An instance of Portis was already initialized. This is probably a mistake. Make sure that you use the same Portis instance throughout your app.");
    }
  };
  WidgetManager2.prototype._initWidget = function() {
    return __awaiter18(this, void 0, void 0, function() {
      var style, container, widgetFrame, connection, communication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, onWindowLoad()];
          case 1:
            _a2.sent();
            style = document.createElement("style");
            style.innerHTML = styles;
            container = document.createElement("div");
            container.className = PORTIS_CONTAINER_CLASS;
            widgetFrame = document.createElement("div");
            widgetFrame.id = "portis-container-" + Date.now();
            widgetFrame.className = PORTIS_IFRAME_CLASS;
            container.appendChild(widgetFrame);
            document.body.appendChild(container);
            document.head.appendChild(style);
            connection = import_penpal.default.connectToChild({
              url: this._widgetUrl,
              appendTo: document.getElementById(widgetFrame.id),
              methods: {
                setHeight: this._setHeight.bind(this),
                getWindowSize: WidgetManager2._getWindowSize.bind(this),
                onLogin: this._onLogin.bind(this),
                onLogout: this._onLogout.bind(this),
                onActiveWalletChanged: this._onActiveWalletChanged.bind(this),
                hasOnActiveWalletChanged: this.hasOnActiveWalletChanged.bind(this),
                onError: this._onError.bind(this)
              }
            });
            return [4, connection.promise];
          case 2:
            communication = _a2.sent();
            communication.setSdkConfig(this._widgetConfig);
            connection.iframe.style.position = "absolute";
            connection.iframe.style.height = "100%";
            connection.iframe.style.width = "100%";
            connection.iframe.style.border = "0 transparent";
            return [2, { communication, widgetFrame }];
        }
      });
    });
  };
  WidgetManager2.prototype._setHeight = function(height) {
    return __awaiter18(this, void 0, void 0, function() {
      var widgetFrame;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetFrame = _a2.sent().widgetFrame;
            widgetFrame.style.height = height + "px";
            return [2];
        }
      });
    });
  };
  WidgetManager2._getWindowSize = function() {
    var body = document.getElementsByTagName("body")[0];
    var width = window.innerWidth || document.documentElement.clientWidth || body.clientWidth;
    var height = window.innerHeight || document.documentElement.clientHeight || body.clientHeight;
    return { width, height };
  };
  WidgetManager2.prototype._onLogin = function(walletAddress, email, reputation) {
    if (this._onLoginCallback) {
      this._onLoginCallback(walletAddress, email, reputation);
    }
  };
  WidgetManager2.prototype._onLogout = function() {
    this._clearProviderSession();
    if (this._onLogoutCallback) {
      this._onLogoutCallback();
    }
  };
  WidgetManager2.prototype._onActiveWalletChanged = function(walletAddress) {
    if (this._onActiveWalletChangedCallback) {
      this._onActiveWalletChangedCallback(walletAddress);
    }
  };
  WidgetManager2.prototype.hasOnActiveWalletChanged = function() {
    return !!this._onActiveWalletChangedCallback;
  };
  WidgetManager2.prototype._onError = function(error) {
    if (this._onErrorCallback) {
      this._onErrorCallback(error);
    }
  };
  return WidgetManager2;
}();
var widgetManager_default = WidgetManager;

// node_modules/@portis/web3/es/utils/getTxGas.js
var __awaiter19 = function(thisArg, _arguments, P4, generator) {
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P4(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _10 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f7, y5, t5, g5;
  return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
    return this;
  }), g5;
  function verb(n3) {
    return function(v8) {
      return step([n3, v8]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_10)
      try {
        if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
          return t5;
        if (y5 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _10.label++;
            return { value: op[1], done: false };
          case 5:
            _10.label++;
            y5 = op[1];
            op = [0];
            continue;
          case 7:
            op = _10.ops.pop();
            _10.trys.pop();
            continue;
          default:
            if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _10 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _10.label = op[1];
              break;
            }
            if (op[0] === 6 && _10.label < t5[1]) {
              _10.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _10.label < t5[2]) {
              _10.label = t5[2];
              _10.ops.push(op);
              break;
            }
            if (t5[2])
              _10.ops.pop();
            _10.trys.pop();
            continue;
        }
        op = body.call(thisArg, _10);
      } catch (e5) {
        op = [6, e5];
        y5 = 0;
      } finally {
        f7 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var _a = require_dist4();
var addHexPrefix = _a.addHexPrefix;
var stripHexPrefix = _a.stripHexPrefix;
var BN4 = _a.BN;
var SIMPLE_GAS_COST = "0x5208";
function getTxGas(query, txParams) {
  return __awaiter19(this, void 0, void 0, function() {
    var block, _a2, safeGas, simpleSend, gasLimitSpecified, gas, error_1;
    return __generator2(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, query.getBlockByNumber("latest", false)];
        case 1:
          block = _b.sent();
          return [4, safeTxGas(query, txParams, block.gasLimit)];
        case 2:
          _a2 = _b.sent(), safeGas = _a2.safeGas, simpleSend = _a2.simpleSend, gasLimitSpecified = _a2.gasLimitSpecified;
          if (simpleSend || gasLimitSpecified) {
            return [2, safeGas];
          }
          _b.label = 3;
        case 3:
          _b.trys.push([3, 5, , 6]);
          return [4, estimateTxGas(query, txParams, block.gasLimit, safeGas)];
        case 4:
          gas = _b.sent();
          return [2, gas];
        case 5:
          error_1 = _b.sent();
          return [2, safeGas];
        case 6:
          return [2];
      }
    });
  });
}
function safeTxGas(query, txParams, blockGasLimitHex) {
  return __awaiter19(this, void 0, void 0, function() {
    var gasLimitSpecified, recipient, hasRecipient, code, codeIsEmpty, err, blockGasLimitBN, saferGasLimitBN;
    return __generator2(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          gasLimitSpecified = Boolean(txParams.gas);
          if (gasLimitSpecified) {
            return [2, { safeGas: txParams.gas, simpleSend: false, gasLimitSpecified: true }];
          }
          recipient = txParams.to;
          hasRecipient = Boolean(recipient);
          if (!hasRecipient)
            return [3, 2];
          return [4, query.getCode(recipient)];
        case 1:
          code = _a2.sent();
          codeIsEmpty = !code || code === "0x" || code === "0x0";
          if (codeIsEmpty) {
            if (txParams.data) {
              err = new Error("Trying to call a function on a non-contract address");
              throw err;
            }
            return [2, { safeGas: SIMPLE_GAS_COST, simpleSend: true, gasLimitSpecified: false }];
          }
          _a2.label = 2;
        case 2:
          blockGasLimitBN = hexToBn(blockGasLimitHex);
          saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
          return [2, { safeGas: bnToHex(saferGasLimitBN), simpleSend: false, gasLimitSpecified: false }];
      }
    });
  });
}
function estimateTxGas(query, txParams, blockGasLimitHex, safeGas) {
  return __awaiter19(this, void 0, void 0, function() {
    var estimatedGas, _a2;
    return __generator2(this, function(_b) {
      switch (_b.label) {
        case 0:
          txParams.gas = safeGas;
          _a2 = addHexPrefix;
          return [4, query.estimateGas(txParams)];
        case 1:
          estimatedGas = _a2.apply(void 0, [_b.sent()]);
          return [2, addGasBuffer(estimatedGas, blockGasLimitHex)];
      }
    });
  });
}
function addGasBuffer(initialGasLimitHex, blockGasLimitHex) {
  var initialGasLimitBn = hexToBn(initialGasLimitHex);
  var blockGasLimitBn = hexToBn(blockGasLimitHex);
  var upperGasLimitBn = blockGasLimitBn.muln(0.9);
  var bufferedGasLimitBn = initialGasLimitBn.muln(1.5);
  if (initialGasLimitBn.gt(upperGasLimitBn))
    return bnToHex(initialGasLimitBn);
  if (bufferedGasLimitBn.lt(upperGasLimitBn))
    return bnToHex(bufferedGasLimitBn);
  return bnToHex(upperGasLimitBn);
}
function hexToBn(inputHex) {
  return new BN4(stripHexPrefix(inputHex), 16);
}
function bnToHex(inputBn) {
  return addHexPrefix(inputBn.toString(16));
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  var numBN = new BN4(numerator);
  var denomBN = new BN4(denominator);
  return targetBN.mul(numBN).div(denomBN);
}

// node_modules/@portis/web3/es/utils/query.js
var Query = function() {
  function Query2(provider) {
    this.provider = provider;
  }
  Query2.prototype.getBlockByNumber = function(blockNumber, fullTransaction) {
    return this.sendAsync("eth_getBlockByNumber", blockNumber, fullTransaction);
  };
  Query2.prototype.getCode = function(address, blockNumber) {
    if (blockNumber === void 0) {
      blockNumber = "latest";
    }
    return this.sendAsync("eth_getCode", address, blockNumber);
  };
  Query2.prototype.estimateGas = function(txParams) {
    return this.sendAsync("eth_estimateGas", txParams);
  };
  Query2.prototype.sendAsync = function(methodName) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new Promise(function(resolve, reject) {
      _this.provider.sendAsync({
        id: 42,
        jsonrpc: "2.0",
        method: methodName,
        params: args
      }, function(error, response) {
        if (error) {
          reject(error);
        } else {
          resolve(response.result);
        }
      });
    });
  };
  return Query2;
}();

// node_modules/@portis/web3/es/web3/web3Manager.js
var __assign = function() {
  __assign = Object.assign || function(t5) {
    for (var s6, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
      s6 = arguments[i5];
      for (var p5 in s6)
        if (Object.prototype.hasOwnProperty.call(s6, p5))
          t5[p5] = s6[p5];
    }
    return t5;
  };
  return __assign.apply(this, arguments);
};
var __awaiter20 = function(thisArg, _arguments, P4, generator) {
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P4(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _10 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f7, y5, t5, g5;
  return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
    return this;
  }), g5;
  function verb(n3) {
    return function(v8) {
      return step([n3, v8]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_10)
      try {
        if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
          return t5;
        if (y5 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _10.label++;
            return { value: op[1], done: false };
          case 5:
            _10.label++;
            y5 = op[1];
            op = [0];
            continue;
          case 7:
            op = _10.ops.pop();
            _10.trys.pop();
            continue;
          default:
            if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _10 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _10.label = op[1];
              break;
            }
            if (op[0] === 6 && _10.label < t5[1]) {
              _10.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _10.label < t5[2]) {
              _10.label = t5[2];
              _10.ops.push(op);
              break;
            }
            if (t5[2])
              _10.ops.pop();
            _10.trys.pop();
            continue;
        }
        op = body.call(thisArg, _10);
      } catch (e5) {
        op = [6, e5];
        y5 = 0;
      } finally {
        f7 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var ProviderEngine = require_web3_provider_engine();
var CacheSubprovider = require_cache();
var FixtureSubprovider = require_fixture();
var FilterSubprovider = require_filters();
var HookedWalletSubprovider = require_hooked_wallet();
var NonceSubprovider = require_nonce_tracker();
var SubscriptionsSubprovider = require_subscriptions();
var Web3Manager = function() {
  function Web3Manager2(config2, _getWidgetCommunication) {
    this.config = config2;
    this._getWidgetCommunication = _getWidgetCommunication;
    this.provider = this._initProvider();
  }
  Web3Manager2.prototype.setSelectedAddress = function(selectedAddress) {
    this._selectedAddress = selectedAddress;
  };
  Web3Manager2.prototype.changeNetwork = function(network, gasRelay) {
    var newNetwork = networkAdapter(network, gasRelay);
    this.clearSubprovider(NonceSubprovider);
    this.clearSubprovider(CacheSubprovider);
    this.config.network = newNetwork;
  };
  Web3Manager2.prototype._initProvider = function() {
    var _this = this;
    if (this.engine) {
      return this.engine;
    }
    this.engine = new ProviderEngine();
    var query = new Query(this.engine);
    this.engine.send = function(payload, callback) {
      if (typeof payload === "string") {
        return new Promise(function(resolve, reject) {
          _this.engine.sendAsync({
            jsonrpc: "2.0",
            id: 42,
            method: payload,
            params: callback || []
          }, function(error, response) {
            if (error) {
              reject(error);
            } else {
              resolve(response.result);
            }
          });
        });
      }
      if (callback) {
        _this.engine.sendAsync(payload, callback);
        return;
      }
      var result = null;
      switch (payload.method) {
        case "eth_accounts":
          result = _this._selectedAddress ? [_this._selectedAddress] : [];
          break;
        case "eth_coinbase":
          result = _this._selectedAddress ? [_this._selectedAddress] : [];
          break;
        case "net_version":
          result = _this._network;
          break;
        case "eth_uninstallFilter":
          _this.engine.sendAsync(payload, function(_10) {
            return _10;
          });
          result = true;
          break;
        default:
          var message = "The Portis Web3 object does not support synchronous methods like " + payload.method + " without a callback parameter.";
          throw new Error(message);
      }
      return {
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        result
      };
    };
    this.engine.addProvider(new FixtureSubprovider({
      web3_clientVersion: "Portis/v" + this.config.version + "/javascript",
      net_listening: true,
      eth_hashrate: "0x00",
      eth_mining: false,
      eth_syncing: true
    }));
    this.engine.addProvider(new CacheSubprovider());
    this.engine.addProvider(new SubscriptionsSubprovider());
    this.engine.addProvider(new FilterSubprovider());
    this.engine.addProvider(new NonceSubprovider());
    this.engine.addProvider({
      setEngine: function(_10) {
        return _10;
      },
      handleRequest: function(payload, next) {
        return __awaiter20(_this, void 0, void 0, function() {
          return __generator3(this, function(_a2) {
            if (!payload.id) {
              payload.id = 42;
            }
            next();
            return [2];
          });
        });
      }
    });
    this.engine.addProvider(new HookedWalletSubprovider({
      getAccounts: function(cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.getAccounts(this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                if (!error && result) {
                  this._selectedAddress = result[0];
                }
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTransaction: function(txParams, cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.signTransaction(txParams, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signMessage: function(msgParams, cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signPersonalMessage: function(msgParams, cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signPersonalMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTypedMessage: function(msgParams, cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signTypedMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTypedMessageV3: function(msgParams, cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signTypedMessageV3" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      estimateGas: function(txParams, cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          var gas;
          return __generator3(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, getTxGas(query, txParams)];
              case 1:
                gas = _a2.sent();
                cb(null, gas);
                return [2];
            }
          });
        });
      },
      getGasPrice: function(cb) {
        return __awaiter20(_this, void 0, void 0, function() {
          return __generator3(this, function(_a2) {
            cb(null, "");
            return [2];
          });
        });
      }
    }));
    this.engine.addProvider({
      setEngine: function(_10) {
        return _10;
      },
      handleRequest: function(payload, next, end) {
        return __awaiter20(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.relay(payload, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                if (payload.method === "net_version") {
                  this._network = result;
                  this.engine.networkVersion = this._network;
                }
                end(error, result);
                return [2];
            }
          });
        });
      }
    });
    this.engine.enable = function() {
      return new Promise(function(resolve, reject) {
        _this.engine.sendAsync({ method: "eth_accounts" }, function(error, response) {
          if (error) {
            reject(error);
          } else {
            resolve(response.result);
          }
        });
      });
    };
    this.engine.isConnected = function() {
      return true;
    };
    this.engine.isPortis = true;
    this.engine.on("error", function(error) {
      if (error && error.message && error.message.includes("PollingBlockTracker")) {
        console.warn("If you see this warning constantly, there might be an error with your RPC node.");
      } else {
        console.error(error);
      }
    });
    this.engine.start();
    return this.engine;
  };
  Web3Manager2.prototype.clearSubprovider = function(subproviderType) {
    var subprovider = this.provider._providers.find(function(subprovider2) {
      return subprovider2 instanceof subproviderType;
    });
    this.provider.removeProvider(subprovider);
    this.provider.addProvider(new subproviderType());
  };
  return Web3Manager2;
}();
var web3Manager_default = Web3Manager;

// node_modules/@portis/web3/es/utils/mockify.js
var mockify = function(obj) {
  return new Proxy(obj, {
    get: function(target, prop) {
      if (target[prop] instanceof Function) {
        return function() {
        };
      } else {
        return void 0;
      }
    }
  });
};

// node_modules/@portis/web3/es/index.js
var __awaiter21 = function(thisArg, _arguments, P4, generator) {
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e5) {
        reject(e5);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e5) {
        reject(e5);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P4(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _10 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f7, y5, t5, g5;
  return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
    return this;
  }), g5;
  function verb(n3) {
    return function(v8) {
      return step([n3, v8]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_10)
      try {
        if (f7 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
          return t5;
        if (y5 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _10.label++;
            return { value: op[1], done: false };
          case 5:
            _10.label++;
            y5 = op[1];
            op = [0];
            continue;
          case 7:
            op = _10.ops.pop();
            _10.trys.pop();
            continue;
          default:
            if (!(t5 = _10.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _10 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _10.label = op[1];
              break;
            }
            if (op[0] === 6 && _10.label < t5[1]) {
              _10.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _10.label < t5[2]) {
              _10.label = t5[2];
              _10.ops.push(op);
              break;
            }
            if (t5[2])
              _10.ops.pop();
            _10.trys.pop();
            continue;
        }
        op = body.call(thisArg, _10);
      } catch (e5) {
        op = [6, e5];
        y5 = 0;
      } finally {
        f7 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var VERSION = "4.0.7";
var SUPPORTED_SCOPES = ["email", "reputation"];
onWindowLoad().then(windowLoadHandler).catch(function() {
});
var Portis = function() {
  function Portis3(dappId, network, options) {
    if (options === void 0) {
      options = {};
    }
    if (!isClientSide()) {
      return mockify(this);
    }
    validateSecureOrigin();
    this._validateParams(dappId, network, options);
    this._config = {
      dappId,
      network: networkAdapter(network, options.gasRelay),
      version: VERSION,
      scope: options.scope,
      registerPageByDefault: options.registerPageByDefault,
      staging: options.staging,
      feature: options.feature
    };
    this._getWidgetCommunication = this._getWidgetCommunication.bind(this);
    this._widgetManagerInstance = new widgetManager_default(this.config, this._clearProviderSession);
    this._web3ManagerInstance = new web3Manager_default(this.config, this._getWidgetCommunication);
    this.setDefaultEmail = this.setDefaultEmail.bind(this);
    this.changeNetwork = this.changeNetwork.bind(this);
    this.getWidget = this.getWidget.bind(this);
    this.onLogin = this.onLogin.bind(this);
    this.onLogout = this.onLogout.bind(this);
    this.onActiveWalletChanged = this.onActiveWalletChanged.bind(this);
    this.onError = this.onError.bind(this);
    this.showPortis = this.showPortis.bind(this);
    this.getCampaignInfo = this.getCampaignInfo.bind(this);
    this.claimVoucher = this.claimVoucher.bind(this);
    this.getExtendedPublicKey = this.getExtendedPublicKey.bind(this);
    this.importWallet = this.importWallet.bind(this);
    this.isLoggedIn = this.isLoggedIn.bind(this);
    this.signBitcoinTransaction = this.signBitcoinTransaction.bind(this);
    this.showBitcoinWallet = this.showBitcoinWallet.bind(this);
  }
  Object.defineProperty(Portis3.prototype, "_widgetManager", {
    get: function() {
      return this._widgetManagerInstance;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis3.prototype, "_web3Manager", {
    get: function() {
      return this._web3ManagerInstance;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis3.prototype, "config", {
    get: function() {
      return this._config;
    },
    enumerable: true,
    configurable: true
  });
  Portis3.prototype._clearProviderSession = function() {
    this._web3Manager.setSelectedAddress("");
  };
  Portis3.prototype._getWidgetCommunication = function() {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this._widgetManager.getWidget()];
          case 1:
            return [2, _a2.sent().communication];
        }
      });
    });
  };
  Object.defineProperty(Portis3.prototype, "web3Provider", {
    get: function() {
      return this._web3Manager.provider;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis3.prototype, "provider", {
    get: function() {
      return this.web3Provider;
    },
    enumerable: true,
    configurable: true
  });
  Portis3.prototype.changeNetwork = function(network, gasRelay) {
    this._web3Manager.changeNetwork(network, gasRelay);
  };
  Portis3.prototype.setDefaultEmail = function(email) {
    this._widgetManager.setDefaultEmail(email);
  };
  Portis3.prototype.getWidget = function() {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getWidget()];
      });
    });
  };
  Portis3.prototype.onLogin = function(callback) {
    this._widgetManager.setOnLoginCallback(callback);
  };
  Portis3.prototype.onLogout = function(callback) {
    this._widgetManager.setOnLogoutCallback(callback);
  };
  Portis3.prototype.onActiveWalletChanged = function(callback) {
    this._widgetManager.setOnActiveWalletChangedCallback(callback);
  };
  Portis3.prototype.onError = function(callback) {
    this._widgetManager.setOnErrorCallback(callback);
  };
  Portis3.prototype.showPortis = function() {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.showPortis()];
      });
    });
  };
  Portis3.prototype.getCampaignInfo = function(campaignId) {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getCampaignInfo(campaignId)];
      });
    });
  };
  Portis3.prototype.claimVoucher = function(voucherId) {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.claimVoucher(voucherId)];
      });
    });
  };
  Portis3.prototype.logout = function() {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.logout()];
      });
    });
  };
  Portis3.prototype.getExtendedPublicKey = function(path, coin) {
    if (path === void 0) {
      path = "m/44'/60'/0'/0/0";
    }
    if (coin === void 0) {
      coin = "Ethereum";
    }
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getExtendedPublicKey(path, coin)];
      });
    });
  };
  Portis3.prototype.importWallet = function(mnemonicOrPrivateKey) {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.importWallet(mnemonicOrPrivateKey)];
      });
    });
  };
  Portis3.prototype.isLoggedIn = function() {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.isLoggedIn()];
      });
    });
  };
  Portis3.prototype.signBitcoinTransaction = function(params) {
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.signBitcoinTransaction(params)];
      });
    });
  };
  Portis3.prototype.showBitcoinWallet = function(path) {
    if (path === void 0) {
      path = "m/49'/0'/0'/0/0";
    }
    return __awaiter21(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.showBitcoinWallet(path)];
      });
    });
  };
  Portis3.prototype._validateParams = function(dappId, network, options) {
    if (!dappId) {
      throw new Error("[Portis] 'dappId' is required. Get your dappId here: https://dashboard.portis.io");
    }
    if (!network) {
      throw new Error("[Portis] 'network' is required. Read more about it here: https://docs.portis.io/#/configuration?id=network");
    }
    if (options.scope) {
      if (!Array.isArray(options.scope)) {
        throw new Error("[Portis] 'scope' must be an array. Read more about it here: https://docs.portis.io/#/configuration?id=scope");
      }
      var unknownScope = options.scope.filter(function(item) {
        return SUPPORTED_SCOPES.indexOf(item) < 0;
      });
      if (unknownScope.length > 0) {
        throw new Error("[Portis] invalid 'scope' parameter. Read more about it here: https://docs.portis.io/#/configuration?id=scope");
      }
    }
    if (options.registerPageByDefault !== void 0 && typeof options.registerPageByDefault !== "boolean") {
      throw new Error("[Portis] invalid 'registerPageByDefault' parameter, must be a boolean. Read more about it here: https://docs.portis.io/#/configuration?id=registerPageByDefault");
    }
  };
  return Portis3;
}();
var es_default = Portis;

// node_modules/wallet-ethers/lib/wallet/portis/index.js
var Portis2 = class {
  constructor({ dappId, network, config: config2 = {} }) {
    this.signer = {};
    this.wallet = {};
    this.account = "";
    this.wallet = new es_default(dappId, network, config2);
  }
  async login() {
    try {
      await this.wallet.provider.enable();
      const getProvider = this.wallet.provider;
      const provider = new lib_exports4.Web3Provider(getProvider);
      this.signer = provider.getSigner();
      const account = await this.signer.getAddress();
      this.account = account;
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
    return await this.wallet.logout();
  }
  onAccountsChanged(callBack) {
    this.wallet.onActiveWalletChanged(callBack);
  }
  onChainChanged(callBack) {
  }
};
var portis_default = Portis2;

// node_modules/wallet-ethers/lib/wallet/phantom/index.js
var Phantom = class {
  constructor() {
    var _a2;
    this.signer = {};
    this.wallet = {};
    this.account = "";
    const Window = globalThis;
    this.wallet = (_a2 = Window.phantom) == null ? void 0 : _a2.solana;
  }
  async login() {
    try {
      const res = await this.wallet.connect();
      this.account = res.publicKey.toString();
      this.signer = index_browser_esm_exports;
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
    return await this.wallet.disconnect();
  }
  onAccountsChanged(callBack) {
  }
  onChainChanged(callBack) {
  }
};
var phantom_default = Phantom;

// node_modules/wallet-ethers/lib/wallet/metamask/index.js
var Metamask = class {
  constructor() {
    var _a2;
    this.signer = {};
    this.wallet = {};
    this.account = "";
    const Window = globalThis;
    const ethereum = Window.ethereum;
    this.wallet = ((_a2 = ethereum.providers) == null ? void 0 : _a2[1]) || ethereum;
  }
  async login() {
    try {
      const [account] = await this.wallet.request({
        method: "eth_requestAccounts"
      });
      this.account = account;
      const provider = new lib_exports4.Web3Provider(this.wallet);
      this.signer = provider.getSigner();
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
  }
  onAccountsChanged(callBack) {
    this.wallet.on("accountsChanged", ([account]) => callBack(account));
  }
  onChainChanged(callBack) {
    this.wallet.on("chainChanged", callBack);
  }
};
var metamask_default = Metamask;

// node_modules/wallet-ethers/lib/wallet/fortmatic/index.js
var import_fortmatic = __toModule(require_fortmatic());
var Fortmatic = class {
  constructor({ apiKey, network }) {
    this.signer = {};
    this.wallet = {};
    this.account = "";
    this.wallet = new import_fortmatic.default(apiKey, network);
  }
  async login() {
    try {
      await this.wallet.user.login();
      const getProvider = this.wallet.getProvider();
      const provider = new lib_exports4.Web3Provider(getProvider);
      this.signer = provider.getSigner();
      const account = await this.signer.getAddress();
      this.account = account;
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
    return await this.wallet.user.logout();
  }
  onAccountsChanged(callBack) {
  }
  onChainChanged(callBack) {
  }
};
var fortmatic_default = Fortmatic;

// node_modules/wallet-ethers/lib/wallet/walletlink/config.json
var ropsten2 = {
  id: 3,
  http: "https://ropsten.infura.io/v3/9e332d39364f4491aec5414fcbc4def7"
};
var mainnet = {
  id: 1,
  http: "https://mainnet.infura.io/v3/9e332d39364f4491aec5414fcbc4def7"
};
var config_default = {
  ropsten: ropsten2,
  mainnet
};

// node_modules/wallet-ethers/lib/wallet/walletlink/index.js
var import_walletlink = __toModule(require_dist10());
var Walletlink = class {
  constructor({ appName, darkMode, appLogoUrl, network }) {
    this.signer = {};
    this.wallet = {};
    this.account = "";
    const init3 = new import_walletlink.default({
      appName,
      darkMode,
      appLogoUrl
    });
    this.wallet = init3.makeWeb3Provider(config_default[network].http, config_default[network].id);
  }
  async login() {
    try {
      await this.wallet.enable();
      const provider = new lib_exports4.Web3Provider(this.wallet);
      this.signer = provider.getSigner();
      const account = await this.signer.getAddress();
      this.account = account;
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
    return await this.wallet.close();
  }
  onAccountsChanged(callBack) {
  }
  onChainChanged(callBack) {
  }
};
var walletlink_default = Walletlink;

// node_modules/wallet-ethers/lib/wallet/walletconnect/rpc.json
var _50 = "https://rpc.ftm.tools/";
var _6 = "https://bsc-dataseed.binance.org/";
var _0001 = "https://rpc-mumbai.matic.today";
var _37 = "https://rpc-mainnet.matic.network";
var _313161555 = "https://testnet.aurora.dev";
var _313161554 = "https://mainnet.aurora.dev";
var _002 = "https://rpc.testnet.fantom.network/";
var _3114 = "https://api.avax.network/ext/bc/C/rpc";
var _3113 = "https://api.avax-test.network/ext/bc/C/rpc";
var _7 = "https://data-seed-prebsc-1-s1.binance.org:8545/";
var _3 = "https://ropsten.infura.io/v3/9e332d39364f4491aec5414fcbc4def7";
var _4 = "https://mainnet.infura.io/v3/9e332d39364f4491aec5414fcbc4def7";
var rpc_default = {
  "250": _50,
  "56": _6,
  "80001": _0001,
  "137": _37,
  "1313161555": _313161555,
  "1313161554": _313161554,
  "4002": _002,
  "43114": _3114,
  "43113": _3113,
  "97": _7,
  "3": _3,
  "1": _4
};

// node_modules/@walletconnect/utils/dist/esm/index.js
init_esm2();

// node_modules/@walletconnect/utils/dist/esm/constants.js
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var infuraNetworks = {
  1: "mainnet",
  3: "ropsten",
  4: "rinkeby",
  5: "goerli",
  42: "kovan"
};

// node_modules/@walletconnect/utils/dist/esm/encoding.js
var import_bn4 = __toModule(require_bn6());
var encoding = __toModule(require_cjs3());
function convertArrayBufferToBuffer(arrBuf) {
  return encoding.arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return encoding.arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return encoding.bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return encoding.utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return encoding.utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return encoding.hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = encoding.removeHexPrefix(encoding.sanitizeHex(new import_bn4.default(num).toString(16)));
  return noPrefix ? hex : encoding.addHexPrefix(hex);
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
var import_js_sha33 = __toModule(require_sha3());
var import_encoding = __toModule(require_cjs3());

// node_modules/@walletconnect/utils/dist/esm/misc.js
var encoding2 = __toModule(require_cjs3());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type2) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type2)) {
    return STANDARD_ERROR_MAP[INTERNAL_ERROR];
  }
  return STANDARD_ERROR_MAP[type2];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e5) => e5.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[INTERNAL_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[INTERNAL_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e5, url, type2) {
  return e5.message.includes("getaddrinfo ENOTFOUND") || e5.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type2} RPC url at ${url}`) : e5;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toModule(require_cjs4());
__reExport(env_exports, __toModule(require_cjs4()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports2, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method, params, id2) {
  return {
    id: id2 || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id2, result) {
  return {
    id: id2,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id2, error) {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: formatErrorMessage(error)
  };
}
function formatErrorMessage(error) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x5) => x5.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents = class {
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection = class extends IEvents {
  constructor(opts) {
    super();
  }
};
var IBaseJsonRpcProvider = class extends IEvents {
  constructor() {
    super();
  }
};
var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex3(hex) {
  return encoding2.sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return encoding2.removeHexLeadingZeros(encoding2.addHexPrefix(hex));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a5, b4) => {
    for (b4 = a5 = ""; a5++ < 36; b4 += a5 * 51 & 52 ? (a5 ^ 15 ? 8 ^ Math.random() * (a5 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b4;
  })();
  return result;
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = infuraNetworks[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}

// node_modules/@walletconnect/utils/dist/esm/validators.js
var encoding3 = __toModule(require_cjs3());
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array2) {
  return !(array2 && array2.length);
}
function isHexString4(value, length) {
  return encoding3.isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = (0, import_encoding.removeHexPrefix)(address.toLowerCase());
  const hash4 = (0, import_encoding.removeHexPrefix)((0, import_js_sha33.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i5 = 0; i5 < address.length; i5++) {
    if (parseInt(hash4[i5], 16) > 7) {
      checksum += address[i5].toUpperCase();
    } else {
      checksum += address[i5];
    }
  }
  return (0, import_encoding.addHexPrefix)(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString4(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString4(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex3(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex3(txData.from),
    to: typeof txData.to === "undefined" ? "" : sanitizeHex3(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex3(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key2) => {
    if (!txDataRPC[key2].trim().length && prunable.includes(key2)) {
      delete txDataRPC[key2];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/utils/dist/esm/payload.js
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/url.js
var queryStringUtils = __toModule(require_query_string());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}

// node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS2 = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser5();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS2(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e5) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e5));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue2 = this._queue;
    queue2.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version29) {
  var _a2, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version: version29,
    env: "browser",
    host: ((_a2 = getLocation2()) === null || _a2 === void 0 ? void 0 : _a2.host) || ""
  } : {
    protocol,
    version: version29,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default = SocketTransport;

// node_modules/@walletconnect/core/dist/esm/errors.js
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/core/dist/esm/events.js
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x5) => x5.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default = EventManager;

// node_modules/@walletconnect/core/dist/esm/storage.js
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/core/dist/esm/url.js
var domain = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key2 = convertHexToArrayBuffer(value);
    this._key = key2;
  }
  get key() {
    if (this._key) {
      const key2 = convertArrayBufferToHex(this._key, true);
      return key2;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key: key2 } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key2;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId2() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id2, callback) {
    this.on(`response:${id2}`, callback);
  }
  _subscribeToSessionResponse(id2, errorMsg) {
    this._subscribeToResponse(id2, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (payload.result) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id2) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id2, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (payload.result) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(new Error(payload.error.message));
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version29 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key2 = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version29}?bridge=${bridge}&key=${key2}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key2 = result.key;
      return { handshakeTopic, bridge, key: key2 };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.encrypt(data, key2);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.decrypt(payload, key2);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default2 = Connector;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  decrypt: () => decrypt3,
  encrypt: () => encrypt2,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert4,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes2,
  ripemd160: () => ripemd1602,
  sha256: () => sha2564,
  sha512: () => sha5122
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
var env = __toModule(require_cjs4());
function randomBytes2(length) {
  const browserCrypto = env.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
var env2 = __toModule(require_cjs4());

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0 = 0;
var LENGTH_1 = 1;
var LENGTH_16 = 16;
var LENGTH_32 = 32;
var LENGTH_64 = 64;
var LENGTH_128 = 128;
var LENGTH_256 = 256;
var LENGTH_512 = 512;
var LENGTH_1024 = 1024;

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH = LENGTH_256;
var HMAC_LENGTH = LENGTH_256;
var AES_BROWSER_ALGO = "AES-CBC";
var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
var HMAC_BROWSER = "HMAC";
var SHA256_BROWSER_ALGO = "SHA-256";
var SHA512_BROWSER_ALGO = "SHA-512";
var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
var SHA256_NODE_ALGO = "sha256";
var SHA512_NODE_ALGO = "sha512";
var RIPEMD160_NODE_ALGO = "ripemd160";
var PREFIX_LENGTH = LENGTH_1;
var KEY_LENGTH = LENGTH_32;
var IV_LENGTH = LENGTH_16;
var MAC_LENGTH = LENGTH_32;

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC = "hex";
var UTF8_ENC = "utf8";

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC = "Bad MAC";

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP = "encrypt";
var DECRYPT_OP = "decrypt";
var SIGN_OP = "sign";
var VERIFY_OP = "verify";

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type2) {
  return type2 === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type2) {
  return type2 === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer2, type2 = AES_BROWSER_ALGO) {
  return env2.getSubtleCrypto().importKey("raw", buffer2, getAlgo(type2), true, getOps(type2));
}
async function browserAesEncrypt(iv, key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature2 = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature2);
}
async function browserHmacSha512Sign(key2, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature2 = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature2);
}
async function browserSha256(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key2, data) {
  return browserAesEncrypt(iv, key2, data);
}
function aesCbcDecrypt(iv, key2, data) {
  return browserAesDecrypt(iv, key2, data);
}

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert4,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
__markAsModule(env_exports2);
__reExport(env_exports2, __toModule(require_cjs4()));

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
__reExport(helpers_exports, env_exports2);

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING = [
  [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
  [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
  [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
  [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
  [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
  [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
  [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
  [9, 9, 9, 9, 9, 9, 9, 9, 9],
  [8, 8, 8, 8, 8, 8, 8, 8],
  [7, 7, 7, 7, 7, 7, 7],
  [6, 6, 6, 6, 6, 6],
  [5, 5, 5, 5, 5],
  [4, 4, 4, 4],
  [3, 3, 3],
  [2, 2],
  [1]
];
var pkcs7 = {
  pad(plaintext) {
    const padding2 = PADDING[plaintext.byteLength % 16 || 0];
    const result = new Uint8Array(plaintext.byteLength + padding2.length);
    result.set(plaintext);
    result.set(padding2, plaintext.byteLength);
    return result;
  },
  unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
};

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i5 = 0; i5 < arr1.length; i5++) {
    res |= arr1[i5] ^ arr2[i5];
  }
  return res === 0;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key2, msg) {
  const result = await browserHmacSha256Sign(key2, msg);
  return result;
}
async function hmacSha256Verify(key2, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key2, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key2, msg) {
  const result = await browserHmacSha512Sign(key2, msg);
  return result;
}
async function hmacSha512Verify(key2, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key2, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha2564(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha5122(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd1602(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
__reExport(browser_exports, helpers_exports);

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var encoding4 = __toModule(require_cjs3());
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes2(_length);
  const result = convertBufferToArrayBuffer(encoding4.arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key2) {
  const cipherText = encoding4.hexToArray(payload.data);
  const iv = encoding4.hexToArray(payload.iv);
  const hmac3 = encoding4.hexToArray(payload.hmac);
  const hmacHex = encoding4.arrayToHex(hmac3, false);
  const unsigned = encoding4.concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key2, unsigned);
  const chmacHex = encoding4.arrayToHex(chmac, false);
  if (encoding4.removeHexPrefix(hmacHex) === encoding4.removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt2(data, key2, providedIv) {
  const _key = encoding4.bufferToArray(convertArrayBufferToBuffer(key2));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = encoding4.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = encoding4.arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = encoding4.utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = encoding4.arrayToHex(cipherText, false);
  const unsigned = encoding4.concatArrays(cipherText, iv);
  const hmac3 = await hmacSha256Sign(_key, unsigned);
  const hmacHex = encoding4.arrayToHex(hmac3, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt3(payload, key2) {
  const _key = encoding4.bufferToArray(convertArrayBufferToBuffer(key2));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = encoding4.hexToArray(payload.data);
  const iv = encoding4.hexToArray(payload.iv);
  const buffer2 = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = encoding4.arrayToUtf8(buffer2);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default2 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports3,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default3 = WalletConnect;

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
var import_qrcode_modal = __toModule(require_cjs5());

// node_modules/@walletconnect/http-connection/dist/esm/index.js
var import_eventemitter32 = __toModule(require_eventemitter3());
var import_xhr2_cookies = __toModule(require_dist11());
var XHR = getFromWindow2("XMLHttpRequest") || import_xhr2_cookies.XMLHttpRequest;
var HTTPConnection = class extends import_eventemitter32.default {
  constructor(url) {
    super();
    this.url = url;
  }
  formatError(payload, message, code = -1) {
    return {
      error: { message, code },
      id: payload.id,
      jsonrpc: payload.jsonrpc
    };
  }
  send(payload, internal) {
    return new Promise((resolve) => {
      if (payload.method === "eth_subscribe") {
        const error = this.formatError(payload, "Subscriptions are not supported by this HTTP endpoint");
        this.emit("error", error);
        return resolve(error);
      }
      const xhr = new XHR();
      let responded = false;
      const res = (err, result) => {
        if (!responded) {
          xhr.abort();
          responded = true;
          if (internal) {
            internal(err, result);
          } else {
            const { id: id2, jsonrpc } = payload;
            const response = err ? { id: id2, jsonrpc, error: { message: err.message, code: err.code } } : { id: id2, jsonrpc, result };
            this.emit("payload", response);
            resolve(response);
          }
        }
      };
      xhr.open("POST", this.url, true);
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.timeout = 60 * 1e3;
      xhr.onerror = res;
      xhr.ontimeout = res;
      xhr.onreadystatechange = () => {
        if (xhr.readyState === 4) {
          try {
            const response = JSON.parse(xhr.responseText);
            res(response.error, response.result);
          } catch (e5) {
            res(e5);
          }
        }
      };
      xhr.send(JSON.stringify(payload));
    });
  }
};
var esm_default4 = HTTPConnection;

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
var ProviderEngine2 = require_web3_provider_engine();
var CacheSubprovider2 = require_cache2();
var FixtureSubprovider2 = require_fixture2();
var FilterSubprovider2 = require_filters2();
var HookedWalletSubprovider2 = require_hooked_wallet2();
var NonceSubprovider2 = require_nonce_tracker2();
var SubscriptionsSubprovider2 = require_subscriptions2();
var WalletConnectProvider = class extends ProviderEngine2 {
  constructor(opts) {
    super({ pollingInterval: opts.pollingInterval || 8e3 });
    this.bridge = "https://bridge.walletconnect.org";
    this.qrcode = true;
    this.qrcodeModal = import_qrcode_modal.default;
    this.qrcodeModalOptions = void 0;
    this.rpc = null;
    this.infuraId = "";
    this.http = null;
    this.isConnecting = false;
    this.connected = false;
    this.connectCallbacks = [];
    this.accounts = [];
    this.chainId = 1;
    this.rpcUrl = "";
    this.enable = async () => {
      const wc = await this.getWalletConnector();
      if (wc) {
        this.start();
        this.subscribeWalletConnector();
        return wc.accounts;
      } else {
        throw new Error("Failed to connect to WalleConnect");
      }
    };
    this.request = async (payload) => {
      return this.send(payload);
    };
    this.send = async (payload, callback) => {
      if (typeof payload === "string") {
        const method = payload;
        let params = callback;
        if (method === "personal_sign") {
          params = parsePersonalSign(params);
        }
        return this.sendAsyncPromise(method, params);
      }
      payload = Object.assign({ id: payloadId2(), jsonrpc: "2.0" }, payload);
      if (payload.method === "personal_sign") {
        payload.params = parsePersonalSign(payload.params);
      }
      if (callback) {
        this.sendAsync(payload, callback);
        return;
      }
      return this.sendAsyncPromise(payload.method, payload.params);
    };
    this.onConnect = (callback) => {
      this.connectCallbacks.push(callback);
    };
    this.triggerConnect = (result) => {
      if (this.connectCallbacks && this.connectCallbacks.length) {
        this.connectCallbacks.forEach((callback) => callback(result));
      }
    };
    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || "https://bridge.walletconnect.org";
    this.qrcode = typeof opts.qrcode === "undefined" || opts.qrcode !== false;
    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;
    this.qrcodeModalOptions = opts.qrcodeModalOptions;
    this.wc = opts.connector || new esm_default3({
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? this.qrcodeModal : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
    });
    this.rpc = opts.rpc || null;
    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== "string" || !opts.infuraId.trim())) {
      throw new Error("Missing one of the required parameters: rpc or infuraId");
    }
    this.infuraId = opts.infuraId || "";
    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
    this.initialize();
  }
  get isWalletConnect() {
    return true;
  }
  get connector() {
    return this.wc;
  }
  get walletMeta() {
    return this.wc.peerMeta;
  }
  async disconnect() {
    this.close();
  }
  async close() {
    const wc = await this.getWalletConnector({ disableSessionCreation: true });
    await wc.killSession();
    await this.onDisconnect();
  }
  async handleRequest(payload) {
    try {
      let response;
      let result = null;
      const wc = await this.getWalletConnector();
      switch (payload.method) {
        case "wc_killSession":
          await this.close();
          result = null;
          break;
        case "eth_accounts":
          result = wc.accounts;
          break;
        case "eth_coinbase":
          result = wc.accounts[0];
          break;
        case "eth_chainId":
          result = wc.chainId;
          break;
        case "net_version":
          result = wc.chainId;
          break;
        case "eth_uninstallFilter":
          this.sendAsync(payload, (_10) => _10);
          result = true;
          break;
        default:
          response = await this.handleOtherRequests(payload);
      }
      if (response) {
        return response;
      }
      return this.formatResponse(payload, result);
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async handleOtherRequests(payload) {
    if (!signingMethods.includes(payload.method) && payload.method.startsWith("eth_")) {
      return this.handleReadRequests(payload);
    }
    const wc = await this.getWalletConnector();
    const result = await wc.sendCustomRequest(payload);
    return this.formatResponse(payload, result);
  }
  async handleReadRequests(payload) {
    if (!this.http) {
      const error = new Error("HTTP Connection not available");
      this.emit("error", error);
      throw error;
    }
    return this.http.send(payload);
  }
  formatResponse(payload, result) {
    return {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      result
    };
  }
  getWalletConnector(opts = {}) {
    const { disableSessionCreation = false } = opts;
    return new Promise((resolve, reject) => {
      const wc = this.wc;
      if (this.isConnecting) {
        this.onConnect((x5) => resolve(x5));
      } else if (!wc.connected && !disableSessionCreation) {
        this.isConnecting = true;
        wc.on("modal_closed", () => {
          reject(new Error("User closed modal"));
        });
        wc.createSession({ chainId: this.chainId }).then(() => {
          wc.on("connect", (error, payload) => {
            if (error) {
              this.isConnecting = false;
              return reject(error);
            }
            this.isConnecting = false;
            this.connected = true;
            if (payload) {
              this.updateState(payload.params[0]);
            }
            this.emit("connect");
            this.triggerConnect(wc);
            resolve(wc);
          });
        }).catch((error) => {
          this.isConnecting = false;
          reject(error);
        });
      } else {
        if (!this.connected) {
          this.connected = true;
          this.updateState(wc.session);
        }
        resolve(wc);
      }
    });
  }
  async subscribeWalletConnector() {
    const wc = await this.getWalletConnector();
    wc.on("disconnect", (error) => {
      if (error) {
        this.emit("error", error);
        return;
      }
      this.onDisconnect();
    });
    wc.on("session_update", (error, payload) => {
      if (error) {
        this.emit("error", error);
        return;
      }
      this.updateState(payload.params[0]);
    });
  }
  async onDisconnect() {
    await this.stop();
    this.emit("close", 1e3, "Connection closed");
    this.emit("disconnect", 1e3, "Connection disconnected");
    this.connected = false;
  }
  async updateState(sessionParams) {
    const { accounts, chainId, networkId, rpcUrl } = sessionParams;
    if (!this.accounts || accounts && this.accounts !== accounts) {
      this.accounts = accounts;
      this.emit("accountsChanged", accounts);
    }
    if (!this.chainId || chainId && this.chainId !== chainId) {
      this.chainId = chainId;
      this.emit("chainChanged", chainId);
    }
    if (!this.networkId || networkId && this.networkId !== networkId) {
      this.networkId = networkId;
      this.emit("networkChanged", networkId);
    }
    this.updateRpcUrl(this.chainId, rpcUrl || "");
  }
  updateRpcUrl(chainId, rpcUrl = "") {
    const rpc = { infuraId: this.infuraId, custom: this.rpc || void 0 };
    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);
    if (rpcUrl) {
      this.rpcUrl = rpcUrl;
      this.updateHttpConnection();
    } else {
      this.emit("error", new Error(`No RPC Url available for chainId: ${chainId}`));
    }
  }
  updateHttpConnection() {
    if (this.rpcUrl) {
      this.http = new esm_default4(this.rpcUrl);
      this.http.on("payload", (payload) => this.emit("payload", payload));
      this.http.on("error", (error) => this.emit("error", error));
    }
  }
  sendAsyncPromise(method, params) {
    return new Promise((resolve, reject) => {
      this.sendAsync({
        id: payloadId2(),
        jsonrpc: "2.0",
        method,
        params: params || []
      }, (error, response) => {
        if (error) {
          reject(error);
          return;
        }
        resolve(response.result);
      });
    });
  }
  initialize() {
    this.updateRpcUrl(this.chainId);
    this.addProvider(new FixtureSubprovider2({
      eth_hashrate: "0x00",
      eth_mining: false,
      eth_syncing: true,
      net_listening: true,
      web3_clientVersion: `WalletConnect/v1.x.x/javascript`
    }));
    this.addProvider(new CacheSubprovider2());
    this.addProvider(new SubscriptionsSubprovider2());
    this.addProvider(new FilterSubprovider2());
    this.addProvider(new NonceSubprovider2());
    this.addProvider(new HookedWalletSubprovider2(this.configWallet()));
    this.addProvider({
      handleRequest: async (payload, next, end) => {
        try {
          const { error, result } = await this.handleRequest(payload);
          end(error, result);
        } catch (error) {
          end(error);
        }
      },
      setEngine: (_10) => _10
    });
  }
  configWallet() {
    return {
      getAccounts: async (cb) => {
        try {
          const wc = await this.getWalletConnector();
          const accounts = wc.accounts;
          if (accounts && accounts.length) {
            cb(null, accounts);
          } else {
            cb(new Error("Failed to get accounts"));
          }
        } catch (error) {
          cb(error);
        }
      },
      processMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signMessage([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error) {
          cb(error);
        }
      },
      processPersonalMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);
          cb(null, result);
        } catch (error) {
          cb(error);
        }
      },
      processSignTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTransaction(txParams);
          cb(null, result);
        } catch (error) {
          cb(error);
        }
      },
      processTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.sendTransaction(txParams);
          cb(null, result);
        } catch (error) {
          cb(error);
        }
      },
      processTypedMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTypedData([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error) {
          cb(error);
        }
      }
    };
  }
};
var esm_default5 = WalletConnectProvider;

// node_modules/wallet-ethers/lib/wallet/walletconnect/index.js
var Walletconnect = class {
  constructor({ rpc = {} } = {}) {
    this.signer = {};
    this.wallet = {};
    this.account = "";
    this.wallet = new esm_default5({
      rpc: __spreadValues(__spreadValues({}, rpc_default), rpc)
    });
  }
  async login() {
    try {
      const [account] = await this.wallet.enable();
      this.account = account;
      const provider = new lib_exports4.Web3Provider(this.wallet);
      this.signer = provider.getSigner();
      return true;
    } catch (error) {
      throw error;
    }
  }
  async logout() {
    return await this.wallet.disconnect();
  }
  onAccountsChanged(callBack) {
    this.wallet.on("accountsChanged", ([account]) => callBack(account));
  }
  onChainChanged(callBack) {
    this.wallet.on("chainChanged", callBack);
  }
};
var walletconnect_default = Walletconnect;

// node_modules/wallet-ethers/lib/index.js
var Wallet3 = class {
  constructor(name2, config2) {
    this.wallets = {
      waxio: waxio_default,
      sollet: sollet_default,
      portis: portis_default,
      phantom: phantom_default,
      metamask: metamask_default,
      fortmatic: fortmatic_default,
      walletlink: walletlink_default,
      walletconnect: walletconnect_default
    };
    this.use = name2;
    return new this.wallets[this.use](config2);
  }
};
var lib_default = Wallet3;

// dep:wallet-ethers
var wallet_ethers_default = lib_default;
export {
  wallet_ethers_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
Copyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=wallet-ethers.js.map
