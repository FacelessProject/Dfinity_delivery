import {
  MalformedJsonRpcError,
  QueueFullError
} from "./chunk-AFTT253Q.js";
import {
  buffer_exports,
  crypto_exports,
  init_buffer,
  init_crypto,
  require_eventemitter3,
  require_nacl_fast
} from "./chunk-H7S37BHS.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __privateWrapper,
  __publicField,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-7T45EBAY.js";

// node_modules/@polkadot/util/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@polkadot/util/node_modules/bn.js/lib/bn.js"(exports, module2) {
    (function(module3, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_buffer(), buffer_exports).Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max3(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init2(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert3(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base, endian) {
        assert3(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
            w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number2.length; i += 3) {
            w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert3(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number2.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert3(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number2, i, number2.length, base);
          for (i = 0; i < mod2; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding2) {
        base = base || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t = new Array(N2);
        var l16 = BN2.prototype._countBits(N2) - 1;
        for (var i = 0; i < N2; i++) {
          t[i] = this.revBin(i, l16, N2);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l16, N2) {
        if (x === 0 || x === N2 - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l16; i++) {
          rb |= (x & 1) << l16 - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i = 0; i < N2; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s = 1; s < N2; s <<= 1) {
          var l16 = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l16);
          var itwdf = Math.sin(2 * Math.PI / l16);
          for (var p = 0; p < N2; p += l16) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l16) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N2 = Math.max(m, n) | 1;
        var odd = N2 & 1;
        var i = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i = 0; i < N2 / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N2 - i - 1];
          rws[N2 - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N2 - i - 1];
          iws[N2 - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i = 0; i < N2 / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N2) * 8192 + Math.round(ws[2 * i] / N2) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N2; ++i) {
          rws[i] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i = 0; i < N2; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N2 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x.words, x.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i = 0; i < N2; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits2) {
        assert3(typeof bits2 === "number" && bits2 >= 0);
        var r = bits2 % 26;
        var s = (bits2 - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits2) {
        assert3(this.negative === 0);
        return this.iushln(bits2);
      };
      BN2.prototype.iushrn = function iushrn(bits2, hint, extended) {
        assert3(typeof bits2 === "number" && bits2 >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits2 % 26;
        var s = Math.min((bits2 - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits2, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits2, hint, extended);
      };
      BN2.prototype.shln = function shln(bits2) {
        return this.clone().ishln(bits2);
      };
      BN2.prototype.ushln = function ushln(bits2) {
        return this.clone().iushln(bits2);
      };
      BN2.prototype.shrn = function shrn(bits2) {
        return this.clone().ishrn(bits2);
      };
      BN2.prototype.ushrn = function ushrn(bits2) {
        return this.clone().iushrn(bits2);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits2) {
        assert3(typeof bits2 === "number" && bits2 >= 0);
        var r = bits2 % 26;
        var s = (bits2 - r) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits2) {
        return this.clone().imaskn(bits2);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd2(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output2) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output2.words[i] = input.words[i];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime6(name) {
        if (primes[name])
          return primes[name];
        var prime7;
        if (name === "k256") {
          prime7 = new K256();
        } else if (name === "p224") {
          prime7 = new P224();
        } else if (name === "p192") {
          prime7 = new P192();
        } else if (name === "p25519") {
          prime7 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime7;
        return prime7;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime6 = BN2._prime(m);
          this.m = prime6.p;
          this.prime = prime6;
        } else {
          assert3(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert3(a.negative === 0, "red works only with positives");
        assert3(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert3((a.negative | b.negative) === 0, "red works only with positives");
        assert3(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert3(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert3(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports);
  }
});

// node_modules/@polkadot/wasm-crypto-wasm/cjs/bytes.js
var require_bytes = __commonJS({
  "node_modules/@polkadot/wasm-crypto-wasm/cjs/bytes.js"(exports, module2) {
    var lenIn2 = 171116;
    var lenOut2 = 339508;
    var bytes3 = "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";
    module2.exports = { bytes: bytes3, lenIn: lenIn2, lenOut: lenOut2 };
  }
});

// node_modules/ed2curve/ed2curve.js
var require_ed2curve = __commonJS({
  "node_modules/ed2curve/ed2curve.js"(exports, module2) {
    (function(root, f) {
      "use strict";
      if (typeof module2 !== "undefined" && module2.exports)
        module2.exports = f(require_nacl_fast());
      else
        root.ed2curve = f(root.nacl);
    })(exports, function(nacl10) {
      "use strict";
      if (!nacl10)
        throw new Error("tweetnacl not loaded");
      var gf = function(init2) {
        var i, r = new Float64Array(16);
        if (init2)
          for (i = 0; i < init2.length; i++)
            r[i] = init2[i];
        return r;
      };
      var gf0 = gf(), gf1 = gf([1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function car25519(o) {
        var c;
        var i;
        for (i = 0; i < 16; i++) {
          o[i] += 65536;
          c = Math.floor(o[i] / 65536);
          o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);
          o[i] -= c * 65536;
        }
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = a[i] + b[i] | 0;
      }
      function Z(o, a, b) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = a[i] - b[i] | 0;
      }
      function M(o, a, b) {
        var i, j, t = new Float64Array(31);
        for (i = 0; i < 31; i++)
          t[i] = 0;
        for (i = 0; i < 16; i++) {
          for (j = 0; j < 16; j++) {
            t[i + j] += a[i] * b[j];
          }
        }
        for (i = 0; i < 15; i++) {
          t[i] += 38 * t[i + 16];
        }
        for (i = 0; i < 16; i++)
          o[i] = t[i];
        car25519(o);
        car25519(o);
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function convertPublicKey(pk) {
        var z = new Uint8Array(32), q = [gf(), gf(), gf(), gf()], a = gf(), b = gf();
        if (unpackneg(q, pk))
          return null;
        var y = q[1];
        A(a, gf1, y);
        Z(b, gf1, y);
        inv25519(b, b);
        M(a, a, b);
        pack25519(z, a);
        return z;
      }
      function convertSecretKey(sk) {
        var d = new Uint8Array(64), o = new Uint8Array(32), i;
        nacl10.lowlevel.crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        for (i = 0; i < 32; i++)
          o[i] = d[i];
        for (i = 0; i < 64; i++)
          d[i] = 0;
        return o;
      }
      function convertKeyPair(edKeyPair) {
        var publicKey2 = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey2)
          return null;
        return {
          publicKey: publicKey2,
          secretKey: convertSecretKey(edKeyPair.secretKey)
        };
      }
      return {
        convertPublicKey,
        convertSecretKey,
        convertKeyPair
      };
    });
  }
});

// node_modules/@polkadot/x-global/packageInfo.js
var import_meta = {};
var packageInfo = {
  name: "@polkadot/x-global",
  path: import_meta && import_meta.url ? new URL(import_meta.url).pathname.substring(0, new URL(import_meta.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-global/index.js
function evaluateThis(fn) {
  return fn("return this");
}
var xglobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis(Function);
function extractGlobal(name, fallback) {
  return typeof xglobal[name] === "undefined" ? fallback : xglobal[name];
}
function exposeGlobal(name, fallback) {
  if (typeof xglobal[name] === "undefined") {
    xglobal[name] = fallback;
  }
}

// node_modules/@polkadot/x-textdecoder/fallback.js
var TextDecoder2 = class {
  constructor(_) {
  }
  decode(value) {
    let result = "";
    for (let i = 0; i < value.length; i++) {
      result += String.fromCharCode(value[i]);
    }
    return result;
  }
};

// node_modules/@polkadot/x-textdecoder/packageInfo.js
var import_meta2 = {};
var packageInfo2 = {
  name: "@polkadot/x-textdecoder",
  path: import_meta2 && import_meta2.url ? new URL(import_meta2.url).pathname.substring(0, new URL(import_meta2.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-textdecoder/browser.js
var TextDecoder3 = extractGlobal("TextDecoder", TextDecoder2);

// node_modules/@polkadot/x-textencoder/fallback.js
var TextEncoder2 = class {
  encode(value) {
    const u8a = new Uint8Array(value.length);
    for (let i = 0; i < value.length; i++) {
      u8a[i] = value.charCodeAt(i);
    }
    return u8a;
  }
};

// node_modules/@polkadot/x-textencoder/packageInfo.js
var import_meta3 = {};
var packageInfo3 = {
  name: "@polkadot/x-textencoder",
  path: import_meta3 && import_meta3.url ? new URL(import_meta3.url).pathname.substring(0, new URL(import_meta3.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-textencoder/browser.js
var TextEncoder3 = extractGlobal("TextEncoder", TextEncoder2);

// node_modules/@polkadot/util/detectOther.js
var detectOther_default = [packageInfo2, packageInfo3];

// node_modules/@polkadot/util/packageInfo.js
var import_meta4 = {};
var packageInfo4 = {
  name: "@polkadot/util",
  path: import_meta4 && import_meta4.url ? new URL(import_meta4.url).pathname.substring(0, new URL(import_meta4.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/util/is/function.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@polkadot/util/versionDetect.js
var DEDUPE = "Either remove and explicitly install matching versions or dedupe using your package manager.\nThe following conflicting packages were found:";
function getEntry(name) {
  const _global = xglobal;
  if (!_global.__polkadotjs) {
    _global.__polkadotjs = {};
  }
  if (!_global.__polkadotjs[name]) {
    _global.__polkadotjs[name] = [];
  }
  return _global.__polkadotjs[name];
}
function formatDisplay(all3, fmt) {
  let max3 = 0;
  for (let i = 0; i < all3.length; i++) {
    max3 = Math.max(max3, all3[i].version.length);
  }
  return all3.map((d) => `	${fmt(d.version.padEnd(max3), d).join("	")}`).join("\n");
}
function formatInfo(version, {
  name
}) {
  return [version, name];
}
function formatVersion(version, {
  path,
  type
}) {
  let extracted;
  if (path && path.length >= 5) {
    const nmIndex = path.indexOf("node_modules");
    extracted = nmIndex === -1 ? path : path.substring(nmIndex);
  } else {
    extracted = "<unknown>";
  }
  return [`${`${type || ""}`.padStart(3)} ${version}`, extracted];
}
function getPath(infoPath, pathOrFn) {
  if (infoPath) {
    return infoPath;
  } else if (isFunction(pathOrFn)) {
    try {
      return pathOrFn() || "";
    } catch (error) {
      return "";
    }
  }
  return pathOrFn || "";
}
function warn(pre, all3, fmt) {
  console.warn(`${pre}
${DEDUPE}
${formatDisplay(all3, fmt)}`);
}
function detectPackage({
  name,
  path,
  type,
  version
}, pathOrFn, deps = []) {
  if (!name.startsWith("@polkadot")) {
    throw new Error(`Invalid package descriptor ${name}`);
  }
  const entry = getEntry(name);
  entry.push({
    path: getPath(path, pathOrFn),
    type,
    version
  });
  if (entry.length !== 1) {
    warn(`${name} has multiple versions, ensure that there is only one installed.`, entry, formatVersion);
  } else {
    const mismatches = deps.filter((d) => d && d.version !== version);
    if (mismatches.length) {
      warn(`${name} requires direct dependencies exactly matching version ${version}.`, mismatches, formatInfo);
    }
  }
}

// node_modules/@polkadot/util/detectPackage.js
detectPackage(packageInfo4, null, detectOther_default);

// node_modules/@polkadot/util/array/chunk.js
function arrayChunk(array, chunkSize) {
  const outputSize = Math.ceil(array.length / chunkSize);
  if (outputSize === 1) {
    return [array];
  }
  const output2 = Array(outputSize);
  for (let i = 0; i < outputSize; i++) {
    const offset = i * chunkSize;
    output2[i] = array.slice(offset, offset + chunkSize);
  }
  return output2;
}

// node_modules/@polkadot/util/array/flatten.js
function arrayFlatten(arrays) {
  if (arrays.length === 0) {
    return [];
  } else if (arrays.length === 1) {
    return arrays[0];
  }
  let size = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    size += arrays[i2].length;
  }
  const output2 = new Array(size);
  let i = -1;
  for (let j = 0; j < arrays.length; j++) {
    const a = arrays[j];
    for (let e = 0; e < a.length; e++) {
      output2[++i] = a[e];
    }
  }
  return output2;
}

// node_modules/@polkadot/util/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(isFunction(message) ? message() : message);
  }
}
function assertReturn(value, message) {
  assert(value !== void 0 && value !== null, message);
  return value;
}
function assertUnreachable(x) {
  throw new Error(`This codepath should be unreachable. Unhandled input: ${x}`);
}

// node_modules/@polkadot/x-bigint/packageInfo.js
var import_meta5 = {};
var packageInfo5 = {
  name: "@polkadot/x-bigint",
  path: import_meta5 && import_meta5.url ? new URL(import_meta5.url).pathname.substring(0, new URL(import_meta5.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-bigint/index.js
var BigInt2 = typeof xglobal.BigInt === "function" && typeof xglobal.BigInt.asIntN === "function" ? xglobal.BigInt : () => Number.NaN;

// node_modules/@polkadot/util/bi/consts.js
var _0n = BigInt2(0);
var _1n = BigInt2(1);
var _1Mn = BigInt2(1e6);
var _1Bn = BigInt2(1e9);
var _1Qn = _1Bn * _1Bn;
var _2pow53n = BigInt2(Number.MAX_SAFE_INTEGER);

// node_modules/@polkadot/util/u8a/toBigInt.js
var U8_MAX = BigInt2(256);
var U16_MAX = BigInt2(256 * 256);
function u8aToBigInt(value, {
  isLe = true,
  isNegative = false
} = {}) {
  if (!value || !value.length) {
    return BigInt2(0);
  }
  const u8a = isLe ? value : value.reverse();
  const dvI = new DataView(u8a.buffer, u8a.byteOffset);
  const mod2 = u8a.length % 2;
  let result = BigInt2(0);
  if (isNegative) {
    for (let i = u8a.length - 2; i >= mod2; i -= 2) {
      result = result * U16_MAX + BigInt2(dvI.getUint16(i, true) ^ 65535);
    }
    if (mod2) {
      result = result * U8_MAX + BigInt2(dvI.getUint8(0) ^ 255);
    }
  } else {
    for (let i = u8a.length - 2; i >= mod2; i -= 2) {
      result = result * U16_MAX + BigInt2(dvI.getUint16(i, true));
    }
    if (mod2) {
      result = result * U8_MAX + BigInt2(dvI.getUint8(0));
    }
  }
  return isNegative ? result * -_1n - _1n : result;
}

// node_modules/@polkadot/util/hex/toU8a.js
var CHR = "0123456789abcdef";
var U8 = new Array(256);
var U16 = new Array(256 * 256);
for (let i = 0; i < CHR.length; i++) {
  U8[CHR[i].charCodeAt(0) | 0] = i | 0;
  if (i > 9) {
    U8[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;
  }
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U16[s | j] = U8[i] << 4 | U8[j];
  }
}
function hexToU8a(value, bitLength = -1) {
  if (!value) {
    return new Uint8Array();
  }
  let s = value.startsWith("0x") ? 2 : 0;
  const decLength = Math.ceil((value.length - s) / 2);
  const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);
  const result = new Uint8Array(endLength);
  const offset = endLength > decLength ? endLength - decLength : 0;
  for (let i = offset; i < endLength; i++, s += 2) {
    result[i] = U16[value.charCodeAt(s) << 8 | value.charCodeAt(s + 1)];
  }
  return result;
}

// node_modules/@polkadot/util/hex/toBigInt.js
function hexToBigInt(value, {
  isLe = false,
  isNegative = false
} = {}) {
  return !value || value === "0x" ? BigInt2(0) : u8aToBigInt(hexToU8a(value), {
    isLe,
    isNegative
  });
}

// node_modules/@polkadot/util/bn/bn.js
var import_bn = __toModule(require_bn());

// node_modules/@polkadot/util/is/bn.js
function isBn(value) {
  return import_bn.default.isBN(value);
}

// node_modules/@polkadot/util/is/hex.js
var REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
var REGEX_HEX_NOPREFIX = /^[\da-fA-F]+$/;
function isHex(value, bitLength = -1, ignoreLength) {
  return typeof value === "string" && (value === "0x" || REGEX_HEX_PREFIXED.test(value)) && (bitLength === -1 ? ignoreLength || value.length % 2 === 0 : value.length === 2 + Math.ceil(bitLength / 4));
}

// node_modules/@polkadot/util/is/object.js
function isObject(value) {
  return !!value && typeof value === "object";
}

// node_modules/@polkadot/util/is/helpers.js
function isOn(...fns) {
  return (value) => (isObject(value) || isFunction(value)) && fns.every((f) => isFunction(value[f]));
}
function isOnObject(...fns) {
  return (value) => isObject(value) && fns.every((f) => isFunction(value[f]));
}

// node_modules/@polkadot/util/is/toBigInt.js
var isToBigInt = isOn("toBigInt");

// node_modules/@polkadot/util/is/toBn.js
var isToBn = isOn("toBn");

// node_modules/@polkadot/util/bi/toBigInt.js
function nToBigInt(value) {
  return typeof value === "bigint" ? value : !value ? BigInt2(0) : isHex(value) ? hexToBigInt(value.toString()) : isBn(value) ? BigInt2(value.toString()) : isToBigInt(value) ? value.toBigInt() : isToBn(value) ? BigInt2(value.toBn().toString()) : BigInt2(value);
}

// node_modules/@polkadot/util/bi/sqrt.js
var SQRT_MAX_SAFE_INTEGER = BigInt2(94906265);

// node_modules/@polkadot/util/bi/helpers.js
function createCmp(cmp) {
  return (...items) => {
    if (items.length === 0) {
      throw new Error("Must provide one or more arguments");
    }
    let result = items[0];
    for (let i = 1; i < items.length; i++) {
      if (cmp(items[i], result)) {
        result = items[i];
      }
    }
    return result;
  };
}

// node_modules/@polkadot/util/bi/min.js
var nMax = createCmp((a, b) => a > b);
var nMin = createCmp((a, b) => a < b);

// node_modules/@polkadot/util/has.js
var hasBigInt = typeof BigInt2 === "function" && typeof BigInt2.asIntN === "function";
var hasBuffer = typeof Buffer !== "undefined";
var hasProcess = typeof process === "object";

// node_modules/@polkadot/util/is/buffer.js
function isBuffer(value) {
  return hasBuffer && isFunction(value && value.readDoubleLE) && Buffer.isBuffer(value);
}

// node_modules/@polkadot/util/is/u8a.js
function isU8a(value) {
  return (value && value.constructor) === Uint8Array || value instanceof Uint8Array;
}

// node_modules/@polkadot/util/string/toU8a.js
var encoder = new TextEncoder3();
function stringToU8a(value) {
  return value ? encoder.encode(value.toString()) : new Uint8Array();
}

// node_modules/@polkadot/util/u8a/toU8a.js
function u8aToU8a(value) {
  return isU8a(value) ? value : isHex(value) ? hexToU8a(value) : isBuffer(value) || Array.isArray(value) ? new Uint8Array(value) : stringToU8a(value);
}

// node_modules/@polkadot/util/u8a/concat.js
function u8aConcat(...list) {
  const u8as = new Array(list.length);
  let length = 0;
  for (let i = 0; i < list.length; i++) {
    u8as[i] = u8aToU8a(list[i]);
    length += u8as[i].length;
  }
  return u8aConcatStrict(u8as, length);
}
function u8aConcatStrict(u8as, length = 0) {
  let offset = 0;
  if (!length) {
    for (let i = 0; i < u8as.length; i++) {
      length += u8as[i].length;
    }
  }
  const result = new Uint8Array(length);
  for (let i = 0; i < u8as.length; i++) {
    result.set(u8as[i], offset);
    offset += u8as[i].length;
  }
  return result;
}

// node_modules/@polkadot/util/u8a/empty.js
function u8aEmpty(value) {
  const len = value.length | 0;
  for (let i = 0; i < len; i++) {
    if (value[i] | 0) {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/util/u8a/eq.js
function u8aEq(a, b) {
  const u8aa = u8aToU8a(a);
  const u8ab = u8aToU8a(b);
  if (u8aa.length === u8ab.length) {
    const dvA = new DataView(u8aa.buffer, u8aa.byteOffset);
    const dvB = new DataView(u8ab.buffer, u8ab.byteOffset);
    const mod2 = u8aa.length % 4 | 0;
    const length = u8aa.length - mod2 | 0;
    for (let i = 0; i < length; i += 4) {
      if (dvA.getUint32(i) !== dvB.getUint32(i)) {
        return false;
      }
    }
    for (let i = length; i < u8aa.length; i++) {
      if (u8aa[i] !== u8ab[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@polkadot/util/u8a/fixLength.js
function u8aFixLength(value, bitLength = -1, atStart = false) {
  const byteLength = Math.ceil(bitLength / 8);
  if (bitLength === -1 || value.length === byteLength) {
    return value;
  } else if (value.length > byteLength) {
    return value.subarray(0, byteLength);
  }
  const result = new Uint8Array(byteLength);
  result.set(value, atStart ? 0 : byteLength - value.length);
  return result;
}

// node_modules/@polkadot/util/u8a/toFloat.js
function u8aToFloat(value, {
  bitLength = 32,
  isLe = true
} = {}) {
  if (bitLength !== 32 && bitLength !== 64) {
    throw new Error("Invalid bitLength provided, expected 32 or 64");
  } else if (value.length < bitLength / 8) {
    throw new Error(`Invalid input buffer provided, expected at least ${bitLength / 8} bytes, found ${value.length}`);
  }
  const dv = new DataView(value.buffer, value.byteOffset);
  return bitLength === 32 ? dv.getFloat32(0, isLe) : dv.getFloat64(0, isLe);
}

// node_modules/@polkadot/util/u8a/toBn.js
function u8aToBn(value, {
  isLe = true,
  isNegative = false
} = {}) {
  const count2 = value.length;
  if (count2 <= 6) {
    if (isNegative) {
      let result = 0;
      if (isLe) {
        switch (count2) {
          case 0:
            return new import_bn.default(0);
          case 1:
            result = value[0] ^ 255;
            break;
          case 2:
            result = value[0] + (value[1] << 8) ^ 65535;
            break;
          case 3:
            result = value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215;
            break;
          case 4:
            result = value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295;
            break;
          case 5:
            result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 255) * 4294967296;
            break;
          default:
            result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296;
            break;
        }
      } else {
        for (let i = 0; i < count2; i++) {
          result = result * 256 + (value[i] ^ 255);
        }
      }
      return count2 ? new import_bn.default(result * -1 - 1) : new import_bn.default(0);
    } else if (isLe) {
      switch (count2) {
        case 0:
          return new import_bn.default(0);
        case 1:
          return new import_bn.default(value[0]);
        case 2:
          return new import_bn.default(value[0] + (value[1] << 8));
        case 3:
          return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16));
        case 4:
          return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216);
        case 5:
          return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216);
        default:
          return new import_bn.default(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);
      }
    } else {
      let result = 0;
      for (let i = 0; i < count2; i++) {
        result = result * 256 + value[i];
      }
      return new import_bn.default(result);
    }
  }
  return isNegative ? new import_bn.default(value, isLe ? "le" : "be").fromTwos(value.length * 8) : new import_bn.default(value, isLe ? "le" : "be");
}

// node_modules/@polkadot/util/u8a/toHex.js
var U82 = new Array(256);
var U162 = new Array(256 * 256);
for (let n = 0; n < 256; n++) {
  U82[n] = n.toString(16).padStart(2, "0");
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U162[s | j] = U82[i] + U82[j];
  }
}
function hex(value, result) {
  const mod2 = value.length % 2 | 0;
  const length = value.length - mod2 | 0;
  for (let i = 0; i < length; i += 2) {
    result += U162[value[i] << 8 | value[i + 1]];
  }
  if (mod2) {
    result += U82[value[length] | 0];
  }
  return result;
}
function u8aToHex(value, bitLength = -1, isPrefixed = true) {
  const empty3 = isPrefixed ? "0x" : "";
  if (!value || !value.length) {
    return empty3;
  } else if (bitLength > 0) {
    const length = Math.ceil(bitLength / 8);
    if (value.length > length) {
      return `${hex(value.subarray(0, length / 2), empty3)}\u2026${hex(value.subarray(value.length - length / 2), "")}`;
    }
  }
  return hex(value, empty3);
}

// node_modules/@polkadot/util/u8a/toNumber.js
function u8aToNumber(value, {
  isNegative = false
} = {}) {
  const count2 = value.length;
  if (isNegative) {
    let result = 0;
    switch (count2) {
      case 0:
        return 0;
      case 1:
        result = value[0] ^ 255;
        break;
      case 2:
        result = value[0] + (value[1] << 8) ^ 65535;
        break;
      case 3:
        result = value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215;
        break;
      case 4:
        result = value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295;
        break;
      case 5:
        result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 255) * 4294967296;
        break;
      case 6:
        result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296;
        break;
      default:
        throw new Error("Value more than 48-bits cannot be reliably converted");
    }
    return result * -1 - 1;
  }
  switch (count2) {
    case 0:
      return 0;
    case 1:
      return value[0];
    case 2:
      return value[0] + (value[1] << 8);
    case 3:
      return value[0] + (value[1] << 8) + (value[2] << 16);
    case 4:
      return value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216;
    case 5:
      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216;
    case 6:
      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216;
    default:
      throw new Error("Value more than 48-bits cannot be reliably converted");
  }
}

// node_modules/@polkadot/util/u8a/toString.js
var decoder = new TextDecoder3("utf-8");
function u8aToString(value) {
  return value ? decoder.decode(value) : "";
}

// node_modules/@polkadot/util/u8a/wrap.js
var U8A_WRAP_ETHEREUM = u8aToU8a("Ethereum Signed Message:\n");
var U8A_WRAP_PREFIX = u8aToU8a("<Bytes>");
var U8A_WRAP_POSTFIX = u8aToU8a("</Bytes>");
var WRAP_LEN = U8A_WRAP_PREFIX.length + U8A_WRAP_POSTFIX.length;
function u8aIsWrapped(u8a, withEthereum) {
  return u8a.length >= WRAP_LEN && u8aEq(u8a.subarray(0, U8A_WRAP_PREFIX.length), U8A_WRAP_PREFIX) && u8aEq(u8a.slice(-U8A_WRAP_POSTFIX.length), U8A_WRAP_POSTFIX) || withEthereum && u8a.length >= U8A_WRAP_ETHEREUM.length && u8aEq(u8a.subarray(0, U8A_WRAP_ETHEREUM.length), U8A_WRAP_ETHEREUM);
}
function u8aUnwrapBytes(bytes3) {
  const u8a = u8aToU8a(bytes3);
  return u8aIsWrapped(u8a, false) ? u8a.subarray(U8A_WRAP_PREFIX.length, u8a.length - U8A_WRAP_POSTFIX.length) : u8a;
}
function u8aWrapBytes(bytes3) {
  const u8a = u8aToU8a(bytes3);
  return u8aIsWrapped(u8a, true) ? u8a : u8aConcatStrict([U8A_WRAP_PREFIX, u8a, U8A_WRAP_POSTFIX]);
}

// node_modules/@polkadot/util/bi/toU8a.js
var DIV = BigInt2(256);
var NEG_MASK = BigInt2(255);
function toU8a(value, isLe, isNegative) {
  const arr = [];
  if (isNegative) {
    value = (value + _1n) * -_1n;
  }
  while (value !== _0n) {
    const mod2 = value % DIV;
    const val = Number(isNegative ? mod2 ^ NEG_MASK : mod2);
    if (isLe) {
      arr.push(val);
    } else {
      arr.unshift(val);
    }
    value = (value - mod2) / DIV;
  }
  return Uint8Array.from(arr);
}
function nToU8a(value, {
  bitLength = -1,
  isLe = true,
  isNegative = false
} = {}) {
  const valueBi = nToBigInt(value);
  if (valueBi === _0n) {
    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(Math.ceil((bitLength || 0) / 8));
  }
  const u8a = toU8a(valueBi, isLe, isNegative);
  if (bitLength === -1) {
    return u8a;
  }
  const byteLength = Math.ceil((bitLength || 0) / 8);
  const output2 = new Uint8Array(byteLength);
  if (isNegative) {
    output2.fill(255);
  }
  output2.set(u8a, isLe ? 0 : byteLength - u8a.length);
  return output2;
}

// node_modules/@polkadot/util/bn/consts.js
var BN_ZERO = new import_bn.default(0);
var BN_ONE = new import_bn.default(1);
var BN_TWO = new import_bn.default(2);
var BN_THREE = new import_bn.default(3);
var BN_FOUR = new import_bn.default(4);
var BN_FIVE = new import_bn.default(5);
var BN_SIX = new import_bn.default(6);
var BN_SEVEN = new import_bn.default(7);
var BN_EIGHT = new import_bn.default(8);
var BN_NINE = new import_bn.default(9);
var BN_TEN = new import_bn.default(10);
var BN_HUNDRED = new import_bn.default(100);
var BN_THOUSAND = new import_bn.default(1e3);
var BN_MILLION = new import_bn.default(1e6);
var BN_BILLION = new import_bn.default(1e9);
var BN_QUINTILL = BN_BILLION.mul(BN_BILLION);
var BN_MAX_INTEGER = new import_bn.default(Number.MAX_SAFE_INTEGER);

// node_modules/@polkadot/util/hex/stripPrefix.js
function hexStripPrefix(value) {
  if (!value || value === "0x") {
    return "";
  } else if (REGEX_HEX_PREFIXED.test(value)) {
    return value.substring(2);
  } else if (REGEX_HEX_NOPREFIX.test(value)) {
    return value;
  }
  throw new Error(`Expected hex value to convert, found '${value}'`);
}

// node_modules/@polkadot/util/hex/toBn.js
function hexToBn(value, {
  isLe = false,
  isNegative = false
} = {}) {
  if (!value || value === "0x") {
    return new import_bn.default(0);
  }
  const stripped = hexStripPrefix(value);
  const bn = new import_bn.default(stripped, 16, isLe ? "le" : "be");
  return isNegative ? bn.fromTwos(stripped.length * 4) : bn;
}

// node_modules/@polkadot/util/bn/min.js
var bnMax = createCmp((a, b) => a.gt(b));
var bnMin = createCmp((a, b) => a.lt(b));

// node_modules/@polkadot/util/is/bigInt.js
function isBigInt(value) {
  return typeof value === "bigint";
}

// node_modules/@polkadot/util/bn/toBn.js
function bnToBn(value) {
  return value ? import_bn.default.isBN(value) ? value : isHex(value) ? hexToBn(value.toString()) : isBigInt(value) ? new import_bn.default(value.toString()) : isToBn(value) ? value.toBn() : isToBigInt(value) ? new import_bn.default(value.toBigInt().toString()) : new import_bn.default(value) : new import_bn.default(0);
}

// node_modules/@polkadot/util/bn/sqrt.js
var SQRT_MAX_SAFE_INTEGER2 = new import_bn.default(94906265);
function bnSqrt(value) {
  const n = bnToBn(value);
  if (n.isNeg()) {
    throw new Error("square root of negative numbers is not supported");
  }
  if (n.lte(BN_MAX_INTEGER)) {
    return new import_bn.default(~~Math.sqrt(n.toNumber()));
  }
  let x0 = SQRT_MAX_SAFE_INTEGER2.clone();
  while (true) {
    const x1 = n.div(x0).iadd(x0).ishrn(1);
    if (x0.eq(x1) || x0.eq(x1.sub(BN_ONE))) {
      return x0;
    }
    x0 = x1;
  }
}

// node_modules/@polkadot/util/bn/toU8a.js
var DEFAULT_OPTS = {
  bitLength: -1,
  isLe: true,
  isNegative: false
};
function bnToU8a(value, {
  bitLength = -1,
  isLe = true,
  isNegative = false
} = DEFAULT_OPTS) {
  const valueBn = bnToBn(value);
  const byteLength = bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((bitLength || 0) / 8);
  if (!value) {
    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(byteLength);
  }
  const output2 = new Uint8Array(byteLength);
  const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
  output2.set(bn.toArray(isLe ? "le" : "be", byteLength), 0);
  return output2;
}

// node_modules/@polkadot/util/bn/toHex.js
function bnToHex(value, {
  bitLength = -1,
  isLe = false,
  isNegative = false
} = {}) {
  return u8aToHex(bnToU8a(value, {
    bitLength,
    isLe,
    isNegative
  }));
}

// node_modules/@polkadot/util/compact/toU8a.js
var MAX_U8 = BN_TWO.pow(new import_bn.default(8 - 2)).isub(BN_ONE);
var MAX_U16 = BN_TWO.pow(new import_bn.default(16 - 2)).isub(BN_ONE);
var MAX_U32 = BN_TWO.pow(new import_bn.default(32 - 2)).isub(BN_ONE);
var BL_16 = {
  bitLength: 16
};
var BL_32 = {
  bitLength: 32
};
function compactToU8a(value) {
  const bn = bnToBn(value);
  if (bn.lte(MAX_U8)) {
    return new Uint8Array([bn.toNumber() << 2]);
  } else if (bn.lte(MAX_U16)) {
    return bnToU8a(bn.shln(2).iadd(BN_ONE), BL_16);
  } else if (bn.lte(MAX_U32)) {
    return bnToU8a(bn.shln(2).iadd(BN_TWO), BL_32);
  }
  const u8a = bnToU8a(bn);
  let length = u8a.length;
  while (u8a[length - 1] === 0) {
    length--;
  }
  if (length < 4) {
    throw new Error("Invalid length, previous checks match anything less than 2^30");
  }
  return u8aConcatStrict([
    new Uint8Array([(length - 4 << 2) + 3]),
    u8a.subarray(0, length)
  ]);
}

// node_modules/@polkadot/util/compact/addLength.js
function compactAddLength(input) {
  return u8aConcatStrict([compactToU8a(input.length), input]);
}

// node_modules/@polkadot/util/compact/fromU8a.js
function compactFromU8a(input) {
  const u8a = u8aToU8a(input);
  switch (u8a[0] & 3) {
    case 0:
      return [1, new import_bn.default(u8a[0] >>> 2)];
    case 1:
      return [2, new import_bn.default(u8a[0] + (u8a[1] << 8) >>> 2)];
    case 2:
      return [4, new import_bn.default(u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 16777216 >>> 2)];
    default: {
      const offset = (u8a[0] >>> 2) + 5;
      switch (offset) {
        case 5:
          return [5, new import_bn.default(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 16777216)];
        case 6:
          return [6, new import_bn.default(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 16777216)];
        case 7:
          return [7, new import_bn.default(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216)];
        default:
          return [offset, u8aToBn(u8a.subarray(1, offset))];
      }
    }
  }
}
function compactFromU8aLim(u8a) {
  switch (u8a[0] & 3) {
    case 0:
      return [1, u8a[0] >>> 2];
    case 1:
      return [2, u8a[0] + (u8a[1] << 8) >>> 2];
    case 2:
      return [4, u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 16777216 >>> 2];
    default: {
      switch ((u8a[0] >>> 2) + 5) {
        case 5:
          return [5, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 16777216];
        case 6:
          return [6, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 16777216];
        case 7:
          return [7, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216];
        default:
          throw new Error("Compact input is > Number.MAX_SAFE_INTEGER");
      }
    }
  }
}

// node_modules/@polkadot/util/compact/stripLength.js
function compactStripLength(input) {
  const [offset, length] = compactFromU8a(input);
  const total = offset + length.toNumber();
  return [total, input.subarray(offset, total)];
}

// node_modules/@polkadot/util/extractTime.js
var MIN_MS = 60 * 1e3;
var HR_MS = MIN_MS * 60;
var DAY_MS = HR_MS * 24;

// node_modules/@polkadot/util/float/toU8a.js
function floatToU8a(value = 0, {
  bitLength = 32,
  isLe = true
} = {}) {
  if (bitLength !== 32 && bitLength !== 64) {
    throw new Error("Invalid bitLength provided, expected 32 or 64");
  }
  const result = new Uint8Array(bitLength / 8);
  const dv = new DataView(result.buffer, result.byteOffset);
  if (bitLength === 32) {
    dv.setFloat32(0, Number(value), isLe);
  } else {
    dv.setFloat64(0, Number(value), isLe);
  }
  return result;
}

// node_modules/@polkadot/util/is/boolean.js
function isBoolean(value) {
  return typeof value === "boolean";
}

// node_modules/@polkadot/util/format/formatDecimal.js
var NUMBER_REGEX = new RegExp("(\\d+?)(?=(\\d{3})+(?!\\d)|$)", "g");
function formatDecimal(value) {
  const isNegative = value[0].startsWith("-");
  const matched = isNegative ? value.substring(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);
  return matched ? `${isNegative ? "-" : ""}${matched.join(",")}` : value;
}

// node_modules/@polkadot/util/format/si.js
var SI_MID = 8;
var SI = [
  {
    power: -24,
    text: "yocto",
    value: "y"
  },
  {
    power: -21,
    text: "zepto",
    value: "z"
  },
  {
    power: -18,
    text: "atto",
    value: "a"
  },
  {
    power: -15,
    text: "femto",
    value: "f"
  },
  {
    power: -12,
    text: "pico",
    value: "p"
  },
  {
    power: -9,
    text: "nano",
    value: "n"
  },
  {
    power: -6,
    text: "micro",
    value: "\xB5"
  },
  {
    power: -3,
    text: "milli",
    value: "m"
  },
  {
    power: 0,
    text: "Unit",
    value: "-"
  },
  {
    power: 3,
    text: "Kilo",
    value: "k"
  },
  {
    power: 6,
    text: "Mill",
    value: "M"
  },
  {
    power: 9,
    text: "Bill",
    value: "B"
  },
  {
    power: 12,
    text: "Tril",
    value: "T"
  },
  {
    power: 15,
    text: "Peta",
    value: "P"
  },
  {
    power: 18,
    text: "Exa",
    value: "E"
  },
  {
    power: 21,
    text: "Zeta",
    value: "Z"
  },
  {
    power: 24,
    text: "Yotta",
    value: "Y"
  }
];
function findSi(type) {
  for (let i = 0; i < SI.length; i++) {
    if (SI[i].value === type) {
      return SI[i];
    }
  }
  return SI[SI_MID];
}
function calcSi(text, decimals, forceUnit) {
  if (forceUnit) {
    return findSi(forceUnit);
  }
  const siDefIndex = SI_MID - 1 + Math.ceil((text.length - decimals) / 3);
  return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];
}

// node_modules/@polkadot/util/format/formatBalance.js
var DEFAULT_DECIMALS = 0;
var DEFAULT_UNIT = SI[SI_MID].text;
var defaultDecimals = DEFAULT_DECIMALS;
var defaultUnit = DEFAULT_UNIT;
function getUnits(si, withSi, withSiFull, withUnit) {
  const unit = isBoolean(withUnit) ? SI[SI_MID].text : withUnit;
  return withSi || withSiFull ? si.value === "-" ? withUnit ? ` ${unit}` : "" : ` ${withSiFull ? `${si.text}${withUnit ? " " : ""}` : si.value}${withUnit ? unit : ""}` : "";
}
function getPrePost(text, decimals, forceUnit) {
  const si = calcSi(text, decimals, forceUnit);
  const mid = text.length - (decimals + si.power);
  const prefix2 = text.substring(0, mid);
  const padding2 = mid < 0 ? 0 - mid : 0;
  const postfix = `${`${new Array(padding2 + 1).join("0")}${text}`.substring(mid < 0 ? 0 : mid)}0000`.substring(0, 4);
  return [si, prefix2 || "0", postfix];
}
function _formatBalance(input, {
  decimals = defaultDecimals,
  forceUnit,
  withSi = true,
  withSiFull = false,
  withUnit = true
} = {}) {
  let text = bnToBn(input).toString();
  if (text.length === 0 || text === "0") {
    return "0";
  }
  let sign2 = "";
  if (text[0].startsWith("-")) {
    sign2 = "-";
    text = text.substring(1);
  }
  const [si, prefix2, postfix] = getPrePost(text, decimals, forceUnit);
  const units = getUnits(si, withSi, withSiFull, withUnit);
  return `${sign2}${formatDecimal(prefix2)}.${postfix}${units}`;
}
var formatBalance = _formatBalance;
formatBalance.calcSi = (text, decimals = defaultDecimals) => calcSi(text, decimals);
formatBalance.findSi = findSi;
formatBalance.getDefaults = () => {
  return {
    decimals: defaultDecimals,
    unit: defaultUnit
  };
};
formatBalance.getOptions = (decimals = defaultDecimals) => {
  return SI.filter(({
    power
  }) => power < 0 ? decimals + power >= 0 : true);
};
formatBalance.setDefaults = ({
  decimals,
  unit
}) => {
  defaultDecimals = decimals === void 0 ? defaultDecimals : Array.isArray(decimals) ? decimals[0] : decimals;
  defaultUnit = unit === void 0 ? defaultUnit : Array.isArray(unit) ? unit[0] : unit;
  SI[SI_MID].text = defaultUnit;
};

// node_modules/@polkadot/util/format/formatDate.js
function zeroPad(value) {
  return value.toString().padStart(2, "0");
}
function formatDate(date) {
  const year = date.getFullYear().toString();
  const month = zeroPad(date.getMonth() + 1);
  const day = zeroPad(date.getDate());
  const hour = zeroPad(date.getHours());
  const minute = zeroPad(date.getMinutes());
  const second = zeroPad(date.getSeconds());
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}

// node_modules/@polkadot/util/format/formatNumber.js
function formatNumber(value) {
  return formatDecimal(bnToBn(value).toString());
}

// node_modules/@polkadot/util/is/string.js
function isString(value) {
  return typeof value === "string" || value instanceof String;
}

// node_modules/@polkadot/util/is/ascii.js
function isAsciiStr(str) {
  const count2 = str.length | 0;
  for (let i = 0; i < count2; i++) {
    const b = str.charCodeAt(i);
    if (b < 32 || b > 126) {
      return false;
    }
  }
  return true;
}
function isAsciiBytes(u8a) {
  const count2 = u8a.length | 0;
  for (let i = 0; i < count2; i++) {
    const b = u8a[i] | 0;
    if (b < 32 || b > 126) {
      return false;
    }
  }
  return true;
}
function isAscii(value) {
  return isString(value) ? isHex(value) ? isAsciiBytes(u8aToU8a(value)) : isAsciiStr(value) : value ? isAsciiBytes(value) : false;
}

// node_modules/@polkadot/util/is/childClass.js
function isChildClass(Parent, Child) {
  return Child ? Parent === Child || Parent.isPrototypeOf(Child) : false;
}

// node_modules/@polkadot/util/is/codec.js
var checkCodec = isOnObject("toHex", "toU8a");
var checkRegistry = isOnObject("get");
function isCodec(value) {
  return checkCodec(value) && checkRegistry(value.registry);
}

// node_modules/@polkadot/util/is/compact.js
var isCompact = isOnObject("toBigInt", "toBn", "toNumber", "unwrap");

// node_modules/@polkadot/util/is/error.js
function isError(value) {
  return (value && value.constructor) === Error || value instanceof Error;
}

// node_modules/@polkadot/util/is/ip.js
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6s = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6s}:){7}(?:${v6s}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6s}:){6}(?:${v4}|:${v6s}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6s}:){5}(?::${v4}|(?::${v6s}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6s}:){4}(?:(?::${v6s}){0,1}:${v4}|(?::${v6s}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6s}:){3}(?:(?::${v6s}){0,2}:${v4}|(?::${v6s}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6s}:){2}(?:(?::${v6s}){0,3}:${v4}|(?::${v6s}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6s}:){1}(?:(?::${v6s}){0,4}:${v4}|(?::${v6s}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6s}){0,5}:${v4}|(?::${v6s}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);

// node_modules/@polkadot/util/stringify.js
function replacer(_, v) {
  return isBigInt(v) ? v.toString() : v;
}
function stringify(value, space) {
  return JSON.stringify(value, replacer, space);
}

// node_modules/@polkadot/util/is/null.js
function isNull(value) {
  return value === null;
}

// node_modules/@polkadot/util/is/number.js
function isNumber(value) {
  return typeof value === "number";
}

// node_modules/@polkadot/util/is/observable.js
var isObservable = isOn("next");

// node_modules/@polkadot/util/is/promise.js
var isPromise = isOnObject("catch", "then");

// node_modules/@polkadot/util/is/undefined.js
function isUndefined(value) {
  return value === void 0;
}

// node_modules/@polkadot/util/is/utf8.js
function isUtf8(value) {
  if (!value) {
    return isString(value);
  }
  const u8a = u8aToU8a(value);
  const len = u8a.length;
  let i = 0;
  while (i < len) {
    if (u8a[i] <= 127) {
      i += 1;
    } else if (u8a[i] >= 194 && u8a[i] <= 223) {
      if (i + 1 < len) {
        if (u8a[i + 1] < 128 || u8a[i + 1] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 2;
    } else if (u8a[i] === 224) {
      if (i + 2 < len) {
        if (u8a[i + 1] < 160 || u8a[i + 1] > 191) {
          return false;
        }
        if (u8a[i + 2] < 128 || u8a[i + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 3;
    } else if (u8a[i] >= 225 && u8a[i] <= 236) {
      if (i + 2 < len) {
        if (u8a[i + 1] < 128 || u8a[i + 1] > 191) {
          return false;
        }
        if (u8a[i + 2] < 128 || u8a[i + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 3;
    } else if (u8a[i] === 237) {
      if (i + 2 < len) {
        if (u8a[i + 1] < 128 || u8a[i + 1] > 159) {
          return false;
        }
        if (u8a[i + 2] < 128 || u8a[i + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 3;
    } else if (u8a[i] >= 238 && u8a[i] <= 239) {
      if (i + 2 < len) {
        if (u8a[i + 1] < 128 || u8a[i + 1] > 191) {
          return false;
        }
        if (u8a[i + 2] < 128 || u8a[i + 2] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 3;
    } else if (u8a[i] === 240) {
      if (i + 3 < len) {
        if (u8a[i + 1] < 144 || u8a[i + 1] > 191) {
          return false;
        }
        if (u8a[i + 2] < 128 || u8a[i + 2] > 191) {
          return false;
        }
        if (u8a[i + 3] < 128 || u8a[i + 3] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 4;
    } else if (u8a[i] >= 241 && u8a[i] <= 243) {
      if (i + 3 < len) {
        if (u8a[i + 1] < 128 || u8a[i + 1] > 191) {
          return false;
        }
        if (u8a[i + 2] < 128 || u8a[i + 2] > 191) {
          return false;
        }
        if (u8a[i + 3] < 128 || u8a[i + 3] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 4;
    } else if (u8a[i] === 244) {
      if (i + 3 < len) {
        if (u8a[i + 1] < 128 || u8a[i + 1] > 143) {
          return false;
        }
        if (u8a[i + 2] < 128 || u8a[i + 2] > 191) {
          return false;
        }
        if (u8a[i + 3] < 128 || u8a[i + 3] > 191) {
          return false;
        }
      } else {
        return false;
      }
      i += 4;
    } else {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/util/is/wasm.js
var WASM_MAGIC = new Uint8Array([0, 97, 115, 109]);

// node_modules/@polkadot/util/lazy.js
function lazyMethod(result, item, creator, getName, index = 0) {
  const name = getName ? getName(item, index) : item.toString();
  let value;
  Object.defineProperty(result, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      if (value === void 0) {
        value = creator(item, index, this);
        try {
          Object.defineProperty(this, name, {
            value
          });
        } catch {
        }
      }
      return value;
    }
  });
}
function lazyMethods(result, items, creator, getName) {
  for (let i = 0; i < items.length; i++) {
    lazyMethod(result, items[i], creator, getName, i);
  }
  return result;
}

// node_modules/@polkadot/util/logger.js
var logTo = {
  debug: "log",
  error: "error",
  log: "log",
  warn: "warn"
};
function formatOther(value) {
  if (value && isObject(value) && value.constructor === Object) {
    const result = {};
    for (const k of Object.keys(value)) {
      result[k] = loggerFormat(value[k]);
    }
    return result;
  }
  return value;
}
function loggerFormat(value) {
  if (Array.isArray(value)) {
    return value.map(loggerFormat);
  } else if (isBn(value)) {
    return value.toString();
  } else if (isU8a(value) || isBuffer(value)) {
    return u8aToHex(u8aToU8a(value));
  }
  return formatOther(value);
}
function formatWithLength(maxLength) {
  return (v) => {
    if (maxLength <= 0) {
      return v;
    }
    const r = `${v}`;
    return r.length < maxLength ? v : `${r.substring(0, maxLength)} ...`;
  };
}
function apply(log, type, values, maxSize = -1) {
  if (values.length === 1 && isFunction(values[0])) {
    const fnResult = values[0]();
    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);
  }
  console[logTo[log]](formatDate(new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));
}
function noop() {
}
function isDebugOn(e, type) {
  return !!e && (e === "*" || type === e || e.endsWith("*") && type.startsWith(e.slice(0, -1)));
}
function isDebugOff(e, type) {
  return !!e && e.startsWith("-") && (type === e.slice(1) || e.endsWith("*") && type.startsWith(e.slice(1, -1)));
}
function getDebugFlag(env, type) {
  let flag = false;
  for (const e of env) {
    if (isDebugOn(e, type)) {
      flag = true;
    } else if (isDebugOff(e, type)) {
      flag = false;
    }
  }
  return flag;
}
function parseEnv(type) {
  const env = (hasProcess ? process : {}).env || {};
  const maxSize = parseInt(env.DEBUG_MAX || "-1", 10);
  return [getDebugFlag((env.DEBUG || "").toLowerCase().split(","), type), isNaN(maxSize) ? -1 : maxSize];
}
function logger(_type4) {
  const type = `${_type4.toUpperCase()}:`.padStart(16);
  const [isDebug, maxSize] = parseEnv(_type4.toLowerCase());
  return {
    debug: isDebug ? (...values) => apply("debug", type, values, maxSize) : noop,
    error: (...values) => apply("error", type, values),
    log: (...values) => apply("log", type, values),
    noop,
    warn: (...values) => apply("warn", type, values)
  };
}

// node_modules/@polkadot/util/memoize.js
function defaultGetId() {
  return "none";
}
function memoize(fn, {
  getInstanceId = defaultGetId
} = {}) {
  const cache = {};
  const memoized = (...args) => {
    const stringParams = stringify(args);
    const instanceId = getInstanceId();
    if (!cache[instanceId]) {
      cache[instanceId] = {};
    }
    if (cache[instanceId][stringParams] === void 0) {
      cache[instanceId][stringParams] = fn(...args);
    }
    return cache[instanceId][stringParams];
  };
  memoized.unmemoize = (...args) => {
    const stringParams = stringify(args);
    const instanceId = getInstanceId();
    if (cache[instanceId] && cache[instanceId][stringParams] !== void 0) {
      delete cache[instanceId][stringParams];
    }
  };
  return memoized;
}

// node_modules/@polkadot/util/nextTick.js
function nextTick(onExec, onError) {
  setTimeout(() => {
    Promise.resolve().then(() => {
      onExec();
    }).catch((error) => {
      if (onError) {
        onError(error);
      } else {
        console.error(error);
      }
    });
  }, 0);
}

// node_modules/@polkadot/util/object/clear.js
function objectClear(value) {
  const keys2 = Object.keys(value);
  for (let i = 0; i < keys2.length; i++) {
    delete value[keys2[i]];
  }
  return value;
}

// node_modules/@polkadot/util/object/spread.js
function objectSpread(dest, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    const src = sources[i];
    if (src) {
      if (typeof src.entries === "function") {
        for (const [key, value] of src.entries()) {
          dest[key] = value;
        }
      } else {
        Object.assign(dest, src);
      }
    }
  }
  return dest;
}

// node_modules/@polkadot/util/object/property.js
function objectProperty(that, key, getter, getName, index = 0) {
  const name = getName ? getName(key, index) : key;
  if (!(name in that)) {
    Object.defineProperty(that, name, {
      enumerable: true,
      get: function() {
        return getter(key, index, this);
      }
    });
  }
}
function objectProperties(that, keys2, getter, getName) {
  for (let i = 0; i < keys2.length; i++) {
    objectProperty(that, keys2[i], getter, getName, i);
  }
}

// node_modules/@polkadot/util/string/camelCase.js
var CC_TO_UP = new Array(256);
var CC_TO_LO = new Array(256);
for (let i = 0; i < CC_TO_UP.length; i++) {
  CC_TO_LO[i] = String.fromCharCode(i).toLowerCase();
  CC_TO_UP[i] = String.fromCharCode(i).toUpperCase();
}
function formatAllCaps(w) {
  return w.slice(0, w.length - 1).toLowerCase() + CC_TO_UP[w.charCodeAt(w.length - 1)];
}
function converter(format) {
  return (value) => {
    const parts = value.replace(/[-_., ]+/g, " ").trim().split(" ");
    const count2 = parts.length;
    let result = "";
    for (let i = 0; i < count2; i++) {
      const w = parts[i];
      result += format(/^[\dA-Z]+$/.test(w) ? w.toLowerCase() : w.replace(/^[\dA-Z]{2,}[^a-z]/, formatAllCaps), i);
    }
    return result;
  };
}
var stringCamelCase = converter((w, i) => (i ? CC_TO_UP[w.charCodeAt(0)] : CC_TO_LO[w.charCodeAt(0)]) + w.slice(1));
var stringPascalCase = converter((w) => CC_TO_UP[w.charCodeAt(0)] + w.slice(1));

// node_modules/@polkadot/util/string/lowerFirst.js
function converter2(map3) {
  return (value) => value ? map3[value.charCodeAt(0)] + value.slice(1) : "";
}
var stringLowerFirst = converter2(CC_TO_LO);
var stringUpperFirst = converter2(CC_TO_UP);

// node_modules/@polkadot/util/string/toHex.js
function stringToHex(value) {
  return u8aToHex(stringToU8a(value));
}

// node_modules/@polkadot/api-derive/packageInfo.js
var import_meta6 = {};
var packageInfo6 = {
  name: "@polkadot/api-derive",
  path: import_meta6 && import_meta6.url ? new URL(import_meta6.url).pathname.substring(0, new URL(import_meta6.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/rpc-core/packageInfo.js
var import_meta7 = {};
var packageInfo7 = {
  name: "@polkadot/rpc-core",
  path: import_meta7 && import_meta7.url ? new URL(import_meta7.url).pathname.substring(0, new URL(import_meta7.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/rpc-provider/packageInfo.js
var import_meta8 = {};
var packageInfo8 = {
  name: "@polkadot/rpc-provider",
  path: import_meta8 && import_meta8.url ? new URL(import_meta8.url).pathname.substring(0, new URL(import_meta8.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/types/packageInfo.js
var import_meta9 = {};
var packageInfo9 = {
  name: "@polkadot/types",
  path: import_meta9 && import_meta9.url ? new URL(import_meta9.url).pathname.substring(0, new URL(import_meta9.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/types-known/packageInfo.js
var import_meta10 = {};
var packageInfo10 = {
  name: "@polkadot/types-known",
  path: import_meta10 && import_meta10.url ? new URL(import_meta10.url).pathname.substring(0, new URL(import_meta10.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/api/detectOther.js
var detectOther_default2 = [packageInfo6, packageInfo7, packageInfo8, packageInfo9, packageInfo10];

// node_modules/@polkadot/api/packageInfo.js
var import_meta11 = {};
var packageInfo11 = {
  name: "@polkadot/api",
  path: import_meta11 && import_meta11.url ? new URL(import_meta11.url).pathname.substring(0, new URL(import_meta11.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/api/detectPackage.js
detectPackage(packageInfo11, null, detectOther_default2);

// node_modules/@polkadot/rpc-augment/detectOther.js
var detectOther_default3 = [packageInfo7, packageInfo9];

// node_modules/@polkadot/rpc-augment/packageInfo.js
var import_meta12 = {};
var packageInfo12 = {
  name: "@polkadot/rpc-augment",
  path: import_meta12 && import_meta12.url ? new URL(import_meta12.url).pathname.substring(0, new URL(import_meta12.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/rpc-augment/detectPackage.js
detectPackage(packageInfo12, null, detectOther_default3);

// node_modules/@polkadot/util-crypto/packageInfo.js
var import_meta13 = {};
var packageInfo13 = {
  name: "@polkadot/util-crypto",
  path: import_meta13 && import_meta13.url ? new URL(import_meta13.url).pathname.substring(0, new URL(import_meta13.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/keyring/detectOther.js
var detectOther_default4 = [packageInfo4, packageInfo13];

// node_modules/@polkadot/keyring/packageInfo.js
var import_meta14 = {};
var packageInfo14 = {
  name: "@polkadot/keyring",
  path: import_meta14 && import_meta14.url ? new URL(import_meta14.url).pathname.substring(0, new URL(import_meta14.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/keyring/detectPackage.js
detectPackage(packageInfo14, null, detectOther_default4);

// node_modules/@polkadot/networks/packageInfo.js
var import_meta15 = {};
var packageInfo15 = {
  name: "@polkadot/networks",
  path: import_meta15 && import_meta15.url ? new URL(import_meta15.url).pathname.substring(0, new URL(import_meta15.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-randomvalues/packageInfo.js
var import_meta16 = {};
var packageInfo16 = {
  name: "@polkadot/x-randomvalues",
  path: import_meta16 && import_meta16.url ? new URL(import_meta16.url).pathname.substring(0, new URL(import_meta16.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-randomvalues/browser.js
function getRandomValues(arr) {
  return xglobal.crypto.getRandomValues(arr);
}

// node_modules/@polkadot/util-crypto/detectOther.js
var detectOther_default5 = [packageInfo15, packageInfo4, packageInfo16];

// node_modules/@polkadot/util-crypto/detectPackage.js
detectPackage(packageInfo13, null, detectOther_default5);

// node_modules/@polkadot/x-bigint/shim.js
exposeGlobal("BigInt", BigInt2);

// node_modules/@noble/secp256k1/lib/esm/index.js
init_crypto();
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _8n = BigInt(8);
var CURVE = Object.freeze({
  a: _0n2,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n2,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
function weistrass(x) {
  const { a, b } = CURVE;
  const x2 = mod(x * x);
  const x3 = mod(x2 * x);
  return mod(x3 + a * x + b);
}
var USE_ENDOMORPHISM = CURVE.a === _0n2;
var ShaError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var JacobianPoint = class {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    return new JacobianPoint(p.x, p.y, _1n2);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod(Z1 * Z1);
    const Z2Z2 = mod(Z2 * Z2);
    const U1 = mod(X1 * Z2Z2);
    const U2 = mod(X2 * Z1Z1);
    const S1 = mod(mod(Y1 * Z2) * Z2Z2);
    const S2 = mod(mod(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod(X1 * X1);
    const B = mod(Y1 * Y1);
    const C = mod(B * B);
    const x1b = X1 + B;
    const D = mod(_2n * (mod(x1b * x1b) - A - C));
    const E = mod(_3n * A);
    const F = mod(E * E);
    const X3 = mod(F - _2n * D);
    const Y3 = mod(E * (D - X3) - _8n * C);
    const Z3 = mod(_2n * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n2 || Y2 === _0n2)
      return this;
    if (X1 === _0n2 || Y1 === _0n2)
      return other;
    const Z1Z1 = mod(Z1 * Z1);
    const Z2Z2 = mod(Z2 * Z2);
    const U1 = mod(X1 * Z2Z2);
    const U2 = mod(X2 * Z1Z1);
    const S1 = mod(mod(Y1 * Z2) * Z2Z2);
    const S2 = mod(mod(Y2 * Z1) * Z1Z1);
    const H = mod(U2 - U1);
    const r = mod(S2 - S1);
    if (H === _0n2) {
      if (r === _0n2) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod(H * H);
    const HHH = mod(H * HH);
    const V = mod(U1 * HH);
    const X3 = mod(r * r - HHH - _2n * V);
    const Y3 = mod(r * (V - X3) - S1 * HHH);
    const Z3 = mod(Z1 * Z2 * H);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n2)
      return P0;
    let n = normalizeScalar(scalar);
    if (n === _1n2)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d2 = this;
      while (n > _0n2) {
        if (n & _1n2)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n2;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
    let k1p = P0;
    let k2p = P0;
    let d = this;
    while (k1 > _0n2 || k2 > _0n2) {
      if (k1 & _1n2)
        k1p = k1p.add(d);
      if (k2 & _1n2)
        k2p = k2p.add(d);
      d = d.double();
      k1 >>= _1n2;
      k2 >>= _1n2;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base = p;
    for (let window3 = 0; window3 < windows; window3++) {
      base = p;
      points.push(base);
      for (let i = 1; i < 2 ** (W - 1); i++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = JacobianPoint.ZERO;
    let f = JacobianPoint.ZERO;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window3 = 0; window3 < windows; window3++) {
      const offset = window3 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n2;
      }
      if (wbits === 0) {
        let pr = precomputes[offset];
        if (window3 % 2)
          pr = pr.negate();
        f = f.add(pr);
      } else {
        let cached = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          cached = cached.negate();
        p = p.add(cached);
      }
    }
    return { p, f };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f } = this.wNAF(n, affinePoint);
      point = p;
      fake = f;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ = invert(this.z)) {
    const { x, y, z } = this;
    const iz1 = invZ;
    const iz2 = mod(iz1 * iz1);
    const iz3 = mod(iz2 * iz1);
    const ax = mod(x * iz2);
    const ay = mod(y * iz3);
    const zz = mod(z * iz1);
    if (zz !== _1n2)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n2);
JacobianPoint.ZERO = new JacobianPoint(_0n2, _1n2, _0n2);
var pointPrecomputes = new WeakMap();
var Point = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  hasEvenY() {
    return this.y % _2n === _0n2;
  }
  static fromCompressedHex(bytes3) {
    const isShort = bytes3.length === 32;
    const x = bytesToNumber(isShort ? bytes3 : bytes3.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weistrass(x);
    let y = sqrtMod(y2);
    const isYOdd = (y & _1n2) === _1n2;
    if (isShort) {
      if (isYOdd)
        y = mod(-y);
    } else {
      const isFirstByteOdd = (bytes3[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod(-y);
    }
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes3) {
    const x = bytesToNumber(bytes3.subarray(1, 33));
    const y = bytesToNumber(bytes3.subarray(33, 65));
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex3) {
    const bytes3 = ensureBytes(hex3);
    const len = bytes3.length;
    const header = bytes3[0];
    if (len === 32 || len === 33 && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes3);
    }
    if (len === 65 && header === 4)
      return this.fromUncompressedHex(bytes3);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    msgHash = ensureBytes(msgHash);
    const h = truncateHash(msgHash);
    const { r, s } = normalizeSignature(signature);
    if (recovery !== 0 && recovery !== 1) {
      throw new Error("Cannot recover signature: invalid recovery bit");
    }
    const prefix2 = recovery & 1 ? "03" : "02";
    const R = Point.fromHex(prefix2 + numTo32bStr(r));
    const { n } = CURVE;
    const rinv = invert(r, n);
    const u1 = mod(-h * rinv, n);
    const u2 = mod(s * rinv, n);
    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix2 = this.hasEvenY() ? "02" : "03";
      return `${prefix2}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod(y * y);
    const right = weistrass(x);
    if (mod(left - right) !== _0n2)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(this.x, mod(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n2 || a === _1n2 || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n2, _0n2);
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
  }
  return { r, s };
}
var Signature = class {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromCompact(hex3) {
    const arr = hex3 instanceof Uint8Array;
    const name = "Signature.fromCompact";
    if (typeof hex3 !== "string" && !arr)
      throw new TypeError(`${name}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex(hex3) : hex3;
    if (str.length !== 128)
      throw new Error(`${name}: Expected 64-byte hex`);
    return new Signature(hexToNumber2(str.slice(0, 64)), hexToNumber2(str.slice(64, 128)));
  }
  static fromDER(hex3) {
    const arr = hex3 instanceof Uint8Array;
    if (typeof hex3 !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s } = parseDERSignature(arr ? hex3 : hexToBytes(hex3));
    return new Signature(r, s);
  }
  static fromHex(hex3) {
    return this.fromDER(hex3);
  }
  assertValidity() {
    const { r, s } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n2;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
  }
  toDERRawBytes(isCompressed = false) {
    return hexToBytes(this.toDERHex(isCompressed));
  }
  toDERHex(isCompressed = false) {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    if (isCompressed)
      return sHex;
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const rLen = numberToHexUnpadded(rHex.length / 2);
    const sLen = numberToHexUnpadded(sHex.length / 2);
    const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex3 = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex3 += hexes[uint8a[i]];
  }
  return hex3;
}
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n2 <= num && num < POW_2_256))
    throw new Error("Expected number < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b = hexToBytes(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded(num) {
  const hex3 = num.toString(16);
  return hex3.length & 1 ? `0${hex3}` : hex3;
}
function hexToNumber2(hex3) {
  if (typeof hex3 !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex3);
  }
  return BigInt(`0x${hex3}`);
}
function hexToBytes(hex3) {
  if (typeof hex3 !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex3);
  }
  if (hex3.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex3.length);
  const array = new Uint8Array(hex3.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex3.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumber(bytes3) {
  return hexToNumber2(bytesToHex(bytes3));
}
function ensureBytes(hex3) {
  return hex3 instanceof Uint8Array ? Uint8Array.from(hex3) : hexToBytes(hex3);
}
function normalizeScalar(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod(a, b = CURVE.P) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n2 = BigInt(11);
  const _22n = BigInt(22);
  const _23n2 = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow2(b3, _3n) * b3 % P;
  const b9 = pow2(b6, _3n) * b3 % P;
  const b11 = pow2(b9, _2n) * b2 % P;
  const b22 = pow2(b11, _11n2) * b11 % P;
  const b44 = pow2(b22, _22n) * b22 % P;
  const b88 = pow2(b44, _44n) * b44 % P;
  const b176 = pow2(b88, _88n) * b88 % P;
  const b220 = pow2(b176, _44n) * b44 % P;
  const b223 = pow2(b220, _3n) * b3 % P;
  const t1 = pow2(b223, _23n2) * b22 % P;
  const t2 = pow2(t1, _6n) * b2 % P;
  return pow2(t2, _2n);
}
function invert(number2, modulo = CURVE.P) {
  if (number2 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n2)
      return acc;
    scratch[i] = acc;
    return mod(acc * num, p);
  }, _1n2);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n2)
      return acc;
    scratch[i] = mod(acc * scratch[i], p);
    return mod(acc * num, p);
  }, inverted);
  return scratch;
}
var divNearest = (a, b) => (a + b / _2n) / b;
var ENDO = {
  a1: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  b1: -_1n2 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
  a2: BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
  b2: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
  POW_2_128: BigInt("0x100000000000000000000000000000000")
};
function splitScalarEndo(k) {
  const { n } = CURVE;
  const { a1, b1, a2, b2, POW_2_128 } = ENDO;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = mod(k - c1 * a1 - c2 * a2, n);
  let k2 = mod(-c1 * b1 - c2 * b2, n);
  const k1neg = k1 > POW_2_128;
  const k2neg = k2 > POW_2_128;
  if (k1neg)
    k1 = n - k1;
  if (k2neg)
    k2 = n - k2;
  if (k1 > POW_2_128 || k2 > POW_2_128) {
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash2) {
  const { n } = CURVE;
  const byteLength = hash2.length;
  const delta = byteLength * 8 - 256;
  let h = bytesToNumber(hash2);
  if (delta > 0)
    h = h >> BigInt(delta);
  if (h >= n)
    h -= n;
  return h;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor() {
    this.v = new Uint8Array(32).fill(1);
    this.k = new Uint8Array(32).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
    this.v = await this.hmac(this.v);
    if (seed.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
    this.v = this.hmacSync(this.v);
    if (seed.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    this.v = await this.hmac(this.v);
    return this.v;
  }
  generateSync() {
    this.checkSync();
    this.incr();
    this.v = this.hmacSync(this.v);
    return this.v;
  }
};
function isWithinCurveOrder(num) {
  return _0n2 < num && num < CURVE.n;
}
function isValidFieldElement(num) {
  return _0n2 < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d) {
  const k = bytesToNumber(kBytes);
  if (!isWithinCurveOrder(k))
    return;
  const { n } = CURVE;
  const q = Point.BASE.multiply(k);
  const r = mod(q.x, n);
  if (r === _0n2)
    return;
  const s = mod(invert(k, n) * mod(m + d * r, n), n);
  if (s === _0n2)
    return;
  const sig2 = new Signature(r, s);
  const recovery = (q.x === sig2.r ? 0 : 2) | Number(q.y & _1n2);
  return { sig: sig2, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 64)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber2(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== 32)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
}
function getPublicKey(privateKey, isCompressed = false) {
  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
function bits2int(bytes3) {
  const slice = bytes3.length > 32 ? bytes3.slice(0, 32) : bytes3;
  return bytesToNumber(slice);
}
function bits2octets(bytes3) {
  const z1 = bits2int(bytes3);
  const z2 = mod(z1, CURVE.n);
  return int2octets(z2 < _0n2 ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils.randomBytes(32);
    const e = ensureBytes(extraEntropy);
    if (e.length !== 32)
      throw new Error("sign: Expected 32 bytes of extra data");
    seedArgs.push(e);
  }
  const seed = concatBytes(...seedArgs);
  const m = bits2int(h1);
  return { seed, m, d };
}
function finalizeSig(recSig, opts) {
  let { sig: sig2, recovery } = recSig;
  const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  if (canonical && sig2.hasHighS()) {
    sig2 = sig2.normalizeS();
    recovery ^= 1;
  }
  const hashed = der ? sig2.toDERRawBytes() : sig2.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
function signSync(msgHash, privKey, opts = {}) {
  const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  let sig2;
  const drbg = new HmacDrbg();
  drbg.reseedSync(seed);
  while (!(sig2 = kmdToSig(drbg.generateSync(), m, d)))
    drbg.reseedSync();
  return finalizeSig(sig2, opts);
}
Point.BASE._setWindowSize(8);
var crypto2 = {
  node: crypto_exports,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES = {};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  mod,
  invert,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash2) => {
    hash2 = ensureBytes(hash2);
    if (hash2.length < 40 || hash2.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    const num = mod(bytesToNumber(hash2), CURVE.n - _1n2) + _1n2;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto2.web) {
      return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto2.node) {
      const { randomBytes } = crypto2.node;
      return Uint8Array.from(randomBytes(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.hashToPrivateKey(utils.randomBytes(40));
  },
  sha256: async (...messages) => {
    if (crypto2.web) {
      const buffer2 = await crypto2.web.subtle.digest("SHA-256", concatBytes(...messages));
      return new Uint8Array(buffer2);
    } else if (crypto2.node) {
      const { createHash } = crypto2.node;
      const hash2 = createHash("sha256");
      messages.forEach((m) => hash2.update(m));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages) => {
    if (crypto2.web) {
      const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message = concatBytes(...messages);
      const buffer2 = await crypto2.web.subtle.sign("HMAC", ckey, message);
      return new Uint8Array(buffer2);
    } else if (crypto2.node) {
      const { createHmac } = crypto2.node;
      const hash2 = createHmac("sha256", key);
      messages.forEach((m) => hash2.update(m));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils.sha256(tagP, ...messages);
  },
  taggedHashSync: (tag, ...messages) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages);
  },
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  }
};
Object.defineProperties(utils, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// node_modules/@polkadot/wasm-bridge/packageInfo.js
var import_meta17 = {};
var packageInfo17 = {
  name: "@polkadot/wasm-bridge",
  path: import_meta17 && import_meta17.url ? new URL(import_meta17.url).pathname.substring(0, new URL(import_meta17.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "6.3.1"
};

// node_modules/@polkadot/wasm-crypto-asmjs/packageInfo.js
var import_meta18 = {};
var packageInfo18 = {
  name: "@polkadot/wasm-crypto-asmjs",
  path: import_meta18 && import_meta18.url ? new URL(import_meta18.url).pathname.substring(0, new URL(import_meta18.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "6.3.1"
};

// node_modules/@polkadot/wasm-crypto-init/packageInfo.js
var import_meta19 = {};
var packageInfo19 = {
  name: "@polkadot/wasm-crypto-init",
  path: import_meta19 && import_meta19.url ? new URL(import_meta19.url).pathname.substring(0, new URL(import_meta19.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "6.3.1"
};

// node_modules/@polkadot/wasm-crypto-wasm/packageInfo.js
var import_meta20 = {};
var packageInfo20 = {
  name: "@polkadot/wasm-crypto-wasm",
  path: import_meta20 && import_meta20.url ? new URL(import_meta20.url).pathname.substring(0, new URL(import_meta20.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "6.3.1"
};

// node_modules/@polkadot/wasm-util/packageInfo.js
var import_meta21 = {};
var packageInfo21 = {
  name: "@polkadot/wasm-util",
  path: import_meta21 && import_meta21.url ? new URL(import_meta21.url).pathname.substring(0, new URL(import_meta21.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "6.3.1"
};

// node_modules/@polkadot/wasm-crypto/detectOther.js
var detectOther_default6 = [packageInfo17, packageInfo18, packageInfo19, packageInfo20, packageInfo21];

// node_modules/@polkadot/wasm-crypto/packageInfo.js
var import_meta22 = {};
var packageInfo22 = {
  name: "@polkadot/wasm-crypto",
  path: import_meta22 && import_meta22.url ? new URL(import_meta22.url).pathname.substring(0, new URL(import_meta22.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "6.3.1"
};

// node_modules/@polkadot/wasm-crypto/detectPackage.js
detectPackage(packageInfo22, null, detectOther_default6);

// node_modules/@polkadot/wasm-bridge/detectOther.js
var detectOther_default7 = [];

// node_modules/@polkadot/wasm-bridge/detectPackage.js
detectPackage(packageInfo17, null, detectOther_default7);

// node_modules/@polkadot/wasm-bridge/wbg.js
var DEFAULT_CRYPTO = {
  getRandomValues
};
var DEFAULT_SELF = {
  crypto: DEFAULT_CRYPTO
};
var _bridge;
var Wbg = class {
  constructor(bridge2) {
    __privateAdd(this, _bridge, void 0);
    __publicField(this, "abort", () => {
      throw new Error("abort");
    });
    __publicField(this, "__wbindgen_is_undefined", (idx) => {
      return __privateGet(this, _bridge).getObject(idx) === void 0;
    });
    __publicField(this, "__wbindgen_throw", (ptr, len) => {
      throw new Error(__privateGet(this, _bridge).getString(ptr, len));
    });
    __publicField(this, "__wbg_self_1b7a39e3a92c949c", () => {
      return __privateGet(this, _bridge).addObject(DEFAULT_SELF);
    });
    __publicField(this, "__wbg_require_604837428532a733", (ptr, len) => {
      throw new Error(`Unable to require ${__privateGet(this, _bridge).getString(ptr, len)}`);
    });
    __publicField(this, "__wbg_crypto_968f1772287e2df0", (_idx) => {
      return __privateGet(this, _bridge).addObject(DEFAULT_CRYPTO);
    });
    __publicField(this, "__wbg_getRandomValues_a3d34b4fee3c2869", (_idx) => {
      return __privateGet(this, _bridge).addObject(DEFAULT_CRYPTO.getRandomValues);
    });
    __publicField(this, "__wbg_getRandomValues_f5e14ab7ac8e995d", (_arg0, ptr, len) => {
      DEFAULT_CRYPTO.getRandomValues(__privateGet(this, _bridge).getU8a(ptr, len));
    });
    __publicField(this, "__wbg_randomFillSync_d5bd2d655fdf256a", (_idx, _ptr, _len) => {
      throw new Error("randomFillsync is not available");
    });
    __publicField(this, "__wbindgen_object_drop_ref", (idx) => {
      __privateGet(this, _bridge).takeObject(idx);
    });
    __privateSet(this, _bridge, bridge2);
  }
};
_bridge = new WeakMap();

// node_modules/@polkadot/wasm-bridge/bridge.js
var _cachegetInt32, _cachegetUint8, _createWasm, _heap, _heapNext, _wasm, _wasmError, _wasmPromise, _wbg, _type;
var Bridge = class {
  constructor(createWasm2) {
    __privateAdd(this, _cachegetInt32, void 0);
    __privateAdd(this, _cachegetUint8, void 0);
    __privateAdd(this, _createWasm, void 0);
    __privateAdd(this, _heap, void 0);
    __privateAdd(this, _heapNext, void 0);
    __privateAdd(this, _wasm, void 0);
    __privateAdd(this, _wasmError, void 0);
    __privateAdd(this, _wasmPromise, void 0);
    __privateAdd(this, _wbg, void 0);
    __privateAdd(this, _type, void 0);
    __privateSet(this, _createWasm, createWasm2);
    __privateSet(this, _cachegetInt32, null);
    __privateSet(this, _cachegetUint8, null);
    __privateSet(this, _heap, new Array(32).fill(void 0).concat(void 0, null, true, false));
    __privateSet(this, _heapNext, __privateGet(this, _heap).length);
    __privateSet(this, _type, "none");
    __privateSet(this, _wasm, null);
    __privateSet(this, _wasmError, null);
    __privateSet(this, _wasmPromise, null);
    __privateSet(this, _wbg, __spreadValues({}, new Wbg(this)));
  }
  get error() {
    return __privateGet(this, _wasmError);
  }
  get type() {
    return __privateGet(this, _type);
  }
  get wasm() {
    return __privateGet(this, _wasm);
  }
  async init(createWasm2) {
    if (!__privateGet(this, _wasmPromise) || createWasm2) {
      __privateSet(this, _wasmPromise, (createWasm2 || __privateGet(this, _createWasm))(__privateGet(this, _wbg)));
    }
    const {
      error,
      type,
      wasm
    } = await __privateGet(this, _wasmPromise);
    __privateSet(this, _type, type);
    __privateSet(this, _wasm, wasm);
    __privateSet(this, _wasmError, error);
    return __privateGet(this, _wasm);
  }
  getObject(idx) {
    return __privateGet(this, _heap)[idx];
  }
  dropObject(idx) {
    if (idx < 36) {
      return;
    }
    __privateGet(this, _heap)[idx] = __privateGet(this, _heapNext);
    __privateSet(this, _heapNext, idx);
  }
  takeObject(idx) {
    const ret = this.getObject(idx);
    this.dropObject(idx);
    return ret;
  }
  addObject(obj) {
    if (__privateGet(this, _heapNext) === __privateGet(this, _heap).length) {
      __privateGet(this, _heap).push(__privateGet(this, _heap).length + 1);
    }
    const idx = __privateGet(this, _heapNext);
    __privateSet(this, _heapNext, __privateGet(this, _heap)[idx]);
    __privateGet(this, _heap)[idx] = obj;
    return idx;
  }
  getInt32() {
    if (__privateGet(this, _cachegetInt32) === null || __privateGet(this, _cachegetInt32).buffer !== __privateGet(this, _wasm).memory.buffer) {
      __privateSet(this, _cachegetInt32, new Int32Array(__privateGet(this, _wasm).memory.buffer));
    }
    return __privateGet(this, _cachegetInt32);
  }
  getUint8() {
    if (__privateGet(this, _cachegetUint8) === null || __privateGet(this, _cachegetUint8).buffer !== __privateGet(this, _wasm).memory.buffer) {
      __privateSet(this, _cachegetUint8, new Uint8Array(__privateGet(this, _wasm).memory.buffer));
    }
    return __privateGet(this, _cachegetUint8);
  }
  getU8a(ptr, len) {
    return this.getUint8().subarray(ptr / 1, ptr / 1 + len);
  }
  getString(ptr, len) {
    return u8aToString(this.getU8a(ptr, len));
  }
  allocU8a(arg) {
    const ptr = __privateGet(this, _wasm).__wbindgen_malloc(arg.length * 1);
    this.getUint8().set(arg, ptr / 1);
    return [ptr, arg.length];
  }
  allocString(arg) {
    return this.allocU8a(stringToU8a(arg));
  }
  resultU8a() {
    const r0 = this.getInt32()[8 / 4 + 0];
    const r1 = this.getInt32()[8 / 4 + 1];
    const ret = this.getU8a(r0, r1).slice();
    __privateGet(this, _wasm).__wbindgen_free(r0, r1 * 1);
    return ret;
  }
  resultString() {
    return u8aToString(this.resultU8a());
  }
};
_cachegetInt32 = new WeakMap();
_cachegetUint8 = new WeakMap();
_createWasm = new WeakMap();
_heap = new WeakMap();
_heapNext = new WeakMap();
_wasm = new WeakMap();
_wasmError = new WeakMap();
_wasmPromise = new WeakMap();
_wbg = new WeakMap();
_type = new WeakMap();

// node_modules/@polkadot/wasm-bridge/init.js
function createWasmFn(root, wasmBytes2, asmFn) {
  return async (wbg) => {
    const result = {
      error: null,
      type: "none",
      wasm: null
    };
    try {
      if (!wasmBytes2 || !wasmBytes2.length) {
        throw new Error("No WebAssembly provided for initialization");
      } else if (typeof WebAssembly !== "object" || typeof WebAssembly.instantiate !== "function") {
        throw new Error("WebAssembly is not available in your environment");
      }
      const source = await WebAssembly.instantiate(wasmBytes2, {
        wbg
      });
      result.wasm = source.instance.exports;
      result.type = "wasm";
    } catch (error) {
      if (typeof asmFn === "function") {
        result.wasm = asmFn(wbg);
        result.type = "asm";
      } else {
        result.error = `FATAL: Unable to initialize @polkadot/wasm-${root}:: ${error.message}`;
        console.error(result.error);
      }
    }
    return result;
  };
}

// node_modules/@polkadot/wasm-crypto-wasm/detectOther.js
var detectOther_default8 = [];

// node_modules/@polkadot/wasm-crypto-wasm/detectPackage.js
detectPackage(packageInfo20, null, detectOther_default8);

// node_modules/@polkadot/wasm-util/detectOther.js
var detectOther_default9 = [packageInfo21];

// node_modules/@polkadot/wasm-util/detectPackage.js
detectPackage(packageInfo21, null, detectOther_default9);

// node_modules/@polkadot/wasm-util/base64.js
var chr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var map = new Array(256);
for (let i = 0; i < chr.length; i++) {
  map[chr.charCodeAt(i)] = i;
}
function base64Decode(data, out) {
  const len = out.length;
  let byte = 0;
  let bits2 = 0;
  let pos = -1;
  for (let i = 0; pos < len; i++) {
    byte = byte << 6 | map[data.charCodeAt(i)];
    if ((bits2 += 6) >= 8) {
      out[++pos] = byte >>> (bits2 -= 8) & 255;
    }
  }
  return out;
}

// node_modules/@polkadot/wasm-util/fflate.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  0,
  0,
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  0,
  0
]);
var freb = (eb, start) => {
  const b = new u16(31);
  for (let i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  const r = new u32(b[30]);
  for (let i = 1; i < 30; ++i) {
    for (let j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return [b, r];
};
var [fl, revfl] = freb(fleb, 2);
fl[28] = 258, revfl[258] = 28;
var [fd] = freb(fdeb, 0);
var rev = new u16(32768);
for (let i = 0; i < 32768; ++i) {
  let x = (i & 43690) >>> 1 | (i & 21845) << 1;
  x = (x & 52428) >>> 2 | (x & 13107) << 2;
  x = (x & 61680) >>> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
}
var hMap = (cd, mb, r) => {
  const s = cd.length;
  let i = 0;
  const l16 = new u16(mb);
  for (; i < s; ++i)
    ++l16[cd[i] - 1];
  const le = new u16(mb);
  for (i = 0; i < mb; ++i) {
    le[i] = le[i - 1] + l16[i - 1] << 1;
  }
  let co;
  if (r) {
    co = new u16(1 << mb);
    const rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        const sv = i << 4 | cd[i];
        const r2 = mb - cd[i];
        let v = le[cd[i] - 1]++ << r2;
        for (const m = v | (1 << r2) - 1; v <= m; ++v) {
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i)
      co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
  }
  return co;
};
var flt = new u8(288);
for (let i = 0; i < 144; ++i)
  flt[i] = 8;
for (let i = 144; i < 256; ++i)
  flt[i] = 9;
for (let i = 256; i < 280; ++i)
  flt[i] = 7;
for (let i = 280; i < 288; ++i)
  flt[i] = 8;
var fdt = new u8(32);
for (let i = 0; i < 32; ++i)
  fdt[i] = 5;
var flrm = hMap(flt, 9, 1);
var fdrm = hMap(fdt, 5, 1);
var bits = (d, p, m) => {
  const o = p >>> 3;
  return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;
};
var bits16 = (d, p) => {
  const o = p >>> 3;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);
};
var shft = (p) => (p >>> 3) + (p & 7 && 1);
var slc = (v, s, e) => {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
  n.set(v.subarray(s, e));
  return n;
};
var max = (a) => {
  let m = a[0];
  for (let i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var inflt = (dat, buf, st) => {
  const noSt = !st || st.i;
  if (!st)
    st = {};
  const sl = dat.length;
  const noBuf = !buf || !noSt;
  if (!buf)
    buf = new u8(sl * 3);
  const cbuf = (l16) => {
    let bl = buf.length;
    if (l16 > bl) {
      const nbuf = new u8(Math.max(bl << 1, l16));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  let final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  if (final && !lm)
    return buf;
  const tbts = sl << 3;
  do {
    if (!lm) {
      st.f = final = bits(dat, pos, 1);
      const type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        const s = shft(pos) + 4, l16 = dat[s - 4] | dat[s - 3] << 8, t = s + l16;
        if (t > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + l16);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l16, st.p = pos = t << 3;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        const hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        const tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        const ldt = new u8(tl);
        const clt = new u8(19);
        for (let i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        const clb = max(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl * (clb + 7) > tbts)
          break;
        const clm = hMap(clt, clb, 1);
        for (let i = 0; i < tl; ) {
          const r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          const s = r >>> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            let c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        const lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt + 131072);
    const lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    const mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      const c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
      pos += c & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lm = void 0;
        break;
      } else {
        let add2 = sym - 254;
        if (sym > 264) {
          const i = sym - 257, b = fleb[i];
          add2 = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        const d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          throw "invalid distance";
        pos += d & 15;
        let dt = fd[dsym];
        if (dsym > 3) {
          const b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt + 131072);
        const end = bt + add2;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = pos, st.b = bt;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var zlv = (d) => {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}

// node_modules/@polkadot/wasm-crypto-wasm/bundle.js
var import_bytes = __toModule(require_bytes());
var wasmBytes = unzlibSync(base64Decode(import_bytes.bytes, new Uint8Array(import_bytes.lenIn)), new Uint8Array(import_bytes.lenOut));

// node_modules/@polkadot/wasm-crypto-init/wasm.js
var createWasm = createWasmFn("crypto", wasmBytes, null);

// node_modules/@polkadot/wasm-crypto/init.js
var bridge = new Bridge(createWasm);
async function initBridge(createWasm2) {
  return bridge.init(createWasm2);
}

// node_modules/@polkadot/wasm-crypto/bundle.js
function withWasm(fn) {
  return (...params) => {
    if (!bridge.wasm) {
      throw new Error("The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.");
    }
    return fn(bridge.wasm, ...params);
  };
}
var bip39Generate = withWasm((wasm, words) => {
  wasm.ext_bip39_generate(8, words);
  return bridge.resultString();
});
var bip39ToEntropy = withWasm((wasm, phrase) => {
  wasm.ext_bip39_to_entropy(8, ...bridge.allocString(phrase));
  return bridge.resultU8a();
});
var bip39ToMiniSecret = withWasm((wasm, phrase, password) => {
  wasm.ext_bip39_to_mini_secret(8, ...bridge.allocString(phrase), ...bridge.allocString(password));
  return bridge.resultU8a();
});
var bip39ToSeed = withWasm((wasm, phrase, password) => {
  wasm.ext_bip39_to_seed(8, ...bridge.allocString(phrase), ...bridge.allocString(password));
  return bridge.resultU8a();
});
var bip39Validate = withWasm((wasm, phrase) => {
  const ret = wasm.ext_bip39_validate(...bridge.allocString(phrase));
  return ret !== 0;
});
var ed25519KeypairFromSeed = withWasm((wasm, seed) => {
  wasm.ext_ed_from_seed(8, ...bridge.allocU8a(seed));
  return bridge.resultU8a();
});
var ed25519Sign = withWasm((wasm, pubkey, seckey, message) => {
  wasm.ext_ed_sign(8, ...bridge.allocU8a(pubkey), ...bridge.allocU8a(seckey), ...bridge.allocU8a(message));
  return bridge.resultU8a();
});
var ed25519Verify = withWasm((wasm, signature, message, pubkey) => {
  const ret = wasm.ext_ed_verify(...bridge.allocU8a(signature), ...bridge.allocU8a(message), ...bridge.allocU8a(pubkey));
  return ret !== 0;
});
var secp256k1FromSeed = withWasm((wasm, seckey) => {
  wasm.ext_secp_from_seed(8, ...bridge.allocU8a(seckey));
  return bridge.resultU8a();
});
var secp256k1Compress = withWasm((wasm, pubkey) => {
  wasm.ext_secp_pub_compress(8, ...bridge.allocU8a(pubkey));
  return bridge.resultU8a();
});
var secp256k1Expand = withWasm((wasm, pubkey) => {
  wasm.ext_secp_pub_expand(8, ...bridge.allocU8a(pubkey));
  return bridge.resultU8a();
});
var secp256k1Recover = withWasm((wasm, msgHash, sig2, recovery) => {
  wasm.ext_secp_recover(8, ...bridge.allocU8a(msgHash), ...bridge.allocU8a(sig2), recovery);
  return bridge.resultU8a();
});
var secp256k1Sign = withWasm((wasm, msgHash, seckey) => {
  wasm.ext_secp_sign(8, ...bridge.allocU8a(msgHash), ...bridge.allocU8a(seckey));
  return bridge.resultU8a();
});
var sr25519DeriveKeypairHard = withWasm((wasm, pair, cc) => {
  wasm.ext_sr_derive_keypair_hard(8, ...bridge.allocU8a(pair), ...bridge.allocU8a(cc));
  return bridge.resultU8a();
});
var sr25519DeriveKeypairSoft = withWasm((wasm, pair, cc) => {
  wasm.ext_sr_derive_keypair_soft(8, ...bridge.allocU8a(pair), ...bridge.allocU8a(cc));
  return bridge.resultU8a();
});
var sr25519DerivePublicSoft = withWasm((wasm, pubkey, cc) => {
  wasm.ext_sr_derive_public_soft(8, ...bridge.allocU8a(pubkey), ...bridge.allocU8a(cc));
  return bridge.resultU8a();
});
var sr25519KeypairFromSeed = withWasm((wasm, seed) => {
  wasm.ext_sr_from_seed(8, ...bridge.allocU8a(seed));
  return bridge.resultU8a();
});
var sr25519Sign = withWasm((wasm, pubkey, secret, message) => {
  wasm.ext_sr_sign(8, ...bridge.allocU8a(pubkey), ...bridge.allocU8a(secret), ...bridge.allocU8a(message));
  return bridge.resultU8a();
});
var sr25519Verify = withWasm((wasm, signature, message, pubkey) => {
  const ret = wasm.ext_sr_verify(...bridge.allocU8a(signature), ...bridge.allocU8a(message), ...bridge.allocU8a(pubkey));
  return ret !== 0;
});
var sr25519Agree = withWasm((wasm, pubkey, secret) => {
  wasm.ext_sr_agree(8, ...bridge.allocU8a(pubkey), ...bridge.allocU8a(secret));
  return bridge.resultU8a();
});
var vrfSign = withWasm((wasm, secret, context2, message, extra) => {
  wasm.ext_vrf_sign(8, ...bridge.allocU8a(secret), ...bridge.allocU8a(context2), ...bridge.allocU8a(message), ...bridge.allocU8a(extra));
  return bridge.resultU8a();
});
var vrfVerify = withWasm((wasm, pubkey, context2, message, extra, outAndProof) => {
  const ret = wasm.ext_vrf_verify(...bridge.allocU8a(pubkey), ...bridge.allocU8a(context2), ...bridge.allocU8a(message), ...bridge.allocU8a(extra), ...bridge.allocU8a(outAndProof));
  return ret !== 0;
});
var blake2b = withWasm((wasm, data, key, size) => {
  wasm.ext_blake2b(8, ...bridge.allocU8a(data), ...bridge.allocU8a(key), size);
  return bridge.resultU8a();
});
var hmacSha256 = withWasm((wasm, key, data) => {
  wasm.ext_hmac_sha256(8, ...bridge.allocU8a(key), ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
var hmacSha512 = withWasm((wasm, key, data) => {
  wasm.ext_hmac_sha512(8, ...bridge.allocU8a(key), ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
var keccak256 = withWasm((wasm, data) => {
  wasm.ext_keccak256(8, ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
var keccak512 = withWasm((wasm, data) => {
  wasm.ext_keccak512(8, ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
var pbkdf2 = withWasm((wasm, data, salt, rounds) => {
  wasm.ext_pbkdf2(8, ...bridge.allocU8a(data), ...bridge.allocU8a(salt), rounds);
  return bridge.resultU8a();
});
var scrypt = withWasm((wasm, password, salt, log2n, r, p) => {
  wasm.ext_scrypt(8, ...bridge.allocU8a(password), ...bridge.allocU8a(salt), log2n, r, p);
  return bridge.resultU8a();
});
var sha256 = withWasm((wasm, data) => {
  wasm.ext_sha256(8, ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
var sha512 = withWasm((wasm, data) => {
  wasm.ext_sha512(8, ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
var twox = withWasm((wasm, data, rounds) => {
  wasm.ext_twox(8, ...bridge.allocU8a(data), rounds);
  return bridge.resultU8a();
});
function isReady() {
  return !!bridge.wasm;
}
async function waitReady() {
  try {
    const wasm = await initBridge();
    return !!wasm;
  } catch {
    return false;
  }
}

// node_modules/@polkadot/util-crypto/crypto.js
function cryptoWaitReady() {
  return waitReady().then(() => {
    if (!isReady()) {
      throw new Error("Unable to initialize @polkadot/util-crypto");
    }
    return true;
  }).catch(() => false);
}

// node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes2(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
var assert2 = {
  number,
  bool,
  bytes: bytes2,
  hash,
  exists,
  output
};
var assert_default = assert2;

// node_modules/@noble/hashes/esm/cryptoBrowser.js
var crypto3 = {
  node: void 0,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};

// node_modules/@noble/hashes/esm/utils.js
var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  clone() {
    return this._cloneInto();
  }
};
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new TypeError("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l16 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l16, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE2));
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha2562 = wrapConstructor(() => new SHA256());

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l: l16 } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l16];
  }
  return [Ah, Al];
}
var toBig = (h, l16) => BigInt(h >>> 0) << _32n | BigInt(l16 >>> 0);
var shrSH = (h, l16, s) => h >>> s;
var shrSL = (h, l16, s) => h << 32 - s | l16 >>> s;
var rotrSH = (h, l16, s) => h >>> s | l16 << 32 - s;
var rotrSL = (h, l16, s) => h << 32 - s | l16 >>> s;
var rotrBH = (h, l16, s) => h << 64 - s | l16 >>> s - 32;
var rotrBL = (h, l16, s) => h >>> s - 32 | l16 << 64 - s;
var rotr32H = (h, l16) => l16;
var rotr32L = (h, l16) => h;
var rotlSH = (h, l16, s) => h << s | l16 >>> 32 - s;
var rotlSL = (h, l16, s) => l16 << s | h >>> 32 - s;
var rotlBH = (h, l16, s) => l16 << s - 32 | h >>> 64 - s;
var rotlBL = (h, l16, s) => h << s - 32 | l16 >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l16 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l16 / 2 ** 32 | 0) | 0, l: l16 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n)));
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha5122 = wrapConstructor(() => new SHA512());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@polkadot/util-crypto/hmac/shaAsU8a.js
var JS_HASH = {
  256: sha2562,
  512: sha5122
};
var WA_MHAC = {
  256: hmacSha256,
  512: hmacSha512
};
function createSha(bitLength) {
  return (key, data, onlyJs) => hmacShaAsU8a(key, data, bitLength, onlyJs);
}
function hmacShaAsU8a(key, data, bitLength = 256, onlyJs) {
  const u8aKey = u8aToU8a(key);
  return !hasBigInt || !onlyJs && isReady() ? WA_MHAC[bitLength](u8aKey, data) : hmac(JS_HASH[bitLength], u8aKey, data);
}
var hmacSha256AsU8a = createSha(256);
var hmacSha512AsU8a = createSha(512);

// node_modules/@polkadot/util-crypto/bundleInit.js
utils.hmacSha256Sync = (key, ...messages) => hmacSha256AsU8a(key, u8aConcat(...messages));
cryptoWaitReady().catch(() => {
});

// node_modules/@scure/base/lib/esm/index.js
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function chain(...args) {
  const wrap = (a, b) => (c) => a(b(c));
  const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, void 0);
  const decode2 = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, void 0);
  return { encode, decode: decode2 };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i) => {
        assertNumber(i);
        if (i < 0 || i >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
        return alphabet2[i];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from2) => {
      if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i of from2)
        if (typeof i !== "string")
          throw new Error(`join.encode: non-string input=${i}`);
      return from2.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits2, chr2 = "=") {
  assertNumber(bits2);
  if (typeof chr2 !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of data)
        if (typeof i !== "string")
          throw new Error(`padding.encode: non-string input=${i}`);
      while (data.length * bits2 % 8)
        data.push(chr2);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of input)
        if (typeof i !== "string")
          throw new Error(`padding.decode: non-string input=${i}`);
      let end = input.length;
      if (end * bits2 % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr2; end--) {
        if (!((end - 1) * bits2 % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from2) => from2, decode: (to) => fn(to) };
}
function convertRadix(data, from2, to) {
  if (from2 < 2)
    throw new Error(`convertRadix: wrong from=${from2}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from2)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < digits.length; i++) {
      const digit = digits[i];
      const digitBase = from2 * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from2 * carry / from2 !== carry || digitBase - digit !== from2 * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      digits[i] = Math.floor(digitBase / to);
      if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!digits[i])
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => !b ? a : gcd(b, a % b);
var radix2carry = (from2, to) => from2 + (to - gcd(from2, to));
function convertRadix2(data, from2, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from2 <= 0 || from2 > 32)
    throw new Error(`convertRadix2: wrong from=${from2}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from2, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry(from2, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from2)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from2}`);
    carry = carry << from2 | n;
    if (pos + from2 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
    pos += from2;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from2)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes3) => {
      if (!(bytes3 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes3), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits2, revPadding = false) {
  assertNumber(bits2);
  if (bits2 <= 0 || bits2 > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits2) > 32 || radix2carry(bits2, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes3) => {
      if (!(bytes3 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes3), 8, bits2, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(digits, bits2, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
function checksum(len, fn) {
  assertNumber(len);
  if (typeof fn !== "function")
    throw new Error("checksum fn should be function");
  return {
    encode(data) {
      if (!(data instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const checksum2 = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum2, data.length);
      return res;
    },
    decode(data) {
      if (!(data instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const newChecksum = fn(payload).slice(0, len);
      const oldChecksum = data.slice(-len);
      for (let i = 0; i < len; i++)
        if (newChecksum[i] !== oldChecksum[i])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var utils2 = { alphabet, chain, checksum, radix, radix2, join, padding };
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
var base58xmr = {
  encode(data) {
    let res = "";
    for (let i = 0; i < data.length; i += 8) {
      const block = data.subarray(i, i + 8);
      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
    }
    return res;
  },
  decode(str) {
    let res = [];
    for (let i = 0; i < str.length; i += 11) {
      const slice = str.slice(i, i + 11);
      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
      const block = base58.decode(slice);
      for (let j = 0; j < block.length - blockLen; j++) {
        if (block[j] !== 0)
          throw new Error("base58xmr: wrong padding");
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix2, words, encodingConst = 1) {
  const len = prefix2.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix2.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix2})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix2.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix2, words, limit = 90) {
    if (typeof prefix2 !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix2}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix2.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    prefix2 = prefix2.toLowerCase();
    return `${prefix2}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix2, words, ENCODING_CONST)}`;
  }
  function decode2(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    str = lowered;
    const sepIndex = str.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix2 = str.slice(0, sepIndex);
    const _words2 = str.slice(sepIndex + 1);
    if (_words2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
    const sum = bechChecksum(prefix2, words, ENCODING_CONST);
    if (!_words2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix: prefix2, words };
  }
  const decodeUnsafe = unsafeWrapper(decode2);
  function decodeToBytes(str) {
    const { prefix: prefix2, words } = decode2(str, false);
    return { prefix: prefix2, words, bytes: fromWords(words) };
  }
  return { encode, decode: decode2, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var utf8 = {
  encode: (data) => new TextDecoder().decode(data),
  decode: (str) => new TextEncoder().encode(str)
};
var hex2 = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));
var CODERS = {
  utf8,
  hex: hex2,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

// node_modules/@polkadot/util-crypto/base32/helpers.js
function createDecode({
  coder,
  ipfs
}, validate) {
  return (value, ipfsCompat) => {
    validate(value, ipfsCompat);
    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
  };
}
function createEncode({
  coder,
  ipfs
}) {
  return (value, ipfsCompat) => {
    const out = coder.encode(u8aToU8a(value));
    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;
  };
}
function createIs(validate) {
  return (value, ipfsCompat) => {
    try {
      return validate(value, ipfsCompat);
    } catch (error) {
      return false;
    }
  };
}
function createValidate({
  chars: chars2,
  ipfs,
  type
}) {
  return (value, ipfsCompat) => {
    if (!value || typeof value !== "string") {
      throw new Error(`Expected non-null, non-empty ${type} string input`);
    }
    if (ipfs && ipfsCompat && value[0] !== ipfs) {
      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
    }
    for (let i = ipfsCompat ? 1 : 0; i < value.length; i++) {
      if (!(chars2.includes(value[i]) || value[i] === "=" && (i === value.length - 1 || !chars2.includes(value[i + 1])))) {
        throw new Error(`Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
      }
    }
    return true;
  };
}

// node_modules/@polkadot/util-crypto/base58/bs58.js
var config = {
  chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  coder: base58,
  ipfs: "z",
  type: "base58"
};
var base58Validate = createValidate(config);
var base58Decode = createDecode(config, base58Validate);
var base58Encode = createEncode(config);
var isBase58 = createIs(base58Validate);

// node_modules/@noble/hashes/esm/_blake2.js
var SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(blockLen);
    assert_default.number(outputLen);
    assert_default.number(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("Blake2: outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error(`Key should be up 1..${keyLen} byte long or undefined`);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error(`Salt should be ${saltLen} byte long or undefined`);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error(`Personalization should be ${persLen} byte long or undefined`);
    this.buffer32 = u322(this.buffer = new Uint8Array(blockLen));
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, buffer: buffer2, buffer32 } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        this.compress(buffer32, 0, false);
        this.pos = 0;
      }
      const take2 = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = data.byteOffset + pos;
      if (take2 === blockLen && !(dataOffset % 4) && pos + take2 < len) {
        const data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      this.length += take2;
      pos += take2;
    }
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    this.compress(buffer32, 0, true);
    const out32 = u322(out);
    this.get().forEach((v, i) => out32[i] = v);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer: buffer2, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.length = length;
    to.finished = finished;
    to.destroyed = destroyed;
    to.outputLen = outputLen;
    to.buffer.set(buffer2);
    to.pos = pos;
    return to;
  }
};

// node_modules/@noble/hashes/esm/blake2b.js
var IV2 = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BUF = new Uint32Array(32);
function G1(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
  let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
  let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
  let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotr32H(Dh, Dl), Dl: u64_default.rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrSH(Bh, Bl, 24), Bl: u64_default.rotrSL(Bh, Bl, 24) });
  BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
  BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
  BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
  BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
}
function G2(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
  let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
  let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
  let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotrSH(Dh, Dl, 16), Dl: u64_default.rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrBH(Bh, Bl, 63), Bl: u64_default.rotrBL(Bh, Bl, 63) });
  BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
  BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
  BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
  BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
}
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
    this.v0l = IV2[0] | 0;
    this.v0h = IV2[1] | 0;
    this.v1l = IV2[2] | 0;
    this.v1h = IV2[3] | 0;
    this.v2l = IV2[4] | 0;
    this.v2h = IV2[5] | 0;
    this.v3l = IV2[6] | 0;
    this.v3h = IV2[7] | 0;
    this.v4l = IV2[8] | 0;
    this.v4h = IV2[9] | 0;
    this.v5l = IV2[10] | 0;
    this.v5h = IV2[11] | 0;
    this.v6l = IV2[12] | 0;
    this.v6h = IV2[13] | 0;
    this.v7l = IV2[14] | 0;
    this.v7h = IV2[15] | 0;
    const keyLength = opts.key ? opts.key.length : 0;
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (opts.salt) {
      const salt = u322(toBytes(opts.salt));
      this.v4l ^= salt[0];
      this.v4h ^= salt[1];
      this.v5l ^= salt[2];
      this.v5h ^= salt[3];
    }
    if (opts.personalization) {
      const pers = u322(toBytes(opts.personalization));
      this.v6l ^= pers[0];
      this.v6h ^= pers[1];
      this.v7l ^= pers[2];
      this.v7h ^= pers[3];
    }
    if (opts.key) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(toBytes(opts.key));
      this.update(tmp);
    }
  }
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BUF[i] = v);
    BUF.set(IV2, 16);
    let { h, l: l16 } = u64_default.fromBig(BigInt(this.length));
    BUF[24] = IV2[8] ^ l16;
    BUF[25] = IV2[9] ^ h;
    if (isLast) {
      BUF[28] = ~BUF[28];
      BUF[29] = ~BUF[29];
    }
    let j = 0;
    const s = SIGMA;
    for (let i = 0; i < 12; i++) {
      G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BUF[0] ^ BUF[16];
    this.v0h ^= BUF[1] ^ BUF[17];
    this.v1l ^= BUF[2] ^ BUF[18];
    this.v1h ^= BUF[3] ^ BUF[19];
    this.v2l ^= BUF[4] ^ BUF[20];
    this.v2h ^= BUF[5] ^ BUF[21];
    this.v3l ^= BUF[6] ^ BUF[22];
    this.v3h ^= BUF[7] ^ BUF[23];
    this.v4l ^= BUF[8] ^ BUF[24];
    this.v4h ^= BUF[9] ^ BUF[25];
    this.v5l ^= BUF[10] ^ BUF[26];
    this.v5h ^= BUF[11] ^ BUF[27];
    this.v6l ^= BUF[12] ^ BUF[28];
    this.v6h ^= BUF[13] ^ BUF[29];
    this.v7l ^= BUF[14] ^ BUF[30];
    this.v7h ^= BUF[15] ^ BUF[31];
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer32.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b2 = wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// node_modules/@polkadot/util-crypto/helpers.js
function createAsHex(fn) {
  return (...args) => u8aToHex(fn(...args));
}
function createBitHasher(bitLength, fn) {
  return (data, onlyJs) => fn(data, bitLength, onlyJs);
}
function createDualHasher(wa, js) {
  return (value, bitLength = 256, onlyJs) => {
    const u8a = u8aToU8a(value);
    return !hasBigInt || !onlyJs && isReady() ? wa[bitLength](u8a) : js[bitLength](u8a);
  };
}

// node_modules/@polkadot/util-crypto/blake2/asU8a.js
function blake2AsU8a(data, bitLength = 256, key, onlyJs) {
  const byteLength = Math.ceil(bitLength / 8);
  const u8a = u8aToU8a(data);
  return !hasBigInt || !onlyJs && isReady() ? blake2b(u8a, u8aToU8a(key), byteLength) : blake2b2(u8a, {
    dkLen: byteLength,
    key: key || void 0
  });
}
var blake2AsHex = createAsHex(blake2AsU8a);

// node_modules/@polkadot/util-crypto/address/sshash.js
var SS58_PREFIX = stringToU8a("SS58PRE");
function sshash(key) {
  return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
}

// node_modules/@polkadot/util-crypto/address/checksum.js
function checkAddressChecksum(decoded) {
  const ss58Length = decoded[0] & 64 ? 2 : 1;
  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;
  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
  const length = decoded.length - (isPublicKey ? 2 : 1);
  const hash2 = sshash(decoded.subarray(0, length));
  const isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash2[0] && decoded[decoded.length - 1] === hash2[1] : decoded[decoded.length - 1] === hash2[0]);
  return [isValid, length, ss58Length, ss58Decoded];
}

// node_modules/@substrate/ss58-registry/esm/index.js
var esm_default = [
  {
    "prefix": 0,
    "network": "polkadot",
    "displayName": "Polkadot Relay Chain",
    "symbols": [
      "DOT"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://polkadot.network"
  },
  {
    "prefix": 1,
    "network": "BareSr25519",
    "displayName": "Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.",
    "symbols": [],
    "decimals": [],
    "standardAccount": "Sr25519",
    "website": null
  },
  {
    "prefix": 2,
    "network": "kusama",
    "displayName": "Kusama Relay Chain",
    "symbols": [
      "KSM"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://kusama.network"
  },
  {
    "prefix": 3,
    "network": "BareEd25519",
    "displayName": "Bare 32-bit Ed25519 public key.",
    "symbols": [],
    "decimals": [],
    "standardAccount": "Ed25519",
    "website": null
  },
  {
    "prefix": 4,
    "network": "katalchain",
    "displayName": "Katal Chain",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 5,
    "network": "astar",
    "displayName": "Astar Network",
    "symbols": [
      "ASTR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://astar.network"
  },
  {
    "prefix": 6,
    "network": "bifrost",
    "displayName": "Bifrost",
    "symbols": [
      "BNC"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://bifrost.finance/"
  },
  {
    "prefix": 7,
    "network": "edgeware",
    "displayName": "Edgeware",
    "symbols": [
      "EDG"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://edgewa.re"
  },
  {
    "prefix": 8,
    "network": "karura",
    "displayName": "Karura",
    "symbols": [
      "KAR"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://karura.network/"
  },
  {
    "prefix": 9,
    "network": "reynolds",
    "displayName": "Laminar Reynolds Canary",
    "symbols": [
      "REY"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "http://laminar.network/"
  },
  {
    "prefix": 10,
    "network": "acala",
    "displayName": "Acala",
    "symbols": [
      "ACA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://acala.network/"
  },
  {
    "prefix": 11,
    "network": "laminar",
    "displayName": "Laminar",
    "symbols": [
      "LAMI"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "http://laminar.network/"
  },
  {
    "prefix": 12,
    "network": "polymesh",
    "displayName": "Polymesh",
    "symbols": [
      "POLYX"
    ],
    "decimals": [
      6
    ],
    "standardAccount": "*25519",
    "website": "https://polymath.network/"
  },
  {
    "prefix": 13,
    "network": "integritee",
    "displayName": "Integritee",
    "symbols": [
      "TEER"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://integritee.network"
  },
  {
    "prefix": 14,
    "network": "totem",
    "displayName": "Totem",
    "symbols": [
      "TOTEM"
    ],
    "decimals": [
      0
    ],
    "standardAccount": "*25519",
    "website": "https://totemaccounting.com"
  },
  {
    "prefix": 15,
    "network": "synesthesia",
    "displayName": "Synesthesia",
    "symbols": [
      "SYN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://synesthesia.network/"
  },
  {
    "prefix": 16,
    "network": "kulupu",
    "displayName": "Kulupu",
    "symbols": [
      "KLP"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://kulupu.network/"
  },
  {
    "prefix": 17,
    "network": "dark",
    "displayName": "Dark Mainnet",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 18,
    "network": "darwinia",
    "displayName": "Darwinia Network",
    "symbols": [
      "RING",
      "KTON"
    ],
    "decimals": [
      9,
      9
    ],
    "standardAccount": "*25519",
    "website": "https://darwinia.network/"
  },
  {
    "prefix": 19,
    "network": "watr",
    "displayName": "Watr Protocol",
    "symbols": [
      "WATR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://www.watr.org"
  },
  {
    "prefix": 20,
    "network": "stafi",
    "displayName": "Stafi",
    "symbols": [
      "FIS"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://stafi.io"
  },
  {
    "prefix": 22,
    "network": "dock-pos-mainnet",
    "displayName": "Dock Mainnet",
    "symbols": [
      "DCK"
    ],
    "decimals": [
      6
    ],
    "standardAccount": "*25519",
    "website": "https://dock.io"
  },
  {
    "prefix": 23,
    "network": "shift",
    "displayName": "ShiftNrg",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 24,
    "network": "zero",
    "displayName": "ZERO",
    "symbols": [
      "ZERO"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://zero.io"
  },
  {
    "prefix": 25,
    "network": "zero-alphaville",
    "displayName": "ZERO Alphaville",
    "symbols": [
      "ZERO"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://zero.io"
  },
  {
    "prefix": 26,
    "network": "jupiter",
    "displayName": "Jupiter",
    "symbols": [
      "jDOT"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://jupiter.patract.io"
  },
  {
    "prefix": 27,
    "network": "kabocha",
    "displayName": "Kabocha",
    "symbols": [
      "KAB"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://kabocha.network"
  },
  {
    "prefix": 28,
    "network": "subsocial",
    "displayName": "Subsocial",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 29,
    "network": "cord",
    "displayName": "CORD Network",
    "symbols": [
      "DHI",
      "WAY"
    ],
    "decimals": [
      12,
      12
    ],
    "standardAccount": "*25519",
    "website": "https://cord.network/"
  },
  {
    "prefix": 30,
    "network": "phala",
    "displayName": "Phala Network",
    "symbols": [
      "PHA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://phala.network"
  },
  {
    "prefix": 31,
    "network": "litentry",
    "displayName": "Litentry Network",
    "symbols": [
      "LIT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://litentry.com/"
  },
  {
    "prefix": 32,
    "network": "robonomics",
    "displayName": "Robonomics",
    "symbols": [
      "XRT"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://robonomics.network"
  },
  {
    "prefix": 33,
    "network": "datahighway",
    "displayName": "DataHighway",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 34,
    "network": "ares",
    "displayName": "Ares Protocol",
    "symbols": [
      "ARES"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://www.aresprotocol.com/"
  },
  {
    "prefix": 35,
    "network": "vln",
    "displayName": "Valiu Liquidity Network",
    "symbols": [
      "USDv"
    ],
    "decimals": [
      15
    ],
    "standardAccount": "*25519",
    "website": "https://valiu.com/"
  },
  {
    "prefix": 36,
    "network": "centrifuge",
    "displayName": "Centrifuge Chain",
    "symbols": [
      "CFG"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://centrifuge.io/"
  },
  {
    "prefix": 37,
    "network": "nodle",
    "displayName": "Nodle Chain",
    "symbols": [
      "NODL"
    ],
    "decimals": [
      11
    ],
    "standardAccount": "*25519",
    "website": "https://nodle.io/"
  },
  {
    "prefix": 38,
    "network": "kilt",
    "displayName": "KILT Spiritnet",
    "symbols": [
      "KILT"
    ],
    "decimals": [
      15
    ],
    "standardAccount": "*25519",
    "website": "https://kilt.io/"
  },
  {
    "prefix": 39,
    "network": "mathchain",
    "displayName": "MathChain mainnet",
    "symbols": [
      "MATH"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://mathwallet.org"
  },
  {
    "prefix": 40,
    "network": "mathchain-testnet",
    "displayName": "MathChain testnet",
    "symbols": [
      "MATH"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://mathwallet.org"
  },
  {
    "prefix": 41,
    "network": "poli",
    "displayName": "Polimec Chain",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": "https://polimec.io/"
  },
  {
    "prefix": 42,
    "network": "substrate",
    "displayName": "Substrate",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": "https://substrate.io/"
  },
  {
    "prefix": 43,
    "network": "BareSecp256k1",
    "displayName": "Bare 32-bit ECDSA SECP-256k1 public key.",
    "symbols": [],
    "decimals": [],
    "standardAccount": "secp256k1",
    "website": null
  },
  {
    "prefix": 44,
    "network": "chainx",
    "displayName": "ChainX",
    "symbols": [
      "PCX"
    ],
    "decimals": [
      8
    ],
    "standardAccount": "*25519",
    "website": "https://chainx.org/"
  },
  {
    "prefix": 45,
    "network": "uniarts",
    "displayName": "UniArts Network",
    "symbols": [
      "UART",
      "UINK"
    ],
    "decimals": [
      12,
      12
    ],
    "standardAccount": "*25519",
    "website": "https://uniarts.me"
  },
  {
    "prefix": 46,
    "network": "reserved46",
    "displayName": "This prefix is reserved.",
    "symbols": [],
    "decimals": [],
    "standardAccount": null,
    "website": null
  },
  {
    "prefix": 47,
    "network": "reserved47",
    "displayName": "This prefix is reserved.",
    "symbols": [],
    "decimals": [],
    "standardAccount": null,
    "website": null
  },
  {
    "prefix": 48,
    "network": "neatcoin",
    "displayName": "Neatcoin Mainnet",
    "symbols": [
      "NEAT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://neatcoin.org"
  },
  {
    "prefix": 49,
    "network": "picasso",
    "displayName": "Picasso",
    "symbols": [
      "PICA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://picasso.composable.finance"
  },
  {
    "prefix": 50,
    "network": "composable",
    "displayName": "Composable",
    "symbols": [
      "LAYR"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://composable.finance"
  },
  {
    "prefix": 51,
    "network": "oak",
    "displayName": "OAK Network",
    "symbols": [
      "OAK",
      "TUR"
    ],
    "decimals": [
      10,
      10
    ],
    "standardAccount": "*25519",
    "website": "https://oak.tech"
  },
  {
    "prefix": 52,
    "network": "KICO",
    "displayName": "KICO",
    "symbols": [
      "KICO"
    ],
    "decimals": [
      14
    ],
    "standardAccount": "*25519",
    "website": "https://dico.io"
  },
  {
    "prefix": 53,
    "network": "DICO",
    "displayName": "DICO",
    "symbols": [
      "DICO"
    ],
    "decimals": [
      14
    ],
    "standardAccount": "*25519",
    "website": "https://dico.io"
  },
  {
    "prefix": 54,
    "network": "cere",
    "displayName": "Cere Network",
    "symbols": [
      "CERE"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://cere.network"
  },
  {
    "prefix": 55,
    "network": "xxnetwork",
    "displayName": "xx network",
    "symbols": [
      "XX"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://xx.network"
  },
  {
    "prefix": 56,
    "network": "pendulum",
    "displayName": "Pendulum chain",
    "symbols": [
      "PEN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://pendulumchain.org/"
  },
  {
    "prefix": 57,
    "network": "amplitude",
    "displayName": "Amplitude chain",
    "symbols": [
      "AMPE"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://pendulumchain.org/"
  },
  {
    "prefix": 63,
    "network": "hydradx",
    "displayName": "HydraDX",
    "symbols": [
      "HDX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://hydradx.io"
  },
  {
    "prefix": 65,
    "network": "aventus",
    "displayName": "AvN Mainnet",
    "symbols": [
      "AVT"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://aventus.io"
  },
  {
    "prefix": 66,
    "network": "crust",
    "displayName": "Crust Network",
    "symbols": [
      "CRU"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://crust.network"
  },
  {
    "prefix": 67,
    "network": "genshiro",
    "displayName": "Genshiro Network",
    "symbols": [
      "GENS",
      "EQD",
      "LPT0"
    ],
    "decimals": [
      9,
      9,
      9
    ],
    "standardAccount": "*25519",
    "website": "https://genshiro.equilibrium.io"
  },
  {
    "prefix": 68,
    "network": "equilibrium",
    "displayName": "Equilibrium Network",
    "symbols": [
      "EQ"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://equilibrium.io"
  },
  {
    "prefix": 69,
    "network": "sora",
    "displayName": "SORA Network",
    "symbols": [
      "XOR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://sora.org"
  },
  {
    "prefix": 71,
    "network": "p3d",
    "displayName": "3DP network",
    "symbols": [
      "P3D"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://3dpass.org"
  },
  {
    "prefix": 72,
    "network": "p3dt",
    "displayName": "3DP test network",
    "symbols": [
      "P3Dt"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://3dpass.org"
  },
  {
    "prefix": 73,
    "network": "zeitgeist",
    "displayName": "Zeitgeist",
    "symbols": [
      "ZTG"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://zeitgeist.pm"
  },
  {
    "prefix": 77,
    "network": "manta",
    "displayName": "Manta network",
    "symbols": [
      "MANTA"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://manta.network"
  },
  {
    "prefix": 78,
    "network": "calamari",
    "displayName": "Calamari: Manta Canary Network",
    "symbols": [
      "KMA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://manta.network"
  },
  {
    "prefix": 88,
    "network": "polkadex",
    "displayName": "Polkadex Mainnet",
    "symbols": [
      "PDEX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://polkadex.trade"
  },
  {
    "prefix": 89,
    "network": "polkadexparachain",
    "displayName": "Polkadex Parachain",
    "symbols": [
      "PDEX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://polkadex.trade"
  },
  {
    "prefix": 90,
    "network": "frequency",
    "displayName": "Frequency",
    "symbols": [
      "FRQCY"
    ],
    "decimals": [
      8
    ],
    "standardAccount": "*25519",
    "website": "https://www.frequency.xyz"
  },
  {
    "prefix": 92,
    "network": "anmol",
    "displayName": "Anmol Network",
    "symbols": [
      "ANML"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://anmol.network/"
  },
  {
    "prefix": 93,
    "network": "fragnova",
    "displayName": "Fragnova Network",
    "symbols": [
      "NOVA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://fragnova.com"
  },
  {
    "prefix": 98,
    "network": "polkasmith",
    "displayName": "PolkaSmith Canary Network",
    "symbols": [
      "PKS"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://polkafoundry.com"
  },
  {
    "prefix": 99,
    "network": "polkafoundry",
    "displayName": "PolkaFoundry Network",
    "symbols": [
      "PKF"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://polkafoundry.com"
  },
  {
    "prefix": 100,
    "network": "ibtida",
    "displayName": "Anmol Network Ibtida Canary network",
    "symbols": [
      "IANML"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://anmol.network/"
  },
  {
    "prefix": 101,
    "network": "origintrail-parachain",
    "displayName": "OriginTrail Parachain",
    "symbols": [
      "OTP"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://parachain.origintrail.io/"
  },
  {
    "prefix": 105,
    "network": "pontem-network",
    "displayName": "Pontem Network",
    "symbols": [
      "PONT"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://pontem.network"
  },
  {
    "prefix": 110,
    "network": "heiko",
    "displayName": "Heiko",
    "symbols": [
      "HKO"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://parallel.fi/"
  },
  {
    "prefix": 113,
    "network": "integritee-incognito",
    "displayName": "Integritee Incognito",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": "https://integritee.network"
  },
  {
    "prefix": 117,
    "network": "tinker",
    "displayName": "Tinker",
    "symbols": [
      "TNKR"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://invarch.network"
  },
  {
    "prefix": 126,
    "network": "joystream",
    "displayName": "Joystream",
    "symbols": [
      "JOY"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://www.joystream.org"
  },
  {
    "prefix": 128,
    "network": "clover",
    "displayName": "Clover Finance",
    "symbols": [
      "CLV"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://clover.finance"
  },
  {
    "prefix": 129,
    "network": "dorafactory-polkadot",
    "displayName": "Dorafactory Polkadot Network",
    "symbols": [
      "DORA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://dorafactory.org"
  },
  {
    "prefix": 131,
    "network": "litmus",
    "displayName": "Litmus Network",
    "symbols": [
      "LIT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://litentry.com/"
  },
  {
    "prefix": 136,
    "network": "altair",
    "displayName": "Altair",
    "symbols": [
      "AIR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://centrifuge.io/"
  },
  {
    "prefix": 137,
    "network": "vara",
    "displayName": "Vara Network",
    "symbols": [
      "VARA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://vara-network.io/"
  },
  {
    "prefix": 172,
    "network": "parallel",
    "displayName": "Parallel",
    "symbols": [
      "PARA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://parallel.fi/"
  },
  {
    "prefix": 252,
    "network": "social-network",
    "displayName": "Social Network",
    "symbols": [
      "NET"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://social.network"
  },
  {
    "prefix": 255,
    "network": "quartz_mainnet",
    "displayName": "QUARTZ by UNIQUE",
    "symbols": [
      "QTZ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://unique.network"
  },
  {
    "prefix": 268,
    "network": "pioneer_network",
    "displayName": "Pioneer Network by Bit.Country",
    "symbols": [
      "NEER"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://bit.country"
  },
  {
    "prefix": 420,
    "network": "sora_kusama_para",
    "displayName": "SORA Kusama Parachain",
    "symbols": [
      "XOR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://sora.org"
  },
  {
    "prefix": 789,
    "network": "geek",
    "displayName": "GEEK Network",
    "symbols": [
      "GEEK"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://geek.gl"
  },
  {
    "prefix": 1110,
    "network": "efinity",
    "displayName": "Efinity",
    "symbols": [
      "EFI"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://efinity.io/"
  },
  {
    "prefix": 1221,
    "network": "peaq",
    "displayName": "Peaq Network",
    "symbols": [
      "PEAQ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "Sr25519",
    "website": "https://www.peaq.network/"
  },
  {
    "prefix": 1222,
    "network": "apex",
    "displayName": "Apex Network",
    "symbols": [
      "APEX"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "Sr25519",
    "website": "https://www.peaq.network/"
  },
  {
    "prefix": 1284,
    "network": "moonbeam",
    "displayName": "Moonbeam",
    "symbols": [
      "GLMR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "secp256k1",
    "website": "https://moonbeam.network"
  },
  {
    "prefix": 1285,
    "network": "moonriver",
    "displayName": "Moonriver",
    "symbols": [
      "MOVR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "secp256k1",
    "website": "https://moonbeam.network"
  },
  {
    "prefix": 1328,
    "network": "ajuna",
    "displayName": "Ajuna Network",
    "symbols": [
      "AJUN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://ajuna.io"
  },
  {
    "prefix": 1337,
    "network": "bajun",
    "displayName": "Bajun Network",
    "symbols": [
      "BAJU"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://ajuna.io"
  },
  {
    "prefix": 1985,
    "network": "seals",
    "displayName": "Seals Network",
    "symbols": [
      "SEAL"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://seals.app"
  },
  {
    "prefix": 2007,
    "network": "kapex",
    "displayName": "Kapex",
    "symbols": [
      "KAPEX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://totemaccounting.com"
  },
  {
    "prefix": 2009,
    "network": "cloudwalk_mainnet",
    "displayName": "CloudWalk Network Mainnet",
    "symbols": [
      "CWN"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://explorer.mainnet.cloudwalk.io"
  },
  {
    "prefix": 2032,
    "network": "interlay",
    "displayName": "Interlay",
    "symbols": [
      "INTR"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://interlay.io/"
  },
  {
    "prefix": 2092,
    "network": "kintsugi",
    "displayName": "Kintsugi",
    "symbols": [
      "KINT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://interlay.io/"
  },
  {
    "prefix": 2106,
    "network": "bitgreen",
    "displayName": "Bitgreen",
    "symbols": [
      "BBB"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://bitgreen.org/"
  },
  {
    "prefix": 2112,
    "network": "chainflip",
    "displayName": "Chainflip",
    "symbols": [
      "FLIP"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://chainflip.io/"
  },
  {
    "prefix": 2114,
    "network": "Turing",
    "displayName": "Turing Network",
    "symbols": [
      "TUR"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://oak.tech/turing/home/"
  },
  {
    "prefix": 2207,
    "network": "SNOW",
    "displayName": "SNOW: ICE Canary Network",
    "symbols": [
      "ICZ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://icenetwork.io"
  },
  {
    "prefix": 2208,
    "network": "ICE",
    "displayName": "ICE Network",
    "symbols": [
      "ICY"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://icenetwork.io"
  },
  {
    "prefix": 2254,
    "network": "subspace_testnet",
    "displayName": "Subspace testnet",
    "symbols": [
      "tSSC"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://subspace.network"
  },
  {
    "prefix": 4006,
    "network": "tangle",
    "displayName": "Tangle Network",
    "symbols": [
      "TNT"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://www.webb.tools/"
  },
  {
    "prefix": 4450,
    "network": "g1",
    "displayName": "\u011E1",
    "symbols": [
      "G1"
    ],
    "decimals": [
      2
    ],
    "standardAccount": "*25519",
    "website": "https://duniter.org"
  },
  {
    "prefix": 5234,
    "network": "humanode",
    "displayName": "Humanode Network",
    "symbols": [
      "HMND"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://humanode.io"
  },
  {
    "prefix": 6094,
    "network": "subspace",
    "displayName": "Subspace",
    "symbols": [
      "SSC"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://subspace.network"
  },
  {
    "prefix": 7007,
    "network": "tidefi",
    "displayName": "Tidefi",
    "symbols": [
      "TDFY"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://tidefi.com"
  },
  {
    "prefix": 7013,
    "network": "gm",
    "displayName": "GM",
    "symbols": [
      "FREN",
      "GM",
      "GN"
    ],
    "decimals": [
      12,
      0,
      0
    ],
    "standardAccount": "*25519",
    "website": "https://gmordie.com"
  },
  {
    "prefix": 7391,
    "network": "unique_mainnet",
    "displayName": "Unique Network",
    "symbols": [
      "UNQ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://unique.network"
  },
  {
    "prefix": 8883,
    "network": "sapphire_mainnet",
    "displayName": "Sapphire by Unique",
    "symbols": [
      "QTZ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://unique.network"
  },
  {
    "prefix": 9072,
    "network": "hashed",
    "displayName": "Hashed Network",
    "symbols": [
      "HASH"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://hashed.network"
  },
  {
    "prefix": 9807,
    "network": "dentnet",
    "displayName": "DENTNet",
    "symbols": [
      "DENTX"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://www.dentnet.io"
  },
  {
    "prefix": 9935,
    "network": "t3rn",
    "displayName": "t3rn",
    "symbols": [
      "TRN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://t3rn.io/"
  },
  {
    "prefix": 10041,
    "network": "basilisk",
    "displayName": "Basilisk",
    "symbols": [
      "BSX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://bsx.fi"
  },
  {
    "prefix": 11330,
    "network": "cess-testnet",
    "displayName": "CESS Testnet",
    "symbols": [
      "TCESS"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://cess.cloud"
  },
  {
    "prefix": 11331,
    "network": "cess",
    "displayName": "CESS",
    "symbols": [
      "CESS"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://cess.cloud"
  },
  {
    "prefix": 11486,
    "network": "luhn",
    "displayName": "Luhn Network",
    "symbols": [
      "LUHN"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://luhn.network"
  },
  {
    "prefix": 11820,
    "network": "contextfree",
    "displayName": "Automata ContextFree",
    "symbols": [
      "CTX"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://ata.network"
  },
  {
    "prefix": 12191,
    "network": "nftmart",
    "displayName": "NFTMart",
    "symbols": [
      "NMT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://nftmart.io"
  }
];

// node_modules/@polkadot/networks/defaults/genesis.js
var knownGenesis = {
  acala: ["0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"],
  "aleph-node": ["0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"],
  astar: ["0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"],
  basilisk: ["0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"],
  bifrost: ["0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"],
  "bifrost-kusama": ["0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"],
  centrifuge: ["0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82", "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"],
  composable: ["0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"],
  darwinia: ["0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"],
  "dock-mainnet": ["0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae", "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"],
  edgeware: ["0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"],
  equilibrium: ["0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"],
  genshiro: ["0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"],
  hydradx: [
    "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
    "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
    "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
    "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
    "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
  ],
  "interlay-parachain": ["0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"],
  karura: ["0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"],
  khala: ["0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"],
  kulupu: ["0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"],
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
  ],
  "nodle-para": ["0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"],
  origintrail: ["0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"],
  parallel: ["0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"],
  phala: ["0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"],
  picasso: ["0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"],
  polkadex: ["0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"],
  polkadot: ["0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"],
  polymesh: ["0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"],
  rococo: ["0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e", "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897", "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770", "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff", "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a", "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9", "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779", "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215", "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9", "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147", "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd", "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"],
  sora: ["0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"],
  stafi: ["0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"],
  statemine: ["0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"],
  statemint: ["0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"],
  subsocial: ["0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"],
  unique: ["0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"],
  vtb: ["0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f", "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"],
  westend: ["0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"],
  xxnetwork: ["0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"]
};

// node_modules/@polkadot/networks/defaults/icons.js
var knownIcon = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
};

// node_modules/@polkadot/networks/defaults/ledger.js
var knownLedger = {
  acala: 787,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  centrifuge: 747,
  composable: 354,
  darwinia: 354,
  "dock-mainnet": 594,
  edgeware: 523,
  equilibrium: 99999997,
  genshiro: 99999996,
  hydradx: 354,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  "nodle-para": 1003,
  origintrail: 354,
  parallel: 354,
  phala: 354,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  sora: 617,
  stafi: 907,
  statemine: 434,
  statemint: 354,
  unique: 354,
  vtb: 694,
  xxnetwork: 1955
};

// node_modules/@polkadot/networks/defaults/testnets.js
var knownTestnet = {
  "": true,
  "cess-testnet": true,
  "dock-testnet": true,
  jupiter: true,
  "mathchain-testnet": true,
  p3dt: true,
  subspace_testnet: true,
  "zero-alphaville": true
};

// node_modules/@polkadot/networks/interfaces.js
var UNSORTED = [0, 2, 42];
var TESTNETS = ["testnet"];
function toExpanded(o) {
  const network = o.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n = o;
  n.slip44 = knownLedger[network];
  n.hasLedgerSupport = !!n.slip44;
  n.genesisHash = knownGenesis[network] || [];
  n.icon = knownIcon[network] || "substrate";
  n.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n.isIgnored = n.isTestnet || !(o.standardAccount && o.decimals && o.decimals.length && o.symbols && o.symbols.length) && o.prefix !== 42;
  return n;
}
function filterSelectable({
  genesisHash,
  prefix: prefix2
}) {
  return !!genesisHash.length || prefix2 === 42;
}
function filterAvailable(n) {
  return !n.isIgnored && !!n.network;
}
function sortNetworks(a, b) {
  const isUnSortedA = UNSORTED.includes(a.prefix);
  const isUnSortedB = UNSORTED.includes(b.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a.displayName.localeCompare(b.displayName) : isUnSortedA ? -1 : 1;
}
var allNetworks = esm_default.map(toExpanded);
var availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
var selectableNetworks = availableNetworks.filter(filterSelectable);

// node_modules/@polkadot/util-crypto/address/defaults.js
var defaults = {
  allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
  allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
  allowedPrefix: availableNetworks.map(({
    prefix: prefix2
  }) => prefix2),
  prefix: 42
};

// node_modules/@polkadot/util-crypto/address/decode.js
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (!encoded) {
    throw new Error("Invalid empty address passed");
  }
  if (isU8a(encoded) || isHex(encoded)) {
    return u8aToU8a(encoded);
  }
  try {
    const decoded = base58Decode(encoded);
    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      throw new Error("Invalid decoded address length");
    }
    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
    if (!isValid && !ignoreChecksum) {
      throw new Error("Invalid decoded address checksum");
    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
    }
    return decoded.slice(ss58Length, endPos);
  } catch (error) {
    throw new Error(`Decoding ${encoded}: ${error.message}`);
  }
}

// node_modules/@polkadot/util-crypto/bn.js
var BN_BE_OPTS = {
  isLe: false
};
var BN_LE_OPTS = {
  isLe: true
};
var BN_BE_32_OPTS = {
  bitLength: 32,
  isLe: false
};
var BN_LE_32_OPTS = {
  bitLength: 32,
  isLe: true
};
var BN_BE_256_OPTS = {
  bitLength: 256,
  isLe: false
};
var BN_LE_256_OPTS = {
  bitLength: 256,
  isLe: true
};

// node_modules/@polkadot/util-crypto/address/keyMulti.js
var PREFIX = stringToU8a("modlpy/utilisuba");

// node_modules/@polkadot/util-crypto/address/keyDerived.js
var PREFIX2 = stringToU8a("modlpy/utilisuba");

// node_modules/@polkadot/util-crypto/key/DeriveJunction.js
var RE_NUMBER = /^\d+$/;
var JUNCTION_ID_LEN = 32;
var _chainCode, _isHard;
var _DeriveJunction = class {
  constructor() {
    __privateAdd(this, _chainCode, new Uint8Array(32));
    __privateAdd(this, _isHard, false);
  }
  static from(value) {
    const result = new _DeriveJunction();
    const [code, isHard] = value.startsWith("/") ? [value.substring(1), true] : [value, false];
    result.soft(RE_NUMBER.test(code) ? new import_bn.default(code, 10) : code);
    return isHard ? result.harden() : result;
  }
  get chainCode() {
    return __privateGet(this, _chainCode);
  }
  get isHard() {
    return __privateGet(this, _isHard);
  }
  get isSoft() {
    return !__privateGet(this, _isHard);
  }
  hard(value) {
    return this.soft(value).harden();
  }
  harden() {
    __privateSet(this, _isHard, true);
    return this;
  }
  soft(value) {
    if (isNumber(value) || isBn(value) || isBigInt(value)) {
      return this.soft(bnToU8a(value, BN_LE_256_OPTS));
    } else if (isHex(value)) {
      return this.soft(hexToU8a(value));
    } else if (isString(value)) {
      return this.soft(compactAddLength(stringToU8a(value)));
    } else if (value.length > JUNCTION_ID_LEN) {
      return this.soft(blake2AsU8a(value));
    }
    __privateGet(this, _chainCode).fill(0);
    __privateGet(this, _chainCode).set(value, 0);
    return this;
  }
  soften() {
    __privateSet(this, _isHard, false);
    return this;
  }
};
var DeriveJunction = _DeriveJunction;
_chainCode = new WeakMap();
_isHard = new WeakMap();

// node_modules/@polkadot/util-crypto/key/extractPath.js
var RE_JUNCTION = /\/(\/?)([^/]+)/g;
function keyExtractPath(derivePath) {
  const parts = derivePath.match(RE_JUNCTION);
  const path = [];
  let constructed = "";
  if (parts) {
    constructed = parts.join("");
    for (const p of parts) {
      path.push(DeriveJunction.from(p.substring(1)));
    }
  }
  if (constructed !== derivePath) {
    throw new Error(`Re-constructed path "${constructed}" does not match input`);
  }
  return {
    parts,
    path
  };
}

// node_modules/@polkadot/util-crypto/key/extractSuri.js
var RE_CAPTURE = /^(\w+( \w+)*)((\/\/?[^/]+)*)(\/\/\/(.*))?$/;
function keyExtractSuri(suri) {
  const matches = suri.match(RE_CAPTURE);
  if (matches === null) {
    throw new Error("Unable to match provided value to a secret URI");
  }
  const [, phrase, , derivePath, , , password] = matches;
  const {
    path
  } = keyExtractPath(derivePath);
  return {
    derivePath,
    password,
    path,
    phrase
  };
}

// node_modules/@polkadot/util-crypto/secp256k1/deriveHard.js
var HDKD = compactAddLength(stringToU8a("Secp256k1HDKD"));
function secp256k1DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);
}

// node_modules/@polkadot/util-crypto/secp256k1/pair/fromSeed.js
function secp256k1PairFromSeed(seed, onlyJs) {
  if (seed.length !== 32) {
    throw new Error("Expected valid 32-byte private key as a seed");
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = secp256k1FromSeed(seed);
    const publicKey2 = full.slice(32);
    if (u8aEmpty(publicKey2)) {
      throw new Error("Invalid publicKey generated from WASM interface");
    }
    return {
      publicKey: publicKey2,
      secretKey: full.slice(0, 32)
    };
  }
  return {
    publicKey: getPublicKey(seed, true),
    secretKey: seed
  };
}

// node_modules/@polkadot/util-crypto/key/hdkdDerive.js
function createSeedDeriveFn(fromSeed, derive2) {
  return (keypair, {
    chainCode,
    isHard
  }) => {
    if (!isHard) {
      throw new Error("A soft key was found in the path and is not supported");
    }
    return fromSeed(derive2(keypair.secretKey.subarray(0, 32), chainCode));
  };
}

// node_modules/@polkadot/util-crypto/key/hdkdEcdsa.js
var keyHdkdEcdsa = createSeedDeriveFn(secp256k1PairFromSeed, secp256k1DeriveHard);

// node_modules/@polkadot/util-crypto/ed25519/convertKey.js
var import_ed2curve = __toModule(require_ed2curve());
function convertSecretKeyToCurve25519(secretKey) {
  return import_ed2curve.default.convertSecretKey(secretKey);
}
function convertPublicKeyToCurve25519(publicKey2) {
  return assertReturn(import_ed2curve.default.convertPublicKey(publicKey2), "Unable to convert publicKey to ed25519");
}

// node_modules/@polkadot/util-crypto/ed25519/deriveHard.js
var HDKD2 = compactAddLength(stringToU8a("Ed25519HDKD"));
function ed25519DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD2, seed, chainCode));
}

// node_modules/@polkadot/util-crypto/random/asU8a.js
function randomAsU8a(length = 32) {
  return getRandomValues(new Uint8Array(length));
}
var randomAsHex = createAsHex(randomAsU8a);

// node_modules/@polkadot/util-crypto/random/asNumber.js
var BN_53 = new import_bn.default(9007199254740991);

// node_modules/@polkadot/util-crypto/ed25519/pair/fromSeed.js
var import_tweetnacl = __toModule(require_nacl_fast());
function ed25519PairFromSeed(seed, onlyJs) {
  if (!onlyJs && isReady()) {
    const full = ed25519KeypairFromSeed(seed);
    return {
      publicKey: full.slice(32),
      secretKey: full.slice(0, 64)
    };
  }
  return import_tweetnacl.default.sign.keyPair.fromSeed(seed);
}

// node_modules/@polkadot/util-crypto/ed25519/pair/fromSecret.js
var import_tweetnacl2 = __toModule(require_nacl_fast());

// node_modules/@polkadot/util-crypto/ed25519/sign.js
var import_tweetnacl3 = __toModule(require_nacl_fast());
function ed25519Sign2(message, {
  publicKey: publicKey2,
  secretKey
}, onlyJs) {
  if (!secretKey) {
    throw new Error("Expected a valid secretKey");
  }
  const messageU8a = u8aToU8a(message);
  return !onlyJs && isReady() ? ed25519Sign(publicKey2, secretKey.subarray(0, 32), messageU8a) : import_tweetnacl3.default.sign.detached(messageU8a, secretKey);
}

// node_modules/@polkadot/util-crypto/ed25519/verify.js
var import_tweetnacl4 = __toModule(require_nacl_fast());
function ed25519Verify2(message, signature, publicKey2, onlyJs) {
  const messageU8a = u8aToU8a(message);
  const publicKeyU8a = u8aToU8a(publicKey2);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  return !onlyJs && isReady() ? ed25519Verify(signatureU8a, messageU8a, publicKeyU8a) : import_tweetnacl4.default.sign.detached.verify(messageU8a, signatureU8a, publicKeyU8a);
}

// node_modules/@polkadot/util-crypto/key/hdkdEd25519.js
var keyHdkdEd25519 = createSeedDeriveFn(ed25519PairFromSeed, ed25519DeriveHard);

// node_modules/@polkadot/util-crypto/sr25519/pair/fromU8a.js
var SEC_LEN = 64;
var PUB_LEN = 32;
var TOT_LEN = SEC_LEN + PUB_LEN;
function sr25519PairFromU8a(full) {
  const fullU8a = u8aToU8a(full);
  if (fullU8a.length !== TOT_LEN) {
    throw new Error(`Expected keypair with ${TOT_LEN} bytes, found ${fullU8a.length}`);
  }
  return {
    publicKey: fullU8a.slice(SEC_LEN, TOT_LEN),
    secretKey: fullU8a.slice(0, SEC_LEN)
  };
}

// node_modules/@polkadot/util-crypto/sr25519/pair/toU8a.js
function sr25519KeypairToU8a({
  publicKey: publicKey2,
  secretKey
}) {
  return u8aConcat(secretKey, publicKey2).slice();
}

// node_modules/@polkadot/util-crypto/sr25519/derive.js
function createDeriveFn(derive2) {
  return (keypair, chainCode) => {
    if (!isU8a(chainCode) || chainCode.length !== 32) {
      throw new Error("Invalid chainCode passed to derive");
    }
    return sr25519PairFromU8a(derive2(sr25519KeypairToU8a(keypair), chainCode));
  };
}

// node_modules/@polkadot/util-crypto/sr25519/deriveHard.js
var sr25519DeriveHard = createDeriveFn(sr25519DeriveKeypairHard);

// node_modules/@polkadot/util-crypto/sr25519/deriveSoft.js
var sr25519DeriveSoft = createDeriveFn(sr25519DeriveKeypairSoft);

// node_modules/@polkadot/util-crypto/key/hdkdSr25519.js
function keyHdkdSr25519(keypair, {
  chainCode,
  isSoft
}) {
  return isSoft ? sr25519DeriveSoft(keypair, chainCode) : sr25519DeriveHard(keypair, chainCode);
}

// node_modules/@polkadot/util-crypto/key/fromPath.js
var generators = {
  ecdsa: keyHdkdEcdsa,
  ed25519: keyHdkdEd25519,
  ethereum: keyHdkdEcdsa,
  sr25519: keyHdkdSr25519
};
function keyFromPath(pair, path, type) {
  const keyHdkd = generators[type];
  let result = pair;
  for (const junction of path) {
    result = keyHdkd(result, junction);
  }
  return result;
}

// node_modules/@polkadot/util-crypto/sr25519/pair/fromSeed.js
function sr25519PairFromSeed(seed) {
  const seedU8a = u8aToU8a(seed);
  if (seedU8a.length !== 32) {
    throw new Error(`Expected a seed matching 32 bytes, found ${seedU8a.length}`);
  }
  return sr25519PairFromU8a(sr25519KeypairFromSeed(seedU8a));
}

// node_modules/@polkadot/util-crypto/sr25519/sign.js
function sr25519Sign2(message, {
  publicKey: publicKey2,
  secretKey
}) {
  if ((publicKey2 == null ? void 0 : publicKey2.length) !== 32) {
    throw new Error("Expected a valid publicKey, 32-bytes");
  } else if ((secretKey == null ? void 0 : secretKey.length) !== 64) {
    throw new Error("Expected a valid secretKey, 64-bytes");
  }
  return sr25519Sign(publicKey2, secretKey, u8aToU8a(message));
}

// node_modules/@polkadot/util-crypto/sr25519/verify.js
function sr25519Verify2(message, signature, publicKey2) {
  const publicKeyU8a = u8aToU8a(publicKey2);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  return sr25519Verify(signatureU8a, u8aToU8a(message), publicKeyU8a);
}

// node_modules/@polkadot/util-crypto/sr25519/vrfSign.js
var EMPTY_U8A = new Uint8Array();
function sr25519VrfSign(message, {
  secretKey
}, context2 = EMPTY_U8A, extra = EMPTY_U8A) {
  if ((secretKey == null ? void 0 : secretKey.length) !== 64) {
    throw new Error("Invalid secretKey, expected 64-bytes");
  }
  return vrfSign(secretKey, u8aToU8a(context2), u8aToU8a(message), u8aToU8a(extra));
}

// node_modules/@polkadot/util-crypto/sr25519/vrfVerify.js
var EMPTY_U8A2 = new Uint8Array();
function sr25519VrfVerify(message, signOutput, publicKey2, context2 = EMPTY_U8A2, extra = EMPTY_U8A2) {
  const publicKeyU8a = u8aToU8a(publicKey2);
  const proofU8a = u8aToU8a(signOutput);
  if (publicKeyU8a.length !== 32) {
    throw new Error("Invalid publicKey, expected 32-bytes");
  } else if (proofU8a.length !== 96) {
    throw new Error("Invalid vrfSign output, expected 96 bytes");
  }
  return vrfVerify(publicKeyU8a, u8aToU8a(context2), u8aToU8a(message), u8aToU8a(extra), proofU8a);
}

// node_modules/@polkadot/util-crypto/address/encode.js
function encodeAddress(key, ss58Format = defaults.prefix) {
  const u8a = decodeAddress(key);
  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {
    throw new Error("Out of range ss58Format specified");
  } else if (!defaults.allowedDecodedLengths.includes(u8a.length)) {
    throw new Error(`Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(", ")}`);
  }
  const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [(ss58Format & 252) >> 2 | 64, ss58Format >> 8 | (ss58Format & 3) << 6], u8a);
  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
}

// node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n2 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n3, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n3;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n3 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n2)
      t ^= _1n3 << (_1n3 << BigInt(j)) - _1n3;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
var rotlH = (h, l16, s) => s > 32 ? u64_default.rotlBH(h, l16, s) : u64_default.rotlSH(h, l16, s);
var rotlL = (h, l16, s) => s > 32 ? u64_default.rotlBL(h, l16, s) : u64_default.rotlSL(h, l16, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class extends Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, state: state2 } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take2; i++)
        state2[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: state2, suffix, pos, blockLen } = this;
    state2[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state2[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    assert_default.exists(this, false);
    assert_default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take2 = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
      this.posOut += take2;
      pos += take2;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    assert_default.number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    assert_default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@polkadot/util-crypto/keccak/asU8a.js
var keccakAsU8a = createDualHasher({
  256: keccak256,
  512: keccak512
}, {
  256: keccak_256,
  512: keccak_512
});
var keccak256AsU8a = createBitHasher(256, keccakAsU8a);
var keccak512AsU8a = createBitHasher(512, keccakAsU8a);
var keccakAsHex = createAsHex(keccakAsU8a);

// node_modules/@polkadot/util-crypto/secp256k1/hasher.js
function hasher(hashType, data, onlyJs) {
  return hashType === "keccak" ? keccakAsU8a(data, void 0, onlyJs) : blake2AsU8a(data, void 0, void 0, onlyJs);
}

// node_modules/@polkadot/util-crypto/address/setSS58Format.js
var l = logger("setSS58Format");

// node_modules/@polkadot/util-crypto/base32/bs32.js
var chars = "abcdefghijklmnopqrstuvwxyz234567";
var config2 = {
  chars,
  coder: utils2.chain(utils2.radix2(5), utils2.alphabet(chars), {
    decode: (input) => input.split(""),
    encode: (input) => input.join("")
  }),
  ipfs: "b",
  type: "base32"
};
var base32Validate = createValidate(config2);
var isBase32 = createIs(base32Validate);
var base32Decode = createDecode(config2, base32Validate);
var base32Encode = createEncode(config2);

// node_modules/@polkadot/util-crypto/base64/bs64.js
var config3 = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  coder: base64,
  type: "base64"
};
var base64Validate = createValidate(config3);
var isBase64 = createIs(base64Validate);
var base64Decode2 = createDecode(config3, base64Validate);
var base64Encode = createEncode(config3);

// node_modules/@polkadot/util-crypto/secp256k1/compress.js
function secp256k1Compress2(publicKey2, onlyJs) {
  if (publicKey2.length === 33) {
    return publicKey2;
  }
  if (publicKey2.length !== 65) {
    throw new Error("Invalid publicKey provided");
  }
  return !hasBigInt || !onlyJs && isReady() ? secp256k1Compress(publicKey2) : Point.fromHex(publicKey2).toRawBytes(true);
}

// node_modules/@polkadot/util-crypto/secp256k1/expand.js
function secp256k1Expand2(publicKey2, onlyJs) {
  if (publicKey2.length === 65) {
    return publicKey2.subarray(1);
  }
  if (publicKey2.length !== 33) {
    throw new Error("Invalid publicKey provided");
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Expand(publicKey2).subarray(1);
  }
  const {
    x,
    y
  } = Point.fromHex(publicKey2);
  return u8aConcat(bnToU8a(x, BN_BE_256_OPTS), bnToU8a(y, BN_BE_256_OPTS));
}

// node_modules/@polkadot/util-crypto/secp256k1/recover.js
function secp256k1Recover2(msgHash, signature, recovery, hashType = "blake2", onlyJs) {
  const sig2 = u8aToU8a(signature).subarray(0, 64);
  const msg = u8aToU8a(msgHash);
  const publicKey2 = !hasBigInt || !onlyJs && isReady() ? secp256k1Recover(msg, sig2, recovery) : recoverPublicKey(msg, Signature.fromCompact(sig2).toRawBytes(), recovery);
  if (!publicKey2) {
    throw new Error("Unable to recover publicKey from signature");
  }
  return hashType === "keccak" ? secp256k1Expand2(publicKey2, onlyJs) : secp256k1Compress2(publicKey2, onlyJs);
}

// node_modules/@polkadot/util-crypto/secp256k1/sign.js
function secp256k1Sign2(message, {
  secretKey
}, hashType = "blake2", onlyJs) {
  if ((secretKey == null ? void 0 : secretKey.length) !== 32) {
    throw new Error("Expected valid secp256k1 secretKey, 32-bytes");
  }
  const data = hasher(hashType, message, onlyJs);
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Sign(data, secretKey);
  }
  const [sigBytes, recoveryParam] = signSync(data, secretKey, {
    canonical: true,
    recovered: true
  });
  const {
    r,
    s
  } = Signature.fromHex(sigBytes);
  return u8aConcat(bnToU8a(r, BN_BE_256_OPTS), bnToU8a(s, BN_BE_256_OPTS), new Uint8Array([recoveryParam || 0]));
}

// node_modules/@polkadot/util-crypto/secp256k1/tweakAdd.js
var N = "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141".replace(/ /g, "");
var N_BI = BigInt2(`0x${N}`);
var N_BN = new import_bn.default(N, "hex");
function addBi(seckey, tweak) {
  let res = u8aToBigInt(tweak, BN_BE_OPTS);
  if (res >= N_BI) {
    throw new Error("Tweak parameter is out of range");
  }
  res += u8aToBigInt(seckey, BN_BE_OPTS);
  if (res >= N_BI) {
    res -= N_BI;
  }
  if (res === _0n) {
    throw new Error("Invalid resulting private key");
  }
  return nToU8a(res, BN_BE_256_OPTS);
}
function addBn(seckey, tweak) {
  const res = new import_bn.default(tweak);
  if (res.cmp(N_BN) >= 0) {
    throw new Error("Tweak parameter is out of range");
  }
  res.iadd(new import_bn.default(seckey));
  if (res.cmp(N_BN) >= 0) {
    res.isub(N_BN);
  }
  if (res.isZero()) {
    throw new Error("Invalid resulting private key");
  }
  return bnToU8a(res, BN_BE_256_OPTS);
}
function secp256k1PrivateKeyTweakAdd(seckey, tweak, onlyBn) {
  if (!isU8a(seckey) || seckey.length !== 32) {
    throw new Error("Expected seckey to be an Uint8Array with length 32");
  } else if (!isU8a(tweak) || tweak.length !== 32) {
    throw new Error("Expected tweak to be an Uint8Array with length 32");
  }
  return !hasBigInt || onlyBn ? addBn(seckey, tweak) : addBi(seckey, tweak);
}

// node_modules/@polkadot/util-crypto/secp256k1/verify.js
function secp256k1Verify(msgHash, signature, address, hashType = "blake2", onlyJs) {
  const sig2 = u8aToU8a(signature);
  if (sig2.length !== 65) {
    throw new Error(`Expected signature with 65 bytes, ${sig2.length} found instead`);
  }
  const publicKey2 = secp256k1Recover2(hasher(hashType, msgHash), sig2, sig2[64], hashType, onlyJs);
  const signerAddr = hasher(hashType, publicKey2, onlyJs);
  const inputAddr = u8aToU8a(address);
  return u8aEq(publicKey2, inputAddr) || (hashType === "keccak" ? u8aEq(signerAddr.slice(-20), inputAddr.slice(-20)) : u8aEq(signerAddr, inputAddr));
}

// node_modules/@polkadot/util-crypto/ethereum/encode.js
function getH160(u8a) {
  if ([33, 65].includes(u8a.length)) {
    u8a = keccakAsU8a(secp256k1Expand2(u8a));
  }
  return u8a.slice(-20);
}
function ethereumEncode(addressOrPublic) {
  if (!addressOrPublic) {
    return "0x";
  }
  const u8aAddress = u8aToU8a(addressOrPublic);
  if (![20, 32, 33, 65].includes(u8aAddress.length)) {
    throw new Error("Invalid address or publicKey passed");
  }
  const address = u8aToHex(getH160(u8aAddress), -1, false);
  const hash2 = u8aToHex(keccakAsU8a(address), -1, false);
  let result = "";
  for (let i = 0; i < 40; i++) {
    result = `${result}${parseInt(hash2[i], 16) > 7 ? address[i].toUpperCase() : address[i]}`;
  }
  return `0x${result}`;
}

// node_modules/@polkadot/util-crypto/ethereum/isChecksum.js
function isInvalidChar(char, byte) {
  return char !== (byte > 7 ? char.toUpperCase() : char.toLowerCase());
}
function isEthereumChecksum(_address) {
  const address = _address.replace("0x", "");
  const hash2 = u8aToHex(keccakAsU8a(address.toLowerCase()), -1, false);
  for (let i = 0; i < 40; i++) {
    if (isInvalidChar(address[i], parseInt(hash2[i], 16))) {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/util-crypto/ethereum/isAddress.js
function isEthereumAddress(address) {
  if (!address || address.length !== 42 || !isHex(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  }
  return isEthereumChecksum(address);
}

// node_modules/@polkadot/util-crypto/hd/validatePath.js
var HARDENED = 2147483648;
function hdValidatePath(path) {
  if (!path.startsWith("m/")) {
    return false;
  }
  const parts = path.split("/").slice(1);
  for (const p of parts) {
    const n = /^\d+'?$/.test(p) ? parseInt(p.replace(/'$/, ""), 10) : Number.NaN;
    if (isNaN(n) || n >= HARDENED || n < 0) {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/util-crypto/hd/ethereum/index.js
var MASTER_SECRET = stringToU8a("Bitcoin seed");
function createCoded(secretKey, chainCode) {
  return {
    chainCode,
    publicKey: secp256k1PairFromSeed(secretKey).publicKey,
    secretKey
  };
}
function deriveChild(hd, index) {
  const indexBuffer = bnToU8a(index, BN_BE_32_OPTS);
  const data = index >= HARDENED ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : u8aConcat(hd.publicKey, indexBuffer);
  try {
    const I = hmacShaAsU8a(hd.chainCode, data, 512);
    return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));
  } catch (err) {
    return deriveChild(hd, index + 1);
  }
}
function hdEthereum(seed, path = "") {
  const I = hmacShaAsU8a(MASTER_SECRET, seed, 512);
  let hd = createCoded(I.slice(0, 32), I.slice(32));
  if (!path || path === "m" || path === "M" || path === "m'" || path === "M'") {
    return hd;
  }
  if (!hdValidatePath(path)) {
    throw new Error("Invalid derivation path");
  }
  const parts = path.split("/").slice(1);
  for (const p of parts) {
    hd = deriveChild(hd, parseInt(p, 10) + (p.length > 1 && p.endsWith("'") ? HARDENED : 0));
  }
  return hd;
}

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash2, _password, _salt, _opts) {
  assert_default.hash(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  assert_default.number(c);
  assert_default.number(dkLen);
  assert_default.number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf22(hash2, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@polkadot/util-crypto/pbkdf2/encode.js
function pbkdf2Encode(passphrase, salt = randomAsU8a(), rounds = 2048, onlyJs) {
  const u8aPass = u8aToU8a(passphrase);
  const u8aSalt = u8aToU8a(salt);
  return {
    password: !hasBigInt || !onlyJs && isReady() ? pbkdf2(u8aPass, u8aSalt, rounds) : pbkdf22(sha5122, u8aPass, u8aSalt, {
      c: rounds,
      dkLen: 64
    }),
    rounds,
    salt
  };
}

// node_modules/@polkadot/util-crypto/sha/asU8a.js
var shaAsU8a = createDualHasher({
  256: sha256,
  512: sha512
}, {
  256: sha2562,
  512: sha5122
});
var sha256AsU8a = createBitHasher(256, shaAsU8a);
var sha512AsU8a = createBitHasher(512, shaAsU8a);

// node_modules/@polkadot/util-crypto/mnemonic/bip39-en.js
var bip39_en_default = "abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo".split("|");

// node_modules/@polkadot/util-crypto/mnemonic/bip39.js
var INVALID_MNEMONIC = "Invalid mnemonic";
var INVALID_ENTROPY = "Invalid entropy";
var INVALID_CHECKSUM = "Invalid mnemonic checksum";
function normalize2(str) {
  return (str || "").normalize("NFKD");
}
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes3) {
  return bytes3.map((x) => x.toString(2).padStart(8, "0")).join("");
}
function deriveChecksumBits(entropyBuffer) {
  return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);
}
function mnemonicToSeedSync(mnemonic, password) {
  return pbkdf2Encode(stringToU8a(normalize2(mnemonic)), stringToU8a(`mnemonic${normalize2(password)}`)).password;
}
function mnemonicToEntropy(mnemonic) {
  const words = normalize2(mnemonic).split(" ");
  if (words.length % 3 !== 0) {
    throw new Error(INVALID_MNEMONIC);
  }
  const bits2 = words.map((word) => {
    const index = bip39_en_default.indexOf(word);
    if (index === -1) {
      throw new Error(INVALID_MNEMONIC);
    }
    return index.toString(2).padStart(11, "0");
  }).join("");
  const dividerIndex = Math.floor(bits2.length / 33) * 32;
  const entropyBits = bits2.slice(0, dividerIndex);
  const checksumBits = bits2.slice(dividerIndex);
  const matched = entropyBits.match(/(.{1,8})/g);
  const entropyBytes = matched && matched.map(binaryToByte);
  if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) {
    throw new Error(INVALID_ENTROPY);
  }
  const entropy = u8aToU8a(entropyBytes);
  if (deriveChecksumBits(entropy) !== checksumBits) {
    throw new Error(INVALID_CHECKSUM);
  }
  return entropy;
}
function validateMnemonic(mnemonic) {
  try {
    mnemonicToEntropy(mnemonic);
  } catch (e) {
    return false;
  }
  return true;
}

// node_modules/@polkadot/util-crypto/mnemonic/toEntropy.js
function mnemonicToEntropy2(mnemonic, onlyJs) {
  return !hasBigInt || !onlyJs && isReady() ? bip39ToEntropy(mnemonic) : mnemonicToEntropy(mnemonic);
}

// node_modules/@polkadot/util-crypto/mnemonic/validate.js
function mnemonicValidate(mnemonic, onlyJs) {
  return !hasBigInt || !onlyJs && isReady() ? bip39Validate(mnemonic) : validateMnemonic(mnemonic);
}

// node_modules/@polkadot/util-crypto/mnemonic/toLegacySeed.js
function mnemonicToLegacySeed(mnemonic, password = "", onlyJs, byteLength = 32) {
  if (!mnemonicValidate(mnemonic)) {
    throw new Error("Invalid bip39 mnemonic specified");
  } else if (![32, 64].includes(byteLength)) {
    throw new Error(`Invalid seed length ${byteLength}, expected 32 or 64`);
  }
  return byteLength === 32 ? !hasBigInt || !onlyJs && isReady() ? bip39ToSeed(mnemonic, password) : mnemonicToSeedSync(mnemonic, password).subarray(0, 32) : mnemonicToSeedSync(mnemonic, password);
}

// node_modules/@polkadot/util-crypto/mnemonic/toMiniSecret.js
function mnemonicToMiniSecret(mnemonic, password = "", onlyJs) {
  if (!mnemonicValidate(mnemonic)) {
    throw new Error("Invalid bip39 mnemonic specified");
  }
  if (!onlyJs && isReady()) {
    return bip39ToMiniSecret(mnemonic, password);
  }
  const entropy = mnemonicToEntropy2(mnemonic);
  const salt = stringToU8a(`mnemonic${password}`);
  return pbkdf2Encode(entropy, salt).password.slice(0, 32);
}

// node_modules/@polkadot/util-crypto/nacl/decrypt.js
var import_tweetnacl5 = __toModule(require_nacl_fast());
function naclDecrypt(encrypted, nonce, secret) {
  return import_tweetnacl5.default.secretbox.open(encrypted, nonce, secret) || null;
}

// node_modules/@polkadot/util-crypto/nacl/encrypt.js
var import_tweetnacl6 = __toModule(require_nacl_fast());
function naclEncrypt(message, secret, nonce = randomAsU8a(24)) {
  return {
    encrypted: import_tweetnacl6.default.secretbox(message, nonce, secret),
    nonce
  };
}

// node_modules/@polkadot/util-crypto/nacl/box/fromSecret.js
var import_tweetnacl7 = __toModule(require_nacl_fast());

// node_modules/@polkadot/util-crypto/nacl/open.js
var import_tweetnacl8 = __toModule(require_nacl_fast());
function naclOpen(sealed, nonce, senderBoxPublic, receiverBoxSecret) {
  return import_tweetnacl8.default.box.open(sealed, nonce, senderBoxPublic, receiverBoxSecret) || null;
}

// node_modules/@polkadot/util-crypto/nacl/seal.js
var import_tweetnacl9 = __toModule(require_nacl_fast());
function naclSeal(message, senderBoxSecret, receiverBoxPublic, nonce = randomAsU8a(24)) {
  return {
    nonce,
    sealed: import_tweetnacl9.default.box(message, nonce, receiverBoxPublic, senderBoxSecret)
  };
}

// node_modules/@noble/hashes/esm/scrypt.js
var rotl = (a, b) => a << b | a >>> 32 - b;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  assert_default.number(N2);
  assert_default.number(r);
  assert_default.number(p);
  assert_default.number(dkLen);
  assert_default.number(asyncTick);
  assert_default.number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf22(sha2562, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u322(B);
  const V = u322(new Uint8Array(blockSize * N2));
  const tmp = u322(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf22(sha2562, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt2(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0; i < N2 - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N2 - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    for (let i = 0; i < N2; i++) {
      const j = B32[Pi + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}

// node_modules/@polkadot/util-crypto/scrypt/defaults.js
var DEFAULT_PARAMS = {
  N: 1 << 15,
  p: 1,
  r: 8
};

// node_modules/@polkadot/util-crypto/scrypt/encode.js
function scryptEncode(passphrase, salt = randomAsU8a(), params = DEFAULT_PARAMS, onlyJs) {
  const u8a = u8aToU8a(passphrase);
  return {
    params,
    password: !hasBigInt || !onlyJs && isReady() ? scrypt(u8a, salt, Math.log2(params.N), params.r, params.p) : scrypt2(u8a, salt, objectSpread({
      dkLen: 64
    }, params)),
    salt
  };
}

// node_modules/@polkadot/util-crypto/scrypt/fromU8a.js
function scryptFromU8a(data) {
  const salt = data.subarray(0, 32);
  const N2 = u8aToBn(data.subarray(32 + 0, 32 + 4), BN_LE_OPTS).toNumber();
  const p = u8aToBn(data.subarray(32 + 4, 32 + 8), BN_LE_OPTS).toNumber();
  const r = u8aToBn(data.subarray(32 + 8, 32 + 12), BN_LE_OPTS).toNumber();
  if (N2 !== DEFAULT_PARAMS.N || p !== DEFAULT_PARAMS.p || r !== DEFAULT_PARAMS.r) {
    throw new Error("Invalid injected scrypt params found");
  }
  return {
    params: {
      N: N2,
      p,
      r
    },
    salt
  };
}

// node_modules/@polkadot/util-crypto/scrypt/toU8a.js
function scryptToU8a(salt, {
  N: N2,
  p,
  r
}) {
  return u8aConcat(salt, bnToU8a(N2, BN_LE_32_OPTS), bnToU8a(p, BN_LE_32_OPTS), bnToU8a(r, BN_LE_32_OPTS));
}

// node_modules/@polkadot/util-crypto/json/constants.js
var ENCODING = ["scrypt", "xsalsa20-poly1305"];
var ENCODING_NONE = ["none"];
var ENCODING_VERSION = "3";
var NONCE_LENGTH = 24;
var SCRYPT_LENGTH = 32 + 3 * 4;

// node_modules/@polkadot/util-crypto/json/decryptData.js
function jsonDecryptData(encrypted, passphrase, encType = ENCODING) {
  if (!encrypted) {
    throw new Error("No encrypted data available to decode");
  } else if (encType.includes("xsalsa20-poly1305") && !passphrase) {
    throw new Error("Password required to decode encrypted data");
  }
  let encoded = encrypted;
  if (passphrase) {
    let password;
    if (encType.includes("scrypt")) {
      const {
        params,
        salt
      } = scryptFromU8a(encrypted);
      password = scryptEncode(passphrase, salt, params).password;
      encrypted = encrypted.subarray(SCRYPT_LENGTH);
    } else {
      password = stringToU8a(passphrase);
    }
    encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));
  }
  if (!encoded) {
    throw new Error("Unable to decode using the supplied passphrase");
  }
  return encoded;
}

// node_modules/@polkadot/util-crypto/json/encryptFormat.js
function jsonEncryptFormat(encoded, contentType, isEncrypted) {
  return {
    encoded: base64Encode(encoded),
    encoding: {
      content: contentType,
      type: isEncrypted ? ENCODING : ENCODING_NONE,
      version: ENCODING_VERSION
    }
  };
}

// node_modules/@polkadot/util-crypto/signature/verify.js
var secp256k1VerifyHasher = (hashType) => (message, signature, publicKey2) => secp256k1Verify(message, signature, publicKey2, hashType);
var VERIFIERS_ECDSA = [["ecdsa", secp256k1VerifyHasher("blake2")], ["ethereum", secp256k1VerifyHasher("keccak")]];
var VERIFIERS = [["ed25519", ed25519Verify2], ["sr25519", sr25519Verify2], ...VERIFIERS_ECDSA];
var CRYPTO_TYPES = ["ed25519", "sr25519", "ecdsa"];
function verifyDetect(result, {
  message,
  publicKey: publicKey2,
  signature
}, verifiers = VERIFIERS) {
  result.isValid = verifiers.some(([crypto4, verify]) => {
    try {
      if (verify(message, signature, publicKey2)) {
        result.crypto = crypto4;
        return true;
      }
    } catch (error) {
    }
    return false;
  });
  return result;
}
function verifyMultisig(result, {
  message,
  publicKey: publicKey2,
  signature
}) {
  if (![0, 1, 2].includes(signature[0])) {
    throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);
  }
  const type = CRYPTO_TYPES[signature[0]] || "none";
  result.crypto = type;
  try {
    result.isValid = {
      ecdsa: () => verifyDetect(result, {
        message,
        publicKey: publicKey2,
        signature: signature.subarray(1)
      }, VERIFIERS_ECDSA).isValid,
      ed25519: () => ed25519Verify2(message, signature.subarray(1), publicKey2),
      none: () => {
        throw Error("no verify for `none` crypto type");
      },
      sr25519: () => sr25519Verify2(message, signature.subarray(1), publicKey2)
    }[type]();
  } catch (error) {
  }
  return result;
}
function getVerifyFn(signature) {
  return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;
}
function signatureVerify(message, signature, addressOrPublicKey) {
  const signatureU8a = u8aToU8a(signature);
  if (![64, 65, 66].includes(signatureU8a.length)) {
    throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);
  }
  const publicKey2 = decodeAddress(addressOrPublicKey);
  const input = {
    message: u8aToU8a(message),
    publicKey: publicKey2,
    signature: signatureU8a
  };
  const result = {
    crypto: "none",
    isValid: false,
    isWrapped: u8aIsWrapped(input.message, true),
    publicKey: publicKey2
  };
  const isWrappedBytes = u8aIsWrapped(input.message, false);
  const verifyFn = getVerifyFn(signatureU8a);
  verifyFn(result, input);
  if (result.crypto !== "none" || result.isWrapped && !isWrappedBytes) {
    return result;
  }
  input.message = isWrappedBytes ? u8aUnwrapBytes(input.message) : u8aWrapBytes(input.message);
  return verifyFn(result, input);
}

// node_modules/@polkadot/util-crypto/xxhash/xxhash64.js
var P64_1 = BigInt2("11400714785074694791");
var P64_2 = BigInt2("14029467366897019727");
var P64_3 = BigInt2("1609587929392839161");
var P64_4 = BigInt2("9650029242287828579");
var P64_5 = BigInt2("2870177450012600261");
var U64 = BigInt2("0xffffffffffffffff");
var _7n2 = BigInt2(7);
var _11n = BigInt2(11);
var _12n = BigInt2(12);
var _16n = BigInt2(16);
var _18n = BigInt2(18);
var _23n = BigInt2(23);
var _27n = BigInt2(27);
var _29n = BigInt2(29);
var _31n = BigInt2(31);
var _32n2 = BigInt2(32);
var _33n = BigInt2(33);
var _64n = BigInt2(64);
var _256n2 = BigInt2(256);
function rotl2(a, b) {
  const c = a & U64;
  return (c << b | c >> _64n - b) & U64;
}
function fromU8a(u8a, p, count2) {
  const bigints = new Array(count2);
  let offset = 0;
  for (let i = 0; i < count2; i++, offset += 2) {
    bigints[i] = BigInt2(u8a[p + offset] | u8a[p + 1 + offset] << 8);
  }
  let result = _0n;
  for (let i = count2 - 1; i >= 0; i--) {
    result = (result << _16n) + bigints[i];
  }
  return result;
}
function toU8a2(h64) {
  const result = new Uint8Array(8);
  for (let i = 7; i >= 0; i--) {
    result[i] = Number(h64 % _256n2);
    h64 = h64 / _256n2;
  }
  return result;
}
function state(initSeed) {
  const seed = BigInt2(initSeed);
  return {
    seed,
    u8a: new Uint8Array(32),
    u8asize: 0,
    v1: seed + P64_1 + P64_2,
    v2: seed + P64_2,
    v3: seed,
    v4: seed - P64_1
  };
}
function init(state2, input) {
  if (input.length < 32) {
    state2.u8a.set(input);
    state2.u8asize = input.length;
    return state2;
  }
  const limit = input.length - 32;
  let p = 0;
  if (limit >= 0) {
    const adjustV = (v) => P64_1 * rotl2(v + P64_2 * fromU8a(input, p, 4), _31n);
    do {
      state2.v1 = adjustV(state2.v1);
      p += 8;
      state2.v2 = adjustV(state2.v2);
      p += 8;
      state2.v3 = adjustV(state2.v3);
      p += 8;
      state2.v4 = adjustV(state2.v4);
      p += 8;
    } while (p <= limit);
  }
  if (p < input.length) {
    state2.u8a.set(input.subarray(p, input.length));
    state2.u8asize = input.length - p;
  }
  return state2;
}
function xxhash64(input, initSeed) {
  const {
    seed,
    u8a,
    u8asize,
    v1: v16,
    v2: v22,
    v3,
    v4: v42
  } = init(state(initSeed), input);
  let p = 0;
  let h64 = U64 & BigInt2(input.length) + (input.length >= 32 ? ((((rotl2(v16, _1n) + rotl2(v22, _7n2) + rotl2(v3, _12n) + rotl2(v42, _18n) ^ P64_1 * rotl2(v16 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl2(v22 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl2(v3 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl2(v42 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);
  while (p <= u8asize - 8) {
    h64 = U64 & P64_4 + P64_1 * rotl2(h64 ^ P64_1 * rotl2(P64_2 * fromU8a(u8a, p, 4), _31n), _27n);
    p += 8;
  }
  if (p + 4 <= u8asize) {
    h64 = U64 & P64_3 + P64_2 * rotl2(h64 ^ P64_1 * fromU8a(u8a, p, 2), _23n);
    p += 4;
  }
  while (p < u8asize) {
    h64 = U64 & P64_1 * rotl2(h64 ^ P64_5 * BigInt2(u8a[p++]), _11n);
  }
  h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);
  h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);
  return toU8a2(U64 & (h64 ^ h64 >> _32n2));
}

// node_modules/@polkadot/util-crypto/xxhash/asU8a.js
function xxhashAsU8a(data, bitLength = 64, onlyJs) {
  const rounds = Math.ceil(bitLength / 64);
  const u8a = u8aToU8a(data);
  if (!hasBigInt || !onlyJs && isReady()) {
    return twox(u8a, rounds);
  }
  const result = new Uint8Array(rounds * 8);
  for (let seed = 0; seed < rounds; seed++) {
    result.set(xxhash64(u8a, seed).reverse(), seed * 8);
  }
  return result;
}
var xxhashAsHex = createAsHex(xxhashAsU8a);

// node_modules/@polkadot/keyring/defaults.js
var DEV_PHRASE = "bottom drive obey lake curtain smoke basket hold race lonely fit walk";

// node_modules/@polkadot/keyring/pair/defaults.js
var PKCS8_DIVIDER = new Uint8Array([161, 35, 3, 33, 0]);
var PKCS8_HEADER = new Uint8Array([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);
var PUB_LENGTH = 32;
var SEC_LENGTH = 64;
var SEED_LENGTH = 32;

// node_modules/@polkadot/keyring/pair/decode.js
var SEED_OFFSET = PKCS8_HEADER.length;
function decodePair(passphrase, encrypted, _encType) {
  const encType = Array.isArray(_encType) || _encType === void 0 ? _encType : [_encType];
  const decrypted = jsonDecryptData(encrypted, passphrase, encType);
  const header = decrypted.subarray(0, PKCS8_HEADER.length);
  if (!u8aEq(header, PKCS8_HEADER)) {
    throw new Error("Invalid Pkcs8 header found in body");
  }
  let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);
  let divOffset = SEED_OFFSET + SEC_LENGTH;
  let divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);
  if (!u8aEq(divider, PKCS8_DIVIDER)) {
    divOffset = SEED_OFFSET + SEED_LENGTH;
    secretKey = decrypted.subarray(SEED_OFFSET, divOffset);
    divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);
    if (!u8aEq(divider, PKCS8_DIVIDER)) {
      throw new Error("Invalid Pkcs8 divider found in body");
    }
  }
  const pubOffset = divOffset + PKCS8_DIVIDER.length;
  const publicKey2 = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);
  return {
    publicKey: publicKey2,
    secretKey
  };
}

// node_modules/@polkadot/keyring/pair/encode.js
function encodePair({
  publicKey: publicKey2,
  secretKey
}, passphrase) {
  if (!secretKey) {
    throw new Error("Expected a valid secretKey to be passed to encode");
  }
  const encoded = u8aConcat(PKCS8_HEADER, secretKey, PKCS8_DIVIDER, publicKey2);
  if (!passphrase) {
    return encoded;
  }
  const {
    params,
    password,
    salt
  } = scryptEncode(passphrase);
  const {
    encrypted,
    nonce
  } = naclEncrypt(encoded, password.subarray(0, 32));
  return u8aConcat(scryptToU8a(salt, params), nonce, encrypted);
}

// node_modules/@polkadot/keyring/pair/toJson.js
function pairToJson(type, {
  address,
  meta
}, encoded, isEncrypted) {
  return objectSpread(jsonEncryptFormat(encoded, ["pkcs8", type], isEncrypted), {
    address,
    meta
  });
}

// node_modules/@polkadot/keyring/pair/index.js
var SIG_TYPE_NONE = new Uint8Array();
var TYPE_FROM_SEED = {
  ecdsa: secp256k1PairFromSeed,
  ed25519: ed25519PairFromSeed,
  ethereum: secp256k1PairFromSeed,
  sr25519: sr25519PairFromSeed
};
var TYPE_PREFIX = {
  ecdsa: new Uint8Array([2]),
  ed25519: new Uint8Array([0]),
  ethereum: new Uint8Array([2]),
  sr25519: new Uint8Array([1])
};
var TYPE_SIGNATURE = {
  ecdsa: (m, p) => secp256k1Sign2(m, p, "blake2"),
  ed25519: ed25519Sign2,
  ethereum: (m, p) => secp256k1Sign2(m, p, "keccak"),
  sr25519: sr25519Sign2
};
var TYPE_ADDRESS = {
  ecdsa: (p) => p.length > 32 ? blake2AsU8a(p) : p,
  ed25519: (p) => p,
  ethereum: (p) => p.length === 20 ? p : keccakAsU8a(secp256k1Expand2(p)),
  sr25519: (p) => p
};
function isLocked(secretKey) {
  return !secretKey || u8aEmpty(secretKey);
}
function vrfHash(proof, context2, extra) {
  return blake2AsU8a(u8aConcat(context2 || "", extra || "", proof));
}
function createPair({
  toSS58,
  type
}, {
  publicKey: publicKey2,
  secretKey
}, meta = {}, encoded = null, encTypes) {
  const decodePkcs8 = (passphrase, userEncoded) => {
    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);
    if (decoded.secretKey.length === 64) {
      publicKey2 = decoded.publicKey;
      secretKey = decoded.secretKey;
    } else {
      const pair = TYPE_FROM_SEED[type](decoded.secretKey);
      publicKey2 = pair.publicKey;
      secretKey = pair.secretKey;
    }
  };
  const recode = (passphrase) => {
    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);
    encoded = encodePair({
      publicKey: publicKey2,
      secretKey
    }, passphrase);
    encTypes = void 0;
    return encoded;
  };
  const encodeAddress2 = () => {
    const raw = TYPE_ADDRESS[type](publicKey2);
    return type === "ethereum" ? ethereumEncode(raw) : toSS58(raw);
  };
  return {
    get address() {
      return encodeAddress2();
    },
    get addressRaw() {
      const raw = TYPE_ADDRESS[type](publicKey2);
      return type === "ethereum" ? raw.slice(-20) : raw;
    },
    get isLocked() {
      return isLocked(secretKey);
    },
    get meta() {
      return meta;
    },
    get publicKey() {
      return publicKey2;
    },
    get type() {
      return type;
    },
    decodePkcs8,
    decryptMessage: (encryptedMessageWithNonce, senderPublicKey) => {
      if (isLocked(secretKey)) {
        throw new Error("Cannot encrypt with a locked key pair");
      } else if (["ecdsa", "ethereum"].includes(type)) {
        throw new Error("Secp256k1 not supported yet");
      }
      const messageU8a = u8aToU8a(encryptedMessageWithNonce);
      return naclOpen(messageU8a.slice(24, messageU8a.length), messageU8a.slice(0, 24), convertPublicKeyToCurve25519(u8aToU8a(senderPublicKey)), convertSecretKeyToCurve25519(secretKey));
    },
    derive: (suri, meta2) => {
      if (type === "ethereum") {
        throw new Error("Unable to derive on this keypair");
      } else if (isLocked(secretKey)) {
        throw new Error("Cannot derive on a locked keypair");
      }
      const {
        path
      } = keyExtractPath(suri);
      const derived = keyFromPath({
        publicKey: publicKey2,
        secretKey
      }, path, type);
      return createPair({
        toSS58,
        type
      }, derived, meta2, null);
    },
    encodePkcs8: (passphrase) => {
      return recode(passphrase);
    },
    encryptMessage: (message, recipientPublicKey, nonceIn) => {
      if (isLocked(secretKey)) {
        throw new Error("Cannot encrypt with a locked key pair");
      } else if (["ecdsa", "ethereum"].includes(type)) {
        throw new Error("Secp256k1 not supported yet");
      }
      const {
        nonce,
        sealed
      } = naclSeal(u8aToU8a(message), convertSecretKeyToCurve25519(secretKey), convertPublicKeyToCurve25519(u8aToU8a(recipientPublicKey)), nonceIn);
      return u8aConcat(nonce, sealed);
    },
    lock: () => {
      secretKey = new Uint8Array();
    },
    setMeta: (additional) => {
      meta = objectSpread({}, meta, additional);
    },
    sign: (message, options = {}) => {
      if (isLocked(secretKey)) {
        throw new Error("Cannot sign with a locked key pair");
      }
      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), {
        publicKey: publicKey2,
        secretKey
      }));
    },
    toJson: (passphrase) => {
      const address = ["ecdsa", "ethereum"].includes(type) ? publicKey2.length === 20 ? u8aToHex(publicKey2) : u8aToHex(secp256k1Compress2(publicKey2)) : encodeAddress2();
      return pairToJson(type, {
        address,
        meta
      }, recode(passphrase), !!passphrase);
    },
    unlock: (passphrase) => {
      return decodePkcs8(passphrase);
    },
    verify: (message, signature, signerPublic) => {
      return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;
    },
    vrfSign: (message, context2, extra) => {
      if (isLocked(secretKey)) {
        throw new Error("Cannot sign with a locked key pair");
      }
      if (type === "sr25519") {
        return sr25519VrfSign(message, {
          secretKey
        }, context2, extra);
      }
      const proof = TYPE_SIGNATURE[type](u8aToU8a(message), {
        publicKey: publicKey2,
        secretKey
      });
      return u8aConcat(vrfHash(proof, context2, extra), proof);
    },
    vrfVerify: (message, vrfResult, signerPublic, context2, extra) => {
      if (type === "sr25519") {
        return sr25519VrfVerify(message, vrfResult, publicKey2, context2, extra);
      }
      const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));
      return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context2, extra));
    }
  };
}

// node_modules/@polkadot/keyring/pairs.js
var _map;
var Pairs = class {
  constructor() {
    __privateAdd(this, _map, {});
  }
  add(pair) {
    __privateGet(this, _map)[decodeAddress(pair.address).toString()] = pair;
    return pair;
  }
  all() {
    return Object.values(__privateGet(this, _map));
  }
  get(address) {
    const pair = __privateGet(this, _map)[decodeAddress(address).toString()];
    if (!pair) {
      throw new Error(`Unable to retrieve keypair '${isU8a(address) || isHex(address) ? u8aToHex(u8aToU8a(address)) : address}'`);
    }
    return pair;
  }
  remove(address) {
    delete __privateGet(this, _map)[decodeAddress(address).toString()];
  }
};
_map = new WeakMap();

// node_modules/@polkadot/keyring/keyring.js
var PairFromSeed = {
  ecdsa: (seed) => secp256k1PairFromSeed(seed),
  ed25519: (seed) => ed25519PairFromSeed(seed),
  ethereum: (seed) => secp256k1PairFromSeed(seed),
  sr25519: (seed) => sr25519PairFromSeed(seed)
};
function pairToPublic({
  publicKey: publicKey2
}) {
  return publicKey2;
}
var _pairs, _type2, _ss58;
var Keyring = class {
  constructor(options = {}) {
    __privateAdd(this, _pairs, void 0);
    __privateAdd(this, _type2, void 0);
    __privateAdd(this, _ss58, void 0);
    __publicField(this, "decodeAddress", decodeAddress);
    __publicField(this, "encodeAddress", (address, ss58Format) => {
      return this.type === "ethereum" ? ethereumEncode(address) : encodeAddress(address, ss58Format === void 0 ? __privateGet(this, _ss58) : ss58Format);
    });
    options.type = options.type || "ed25519";
    if (!["ecdsa", "ethereum", "ed25519", "sr25519"].includes(options.type || "undefined")) {
      throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || "unknown"}`);
    }
    __privateSet(this, _pairs, new Pairs());
    __privateSet(this, _ss58, options.ss58Format);
    __privateSet(this, _type2, options.type);
  }
  get pairs() {
    return this.getPairs();
  }
  get publicKeys() {
    return this.getPublicKeys();
  }
  get type() {
    return __privateGet(this, _type2);
  }
  addPair(pair) {
    return __privateGet(this, _pairs).add(pair);
  }
  addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {
    const publicKey2 = this.decodeAddress(address, ignoreChecksum);
    return this.addPair(createPair({
      toSS58: this.encodeAddress,
      type
    }, {
      publicKey: publicKey2,
      secretKey: new Uint8Array()
    }, meta, encoded, encType));
  }
  addFromJson(json, ignoreChecksum) {
    return this.addPair(this.createFromJson(json, ignoreChecksum));
  }
  addFromMnemonic(mnemonic, meta = {}, type = this.type) {
    return this.addFromUri(mnemonic, meta, type);
  }
  addFromPair(pair, meta = {}, type = this.type) {
    return this.addPair(this.createFromPair(pair, meta, type));
  }
  addFromSeed(seed, meta = {}, type = this.type) {
    return this.addPair(createPair({
      toSS58: this.encodeAddress,
      type
    }, PairFromSeed[type](seed), meta, null));
  }
  addFromUri(suri, meta = {}, type = this.type) {
    return this.addPair(this.createFromUri(suri, meta, type));
  }
  createFromJson({
    address,
    encoded,
    encoding: {
      content,
      type,
      version
    },
    meta
  }, ignoreChecksum) {
    if (version === "3" && content[0] !== "pkcs8") {
      throw new Error(`Unable to decode non-pkcs8 type, [${content.join(",")}] found}`);
    }
    const cryptoType = version === "0" || !Array.isArray(content) ? this.type : content[1];
    const encType = !Array.isArray(type) ? [type] : type;
    if (!["ed25519", "sr25519", "ecdsa", "ethereum"].includes(cryptoType)) {
      throw new Error(`Unknown crypto type ${cryptoType}`);
    }
    const publicKey2 = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);
    const decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode2(encoded);
    return createPair({
      toSS58: this.encodeAddress,
      type: cryptoType
    }, {
      publicKey: publicKey2,
      secretKey: new Uint8Array()
    }, meta, decoded, encType);
  }
  createFromPair(pair, meta = {}, type = this.type) {
    return createPair({
      toSS58: this.encodeAddress,
      type
    }, pair, meta, null);
  }
  createFromUri(_suri, meta = {}, type = this.type) {
    const suri = _suri.startsWith("//") ? `${DEV_PHRASE}${_suri}` : _suri;
    const {
      derivePath,
      password,
      path,
      phrase
    } = keyExtractSuri(suri);
    let seed;
    const isPhraseHex = isHex(phrase, 256);
    if (isPhraseHex) {
      seed = hexToU8a(phrase);
    } else {
      const parts = phrase.split(" ");
      if ([12, 15, 18, 21, 24].includes(parts.length)) {
        seed = type === "ethereum" ? mnemonicToLegacySeed(phrase, "", false, 64) : mnemonicToMiniSecret(phrase, password);
      } else {
        if (phrase.length > 32) {
          throw new Error("specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes");
        }
        seed = stringToU8a(phrase.padEnd(32));
      }
    }
    const derived = type === "ethereum" ? isPhraseHex ? PairFromSeed[type](seed) : hdEthereum(seed, derivePath.substring(1)) : keyFromPath(PairFromSeed[type](seed), path, type);
    return createPair({
      toSS58: this.encodeAddress,
      type
    }, derived, meta, null);
  }
  getPair(address) {
    return __privateGet(this, _pairs).get(address);
  }
  getPairs() {
    return __privateGet(this, _pairs).all();
  }
  getPublicKeys() {
    return __privateGet(this, _pairs).all().map(pairToPublic);
  }
  removePair(address) {
    __privateGet(this, _pairs).remove(address);
  }
  setSS58Format(ss58) {
    __privateSet(this, _ss58, ss58);
  }
  toJson(address, passphrase) {
    return __privateGet(this, _pairs).get(address).toJson(passphrase);
  }
};
_pairs = new WeakMap();
_type2 = new WeakMap();
_ss58 = new WeakMap();

// node_modules/@polkadot/keyring/pair/nobody.js
var publicKey = new Uint8Array(32);

// node_modules/@polkadot/rpc-provider/detectOther.js
var detectOther_default10 = [packageInfo9];

// node_modules/@polkadot/rpc-provider/detectPackage.js
detectPackage(packageInfo8, null, detectOther_default10);

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
function _classPrivateFieldBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var id = 0;
function _classPrivateFieldKey(name) {
  return "__private_" + id++ + "_" + name;
}

// node_modules/@polkadot/x-fetch/packageInfo.js
var import_meta23 = {};
var packageInfo23 = {
  name: "@polkadot/x-fetch",
  path: import_meta23 && import_meta23.url ? new URL(import_meta23.url).pathname.substring(0, new URL(import_meta23.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-fetch/browser.js
var fetch = xglobal.fetch;

// node_modules/@polkadot/rpc-provider/coder/error.js
var UNKNOWN = -99999;
function extend(that, name, value) {
  Object.defineProperty(that, name, {
    configurable: true,
    enumerable: false,
    value
  });
}
var RpcError = class extends Error {
  constructor(message = "", code = UNKNOWN, data) {
    super();
    extend(this, "message", String(message));
    extend(this, "name", this.constructor.name);
    extend(this, "data", data);
    extend(this, "code", code);
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      const {
        stack
      } = new Error(message);
      stack && extend(this, "stack", stack);
    }
  }
};
__publicField(RpcError, "CODES", {
  ASSERT: -90009,
  INVALID_JSONRPC: -99998,
  METHOD_NOT_FOUND: -32601,
  UNKNOWN
});

// node_modules/@polkadot/rpc-provider/coder/index.js
function formatErrorData(data) {
  if (isUndefined(data)) {
    return "";
  }
  const formatted = `: ${isString(data) ? data.replace(/Error\("/g, "").replace(/\("/g, "(").replace(/"\)/g, ")").replace(/\(/g, ", ").replace(/\)/g, "") : stringify(data)}`;
  return formatted.length <= 256 ? formatted : `${formatted.substring(0, 255)}\u2026`;
}
function checkError(error) {
  if (error) {
    const {
      code,
      data,
      message
    } = error;
    throw new RpcError(`${code}: ${message}${formatErrorData(data)}`, code, data);
  }
}
var _id;
var RpcCoder = class {
  constructor() {
    __privateAdd(this, _id, 0);
  }
  decodeResponse(response) {
    if (!response || response.jsonrpc !== "2.0") {
      throw new Error("Invalid jsonrpc field in decoded object");
    }
    const isSubscription2 = !isUndefined(response.params) && !isUndefined(response.method);
    if (!isNumber(response.id) && (!isSubscription2 || !isNumber(response.params.subscription) && !isString(response.params.subscription))) {
      throw new Error("Invalid id field in decoded object");
    }
    checkError(response.error);
    if (response.result === void 0 && !isSubscription2) {
      throw new Error("No result found in jsonrpc response");
    }
    if (isSubscription2) {
      checkError(response.params.error);
      return response.params.result;
    }
    return response.result;
  }
  encodeJson(method, params) {
    const [id2, data] = this.encodeObject(method, params);
    return [id2, stringify(data)];
  }
  encodeObject(method, params) {
    const id2 = ++__privateWrapper(this, _id)._;
    return [id2, {
      id: id2,
      jsonrpc: "2.0",
      method,
      params
    }];
  }
};
_id = new WeakMap();

// node_modules/@polkadot/rpc-provider/defaults.js
var HTTP_URL = "http://127.0.0.1:9933";
var WS_URL = "ws://127.0.0.1:9944";
var defaults_default = {
  HTTP_URL,
  WS_URL
};

// node_modules/@polkadot/rpc-provider/lru.js
var DEFAULT_CAPACITY = 128;
var LRUNode = class {
  constructor(key) {
    this.key = key;
    this.next = this.prev = this;
  }
};
var _data = _classPrivateFieldKey("data");
var _refs = _classPrivateFieldKey("refs");
var _length = _classPrivateFieldKey("length");
var _head = _classPrivateFieldKey("head");
var _tail = _classPrivateFieldKey("tail");
var _toHead = _classPrivateFieldKey("toHead");
var LRUCache = class {
  constructor(capacity = DEFAULT_CAPACITY) {
    Object.defineProperty(this, _toHead, {
      value: _toHead2
    });
    this.capacity = void 0;
    Object.defineProperty(this, _data, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _refs, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _length, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _head, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _tail, {
      writable: true,
      value: void 0
    });
    this.capacity = capacity;
    _classPrivateFieldBase(this, _head)[_head] = _classPrivateFieldBase(this, _tail)[_tail] = new LRUNode("<empty>");
  }
  get length() {
    return _classPrivateFieldBase(this, _length)[_length];
  }
  get lengthData() {
    return _classPrivateFieldBase(this, _data)[_data].size;
  }
  get lengthRefs() {
    return _classPrivateFieldBase(this, _refs)[_refs].size;
  }
  entries() {
    const keys2 = this.keys();
    const entries = new Array(keys2.length);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      entries[i] = [key, _classPrivateFieldBase(this, _data)[_data].get(key)];
    }
    return entries;
  }
  keys() {
    const keys2 = [];
    if (_classPrivateFieldBase(this, _length)[_length]) {
      let curr = _classPrivateFieldBase(this, _head)[_head];
      while (curr !== _classPrivateFieldBase(this, _tail)[_tail]) {
        keys2.push(curr.key);
        curr = curr.next;
      }
      keys2.push(curr.key);
    }
    return keys2;
  }
  get(key) {
    const data = _classPrivateFieldBase(this, _data)[_data].get(key);
    if (data) {
      _classPrivateFieldBase(this, _toHead)[_toHead](key);
      return data;
    }
    return null;
  }
  set(key, value) {
    if (_classPrivateFieldBase(this, _data)[_data].has(key)) {
      _classPrivateFieldBase(this, _toHead)[_toHead](key);
    } else {
      const node = new LRUNode(key);
      _classPrivateFieldBase(this, _refs)[_refs].set(node.key, node);
      if (this.length === 0) {
        _classPrivateFieldBase(this, _head)[_head] = _classPrivateFieldBase(this, _tail)[_tail] = node;
      } else {
        _classPrivateFieldBase(this, _head)[_head].prev = node;
        node.next = _classPrivateFieldBase(this, _head)[_head];
        _classPrivateFieldBase(this, _head)[_head] = node;
      }
      if (_classPrivateFieldBase(this, _length)[_length] === this.capacity) {
        _classPrivateFieldBase(this, _data)[_data].delete(_classPrivateFieldBase(this, _tail)[_tail].key);
        _classPrivateFieldBase(this, _refs)[_refs].delete(_classPrivateFieldBase(this, _tail)[_tail].key);
        _classPrivateFieldBase(this, _tail)[_tail] = _classPrivateFieldBase(this, _tail)[_tail].prev;
        _classPrivateFieldBase(this, _tail)[_tail].next = _classPrivateFieldBase(this, _head)[_head];
      } else {
        _classPrivateFieldBase(this, _length)[_length] += 1;
      }
    }
    _classPrivateFieldBase(this, _data)[_data].set(key, value);
  }
};
function _toHead2(key) {
  const ref = _classPrivateFieldBase(this, _refs)[_refs].get(key);
  if (ref && ref !== _classPrivateFieldBase(this, _head)[_head]) {
    ref.prev.next = ref.next;
    ref.next.prev = ref.prev;
    ref.next = _classPrivateFieldBase(this, _head)[_head];
    _classPrivateFieldBase(this, _head)[_head].prev = ref;
    _classPrivateFieldBase(this, _head)[_head] = ref;
  }
}

// node_modules/@polkadot/rpc-provider/http/index.js
var ERROR_SUBSCRIBE = "HTTP Provider does not have subscriptions, use WebSockets instead";
var l2 = logger("api-http");
var _callCache = _classPrivateFieldKey("callCache");
var _coder = _classPrivateFieldKey("coder");
var _endpoint = _classPrivateFieldKey("endpoint");
var _headers = _classPrivateFieldKey("headers");
var _stats = _classPrivateFieldKey("stats");
var _send = _classPrivateFieldKey("send");
var HttpProvider = class {
  constructor(endpoint = defaults_default.HTTP_URL, headers = {}) {
    Object.defineProperty(this, _send, {
      value: _send2
    });
    Object.defineProperty(this, _callCache, {
      writable: true,
      value: new LRUCache()
    });
    Object.defineProperty(this, _coder, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpoint, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _headers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _stats, {
      writable: true,
      value: void 0
    });
    if (!/^(https|http):\/\//.test(endpoint)) {
      throw new Error(`Endpoint should start with 'http://' or 'https://', received '${endpoint}'`);
    }
    _classPrivateFieldBase(this, _coder)[_coder] = new RpcCoder();
    _classPrivateFieldBase(this, _endpoint)[_endpoint] = endpoint;
    _classPrivateFieldBase(this, _headers)[_headers] = headers;
    _classPrivateFieldBase(this, _stats)[_stats] = {
      active: {
        requests: 0,
        subscriptions: 0
      },
      total: {
        bytesRecv: 0,
        bytesSent: 0,
        cached: 0,
        errors: 0,
        requests: 0,
        subscriptions: 0,
        timeout: 0
      }
    };
  }
  get hasSubscriptions() {
    return false;
  }
  clone() {
    return new HttpProvider(_classPrivateFieldBase(this, _endpoint)[_endpoint], _classPrivateFieldBase(this, _headers)[_headers]);
  }
  async connect() {
  }
  async disconnect() {
  }
  get stats() {
    return _classPrivateFieldBase(this, _stats)[_stats];
  }
  get isClonable() {
    return true;
  }
  get isConnected() {
    return true;
  }
  on(type, sub) {
    l2.error("HTTP Provider does not have 'on' emitters, use WebSockets instead");
    return () => {
    };
  }
  async send(method, params, isCacheable) {
    _classPrivateFieldBase(this, _stats)[_stats].total.requests++;
    const [, body] = _classPrivateFieldBase(this, _coder)[_coder].encodeJson(method, params);
    let resultPromise = isCacheable ? _classPrivateFieldBase(this, _callCache)[_callCache].get(body) : null;
    if (!resultPromise) {
      resultPromise = _classPrivateFieldBase(this, _send)[_send](body);
      if (isCacheable) {
        _classPrivateFieldBase(this, _callCache)[_callCache].set(body, resultPromise);
      }
    } else {
      _classPrivateFieldBase(this, _stats)[_stats].total.cached++;
    }
    return resultPromise;
  }
  async subscribe(types2, method, params, cb) {
    l2.error(ERROR_SUBSCRIBE);
    throw new Error(ERROR_SUBSCRIBE);
  }
  async unsubscribe(type, method, id2) {
    l2.error(ERROR_SUBSCRIBE);
    throw new Error(ERROR_SUBSCRIBE);
  }
};
async function _send2(body) {
  _classPrivateFieldBase(this, _stats)[_stats].active.requests++;
  _classPrivateFieldBase(this, _stats)[_stats].total.bytesSent += body.length;
  try {
    const response = await fetch(_classPrivateFieldBase(this, _endpoint)[_endpoint], {
      body,
      headers: __spreadValues({
        Accept: "application/json",
        "Content-Length": `${body.length}`,
        "Content-Type": "application/json"
      }, _classPrivateFieldBase(this, _headers)[_headers]),
      method: "POST"
    });
    if (!response.ok) {
      throw new Error(`[${response.status}]: ${response.statusText}`);
    }
    const result = await response.text();
    _classPrivateFieldBase(this, _stats)[_stats].total.bytesRecv += result.length;
    const decoded = _classPrivateFieldBase(this, _coder)[_coder].decodeResponse(JSON.parse(result));
    _classPrivateFieldBase(this, _stats)[_stats].active.requests--;
    return decoded;
  } catch (e) {
    _classPrivateFieldBase(this, _stats)[_stats].active.requests--;
    _classPrivateFieldBase(this, _stats)[_stats].total.errors++;
    throw e;
  }
}

// node_modules/@substrate/connect/dist/mjs/WellKnownChain.js
var WellKnownChain;
(function(WellKnownChain2) {
  WellKnownChain2["polkadot"] = "polkadot";
  WellKnownChain2["ksmcc3"] = "ksmcc3";
  WellKnownChain2["rococo_v2_2"] = "rococo_v2_2";
  WellKnownChain2["westend2"] = "westend2";
})(WellKnownChain || (WellKnownChain = {}));

// node_modules/@substrate/connect/dist/mjs/connector/specs/index.js
async function getSpec(chain2) {
  if (chain2.indexOf("..") !== -1)
    throw new Error("Invalid chain name");
  try {
    const specRaw = await import("./generated/" + chain2 + ".js");
    return typeof specRaw === "string" ? specRaw : specRaw.default;
  } catch (error) {
    throw new Error("Invalid chain name");
  }
}

// node_modules/@substrate/connect/dist/mjs/connector/types.js
var AlreadyDestroyedError = class extends Error {
  constructor() {
    super();
    this.name = "AlreadyDestroyedError";
  }
};
var CrashError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CrashError";
  }
};
var JsonRpcDisabledError = class extends Error {
  constructor() {
    super();
    this.name = "JsonRpcDisabledError";
  }
};

// node_modules/@substrate/connect/dist/mjs/connector/smoldot-light.js
var startPromise = null;
var getStart = () => {
  if (startPromise)
    return startPromise;
  startPromise = import("./index-browser-YZI5SQAN.js").then((sm) => sm.start);
  return startPromise;
};
var clientReferences = [];
var clientPromise = null;
var clientReferencesMaxLogLevel = 3;
var getClientAndIncRef = (config5) => {
  if (config5.maxLogLevel && config5.maxLogLevel > clientReferencesMaxLogLevel)
    clientReferencesMaxLogLevel = config5.maxLogLevel;
  if (clientPromise) {
    clientReferences.push(config5);
    if (clientPromise instanceof Promise)
      return clientPromise;
    else
      return Promise.resolve(clientPromise);
  }
  const newClientPromise = getStart().then((start) => start({
    forbidTcp: true,
    forbidNonLocalWs: true,
    maxLogLevel: 9999999,
    cpuRateLimit: 0.5,
    logCallback: (level, target, message) => {
      if (level > clientReferencesMaxLogLevel)
        return;
      if (level <= 1) {
        console.error("[%s] %s", target, message);
      } else if (level === 2) {
        console.warn("[%s] %s", target, message);
      } else if (level === 3) {
        console.info("[%s] %s", target, message);
      } else if (level === 4) {
        console.debug("[%s] %s", target, message);
      } else {
        console.trace("[%s] %s", target, message);
      }
    }
  }));
  clientPromise = newClientPromise;
  newClientPromise.then((client) => {
    if (clientPromise === newClientPromise)
      clientPromise = client;
    else
      client.terminate();
    return client;
  });
  clientReferences.push(config5);
  return clientPromise;
};
var decRef = (config5) => {
  const idx = clientReferences.indexOf(config5);
  if (idx === -1)
    throw new Error("Internal error within smoldot-light");
  clientReferences.splice(idx, 1);
  clientReferencesMaxLogLevel = 3;
  for (const cfg of clientReferences.values()) {
    if (cfg.maxLogLevel && cfg.maxLogLevel > clientReferencesMaxLogLevel)
      clientReferencesMaxLogLevel = cfg.maxLogLevel;
  }
  if (clientReferences.length === 0) {
    if (clientPromise && !(clientPromise instanceof Promise))
      clientPromise.terminate();
    clientPromise = null;
  }
};
var transformErrors = (thunk) => {
  try {
    thunk();
  } catch (e) {
    const error = e;
    if ((error === null || error === void 0 ? void 0 : error.name) === "JsonRpcDisabledError")
      throw new JsonRpcDisabledError();
    if ((error === null || error === void 0 ? void 0 : error.name) === "CrashError")
      throw new CrashError(error.message);
    if ((error === null || error === void 0 ? void 0 : error.name) === "AlreadyDestroyedError")
      throw new AlreadyDestroyedError();
    throw new CrashError(e instanceof Error ? e.message : `Unexpected error ${e}`);
  }
};
var createScClient = (config5) => {
  const configOrDefault = config5 || { maxLogLevel: 3 };
  const chains = new Map();
  const addChain = async (chainSpec, jsonRpcCallback) => {
    const client = await getClientAndIncRef(configOrDefault);
    try {
      const internalChain = await client.addChain({
        chainSpec,
        potentialRelayChains: [...chains.values()],
        disableJsonRpc: jsonRpcCallback === void 0
      });
      (async () => {
        while (true) {
          let jsonRpcResponse;
          try {
            jsonRpcResponse = await internalChain.nextJsonRpcResponse();
          } catch (_) {
            break;
          }
          try {
            jsonRpcCallback(jsonRpcResponse);
          } catch (error) {
            console.error("JSON-RPC callback has thrown an exception:", error);
          }
        }
      })();
      const chain2 = {
        sendJsonRpc: (rpc18) => {
          transformErrors(() => {
            try {
              internalChain.sendJsonRpc(rpc18);
            } catch (error) {
              if (error instanceof MalformedJsonRpcError) {
                return;
              } else if (error instanceof QueueFullError) {
                try {
                  const parsedRq = JSON.parse(rpc18);
                  jsonRpcCallback(JSON.stringify({
                    jsonrpc: "v2",
                    id: parsedRq.id,
                    error: {
                      code: -32e3,
                      message: "JSON-RPC server is too busy"
                    }
                  }));
                } catch (_error) {
                }
              } else {
                throw error;
              }
            }
          });
        },
        remove: () => {
          try {
            transformErrors(() => {
              internalChain.remove();
            });
          } finally {
            chains.delete(chain2);
            decRef(configOrDefault);
          }
        }
      };
      chains.set(chain2, internalChain);
      return chain2;
    } catch (error) {
      decRef(configOrDefault);
      throw error;
    }
  };
  const addWellKnownChain = async (supposedChain, jsonRpcCallback) => {
    getClientAndIncRef(configOrDefault);
    try {
      const spec2 = await getSpec(supposedChain);
      return await addChain(spec2, jsonRpcCallback);
    } finally {
      decRef(configOrDefault);
    }
  };
  return { addChain, addWellKnownChain };
};

// node_modules/@substrate/connect/dist/mjs/connector/extension.js
var listeners = new Map();
if (typeof window === "object") {
  window.addEventListener("message", ({ data }) => {
    var _a;
    if ((data === null || data === void 0 ? void 0 : data.origin) !== "substrate-connect-extension")
      return;
    (_a = listeners.get(data.chainId)) === null || _a === void 0 ? void 0 : _a(data);
  });
}
function getRandomChainId() {
  const arr = new BigUint64Array(2);
  crypto.getRandomValues(arr);
  const result = arr[1] << BigInt(64) | arr[0];
  return result.toString(36);
}
var createScClient2 = () => {
  const chains = new Map();
  const internalAddChain = async (isWellKnown, chainSpecOrWellKnownName, jsonRpcCallback, potentialRelayChainIds = []) => {
    let resolve;
    const initFinished = new Promise((res) => {
      resolve = () => res(null);
    });
    const chainState = {
      id: getRandomChainId(),
      state: {
        state: "pending",
        waitFinished: resolve
      }
    };
    if (listeners.has(chainState.id))
      throw new Error("Unexpectedly randomly generated the same chain ID twice despite 64bits of entropy");
    listeners.set(chainState.id, (msg) => {
      switch (chainState.state.state) {
        case "pending": {
          const waitFinished = chainState.state.waitFinished;
          switch (msg.type) {
            case "chain-ready": {
              chainState.state = {
                state: "ok"
              };
              break;
            }
            case "error": {
              chainState.state = {
                state: "dead",
                error: new CrashError("Error while creating the chain: " + msg.errorMessage)
              };
              break;
            }
            default: {
              console.warn("Unexpected message of type `msg.type` received from substrate-connect extension");
            }
          }
          waitFinished();
          break;
        }
        case "ok": {
          switch (msg.type) {
            case "error": {
              chainState.state = {
                state: "dead",
                error: new CrashError("Extension has killed the chain: " + msg.errorMessage)
              };
              break;
            }
            case "rpc": {
              if (jsonRpcCallback) {
                jsonRpcCallback(msg.jsonRpcMessage);
              } else {
                console.warn("Unexpected message of type `msg.type` received from substrate-connect extension");
              }
              break;
            }
            default: {
              console.warn("Unexpected message of type `msg.type` received from substrate-connect extension");
            }
          }
          break;
        }
        case "dead": {
          break;
        }
      }
    });
    if (isWellKnown) {
      postToExtension({
        origin: "substrate-connect-client",
        chainId: chainState.id,
        type: "add-well-known-chain",
        chainName: chainSpecOrWellKnownName
      });
    } else {
      postToExtension({
        origin: "substrate-connect-client",
        chainId: chainState.id,
        type: "add-chain",
        chainSpec: chainSpecOrWellKnownName,
        potentialRelayChainIds
      });
    }
    await initFinished;
    if (isWellKnown && chainState.state.state === "dead") {
      let resolve2;
      const initFinished2 = new Promise((res) => {
        resolve2 = () => res(null);
      });
      chainState.state = {
        state: "pending",
        waitFinished: resolve2
      };
      postToExtension({
        origin: "substrate-connect-client",
        chainId: chainState.id,
        type: "add-chain",
        chainSpec: await getSpec(chainSpecOrWellKnownName),
        potentialRelayChainIds: []
      });
      await initFinished2;
    }
    if (chainState.state.state === "dead") {
      throw chainState.state.error;
    }
    const chain2 = {
      sendJsonRpc: (jsonRpcMessage) => {
        if (chainState.state.state === "dead") {
          throw chainState.state.error;
        }
        if (!jsonRpcCallback)
          throw new JsonRpcDisabledError();
        postToExtension({
          origin: "substrate-connect-client",
          chainId: chainState.id,
          type: "rpc",
          jsonRpcMessage
        });
      },
      remove: () => {
        if (chainState.state.state === "dead") {
          throw chainState.state.error;
        }
        chainState.state = {
          state: "dead",
          error: new AlreadyDestroyedError()
        };
        listeners.delete(chainState.id);
        chains.delete(chain2);
        postToExtension({
          origin: "substrate-connect-client",
          chainId: chainState.id,
          type: "remove-chain"
        });
      }
    };
    chains.set(chain2, chainState.id);
    return chain2;
  };
  return {
    addChain: (chainSpec, jsonRpcCallback) => internalAddChain(false, chainSpec, jsonRpcCallback, [...chains.values()]),
    addWellKnownChain: (name, jsonRpcCallback) => internalAddChain(true, name, jsonRpcCallback)
  };
};
function postToExtension(msg) {
  window.postMessage(msg, "*");
}

// node_modules/@substrate/connect-extension-protocol/dist/mjs/index.js
var DOM_ELEMENT_ID = "substrateConnectExtensionAvailable";

// node_modules/@substrate/connect/dist/mjs/connector/index.js
var isExtensionPresent = typeof document === "object" && typeof document.getElementById === "function" && !!document.getElementById(DOM_ELEMENT_ID);
function createScClient3(config5) {
  const forceEmbedded = config5 === null || config5 === void 0 ? void 0 : config5.forceEmbeddedNode;
  if (!forceEmbedded && isExtensionPresent)
    return createScClient2();
  return createScClient(config5 === null || config5 === void 0 ? void 0 : config5.embeddedNodeConfig);
}

// node_modules/@polkadot/rpc-provider/substrate-connect/index.js
var import_eventemitter3 = __toModule(require_eventemitter3());

// node_modules/@polkadot/rpc-provider/substrate-connect/Health.js
function healthChecker() {
  let checker = null;
  let sendJsonRpc = null;
  return {
    responsePassThrough: (jsonRpcResponse) => {
      if (checker === null) {
        return jsonRpcResponse;
      }
      return checker.responsePassThrough(jsonRpcResponse);
    },
    sendJsonRpc: (request) => {
      if (!sendJsonRpc) {
        throw new Error("setSendJsonRpc must be called before sending requests");
      }
      if (checker === null) {
        sendJsonRpc(request);
      } else {
        checker.sendJsonRpc(request);
      }
    },
    setSendJsonRpc: (cb) => {
      sendJsonRpc = cb;
    },
    start: (healthCallback) => {
      if (checker !== null) {
        throw new Error("Can't start the health checker multiple times in parallel");
      } else if (!sendJsonRpc) {
        throw new Error("setSendJsonRpc must be called before starting the health checks");
      }
      checker = new InnerChecker(healthCallback, sendJsonRpc);
      checker.update(true);
    },
    stop: () => {
      if (checker === null) {
        return;
      }
      checker.destroy();
      checker = null;
    }
  };
}
var _healthCallback, _currentHealthCheckId, _currentHealthTimeout, _currentSubunsubRequestId, _currentSubscriptionId, _requestToSmoldot, _isSyncing, _nextRequestId;
var InnerChecker = class {
  constructor(healthCallback, requestToSmoldot) {
    __privateAdd(this, _healthCallback, void 0);
    __privateAdd(this, _currentHealthCheckId, null);
    __privateAdd(this, _currentHealthTimeout, null);
    __privateAdd(this, _currentSubunsubRequestId, null);
    __privateAdd(this, _currentSubscriptionId, null);
    __privateAdd(this, _requestToSmoldot, void 0);
    __privateAdd(this, _isSyncing, false);
    __privateAdd(this, _nextRequestId, 0);
    __publicField(this, "sendJsonRpc", (request) => {
      let parsedRequest;
      try {
        parsedRequest = JSON.parse(request);
      } catch (err) {
        return;
      }
      if (parsedRequest.id) {
        const newId = "extern:" + stringify(parsedRequest.id);
        parsedRequest.id = newId;
      }
      __privateGet(this, _requestToSmoldot).call(this, stringify(parsedRequest));
    });
    __publicField(this, "responsePassThrough", (jsonRpcResponse) => {
      let parsedResponse;
      try {
        parsedResponse = JSON.parse(jsonRpcResponse);
      } catch (err) {
        return jsonRpcResponse;
      }
      if (parsedResponse.id && __privateGet(this, _currentHealthCheckId) === parsedResponse.id) {
        __privateSet(this, _currentHealthCheckId, null);
        if (!parsedResponse.result) {
          this.update(false);
          return null;
        }
        __privateGet(this, _healthCallback).call(this, parsedResponse.result);
        __privateSet(this, _isSyncing, parsedResponse.result.isSyncing);
        this.update(false);
        return null;
      }
      if (parsedResponse.id && __privateGet(this, _currentSubunsubRequestId) === parsedResponse.id) {
        __privateSet(this, _currentSubunsubRequestId, null);
        if (!parsedResponse.result) {
          this.update(false);
          return null;
        }
        if (__privateGet(this, _currentSubscriptionId)) {
          __privateSet(this, _currentSubscriptionId, null);
        } else {
          __privateSet(this, _currentSubscriptionId, parsedResponse.result);
        }
        this.update(false);
        return null;
      }
      if (parsedResponse.params && __privateGet(this, _currentSubscriptionId) && parsedResponse.params.subscription === __privateGet(this, _currentSubscriptionId)) {
        this.update(true);
        return null;
      }
      if (parsedResponse.id) {
        const id2 = parsedResponse.id;
        if (!id2.startsWith("extern:")) {
          throw new Error("State inconsistency in health checker");
        }
        const newId = JSON.parse(id2.slice("extern:".length));
        parsedResponse.id = newId;
      }
      return stringify(parsedResponse);
    });
    __publicField(this, "update", (startNow) => {
      if (startNow && __privateGet(this, _currentHealthTimeout)) {
        clearTimeout(__privateGet(this, _currentHealthTimeout));
        __privateSet(this, _currentHealthTimeout, null);
      }
      if (!__privateGet(this, _currentHealthTimeout)) {
        const startHealthRequest = () => {
          __privateSet(this, _currentHealthTimeout, null);
          if (__privateGet(this, _currentHealthCheckId)) {
            return;
          }
          __privateSet(this, _currentHealthCheckId, `health-checker:${__privateGet(this, _nextRequestId)}`);
          __privateSet(this, _nextRequestId, __privateGet(this, _nextRequestId) + 1);
          __privateGet(this, _requestToSmoldot).call(this, stringify({
            id: __privateGet(this, _currentHealthCheckId),
            jsonrpc: "2.0",
            method: "system_health",
            params: []
          }));
        };
        if (startNow) {
          startHealthRequest();
        } else {
          __privateSet(this, _currentHealthTimeout, setTimeout(startHealthRequest, 1e3));
        }
      }
      if (__privateGet(this, _isSyncing) && !__privateGet(this, _currentSubscriptionId) && !__privateGet(this, _currentSubunsubRequestId)) {
        this.startSubscription();
      }
      if (!__privateGet(this, _isSyncing) && __privateGet(this, _currentSubscriptionId) && !__privateGet(this, _currentSubunsubRequestId)) {
        this.endSubscription();
      }
    });
    __publicField(this, "startSubscription", () => {
      if (__privateGet(this, _currentSubunsubRequestId) || __privateGet(this, _currentSubscriptionId)) {
        throw new Error("Internal error in health checker");
      }
      __privateSet(this, _currentSubunsubRequestId, `health-checker:${__privateGet(this, _nextRequestId)}`);
      __privateSet(this, _nextRequestId, __privateGet(this, _nextRequestId) + 1);
      __privateGet(this, _requestToSmoldot).call(this, stringify({
        id: __privateGet(this, _currentSubunsubRequestId),
        jsonrpc: "2.0",
        method: "chain_subscribeNewHeads",
        params: []
      }));
    });
    __publicField(this, "endSubscription", () => {
      if (__privateGet(this, _currentSubunsubRequestId) || !__privateGet(this, _currentSubscriptionId)) {
        throw new Error("Internal error in health checker");
      }
      __privateSet(this, _currentSubunsubRequestId, `health-checker:${__privateGet(this, _nextRequestId)}`);
      __privateSet(this, _nextRequestId, __privateGet(this, _nextRequestId) + 1);
      __privateGet(this, _requestToSmoldot).call(this, stringify({
        id: __privateGet(this, _currentSubunsubRequestId),
        jsonrpc: "2.0",
        method: "chain_unsubscribeNewHeads",
        params: [__privateGet(this, _currentSubscriptionId)]
      }));
    });
    __publicField(this, "destroy", () => {
      if (__privateGet(this, _currentHealthTimeout)) {
        clearTimeout(__privateGet(this, _currentHealthTimeout));
        __privateSet(this, _currentHealthTimeout, null);
      }
    });
    __privateSet(this, _healthCallback, healthCallback);
    __privateSet(this, _requestToSmoldot, requestToSmoldot);
  }
};
_healthCallback = new WeakMap();
_currentHealthCheckId = new WeakMap();
_currentHealthTimeout = new WeakMap();
_currentSubunsubRequestId = new WeakMap();
_currentSubscriptionId = new WeakMap();
_requestToSmoldot = new WeakMap();
_isSyncing = new WeakMap();
_nextRequestId = new WeakMap();
var _cause;
var HealthCheckError = class extends Error {
  constructor(response, message = "Got error response asking for system health") {
    super(message);
    __privateAdd(this, _cause, void 0);
    __privateSet(this, _cause, response);
  }
  getCause() {
    return __privateGet(this, _cause);
  }
};
_cause = new WeakMap();

// node_modules/@polkadot/rpc-provider/substrate-connect/index.js
var l3 = logger("api-substrate-connect");
var subscriptionUnsubscriptionMethods = new Map([["author_submitAndWatchExtrinsic", "author_unwatchExtrinsic"], ["chain_subscribeAllHeads", "chain_unsubscribeAllHeads"], ["chain_subscribeFinalizedHeads", "chain_unsubscribeFinalizedHeads"], ["chain_subscribeFinalisedHeads", "chain_subscribeFinalisedHeads"], ["chain_subscribeNewHeads", "chain_unsubscribeNewHeads"], ["chain_subscribeNewHead", "chain_unsubscribeNewHead"], ["chain_subscribeRuntimeVersion", "chain_unsubscribeRuntimeVersion"], ["subscribe_newHead", "unsubscribe_newHead"], ["state_subscribeRuntimeVersion", "state_unsubscribeRuntimeVersion"], ["state_subscribeStorage", "state_unsubscribeStorage"]]);
var wellKnownChains = new Set(Object.values(WellKnownChain));
var scClients = new WeakMap();
var _coder2, _spec, _sharedSandbox, _subscriptions, _resubscribeMethods, _requests, _eventemitter, _chain, _isChainReady, _resubscribe;
var ScProvider = class {
  constructor(spec2, sharedSandbox) {
    __privateAdd(this, _coder2, new RpcCoder());
    __privateAdd(this, _spec, void 0);
    __privateAdd(this, _sharedSandbox, void 0);
    __privateAdd(this, _subscriptions, new Map());
    __privateAdd(this, _resubscribeMethods, new Map());
    __privateAdd(this, _requests, new Map());
    __privateAdd(this, _eventemitter, new import_eventemitter3.default());
    __privateAdd(this, _chain, null);
    __privateAdd(this, _isChainReady, false);
    __privateAdd(this, _resubscribe, () => {
      const promises = [];
      __privateGet(this, _resubscribeMethods).forEach((subDetails) => {
        if (subDetails.type.startsWith("author_")) {
          return;
        }
        try {
          const promise = new Promise((resolve) => {
            this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));
            resolve();
          });
          promises.push(promise);
        } catch (error) {
          l3.error(error);
        }
      });
      Promise.all(promises).catch((err) => l3.log(err));
    });
    __privateSet(this, _spec, spec2);
    __privateSet(this, _sharedSandbox, sharedSandbox);
  }
  get hasSubscriptions() {
    return true;
  }
  get isClonable() {
    return false;
  }
  get isConnected() {
    return !!__privateGet(this, _chain) && __privateGet(this, _isChainReady);
  }
  clone() {
    throw new Error("clone() is not supported.");
  }
  async connect(config5, checkerFactory = healthChecker) {
    if (this.isConnected) {
      throw new Error("Already connected!");
    }
    if (__privateGet(this, _chain)) {
      await __privateGet(this, _chain);
      return;
    }
    if (__privateGet(this, _sharedSandbox) && !__privateGet(this, _sharedSandbox).isConnected) {
      await __privateGet(this, _sharedSandbox).connect();
    }
    const client = __privateGet(this, _sharedSandbox) ? scClients.get(__privateGet(this, _sharedSandbox)) : createScClient3(config5);
    if (!client) {
      throw new Error("Unkown ScProvider!");
    }
    scClients.set(this, client);
    const hc = checkerFactory();
    const onResponse = (res) => {
      var _response$params, _this$subscriptions$g;
      const hcRes = hc.responsePassThrough(res);
      if (!hcRes) {
        return;
      }
      const response = JSON.parse(hcRes);
      let decodedResponse;
      try {
        decodedResponse = __privateGet(this, _coder2).decodeResponse(response);
      } catch (e) {
        decodedResponse = e;
      }
      if (((_response$params = response.params) == null ? void 0 : _response$params.subscription) === void 0 || !response.method) {
        var _this$requests$get;
        return (_this$requests$get = __privateGet(this, _requests).get(response.id)) == null ? void 0 : _this$requests$get(decodedResponse);
      }
      const subscriptionId = `${response.method}::${response.params.subscription}`;
      const callback = (_this$subscriptions$g = __privateGet(this, _subscriptions).get(subscriptionId)) == null ? void 0 : _this$subscriptions$g[0];
      callback == null ? void 0 : callback(decodedResponse);
    };
    const addChain = wellKnownChains.has(__privateGet(this, _spec)) ? client.addWellKnownChain : client.addChain;
    __privateSet(this, _chain, addChain(__privateGet(this, _spec), onResponse).then((chain2) => {
      hc.setSendJsonRpc(chain2.sendJsonRpc);
      __privateSet(this, _isChainReady, false);
      const cleanup = () => {
        const disconnectionError = new Error("Disconnected");
        __privateGet(this, _requests).forEach((cb) => cb(disconnectionError));
        __privateGet(this, _subscriptions).forEach(([cb]) => cb(disconnectionError));
        __privateGet(this, _subscriptions).clear();
      };
      const staleSubscriptions = [];
      const killStaleSubscriptions = () => {
        if (staleSubscriptions.length === 0) {
          return;
        }
        const stale = staleSubscriptions.pop();
        if (!stale) {
          throw new Error("Unable to get stale subscription");
        }
        const {
          id: id2,
          unsubscribeMethod
        } = stale;
        Promise.race([this.send(unsubscribeMethod, [id2]).catch(() => void 0), new Promise((resolve) => setTimeout(resolve, 500))]).then(killStaleSubscriptions).catch(() => void 0);
      };
      hc.start((health) => {
        const isReady2 = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);
        if (__privateGet(this, _isChainReady) === isReady2) {
          return;
        }
        __privateSet(this, _isChainReady, isReady2);
        if (!isReady2) {
          [...__privateGet(this, _subscriptions).values()].forEach((s) => {
            staleSubscriptions.push(s[1]);
          });
          cleanup();
          __privateGet(this, _eventemitter).emit("disconnected");
        } else {
          killStaleSubscriptions();
          __privateGet(this, _eventemitter).emit("connected");
          if (__privateGet(this, _resubscribeMethods).size) {
            __privateGet(this, _resubscribe).call(this);
          }
        }
      });
      return objectSpread({}, chain2, {
        remove: () => {
          hc.stop();
          chain2.remove();
          cleanup();
        },
        sendJsonRpc: hc.sendJsonRpc.bind(hc)
      });
    }));
    try {
      await __privateGet(this, _chain);
    } catch (e) {
      __privateSet(this, _chain, null);
      __privateGet(this, _eventemitter).emit("error", e);
      throw e;
    }
  }
  async disconnect() {
    if (!__privateGet(this, _chain)) {
      return;
    }
    const chain2 = await __privateGet(this, _chain);
    __privateSet(this, _chain, null);
    __privateSet(this, _isChainReady, false);
    try {
      chain2.remove();
    } catch (_) {
    }
    __privateGet(this, _eventemitter).emit("disconnected");
  }
  on(type, sub) {
    if (type === "connected" && this.isConnected) {
      sub();
    }
    __privateGet(this, _eventemitter).on(type, sub);
    return () => {
      __privateGet(this, _eventemitter).removeListener(type, sub);
    };
  }
  async send(method, params) {
    if (!this.isConnected || !__privateGet(this, _chain)) {
      throw new Error("Provider is not connected");
    }
    const chain2 = await __privateGet(this, _chain);
    const [id2, json] = __privateGet(this, _coder2).encodeJson(method, params);
    const result = new Promise((resolve, reject) => {
      __privateGet(this, _requests).set(id2, (response) => {
        (isError(response) ? reject : resolve)(response);
      });
      try {
        chain2.sendJsonRpc(json);
      } catch (e) {
        __privateSet(this, _chain, null);
        try {
          chain2.remove();
        } catch (_) {
        }
        __privateGet(this, _eventemitter).emit("error", e);
      }
    });
    try {
      return await result;
    } finally {
      __privateGet(this, _requests).delete(id2);
    }
  }
  async subscribe(type, method, params, callback) {
    if (!subscriptionUnsubscriptionMethods.has(method)) {
      throw new Error(`Unsupported subscribe method: ${method}`);
    }
    const id2 = await this.send(method, params);
    const subscriptionId = `${type}::${id2}`;
    const cb = (response) => {
      if (response instanceof Error) {
        callback(response, void 0);
      } else {
        callback(null, response);
      }
    };
    const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);
    if (!unsubscribeMethod) {
      throw new Error("Invalid unsubscribe method found");
    }
    __privateGet(this, _resubscribeMethods).set(subscriptionId, {
      callback,
      method,
      params,
      type
    });
    __privateGet(this, _subscriptions).set(subscriptionId, [cb, {
      id: id2,
      unsubscribeMethod
    }]);
    return id2;
  }
  unsubscribe(type, method, id2) {
    if (!this.isConnected) {
      throw new Error("Provider is not connected");
    }
    const subscriptionId = `${type}::${id2}`;
    if (!__privateGet(this, _subscriptions).has(subscriptionId)) {
      return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));
    }
    __privateGet(this, _resubscribeMethods).delete(subscriptionId);
    __privateGet(this, _subscriptions).delete(subscriptionId);
    return this.send(method, [id2]);
  }
};
_coder2 = new WeakMap();
_spec = new WeakMap();
_sharedSandbox = new WeakMap();
_subscriptions = new WeakMap();
_resubscribeMethods = new WeakMap();
_requests = new WeakMap();
_eventemitter = new WeakMap();
_chain = new WeakMap();
_isChainReady = new WeakMap();
_resubscribe = new WeakMap();
__publicField(ScProvider, "WellKnownChain", WellKnownChain);

// node_modules/@polkadot/rpc-provider/ws/index.js
var import_eventemitter32 = __toModule(require_eventemitter3());

// node_modules/@polkadot/x-ws/packageInfo.js
var import_meta24 = {};
var packageInfo24 = {
  name: "@polkadot/x-ws",
  path: import_meta24 && import_meta24.url ? new URL(import_meta24.url).pathname.substring(0, new URL(import_meta24.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "10.1.14"
};

// node_modules/@polkadot/x-ws/browser.js
var WebSocket = xglobal.WebSocket;

// node_modules/@polkadot/rpc-provider/ws/errors.js
var known = {
  1e3: "Normal Closure",
  1001: "Going Away",
  1002: "Protocol Error",
  1003: "Unsupported Data",
  1004: "(For future)",
  1005: "No Status Received",
  1006: "Abnormal Closure",
  1007: "Invalid frame payload data",
  1008: "Policy Violation",
  1009: "Message too big",
  1010: "Missing Extension",
  1011: "Internal Error",
  1012: "Service Restart",
  1013: "Try Again Later",
  1014: "Bad Gateway",
  1015: "TLS Handshake"
};
function getUnmapped(code) {
  if (code <= 1999) {
    return "(For WebSocket standard)";
  } else if (code <= 2999) {
    return "(For WebSocket extensions)";
  } else if (code <= 3999) {
    return "(For libraries and frameworks)";
  } else if (code <= 4999) {
    return "(For applications)";
  }
}
function getWSErrorString(code) {
  if (code >= 0 && code <= 999) {
    return "(Unused)";
  }
  return known[code] || getUnmapped(code) || "(Unknown)";
}

// node_modules/@polkadot/rpc-provider/ws/index.js
var ALIASES = {
  chain_finalisedHead: "chain_finalizedHead",
  chain_subscribeFinalisedHeads: "chain_subscribeFinalizedHeads",
  chain_unsubscribeFinalisedHeads: "chain_unsubscribeFinalizedHeads"
};
var RETRY_DELAY = 2500;
var DEFAULT_TIMEOUT_MS = 60 * 1e3;
var TIMEOUT_INTERVAL = 5e3;
var MEGABYTE = 1024 * 1024;
var l4 = logger("api-ws");
function eraseRecord(record, cb) {
  Object.keys(record).forEach((key) => {
    if (cb) {
      cb(record[key]);
    }
    delete record[key];
  });
}
var _callCache2 = _classPrivateFieldKey("callCache");
var _coder3 = _classPrivateFieldKey("coder");
var _endpoints = _classPrivateFieldKey("endpoints");
var _headers2 = _classPrivateFieldKey("headers");
var _eventemitter2 = _classPrivateFieldKey("eventemitter");
var _handlers = _classPrivateFieldKey("handlers");
var _isReadyPromise = _classPrivateFieldKey("isReadyPromise");
var _stats2 = _classPrivateFieldKey("stats");
var _waitingForId = _classPrivateFieldKey("waitingForId");
var _autoConnectMs = _classPrivateFieldKey("autoConnectMs");
var _endpointIndex = _classPrivateFieldKey("endpointIndex");
var _isConnected = _classPrivateFieldKey("isConnected");
var _subscriptions2 = _classPrivateFieldKey("subscriptions");
var _timeoutId = _classPrivateFieldKey("timeoutId");
var _websocket = _classPrivateFieldKey("websocket");
var _timeout = _classPrivateFieldKey("timeout");
var _send3 = _classPrivateFieldKey("send");
var _emit = _classPrivateFieldKey("emit");
var _onSocketClose = _classPrivateFieldKey("onSocketClose");
var _onSocketError = _classPrivateFieldKey("onSocketError");
var _onSocketMessage = _classPrivateFieldKey("onSocketMessage");
var _onSocketMessageResult = _classPrivateFieldKey("onSocketMessageResult");
var _onSocketMessageSubscribe = _classPrivateFieldKey("onSocketMessageSubscribe");
var _onSocketOpen = _classPrivateFieldKey("onSocketOpen");
var _resubscribe2 = _classPrivateFieldKey("resubscribe");
var _timeoutHandlers = _classPrivateFieldKey("timeoutHandlers");
var WsProvider = class {
  constructor(endpoint = defaults_default.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout2) {
    Object.defineProperty(this, _send3, {
      value: _send22
    });
    Object.defineProperty(this, _callCache2, {
      writable: true,
      value: new LRUCache()
    });
    Object.defineProperty(this, _coder3, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpoints, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _headers2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _eventemitter2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handlers, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _isReadyPromise, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _stats2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _waitingForId, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _autoConnectMs, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpointIndex, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isConnected, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _subscriptions2, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _timeoutId, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _websocket, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _timeout, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _emit, {
      writable: true,
      value: (type, ...args) => {
        _classPrivateFieldBase(this, _eventemitter2)[_eventemitter2].emit(type, ...args);
      }
    });
    Object.defineProperty(this, _onSocketClose, {
      writable: true,
      value: (event) => {
        const error = new Error(`disconnected from ${_classPrivateFieldBase(this, _endpoints)[_endpoints][_classPrivateFieldBase(this, _endpointIndex)[_endpointIndex]]}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);
        if (_classPrivateFieldBase(this, _autoConnectMs)[_autoConnectMs] > 0) {
          l4.error(error.message);
        }
        _classPrivateFieldBase(this, _isConnected)[_isConnected] = false;
        if (_classPrivateFieldBase(this, _websocket)[_websocket]) {
          _classPrivateFieldBase(this, _websocket)[_websocket].onclose = null;
          _classPrivateFieldBase(this, _websocket)[_websocket].onerror = null;
          _classPrivateFieldBase(this, _websocket)[_websocket].onmessage = null;
          _classPrivateFieldBase(this, _websocket)[_websocket].onopen = null;
          _classPrivateFieldBase(this, _websocket)[_websocket] = null;
        }
        if (_classPrivateFieldBase(this, _timeoutId)[_timeoutId]) {
          clearInterval(_classPrivateFieldBase(this, _timeoutId)[_timeoutId]);
          _classPrivateFieldBase(this, _timeoutId)[_timeoutId] = null;
        }
        _classPrivateFieldBase(this, _emit)[_emit]("disconnected");
        eraseRecord(_classPrivateFieldBase(this, _handlers)[_handlers], (h) => {
          try {
            h.callback(error, void 0);
          } catch (err) {
            l4.error(err);
          }
        });
        eraseRecord(_classPrivateFieldBase(this, _waitingForId)[_waitingForId]);
        if (_classPrivateFieldBase(this, _autoConnectMs)[_autoConnectMs] > 0) {
          setTimeout(() => {
            this.connectWithRetry().catch(() => {
            });
          }, _classPrivateFieldBase(this, _autoConnectMs)[_autoConnectMs]);
        }
      }
    });
    Object.defineProperty(this, _onSocketError, {
      writable: true,
      value: (error) => {
        l4.debug(() => ["socket error", error]);
        _classPrivateFieldBase(this, _emit)[_emit]("error", error);
      }
    });
    Object.defineProperty(this, _onSocketMessage, {
      writable: true,
      value: (message) => {
        l4.debug(() => ["received", message.data]);
        _classPrivateFieldBase(this, _stats2)[_stats2].total.bytesRecv += message.data.length;
        const response = JSON.parse(message.data);
        return isUndefined(response.method) ? _classPrivateFieldBase(this, _onSocketMessageResult)[_onSocketMessageResult](response) : _classPrivateFieldBase(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);
      }
    });
    Object.defineProperty(this, _onSocketMessageResult, {
      writable: true,
      value: (response) => {
        const handler = _classPrivateFieldBase(this, _handlers)[_handlers][response.id];
        if (!handler) {
          l4.debug(() => `Unable to find handler for id=${response.id}`);
          return;
        }
        try {
          const {
            method,
            params,
            subscription
          } = handler;
          const result = _classPrivateFieldBase(this, _coder3)[_coder3].decodeResponse(response);
          handler.callback(null, result);
          if (subscription) {
            const subId = `${subscription.type}::${result}`;
            _classPrivateFieldBase(this, _subscriptions2)[_subscriptions2][subId] = objectSpread({}, subscription, {
              method,
              params
            });
            if (_classPrivateFieldBase(this, _waitingForId)[_waitingForId][subId]) {
              _classPrivateFieldBase(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](_classPrivateFieldBase(this, _waitingForId)[_waitingForId][subId]);
            }
          }
        } catch (error) {
          _classPrivateFieldBase(this, _stats2)[_stats2].total.errors++;
          handler.callback(error, void 0);
        }
        delete _classPrivateFieldBase(this, _handlers)[_handlers][response.id];
      }
    });
    Object.defineProperty(this, _onSocketMessageSubscribe, {
      writable: true,
      value: (response) => {
        const method = ALIASES[response.method] || response.method || "invalid";
        const subId = `${method}::${response.params.subscription}`;
        const handler = _classPrivateFieldBase(this, _subscriptions2)[_subscriptions2][subId];
        if (!handler) {
          _classPrivateFieldBase(this, _waitingForId)[_waitingForId][subId] = response;
          l4.debug(() => `Unable to find handler for subscription=${subId}`);
          return;
        }
        delete _classPrivateFieldBase(this, _waitingForId)[_waitingForId][subId];
        try {
          const result = _classPrivateFieldBase(this, _coder3)[_coder3].decodeResponse(response);
          handler.callback(null, result);
        } catch (error) {
          _classPrivateFieldBase(this, _stats2)[_stats2].total.errors++;
          handler.callback(error, void 0);
        }
      }
    });
    Object.defineProperty(this, _onSocketOpen, {
      writable: true,
      value: () => {
        if (_classPrivateFieldBase(this, _websocket)[_websocket] === null) {
          throw new Error("WebSocket cannot be null in onOpen");
        }
        l4.debug(() => ["connected to", _classPrivateFieldBase(this, _endpoints)[_endpoints][_classPrivateFieldBase(this, _endpointIndex)[_endpointIndex]]]);
        _classPrivateFieldBase(this, _isConnected)[_isConnected] = true;
        _classPrivateFieldBase(this, _emit)[_emit]("connected");
        _classPrivateFieldBase(this, _resubscribe2)[_resubscribe2]();
        return true;
      }
    });
    Object.defineProperty(this, _resubscribe2, {
      writable: true,
      value: () => {
        const subscriptions = _classPrivateFieldBase(this, _subscriptions2)[_subscriptions2];
        _classPrivateFieldBase(this, _subscriptions2)[_subscriptions2] = {};
        Promise.all(Object.keys(subscriptions).map(async (id2) => {
          const {
            callback,
            method,
            params,
            type
          } = subscriptions[id2];
          if (type.startsWith("author_")) {
            return;
          }
          try {
            await this.subscribe(type, method, params, callback);
          } catch (error) {
            l4.error(error);
          }
        })).catch(l4.error);
      }
    });
    Object.defineProperty(this, _timeoutHandlers, {
      writable: true,
      value: () => {
        const now = Date.now();
        const ids = Object.keys(_classPrivateFieldBase(this, _handlers)[_handlers]);
        for (let i = 0; i < ids.length; i++) {
          const handler = _classPrivateFieldBase(this, _handlers)[_handlers][ids[i]];
          if (now - handler.start > _classPrivateFieldBase(this, _timeout)[_timeout]) {
            try {
              handler.callback(new Error(`No response received from RPC endpoint in ${_classPrivateFieldBase(this, _timeout)[_timeout] / 1e3}s`), void 0);
            } catch {
            }
            _classPrivateFieldBase(this, _stats2)[_stats2].total.timeout++;
            delete _classPrivateFieldBase(this, _handlers)[_handlers][ids[i]];
          }
        }
      }
    });
    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];
    if (endpoints.length === 0) {
      throw new Error("WsProvider requires at least one Endpoint");
    }
    endpoints.forEach((endpoint2) => {
      if (!/^(wss|ws):\/\//.test(endpoint2)) {
        throw new Error(`Endpoint should start with 'ws://', received '${endpoint2}'`);
      }
    });
    _classPrivateFieldBase(this, _eventemitter2)[_eventemitter2] = new import_eventemitter32.default();
    _classPrivateFieldBase(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;
    _classPrivateFieldBase(this, _coder3)[_coder3] = new RpcCoder();
    _classPrivateFieldBase(this, _endpointIndex)[_endpointIndex] = -1;
    _classPrivateFieldBase(this, _endpoints)[_endpoints] = endpoints;
    _classPrivateFieldBase(this, _headers2)[_headers2] = headers;
    _classPrivateFieldBase(this, _websocket)[_websocket] = null;
    _classPrivateFieldBase(this, _stats2)[_stats2] = {
      active: {
        requests: 0,
        subscriptions: 0
      },
      total: {
        bytesRecv: 0,
        bytesSent: 0,
        cached: 0,
        errors: 0,
        requests: 0,
        subscriptions: 0,
        timeout: 0
      }
    };
    _classPrivateFieldBase(this, _timeout)[_timeout] = timeout2 || DEFAULT_TIMEOUT_MS;
    if (autoConnectMs > 0) {
      this.connectWithRetry().catch(() => {
      });
    }
    _classPrivateFieldBase(this, _isReadyPromise)[_isReadyPromise] = new Promise((resolve) => {
      _classPrivateFieldBase(this, _eventemitter2)[_eventemitter2].once("connected", () => {
        resolve(this);
      });
    });
  }
  get hasSubscriptions() {
    return true;
  }
  get isClonable() {
    return true;
  }
  get isConnected() {
    return _classPrivateFieldBase(this, _isConnected)[_isConnected];
  }
  get isReady() {
    return _classPrivateFieldBase(this, _isReadyPromise)[_isReadyPromise];
  }
  clone() {
    return new WsProvider(_classPrivateFieldBase(this, _endpoints)[_endpoints]);
  }
  async connect() {
    try {
      _classPrivateFieldBase(this, _endpointIndex)[_endpointIndex] = (_classPrivateFieldBase(this, _endpointIndex)[_endpointIndex] + 1) % _classPrivateFieldBase(this, _endpoints)[_endpoints].length;
      _classPrivateFieldBase(this, _websocket)[_websocket] = typeof xglobal.WebSocket !== "undefined" && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(_classPrivateFieldBase(this, _endpoints)[_endpoints][_classPrivateFieldBase(this, _endpointIndex)[_endpointIndex]]) : new WebSocket(_classPrivateFieldBase(this, _endpoints)[_endpoints][_classPrivateFieldBase(this, _endpointIndex)[_endpointIndex]], void 0, void 0, _classPrivateFieldBase(this, _headers2)[_headers2], void 0, {
        fragmentOutgoingMessages: true,
        fragmentationThreshold: 1 * MEGABYTE,
        maxReceivedFrameSize: 24 * MEGABYTE,
        maxReceivedMessageSize: 24 * MEGABYTE
      });
      if (_classPrivateFieldBase(this, _websocket)[_websocket]) {
        _classPrivateFieldBase(this, _websocket)[_websocket].onclose = _classPrivateFieldBase(this, _onSocketClose)[_onSocketClose];
        _classPrivateFieldBase(this, _websocket)[_websocket].onerror = _classPrivateFieldBase(this, _onSocketError)[_onSocketError];
        _classPrivateFieldBase(this, _websocket)[_websocket].onmessage = _classPrivateFieldBase(this, _onSocketMessage)[_onSocketMessage];
        _classPrivateFieldBase(this, _websocket)[_websocket].onopen = _classPrivateFieldBase(this, _onSocketOpen)[_onSocketOpen];
      }
      _classPrivateFieldBase(this, _timeoutId)[_timeoutId] = setInterval(() => _classPrivateFieldBase(this, _timeoutHandlers)[_timeoutHandlers](), TIMEOUT_INTERVAL);
    } catch (error) {
      l4.error(error);
      _classPrivateFieldBase(this, _emit)[_emit]("error", error);
      throw error;
    }
  }
  async connectWithRetry() {
    if (_classPrivateFieldBase(this, _autoConnectMs)[_autoConnectMs] > 0) {
      try {
        await this.connect();
      } catch (error) {
        setTimeout(() => {
          this.connectWithRetry().catch(() => {
          });
        }, _classPrivateFieldBase(this, _autoConnectMs)[_autoConnectMs]);
      }
    }
  }
  async disconnect() {
    _classPrivateFieldBase(this, _autoConnectMs)[_autoConnectMs] = 0;
    try {
      if (_classPrivateFieldBase(this, _websocket)[_websocket]) {
        _classPrivateFieldBase(this, _websocket)[_websocket].close(1e3);
      }
    } catch (error) {
      l4.error(error);
      _classPrivateFieldBase(this, _emit)[_emit]("error", error);
      throw error;
    }
  }
  get stats() {
    return {
      active: {
        requests: Object.keys(_classPrivateFieldBase(this, _handlers)[_handlers]).length,
        subscriptions: Object.keys(_classPrivateFieldBase(this, _subscriptions2)[_subscriptions2]).length
      },
      total: _classPrivateFieldBase(this, _stats2)[_stats2].total
    };
  }
  on(type, sub) {
    _classPrivateFieldBase(this, _eventemitter2)[_eventemitter2].on(type, sub);
    return () => {
      _classPrivateFieldBase(this, _eventemitter2)[_eventemitter2].removeListener(type, sub);
    };
  }
  send(method, params, isCacheable, subscription) {
    _classPrivateFieldBase(this, _stats2)[_stats2].total.requests++;
    const [id2, body] = _classPrivateFieldBase(this, _coder3)[_coder3].encodeJson(method, params);
    let resultPromise = isCacheable ? _classPrivateFieldBase(this, _callCache2)[_callCache2].get(body) : null;
    if (!resultPromise) {
      resultPromise = _classPrivateFieldBase(this, _send3)[_send3](id2, body, method, params, subscription);
      if (isCacheable) {
        _classPrivateFieldBase(this, _callCache2)[_callCache2].set(body, resultPromise);
      }
    } else {
      _classPrivateFieldBase(this, _stats2)[_stats2].total.cached++;
    }
    return resultPromise;
  }
  subscribe(type, method, params, callback) {
    _classPrivateFieldBase(this, _stats2)[_stats2].total.subscriptions++;
    return this.send(method, params, false, {
      callback,
      type
    });
  }
  async unsubscribe(type, method, id2) {
    const subscription = `${type}::${id2}`;
    if (isUndefined(_classPrivateFieldBase(this, _subscriptions2)[_subscriptions2][subscription])) {
      l4.debug(() => `Unable to find active subscription=${subscription}`);
      return false;
    }
    delete _classPrivateFieldBase(this, _subscriptions2)[_subscriptions2][subscription];
    try {
      return this.isConnected && !isNull(_classPrivateFieldBase(this, _websocket)[_websocket]) ? this.send(method, [id2]) : true;
    } catch (error) {
      return false;
    }
  }
};
async function _send22(id2, body, method, params, subscription) {
  return new Promise((resolve, reject) => {
    try {
      if (!this.isConnected || _classPrivateFieldBase(this, _websocket)[_websocket] === null) {
        throw new Error("WebSocket is not connected");
      }
      const callback = (error, result) => {
        error ? reject(error) : resolve(result);
      };
      l4.debug(() => ["calling", method, body]);
      _classPrivateFieldBase(this, _handlers)[_handlers][id2] = {
        callback,
        method,
        params,
        start: Date.now(),
        subscription
      };
      _classPrivateFieldBase(this, _stats2)[_stats2].total.bytesSent += body.length;
      _classPrivateFieldBase(this, _websocket)[_websocket].send(body);
    } catch (error) {
      _classPrivateFieldBase(this, _stats2)[_stats2].total.errors++;
      reject(error);
    }
  });
}

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l16 = from2.length, ar; i < l16; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction2(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty3 = new Subscription2();
    empty3.closed = true;
    return empty3;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction2(value.remove) && isFunction2(value.add) && isFunction2(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction2(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config4 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config4.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop2() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config4.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config4.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction2(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config4.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config4.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config4.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop2,
  error: defaultErrorHandler,
  complete: noop2
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config4.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction2(value.next) && isFunction2(value.error) && isFunction2(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction2(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id2 = 0;
    var run = function() {
      if (!subscriber.closed) {
        id2 = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id2 = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id2) {
        animationFrameProvider.cancelAnimationFrame(id2);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state2);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id2 = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    var actions = scheduler.actions;
    if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      immediateProvider.clearImmediate(id2);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    var actions = scheduler.actions;
    if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      animationFrameProvider.cancelAnimationFrame(id2);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state2, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state2, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state2, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state2, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction2(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction2(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise2(value) {
  return isFunction2(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction2(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction2(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction2(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise2(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction2(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction2(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise2(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction2(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init2 = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init2, 0, subscriber);
  } : init2);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction2((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config5) {
  var hasConfig = typeof config5 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config5.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info6) {
    if (info6 === void 0) {
      info6 = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info6;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map2(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray2 = Array.isArray;
function callOrApply(fn, args) {
  return isArray2(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map2(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray3 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray3(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys2 = getKeys(first_1);
      return {
        args: keys2.map(function(key) {
          return first_1[key];
        }),
        keys: keys2
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys2, values) {
  return keys2.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys2 = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys2 ? function(values) {
    return createObject(keys2, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand3, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand3 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand3) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction2(resultSelector)) {
    return mergeMap(function(a, i) {
      return map2(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop2);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray4 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state2 = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state2 = hasState ? accumulator(state2, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state2);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state2);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/toArray.js
var arrReducer = function(arr, value) {
  return arr.push(value), arr;
};
function toArray() {
  return operate(function(source, subscriber) {
    reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js
function fromSubscribable(subscribable) {
  return new Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/connect.js
var DEFAULT_CONFIG = {
  connector: function() {
    return new Subject();
  }
};
function connect(selector, config5) {
  if (config5 === void 0) {
    config5 = DEFAULT_CONFIG;
  }
  var connector = config5.connector;
  return operate(function(source, subscriber) {
    var subject = connector();
    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
function mapTo(value) {
  return map2(function() {
    return value;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}

// node_modules/rxjs/dist/esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction2(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction2(selector)) {
    return connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable(source, subjectFactory);
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
  if (selectorOrScheduler && !isFunction2(selectorOrScheduler)) {
    timestampProvider = selectorOrScheduler;
  }
  var selector = isFunction2(selectorOrScheduler) ? selectorOrScheduler : void 0;
  return function(source) {
    return multicast(new ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction2(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/@polkadot/api-derive/detectOther.js
var detectOther_default11 = [];

// node_modules/@polkadot/api-derive/detectPackage.js
detectPackage(packageInfo6, null, detectOther_default11);

// node_modules/@polkadot/api-derive/accounts/index.js
var accounts_exports = {};
__export(accounts_exports, {
  _flags: () => _flags,
  _identity: () => _identity,
  accountId: () => accountId,
  flags: () => flags,
  hasIdentity: () => hasIdentity,
  hasIdentityMulti: () => hasIdentityMulti,
  idAndIndex: () => idAndIndex,
  idToIndex: () => idToIndex,
  identity: () => identity2,
  indexToId: () => indexToId,
  indexes: () => indexes,
  info: () => info
});

// node_modules/@polkadot/rpc-core/detectOther.js
var detectOther_default12 = [packageInfo8, packageInfo9];

// node_modules/@polkadot/rpc-core/detectPackage.js
detectPackage(packageInfo7, null, detectOther_default12);

// node_modules/@polkadot/types-codec/packageInfo.js
var import_meta25 = {};
var packageInfo25 = {
  name: "@polkadot/types-codec",
  path: import_meta25 && import_meta25.url ? new URL(import_meta25.url).pathname.substring(0, new URL(import_meta25.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/types-create/packageInfo.js
var import_meta26 = {};
var packageInfo26 = {
  name: "@polkadot/types-create",
  path: import_meta26 && import_meta26.url ? new URL(import_meta26.url).pathname.substring(0, new URL(import_meta26.url).pathname.lastIndexOf("/") + 1) : "auto",
  type: "esm",
  version: "9.9.4"
};

// node_modules/@polkadot/types/detectOther.js
var detectOther_default13 = [packageInfo25, packageInfo26];

// node_modules/@polkadot/types/detectPackage.js
detectPackage(packageInfo9, null, detectOther_default13);

// node_modules/@polkadot/types/interfaces/definitions.js
var definitions_exports = {};
__export(definitions_exports, {
  assets: () => definitions_default4,
  attestations: () => definitions_default47,
  aura: () => definitions_default6,
  author: () => definitions_default63,
  authorship: () => definitions_default5,
  babe: () => definitions_default7,
  balances: () => definitions_default8,
  beefy: () => definitions_default9,
  benchmark: () => definitions_default10,
  blockbuilder: () => definitions_default11,
  bridges: () => definitions_default48,
  chain: () => definitions_default64,
  childstate: () => definitions_default65,
  claims: () => definitions_default49,
  collective: () => definitions_default12,
  consensus: () => definitions_default13,
  contracts: () => definitions_default14,
  contractsAbi: () => definitions_default57,
  crowdloan: () => definitions_default50,
  cumulus: () => definitions_default51,
  democracy: () => definitions_default15,
  dev: () => definitions_default16,
  discovery: () => definitions_default17,
  elections: () => definitions_default18,
  engine: () => definitions_default19,
  eth: () => definitions_default58,
  evm: () => definitions_default20,
  extrinsics: () => definitions_default21,
  finality: () => definitions_default52,
  genericAsset: () => definitions_default22,
  gilt: () => definitions_default23,
  grandpa: () => definitions_default24,
  identity: () => definitions_default25,
  imOnline: () => definitions_default26,
  lottery: () => definitions_default27,
  metadata: () => definitions_default,
  mmr: () => definitions_default28,
  nimbus: () => definitions_default59,
  nompools: () => definitions_default29,
  offchain: () => definitions_default66,
  offences: () => definitions_default30,
  ormlOracle: () => definitions_default60,
  ormlTokens: () => definitions_default61,
  parachains: () => definitions_default53,
  payment: () => definitions_default67,
  poll: () => definitions_default54,
  pow: () => definitions_default31,
  proxy: () => definitions_default32,
  purchase: () => definitions_default55,
  recovery: () => definitions_default33,
  rpc: () => definitions_default62,
  runtime: () => definitions_default2,
  scaleInfo: () => definitions_default3,
  scheduler: () => definitions_default34,
  session: () => definitions_default35,
  society: () => definitions_default36,
  staking: () => definitions_default37,
  state: () => definitions_default68,
  support: () => definitions_default38,
  syncstate: () => definitions_default39,
  system: () => definitions_default40,
  treasury: () => definitions_default41,
  txpayment: () => definitions_default42,
  txqueue: () => definitions_default43,
  uniques: () => definitions_default44,
  utility: () => definitions_default45,
  vesting: () => definitions_default46,
  xcm: () => definitions_default56
});

// node_modules/@polkadot/types/interfaces/metadata/hashers.js
var AllHashers = {
  Blake2_128: null,
  Blake2_256: null,
  Blake2_128Concat: null,
  Twox128: null,
  Twox256: null,
  Twox64Concat: null,
  Identity: null
};

// node_modules/@polkadot/types/interfaces/metadata/runtime.js
var runtime = {
  Metadata: [{
    methods: {
      metadata: {
        description: "Returns the metadata of a runtime",
        params: [],
        type: "OpaqueMetadata"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/metadata/v9.js
var v9 = {
  ErrorMetadataV9: {
    name: "Text",
    docs: "Vec<Text>"
  },
  EventMetadataV9: {
    name: "Text",
    args: "Vec<Type>",
    docs: "Vec<Text>"
  },
  FunctionArgumentMetadataV9: {
    name: "Text",
    type: "Type"
  },
  FunctionMetadataV9: {
    name: "Text",
    args: "Vec<FunctionArgumentMetadataV9>",
    docs: "Vec<Text>"
  },
  MetadataV9: {
    modules: "Vec<ModuleMetadataV9>"
  },
  ModuleConstantMetadataV9: {
    name: "Text",
    type: "Type",
    value: "Bytes",
    docs: "Vec<Text>"
  },
  ModuleMetadataV9: {
    name: "Text",
    storage: "Option<StorageMetadataV9>",
    calls: "Option<Vec<FunctionMetadataV9>>",
    events: "Option<Vec<EventMetadataV9>>",
    constants: "Vec<ModuleConstantMetadataV9>",
    errors: "Vec<ErrorMetadataV9>"
  },
  StorageEntryMetadataV9: {
    name: "Text",
    modifier: "StorageEntryModifierV9",
    type: "StorageEntryTypeV9",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryModifierV9: {
    _enum: ["Optional", "Default", "Required"]
  },
  StorageEntryTypeV9: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV9",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV9",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV9"
      }
    }
  },
  StorageHasherV9: {
    _enum: {
      Blake2_128: null,
      Blake2_256: null,
      Twox128: null,
      Twox256: null,
      Twox64Concat: null
    }
  },
  StorageMetadataV9: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV9>"
  }
};

// node_modules/@polkadot/types/interfaces/metadata/v10.js
var v10 = {
  ErrorMetadataV10: "ErrorMetadataV9",
  EventMetadataV10: "EventMetadataV9",
  FunctionArgumentMetadataV10: "FunctionArgumentMetadataV9",
  FunctionMetadataV10: "FunctionMetadataV9",
  MetadataV10: {
    modules: "Vec<ModuleMetadataV10>"
  },
  ModuleConstantMetadataV10: "ModuleConstantMetadataV9",
  ModuleMetadataV10: {
    name: "Text",
    storage: "Option<StorageMetadataV10>",
    calls: "Option<Vec<FunctionMetadataV10>>",
    events: "Option<Vec<EventMetadataV10>>",
    constants: "Vec<ModuleConstantMetadataV10>",
    errors: "Vec<ErrorMetadataV10>"
  },
  StorageEntryModifierV10: "StorageEntryModifierV9",
  StorageEntryMetadataV10: {
    name: "Text",
    modifier: "StorageEntryModifierV10",
    type: "StorageEntryTypeV10",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryTypeV10: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV10",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV10",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV10"
      }
    }
  },
  StorageMetadataV10: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV10>"
  },
  StorageHasherV10: {
    _enum: {
      Blake2_128: null,
      Blake2_256: null,
      Blake2_128Concat: null,
      Twox128: null,
      Twox256: null,
      Twox64Concat: null
    }
  }
};

// node_modules/@polkadot/types/interfaces/metadata/v11.js
var v11 = {
  ErrorMetadataV11: "ErrorMetadataV10",
  EventMetadataV11: "EventMetadataV10",
  ExtrinsicMetadataV11: {
    version: "u8",
    signedExtensions: "Vec<Text>"
  },
  FunctionArgumentMetadataV11: "FunctionArgumentMetadataV10",
  FunctionMetadataV11: "FunctionMetadataV10",
  MetadataV11: {
    modules: "Vec<ModuleMetadataV11>",
    extrinsic: "ExtrinsicMetadataV11"
  },
  ModuleConstantMetadataV11: "ModuleConstantMetadataV10",
  ModuleMetadataV11: {
    name: "Text",
    storage: "Option<StorageMetadataV11>",
    calls: "Option<Vec<FunctionMetadataV11>>",
    events: "Option<Vec<EventMetadataV11>>",
    constants: "Vec<ModuleConstantMetadataV11>",
    errors: "Vec<ErrorMetadataV11>"
  },
  StorageEntryModifierV11: "StorageEntryModifierV10",
  StorageEntryMetadataV11: {
    name: "Text",
    modifier: "StorageEntryModifierV11",
    type: "StorageEntryTypeV11",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryTypeV11: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV11",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV11",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV11"
      }
    }
  },
  StorageMetadataV11: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV11>"
  },
  StorageHasherV11: {
    _enum: AllHashers
  }
};

// node_modules/@polkadot/types/interfaces/metadata/v12.js
var v12 = {
  ErrorMetadataV12: "ErrorMetadataV11",
  EventMetadataV12: "EventMetadataV11",
  ExtrinsicMetadataV12: "ExtrinsicMetadataV11",
  FunctionArgumentMetadataV12: "FunctionArgumentMetadataV11",
  FunctionMetadataV12: "FunctionMetadataV11",
  MetadataV12: {
    modules: "Vec<ModuleMetadataV12>",
    extrinsic: "ExtrinsicMetadataV12"
  },
  ModuleConstantMetadataV12: "ModuleConstantMetadataV11",
  ModuleMetadataV12: {
    name: "Text",
    storage: "Option<StorageMetadataV12>",
    calls: "Option<Vec<FunctionMetadataV12>>",
    events: "Option<Vec<EventMetadataV12>>",
    constants: "Vec<ModuleConstantMetadataV12>",
    errors: "Vec<ErrorMetadataV12>",
    index: "u8"
  },
  StorageEntryModifierV12: "StorageEntryModifierV11",
  StorageEntryMetadataV12: "StorageEntryMetadataV11",
  StorageEntryTypeV12: "StorageEntryTypeV11",
  StorageMetadataV12: "StorageMetadataV11",
  StorageHasherV12: "StorageHasherV11"
};

// node_modules/@polkadot/types/interfaces/metadata/v13.js
var v13 = {
  ErrorMetadataV13: "ErrorMetadataV12",
  EventMetadataV13: "EventMetadataV12",
  ExtrinsicMetadataV13: "ExtrinsicMetadataV12",
  FunctionArgumentMetadataV13: "FunctionArgumentMetadataV12",
  FunctionMetadataV13: "FunctionMetadataV12",
  MetadataV13: {
    modules: "Vec<ModuleMetadataV13>",
    extrinsic: "ExtrinsicMetadataV13"
  },
  ModuleConstantMetadataV13: "ModuleConstantMetadataV12",
  ModuleMetadataV13: {
    name: "Text",
    storage: "Option<StorageMetadataV13>",
    calls: "Option<Vec<FunctionMetadataV13>>",
    events: "Option<Vec<EventMetadataV13>>",
    constants: "Vec<ModuleConstantMetadataV13>",
    errors: "Vec<ErrorMetadataV13>",
    index: "u8"
  },
  StorageEntryModifierV13: "StorageEntryModifierV12",
  StorageEntryMetadataV13: {
    name: "Text",
    modifier: "StorageEntryModifierV13",
    type: "StorageEntryTypeV13",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryTypeV13: {
    _enum: {
      Plain: "Type",
      Map: {
        hasher: "StorageHasherV13",
        key: "Type",
        value: "Type",
        linked: "bool"
      },
      DoubleMap: {
        hasher: "StorageHasherV13",
        key1: "Type",
        key2: "Type",
        value: "Type",
        key2Hasher: "StorageHasherV13"
      },
      NMap: {
        keyVec: "Vec<Type>",
        hashers: "Vec<StorageHasherV13>",
        value: "Type"
      }
    }
  },
  StorageMetadataV13: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV13>"
  },
  StorageHasherV13: "StorageHasherV12"
};

// node_modules/@polkadot/types/interfaces/scaleInfo/v1.js
var Si1Variant = {
  name: "Text",
  fields: "Vec<Si1Field>",
  index: "u8",
  docs: "Vec<Text>"
};
var v1 = {
  Si1Field: {
    name: "Option<Text>",
    type: "Si1LookupTypeId",
    typeName: "Option<Text>",
    docs: "Vec<Text>"
  },
  Si1LookupTypeId: "Compact<u32>",
  Si1Path: "Si0Path",
  Si1Type: {
    path: "Si1Path",
    params: "Vec<Si1TypeParameter>",
    def: "Si1TypeDef",
    docs: "Vec<Text>"
  },
  Si1TypeDef: {
    _enum: {
      Composite: "Si1TypeDefComposite",
      Variant: "Si1TypeDefVariant",
      Sequence: "Si1TypeDefSequence",
      Array: "Si1TypeDefArray",
      Tuple: "Si1TypeDefTuple",
      Primitive: "Si1TypeDefPrimitive",
      Compact: "Si1TypeDefCompact",
      BitSequence: "Si1TypeDefBitSequence",
      HistoricMetaCompat: "Type"
    }
  },
  Si1TypeDefArray: {
    len: "u32",
    type: "Si1LookupTypeId"
  },
  Si1TypeDefBitSequence: {
    bitStoreType: "Si1LookupTypeId",
    bitOrderType: "Si1LookupTypeId"
  },
  Si1TypeDefCompact: {
    type: "Si1LookupTypeId"
  },
  Si1TypeDefComposite: {
    fields: "Vec<Si1Field>"
  },
  Si1TypeDefPrimitive: "Si0TypeDefPrimitive",
  Si1TypeDefSequence: {
    type: "Si1LookupTypeId"
  },
  Si1TypeDefTuple: "Vec<Si1LookupTypeId>",
  Si1TypeParameter: {
    name: "Text",
    type: "Option<Si1LookupTypeId>"
  },
  Si1TypeDefVariant: {
    variants: "Vec<Si1Variant>"
  },
  Si1Variant
};

// node_modules/@polkadot/types/interfaces/metadata/v14.js
var v14 = {
  PortableTypeV14: {
    id: "Si1LookupTypeId",
    type: "Si1Type"
  },
  ErrorMetadataV14: objectSpread({}, Si1Variant, {
    args: "Vec<Type>"
  }),
  EventMetadataV14: objectSpread({}, Si1Variant, {
    args: "Vec<Type>"
  }),
  FunctionArgumentMetadataV14: {
    name: "Text",
    type: "Type",
    typeName: "Option<Type>"
  },
  FunctionMetadataV14: objectSpread({}, Si1Variant, {
    args: "Vec<FunctionArgumentMetadataV14>"
  }),
  ExtrinsicMetadataV14: {
    type: "SiLookupTypeId",
    version: "u8",
    signedExtensions: "Vec<SignedExtensionMetadataV14>"
  },
  MetadataV14: {
    lookup: "PortableRegistry",
    pallets: "Vec<PalletMetadataV14>",
    extrinsic: "ExtrinsicMetadataV14",
    type: "SiLookupTypeId"
  },
  PalletCallMetadataV14: {
    type: "SiLookupTypeId"
  },
  PalletConstantMetadataV14: {
    name: "Text",
    type: "SiLookupTypeId",
    value: "Bytes",
    docs: "Vec<Text>"
  },
  PalletErrorMetadataV14: {
    type: "SiLookupTypeId"
  },
  PalletEventMetadataV14: {
    type: "SiLookupTypeId"
  },
  PalletMetadataV14: {
    name: "Text",
    storage: "Option<PalletStorageMetadataV14>",
    calls: "Option<PalletCallMetadataV14>",
    events: "Option<PalletEventMetadataV14>",
    constants: "Vec<PalletConstantMetadataV14>",
    errors: "Option<PalletErrorMetadataV14>",
    index: "u8"
  },
  PalletStorageMetadataV14: {
    prefix: "Text",
    items: "Vec<StorageEntryMetadataV14>"
  },
  SignedExtensionMetadataV14: {
    identifier: "Text",
    type: "SiLookupTypeId",
    additionalSigned: "SiLookupTypeId"
  },
  StorageEntryMetadataV14: {
    name: "Text",
    modifier: "StorageEntryModifierV14",
    type: "StorageEntryTypeV14",
    fallback: "Bytes",
    docs: "Vec<Text>"
  },
  StorageEntryModifierV14: "StorageEntryModifierV13",
  StorageEntryTypeV14: {
    _enum: {
      Plain: "SiLookupTypeId",
      Map: {
        hashers: "Vec<StorageHasherV14>",
        key: "SiLookupTypeId",
        value: "SiLookupTypeId"
      }
    }
  },
  StorageHasherV14: "StorageHasherV13"
};

// node_modules/@polkadot/types/interfaces/metadata/definitions.js
var definitions_default = {
  rpc: {},
  runtime,
  types: objectSpread({}, v9, v10, v11, v12, v13, v14, {
    ErrorMetadataLatest: "ErrorMetadataV14",
    EventMetadataLatest: "EventMetadataV14",
    ExtrinsicMetadataLatest: "ExtrinsicMetadataV14",
    FunctionArgumentMetadataLatest: "FunctionArgumentMetadataV14",
    FunctionMetadataLatest: "FunctionMetadataV14",
    MetadataLatest: "MetadataV14",
    PalletCallMetadataLatest: "PalletCallMetadataV14",
    PalletConstantMetadataLatest: "PalletConstantMetadataV14",
    PalletErrorMetadataLatest: "PalletErrorMetadataV14",
    PalletEventMetadataLatest: "PalletEventMetadataV14",
    PalletMetadataLatest: "PalletMetadataV14",
    PalletStorageMetadataLatest: "PalletStorageMetadataV14",
    PortableType: "PortableTypeV14",
    SignedExtensionMetadataLatest: "SignedExtensionMetadataV14",
    StorageEntryMetadataLatest: "StorageEntryMetadataV14",
    StorageEntryModifierLatest: "StorageEntryModifierV14",
    StorageEntryTypeLatest: "StorageEntryTypeV14",
    StorageHasher: "StorageHasherV14",
    OpaqueMetadata: "Opaque<Bytes>",
    MetadataAll: {
      _enum: {
        V0: "DoNotConstruct<MetadataV0>",
        V1: "DoNotConstruct<MetadataV1>",
        V2: "DoNotConstruct<MetadataV2>",
        V3: "DoNotConstruct<MetadataV3>",
        V4: "DoNotConstruct<MetadataV4>",
        V5: "DoNotConstruct<MetadataV5>",
        V6: "DoNotConstruct<MetadataV6>",
        V7: "DoNotConstruct<MetadataV7>",
        V8: "DoNotConstruct<MetadataV8>",
        V9: "MetadataV9",
        V10: "MetadataV10",
        V11: "MetadataV11",
        V12: "MetadataV12",
        V13: "MetadataV13",
        V14: "MetadataV14"
      }
    }
  })
};

// node_modules/@polkadot/types/interfaces/runtime/runtime.js
var CORE_V1_TO_V4 = {
  execute_block: {
    description: "Execute the given block.",
    params: [{
      name: "block",
      type: "Block"
    }],
    type: "Null"
  }
};
var CORE_V1_TO_V2 = {
  version: {
    description: "Returns the version of the runtime.",
    params: [],
    type: "RuntimeVersionPre3"
  }
};
var CORE_V2_TO_V4 = {
  initialize_block: {
    description: "Initialize a block with the given header.",
    params: [{
      name: "header",
      type: "Header"
    }],
    type: "Null"
  }
};
var runtime2 = {
  Core: [{
    methods: objectSpread({
      version: {
        description: "Returns the version of the runtime.",
        params: [],
        type: "RuntimeVersion"
      }
    }, CORE_V1_TO_V4, CORE_V2_TO_V4),
    version: 4
  }, {
    methods: objectSpread({
      version: {
        description: "Returns the version of the runtime.",
        params: [],
        type: "RuntimeVersionPre4"
      }
    }, CORE_V1_TO_V4, CORE_V2_TO_V4),
    version: 3
  }, {
    methods: objectSpread({}, CORE_V1_TO_V2, CORE_V1_TO_V4, CORE_V2_TO_V4),
    version: 2
  }, {
    methods: objectSpread({
      initialise_block: {
        description: "Initialize a block with the given header.",
        params: [{
          name: "header",
          type: "Header"
        }],
        type: "Null"
      }
    }, CORE_V1_TO_V2, CORE_V1_TO_V4),
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/runtime/definitions.js
var numberTypes = {
  Fixed64: "Int<64, Fixed64>",
  FixedI64: "Int<64, FixedI64>",
  FixedU64: "UInt<64, FixedU64>",
  Fixed128: "Int<128, Fixed128>",
  FixedI128: "Int<128, FixedI128>",
  FixedU128: "UInt<128, FixedU128>",
  I32F32: "Int<64, I32F32>",
  U32F32: "UInt<64, U32F32>",
  PerU16: "UInt<16, PerU16>",
  Perbill: "UInt<32, Perbill>",
  Percent: "UInt<8, Percent>",
  Permill: "UInt<32, Permill>",
  Perquintill: "UInt<64, Perquintill>"
};
var knownOrigins = {
  Council: "CollectiveOrigin",
  System: "SystemOrigin",
  TechnicalCommittee: "CollectiveOrigin",
  Xcm: "XcmOrigin",
  XcmPallet: "XcmOrigin",
  Authority: "AuthorityOrigin",
  GeneralCouncil: "CollectiveOrigin"
};
var definitions_default2 = {
  rpc: {},
  runtime: runtime2,
  types: objectSpread({}, numberTypes, {
    AccountId: "AccountId32",
    AccountId20: "GenericEthereumAccountId",
    AccountId32: "GenericAccountId32",
    AccountId33: "GenericAccountId33",
    AccountIdOf: "AccountId",
    AccountIndex: "GenericAccountIndex",
    Address: "MultiAddress",
    AssetId: "u32",
    Balance: "UInt<128, Balance>",
    BalanceOf: "Balance",
    Block: "GenericBlock",
    BlockNumber: "u32",
    BlockNumberFor: "BlockNumber",
    BlockNumberOf: "BlockNumber",
    Call: "GenericCall",
    CallHash: "Hash",
    CallHashOf: "CallHash",
    ChangesTrieConfiguration: {
      digestInterval: "u32",
      digestLevels: "u32"
    },
    ChangesTrieSignal: {
      _enum: {
        NewConfiguration: "Option<ChangesTrieConfiguration>"
      }
    },
    ConsensusEngineId: "GenericConsensusEngineId",
    CodecHash: "Hash",
    CrateVersion: {
      major: "u16",
      minor: "u8",
      patch: "u8"
    },
    Digest: {
      logs: "Vec<DigestItem>"
    },
    DigestItem: {
      _enum: {
        Other: "Bytes",
        AuthoritiesChange: "Vec<AuthorityId>",
        ChangesTrieRoot: "Hash",
        SealV0: "SealV0",
        Consensus: "Consensus",
        Seal: "Seal",
        PreRuntime: "PreRuntime",
        ChangesTrieSignal: "ChangesTrieSignal",
        RuntimeEnvironmentUpdated: "Null"
      }
    },
    ExtrinsicsWeight: {
      normal: "Weight",
      operational: "Weight"
    },
    H32: "[u8; 4; H32]",
    H64: "[u8; 8; H64]",
    H128: "[u8; 16; H128]",
    H160: "[u8; 20; H160]",
    H256: "[u8; 32; H256]",
    H512: "[u8; 64; H512]",
    H1024: "[u8; 128; H1024]",
    H2048: "[u8; 256; H2048]",
    Hash: "H256",
    Header: {
      parentHash: "Hash",
      number: "Compact<BlockNumber>",
      stateRoot: "Hash",
      extrinsicsRoot: "Hash",
      digest: "Digest"
    },
    HeaderPartial: {
      parentHash: "Hash",
      number: "BlockNumber"
    },
    IndicesLookupSource: "GenericLookupSource",
    Index: "u32",
    Justification: "(ConsensusEngineId, EncodedJustification)",
    EncodedJustification: "Bytes",
    Justifications: "Vec<Justification>",
    KeyValue: "(StorageKey, StorageData)",
    KeyTypeId: "u32",
    LockIdentifier: "[u8; 8]",
    LookupSource: "MultiAddress",
    LookupTarget: "AccountId",
    ModuleId: "LockIdentifier",
    MultiAddress: "GenericMultiAddress",
    MultiSigner: {
      _enum: {
        Ed25519: "[u8; 32]",
        Sr25519: "[u8; 32]",
        Ecdsa: "[u8; 33]"
      }
    },
    Moment: "UInt<64, Moment>",
    OpaqueCall: "Bytes",
    Origin: "DoNotConstruct<Origin>",
    OriginCaller: {
      _enum: {
        System: "SystemOrigin"
      }
    },
    PalletId: "LockIdentifier",
    PalletsOrigin: "OriginCaller",
    PalletVersion: {
      major: "u16",
      minor: "u8",
      patch: "u8"
    },
    Pays: {
      _enum: ["Yes", "No"]
    },
    Phantom: "Null",
    PhantomData: "Null",
    Releases: {
      _enum: ["V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9", "V10"]
    },
    RuntimeDbWeight: {
      read: "Weight",
      write: "Weight"
    },
    SignedBlock: "SignedBlockWithJustifications",
    SignedBlockWithJustification: {
      block: "Block",
      justification: "Option<EncodedJustification>"
    },
    SignedBlockWithJustifications: {
      block: "Block",
      justifications: "Option<Justifications>"
    },
    Slot: "u64",
    SlotDuration: "u64",
    StorageData: "Bytes",
    StorageInfo: {
      palletName: "Bytes",
      storage_name: "Bytes",
      prefix: "Bytes",
      maxValues: "Option<u32>",
      maxSize: "Option<u32>"
    },
    StorageProof: {
      trieNodes: "Vec<Bytes>"
    },
    TransactionPriority: "u64",
    TransactionLongevity: "u64",
    TransactionTag: "Bytes",
    TransactionInfo: {
      _alias: {
        dataSize: "size"
      },
      chunkRoot: "H256",
      contentHash: "H256",
      dataSize: "u32",
      blockChunks: "u32"
    },
    TransactionStorageProof: {
      chunk: "Vec<u8>",
      proof: "Vec<Vec<u8>>"
    },
    ValidatorId: "AccountId",
    ValidatorIdOf: "ValidatorId",
    WeightV1: "u64",
    WeightV2: {
      refTime: "Compact<u64>",
      proofSize: "Compact<u64>"
    },
    Weight: "WeightV1",
    WeightMultiplier: "Fixed64",
    PreRuntime: "(ConsensusEngineId, Bytes)",
    SealV0: "(u64, Signature)",
    Seal: "(ConsensusEngineId, Bytes)",
    Consensus: "(ConsensusEngineId, Bytes)"
  })
};

// node_modules/@polkadot/types/interfaces/scaleInfo/v0.js
var v0 = {
  Si0Field: {
    name: "Option<Text>",
    type: "Si0LookupTypeId",
    typeName: "Option<Text>",
    docs: "Vec<Text>"
  },
  Si0LookupTypeId: "u32",
  Si0Path: "Vec<Text>",
  Si0Type: {
    path: "Si0Path",
    params: "Vec<Si0LookupTypeId>",
    def: "Si0TypeDef"
  },
  Si0TypeDef: {
    _enum: {
      Composite: "Si0TypeDefComposite",
      Variant: "Si0TypeDefVariant",
      Sequence: "Si0TypeDefSequence",
      Array: "Si0TypeDefArray",
      Tuple: "Si0TypeDefTuple",
      Primitive: "Si0TypeDefPrimitive",
      Compact: "Si0TypeDefCompact",
      Phantom: "Si0TypeDefPhantom",
      BitSequence: "Si0TypeDefBitSequence"
    }
  },
  Si0TypeDefArray: {
    len: "u32",
    type: "Si0LookupTypeId"
  },
  Si0TypeDefBitSequence: {
    bitStoreType: "Si0LookupTypeId",
    bitOrderType: "Si0LookupTypeId"
  },
  Si0TypeDefCompact: {
    type: "Si0LookupTypeId"
  },
  Si0TypeDefComposite: {
    fields: "Vec<Si0Field>"
  },
  Si0TypeDefPhantom: "Null",
  Si0TypeDefVariant: {
    variants: "Vec<Si0Variant>"
  },
  Si0TypeDefPrimitive: {
    _enum: ["Bool", "Char", "Str", "U8", "U16", "U32", "U64", "U128", "U256", "I8", "I16", "I32", "I64", "I128", "I256"]
  },
  Si0TypeDefSequence: {
    type: "Si0LookupTypeId"
  },
  Si0TypeDefTuple: "Vec<Si0LookupTypeId>",
  Si0TypeParameter: {
    name: "Text",
    type: "Option<Si0LookupTypeId>"
  },
  Si0Variant: {
    name: "Text",
    fields: "Vec<Si0Field>",
    index: "Option<u8>",
    discriminant: "Option<u64>",
    docs: "Vec<Text>"
  }
};

// node_modules/@polkadot/types/interfaces/scaleInfo/definitions.js
var definitions_default3 = {
  rpc: {},
  types: objectSpread({}, v0, v1, {
    SiField: "Si1Field",
    SiLookupTypeId: "Si1LookupTypeId",
    SiPath: "Si1Path",
    SiType: "Si1Type",
    SiTypeDef: "Si1TypeDef",
    SiTypeDefArray: "Si1TypeDefArray",
    SiTypeDefBitSequence: "Si1TypeDefBitSequence",
    SiTypeDefCompact: "Si1TypeDefCompact",
    SiTypeDefComposite: "Si1TypeDefComposite",
    SiTypeDefPrimitive: "Si1TypeDefPrimitive",
    SiTypeDefSequence: "Si1TypeDefSequence",
    SiTypeDefTuple: "Si1TypeDefTuple",
    SiTypeParameter: "Si1TypeParameter",
    SiTypeDefVariant: "Si1TypeDefVariant",
    SiVariant: "Si1Variant"
  })
};

// node_modules/@polkadot/types/interfaces/assets/definitions.js
var definitions_default4 = {
  rpc: {},
  types: {
    AssetApprovalKey: {
      owner: "AccountId",
      delegate: "AccountId"
    },
    AssetApproval: {
      amount: "TAssetBalance",
      deposit: "TAssetDepositBalance"
    },
    AssetBalance: {
      balance: "TAssetBalance",
      isFrozen: "bool",
      isSufficient: "bool"
    },
    AssetDestroyWitness: {
      accounts: "Compact<u32>",
      sufficients: "Compact<u32>",
      approvals: "Compact<u32>"
    },
    AssetDetails: {
      owner: "AccountId",
      issuer: "AccountId",
      admin: "AccountId",
      freezer: "AccountId",
      supply: "TAssetBalance",
      deposit: "TAssetDepositBalance",
      minBalance: "TAssetBalance",
      isSufficient: "bool",
      accounts: "u32",
      sufficients: "u32",
      approvals: "u32",
      isFrozen: "bool"
    },
    AssetMetadata: {
      deposit: "TAssetDepositBalance",
      name: "Vec<u8>",
      symbol: "Vec<u8>",
      decimals: "u8",
      isFrozen: "bool"
    },
    TAssetBalance: "u64",
    TAssetDepositBalance: "BalanceOf"
  }
};

// node_modules/@polkadot/types/interfaces/authorship/definitions.js
var definitions_default5 = {
  rpc: {},
  types: {
    UncleEntryItem: {
      _enum: {
        InclusionHeight: "BlockNumber",
        Uncle: "(Hash, Option<AccountId>)"
      }
    }
  }
};

// node_modules/@polkadot/types/interfaces/aura/runtime.js
var runtime3 = {
  AuraApi: [{
    methods: {
      authorities: {
        description: "Return the current set of authorities.",
        params: [],
        type: "Vec<AuthorityId>"
      },
      slot_duration: {
        description: "Returns the slot duration for Aura.",
        params: [],
        type: "SlotDuration"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/aura/definitions.js
var definitions_default6 = {
  rpc: {},
  runtime: runtime3,
  types: {
    RawAuraPreDigest: {
      slotNumber: "u64"
    }
  }
};

// node_modules/@polkadot/types/interfaces/babe/rpc.js
var rpc = {
  epochAuthorship: {
    description: "Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore",
    params: [],
    type: "HashMap<AuthorityId, EpochAuthorship>"
  }
};

// node_modules/@polkadot/types/interfaces/babe/runtime.js
var V1_V2_SHARED = {
  current_epoch: {
    description: "Returns information regarding the current epoch.",
    params: [],
    type: "Epoch"
  },
  current_epoch_start: {
    description: "Returns the slot that started the current epoch.",
    params: [],
    type: "Slot"
  },
  generate_key_ownership_proof: {
    description: "Generates a proof of key ownership for the given authority in the current epoch.",
    params: [{
      name: "slot",
      type: "Slot"
    }, {
      name: "authorityId",
      type: "AuthorityId"
    }],
    type: "Option<OpaqueKeyOwnershipProof>"
  },
  next_epoch: {
    description: "Returns information regarding the next epoch (which was already previously announced).",
    params: [],
    type: "Epoch"
  },
  submit_report_equivocation_unsigned_extrinsic: {
    description: "Submits an unsigned extrinsic to report an equivocation.",
    params: [{
      name: "equivocationProof",
      type: "BabeEquivocationProof"
    }, {
      name: "keyOwnerProof",
      type: "OpaqueKeyOwnershipProof"
    }],
    type: "Option<Null>"
  }
};
var runtime4 = {
  BabeApi: [{
    methods: objectSpread({
      configuration: {
        description: "Return the genesis configuration for BABE. The configuration is only read on genesis.",
        params: [],
        type: "BabeGenesisConfiguration"
      }
    }, V1_V2_SHARED),
    version: 2
  }, {
    methods: objectSpread({
      configuration: {
        description: "Return the configuration for BABE. Version 1.",
        params: [],
        type: "BabeGenesisConfigurationV1"
      }
    }, V1_V2_SHARED),
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/babe/definitions.js
var definitions_default7 = {
  rpc,
  runtime: runtime4,
  types: {
    AllowedSlots: {
      _enum: ["PrimarySlots", "PrimaryAndSecondaryPlainSlots", "PrimaryAndSecondaryVRFSlots"]
    },
    BabeAuthorityWeight: "u64",
    BabeEpochConfiguration: {
      c: "(u64, u64)",
      allowedSlots: "AllowedSlots"
    },
    BabeBlockWeight: "u32",
    BabeEquivocationProof: {
      offender: "AuthorityId",
      slotNumber: "SlotNumber",
      firstHeader: "Header",
      secondHeader: "Header"
    },
    BabeGenesisConfiguration: {
      slotDuration: "u64",
      epochLength: "u64",
      c: "(u64, u64)",
      genesisAuthorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
      randomness: "Randomness",
      allowedSlots: "AllowedSlots"
    },
    BabeGenesisConfigurationV1: {
      slotDuration: "u64",
      epochLength: "u64",
      c: "(u64, u64)",
      genesisAuthorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
      randomness: "Randomness",
      secondarySlots: "bool"
    },
    BabeWeight: "u64",
    MaybeRandomness: "Option<Randomness>",
    MaybeVrf: "Option<VrfData>",
    Epoch: {
      epochIndex: "u64",
      startSlot: "Slot",
      duration: "u64",
      authorities: "Vec<(AuthorityId, BabeAuthorityWeight)>",
      randomness: "Hash",
      config: "BabeEpochConfiguration"
    },
    EpochAuthorship: {
      primary: "Vec<u64>",
      secondary: "Vec<u64>",
      secondary_vrf: "Vec<u64>"
    },
    NextConfigDescriptor: {
      _enum: {
        V0: "Null",
        V1: "NextConfigDescriptorV1"
      }
    },
    NextConfigDescriptorV1: {
      c: "(u64, u64)",
      allowedSlots: "AllowedSlots"
    },
    OpaqueKeyOwnershipProof: "Bytes",
    Randomness: "Hash",
    RawBabePreDigest: {
      _enum: {
        Phantom: "Null",
        Primary: "RawBabePreDigestPrimary",
        SecondaryPlain: "RawBabePreDigestSecondaryPlain",
        SecondaryVRF: "RawBabePreDigestSecondaryVRF"
      }
    },
    RawBabePreDigestPrimary: {
      authorityIndex: "u32",
      slotNumber: "SlotNumber",
      vrfOutput: "VrfOutput",
      vrfProof: "VrfProof"
    },
    RawBabePreDigestSecondaryPlain: {
      authorityIndex: "u32",
      slotNumber: "SlotNumber"
    },
    RawBabePreDigestSecondaryVRF: {
      authorityIndex: "u32",
      slotNumber: "SlotNumber",
      vrfOutput: "VrfOutput",
      vrfProof: "VrfProof"
    },
    RawBabePreDigestTo159: {
      _enum: {
        Primary: "RawBabePreDigestPrimaryTo159",
        Secondary: "RawBabePreDigestSecondaryTo159"
      }
    },
    RawBabePreDigestPrimaryTo159: {
      authorityIndex: "u32",
      slotNumber: "SlotNumber",
      weight: "BabeBlockWeight",
      vrfOutput: "VrfOutput",
      vrfProof: "VrfProof"
    },
    RawBabePreDigestSecondaryTo159: {
      authorityIndex: "u32",
      slotNumber: "SlotNumber",
      weight: "BabeBlockWeight"
    },
    RawBabePreDigestCompat: {
      _enum: {
        Zero: "u32",
        One: "u32",
        Two: "u32",
        Three: "u32"
      }
    },
    SlotNumber: "u64",
    VrfData: "[u8; 32]",
    VrfOutput: "[u8; 32]",
    VrfProof: "[u8; 64]"
  }
};

// node_modules/@polkadot/types/interfaces/balances/definitions.js
var definitions_default8 = {
  rpc: {},
  types: {
    AccountData: {
      free: "Balance",
      reserved: "Balance",
      miscFrozen: "Balance",
      feeFrozen: "Balance"
    },
    BalanceLockTo212: {
      id: "LockIdentifier",
      amount: "Balance",
      until: "BlockNumber",
      reasons: "WithdrawReasons"
    },
    BalanceLock: {
      id: "LockIdentifier",
      amount: "Balance",
      reasons: "Reasons"
    },
    BalanceStatus: {
      _enum: ["Free", "Reserved"]
    },
    Reasons: {
      _enum: ["Fee", "Misc", "All"]
    },
    ReserveData: {
      id: "ReserveIdentifier",
      amount: "Balance"
    },
    ReserveIdentifier: "[u8; 8]",
    VestingSchedule: {
      offset: "Balance",
      perBlock: "Balance",
      startingBlock: "BlockNumber"
    },
    WithdrawReasons: {
      _set: {
        TransactionPayment: 1,
        Transfer: 2,
        Reserve: 4,
        Fee: 8,
        Tip: 16
      }
    }
  }
};

// node_modules/@polkadot/types/interfaces/beefy/rpc.js
var rpc2 = {
  getFinalizedHead: {
    description: "Returns hash of the latest BEEFY finalized block as seen by this client.",
    params: [],
    type: "H256"
  },
  subscribeJustifications: {
    description: "Returns the block most recently finalized by BEEFY, alongside side its justification.",
    params: [],
    pubsub: ["justifications", "subscribeJustifications", "unsubscribeJustifications"],
    type: "BeefySignedCommitment"
  }
};

// node_modules/@polkadot/types/interfaces/beefy/runtime.js
var runtime5 = {
  BeefyApi: [{
    methods: {
      validator_set: {
        description: "Return the current active BEEFY validator set",
        params: [],
        type: "Option<ValidatorSet>"
      }
    },
    version: 1
  }],
  BeefyMmrApi: [{
    methods: {
      authority_set_proof: {
        description: "Return the currently active BEEFY authority set proof.",
        params: [],
        type: "BeefyAuthoritySet"
      },
      next_authority_set_proof: {
        description: "Return the next/queued BEEFY authority set proof.",
        params: [],
        type: "BeefyNextAuthoritySet"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/beefy/definitions.js
var definitions_default9 = {
  rpc: rpc2,
  runtime: runtime5,
  types: {
    BeefyAuthoritySet: {
      id: "u64",
      len: "u32",
      root: "H256"
    },
    BeefyCommitment: {
      payload: "BeefyPayload",
      blockNumber: "BlockNumber",
      validatorSetId: "ValidatorSetId"
    },
    BeefyId: "[u8; 33]",
    BeefySignedCommitment: {
      commitment: "BeefyCommitment",
      signatures: "Vec<Option<EcdsaSignature>>"
    },
    BeefyNextAuthoritySet: {
      id: "u64",
      len: "u32",
      root: "H256"
    },
    BeefyPayload: "Vec<(BeefyPayloadId, Bytes)>",
    BeefyPayloadId: "[u8;2]",
    MmrRootHash: "H256",
    ValidatorSetId: "u64",
    ValidatorSet: {
      validators: "Vec<AuthorityId>",
      id: "ValidatorSetId"
    }
  }
};

// node_modules/@polkadot/types/interfaces/benchmark/runtime.js
var runtime6 = {
  Benchmark: [{
    methods: {
      benchmark_metadata: {
        description: "Get the benchmark metadata available for this runtime.",
        params: [{
          name: "extra",
          type: "bool"
        }],
        type: "(Vec<BenchmarkList>, Vec<StorageInfo>)"
      },
      dispatch_benchmark: {
        description: "Dispatch the given benchmark.",
        params: [{
          name: "config",
          type: "BenchmarkConfig"
        }],
        type: "Result<Vec<BenchmarkBatch>, Text>"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/benchmark/definitions.js
var definitions_default10 = {
  rpc: {},
  runtime: runtime6,
  types: {
    BenchmarkBatch: {
      pallet: "Text",
      instance: "Text",
      benchmark: "Text",
      results: "Vec<BenchmarkResult>"
    },
    BenchmarkConfig: {
      pallet: "Bytes",
      benchmark: "Bytes",
      selectedComponents: "Vec<(BenchmarkParameter, u32)>",
      verify: "bool",
      internalRepeats: "u32"
    },
    BenchmarkList: {
      pallet: "Bytes",
      instance: "Bytes",
      benchmarks: "Vec<BenchmarkMetadata>"
    },
    BenchmarkMetadata: {
      name: "Bytes",
      components: "Vec<(BenchmarkParameter, u32, u32)>"
    },
    BenchmarkParameter: {
      _enum: ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
    },
    BenchmarkResult: {
      components: "Vec<(BenchmarkParameter, u32)>",
      extrinsicTime: "u128",
      storageRootTime: "u128",
      reads: "u32",
      repeatReads: "u32",
      writes: "u32",
      repeatWrites: "u32",
      proofSize: "u32",
      benchKeys: "Vec<(Vec<u8>, u32, u32, bool)>"
    }
  }
};

// node_modules/@polkadot/types/interfaces/blockbuilder/runtime.js
var BB_V2_TO_V4 = {
  random_seed: {
    description: "Generate a random seed.",
    params: [],
    type: "Hash"
  }
};
var BB_V2_TO_V5 = {
  apply_extrinsic: {
    description: "Apply the given extrinsic.",
    params: [{
      name: "extrinsic",
      type: "Extrinsic"
    }],
    type: "ApplyExtrinsicResultPre6"
  }
};
var BB_V2_TO_V6 = {
  check_inherents: {
    description: "Check that the inherents are valid.",
    params: [{
      name: "block",
      type: "Block"
    }, {
      name: "data",
      type: "InherentData"
    }],
    type: "CheckInherentsResult"
  },
  inherent_extrinsics: {
    description: "Generate inherent extrinsics.",
    params: [{
      name: "inherent",
      type: "InherentData"
    }],
    type: "Vec<Extrinsic>"
  }
};
var BB_V3_TO_V6 = {
  finalize_block: {
    description: "Finish the current block.",
    params: [],
    type: "Header"
  }
};
var runtime7 = {
  BlockBuilder: [{
    methods: objectSpread({
      apply_extrinsic: {
        description: "Apply the given extrinsic.",
        params: [{
          name: "extrinsic",
          type: "Extrinsic"
        }],
        type: "ApplyExtrinsicResult"
      }
    }, BB_V2_TO_V6, BB_V3_TO_V6),
    version: 6
  }, {
    methods: objectSpread({}, BB_V2_TO_V5, BB_V2_TO_V6, BB_V3_TO_V6),
    version: 5
  }, {
    methods: objectSpread({}, BB_V2_TO_V4, BB_V2_TO_V5, BB_V2_TO_V6, BB_V3_TO_V6),
    version: 4
  }, {
    methods: objectSpread({}, BB_V2_TO_V4, BB_V2_TO_V6, BB_V3_TO_V6),
    version: 3
  }, {
    methods: objectSpread({
      finalise_block: {
        description: "Finish the current block.",
        params: [],
        type: "Header"
      }
    }, BB_V2_TO_V4, BB_V2_TO_V6),
    version: 2
  }]
};

// node_modules/@polkadot/types/interfaces/blockbuilder/definitions.js
var definitions_default11 = {
  rpc: {},
  runtime: runtime7,
  types: {
    CheckInherentsResult: {
      okay: "bool",
      fatalError: "bool",
      errors: "InherentData"
    },
    InherentData: {
      data: "BTreeMap<InherentIdentifier, Bytes>"
    },
    InherentIdentifier: "[u8; 8]"
  }
};

// node_modules/@polkadot/types/interfaces/collective/definitions.js
var definitions_default12 = {
  rpc: {},
  types: {
    CollectiveOrigin: {
      _enum: {
        Members: "(MemberCount, MemberCount)",
        Member: "AccountId"
      }
    },
    MemberCount: "u32",
    ProposalIndex: "u32",
    VotesTo230: {
      index: "ProposalIndex",
      threshold: "MemberCount",
      ayes: "Vec<AccountId>",
      nays: "Vec<AccountId>"
    },
    Votes: {
      index: "ProposalIndex",
      threshold: "MemberCount",
      ayes: "Vec<AccountId>",
      nays: "Vec<AccountId>",
      end: "BlockNumber"
    }
  }
};

// node_modules/@polkadot/types/interfaces/consensus/definitions.js
var definitions_default13 = {
  rpc: {},
  types: {
    AuthorityId: "AccountId",
    RawVRFOutput: "[u8; 32]"
  }
};

// node_modules/@polkadot/types/interfaces/contracts/rpc.js
var rpc3 = {
  call: {
    deprecated: "Use the runtime interface `api.call.contractsApi.call` instead",
    description: "Executes a call to a contract",
    params: [{
      name: "callRequest",
      type: "ContractCallRequest"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "ContractExecResult"
  },
  getStorage: {
    deprecated: "Use the runtime interface `api.call.contractsApi.getStorage` instead",
    description: "Returns the value under a specified storage key in a contract",
    params: [{
      name: "address",
      type: "AccountId"
    }, {
      name: "key",
      type: "H256"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Option<Bytes>"
  },
  instantiate: {
    deprecated: "Use the runtime interface `api.call.contractsApi.instantiate` instead",
    description: "Instantiate a new contract",
    params: [{
      name: "request",
      type: "InstantiateRequestV1"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "ContractInstantiateResult"
  },
  rentProjection: {
    deprecated: "Not available in newer versions of the contracts interfaces",
    description: "Returns the projected time a given contract will be able to sustain paying its rent",
    params: [{
      name: "address",
      type: "AccountId"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Option<BlockNumber>"
  },
  uploadCode: {
    deprecated: "Use the runtime interface `api.call.contractsApi.uploadCode` instead",
    description: "Upload new code without instantiating a contract from it",
    endpoint: "contracts_upload_code",
    params: [{
      name: "uploadRequest",
      type: "CodeUploadRequest"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "CodeUploadResult"
  }
};

// node_modules/@polkadot/types/interfaces/contracts/runtime.js
var SHARED_V1_V2 = {
  get_storage: {
    description: "Query a given storage key in a given contract.",
    params: [{
      name: "address",
      type: "AccountId"
    }, {
      name: "key",
      type: "Bytes"
    }],
    type: "Option<Bytes>"
  },
  upload_code: {
    description: "Upload new code without instantiating a contract from it.",
    params: [{
      name: "origin",
      type: "AccountId"
    }, {
      name: "code",
      type: "Bytes"
    }, {
      name: "storageDepositLimit",
      type: "Option<Balance>"
    }],
    type: "CodeUploadResult"
  }
};
var runtime8 = {
  ContractsApi: [{
    methods: objectSpread({
      call: {
        description: "Perform a call from a specified account to a given contract.",
        params: [{
          name: "origin",
          type: "AccountId"
        }, {
          name: "dest",
          type: "AccountId"
        }, {
          name: "value",
          type: "Balance"
        }, {
          name: "gasLimit",
          type: "Option<WeightV2>"
        }, {
          name: "storageDepositLimit",
          type: "Option<Balance>"
        }, {
          name: "inputData",
          type: "Vec<u8>"
        }],
        type: "ContractExecResult"
      },
      instantiate: {
        description: "Instantiate a new contract.",
        params: [{
          name: "origin",
          type: "AccountId"
        }, {
          name: "value",
          type: "Balance"
        }, {
          name: "gasLimit",
          type: "Option<WeightV2>"
        }, {
          name: "storageDepositLimit",
          type: "Option<Balance>"
        }, {
          name: "code",
          type: "CodeSource"
        }, {
          name: "data",
          type: "Bytes"
        }, {
          name: "salt",
          type: "Bytes"
        }],
        type: "ContractInstantiateResult"
      }
    }, SHARED_V1_V2),
    version: 2
  }, {
    methods: objectSpread({
      call: {
        description: "Perform a call from a specified account to a given contract.",
        params: [{
          name: "origin",
          type: "AccountId"
        }, {
          name: "dest",
          type: "AccountId"
        }, {
          name: "value",
          type: "Balance"
        }, {
          name: "gasLimit",
          type: "u64"
        }, {
          name: "storageDepositLimit",
          type: "Option<Balance>"
        }, {
          name: "inputData",
          type: "Vec<u8>"
        }],
        type: "ContractExecResultU64"
      },
      instantiate: {
        description: "Instantiate a new contract.",
        params: [{
          name: "origin",
          type: "AccountId"
        }, {
          name: "value",
          type: "Balance"
        }, {
          name: "gasLimit",
          type: "u64"
        }, {
          name: "storageDepositLimit",
          type: "Option<Balance>"
        }, {
          name: "code",
          type: "CodeSource"
        }, {
          name: "data",
          type: "Bytes"
        }, {
          name: "salt",
          type: "Bytes"
        }],
        type: "ContractInstantiateResultU64"
      }
    }, SHARED_V1_V2),
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/contracts/definitions.js
var definitions_default14 = {
  rpc: rpc3,
  runtime: runtime8,
  types: {
    AliveContractInfo: {
      trieId: "TrieId",
      storageSize: "u32",
      pairCount: "u32",
      codeHash: "CodeHash",
      rentAllowance: "Balance",
      rentPaid: "Balance",
      deductBlock: "BlockNumber",
      lastWrite: "Option<BlockNumber>",
      _reserved: "Option<Null>"
    },
    CodeHash: "Hash",
    CodeSource: {
      _enum: {
        Upload: "Bytes",
        Existing: "Hash"
      }
    },
    CodeUploadRequest: {
      origin: "AccountId",
      code: "Bytes",
      storageDepositLimit: "Option<Balance>"
    },
    CodeUploadResult: "Result<CodeUploadResultValue, DispatchError>",
    CodeUploadResultValue: {
      codeHash: "CodeHash",
      deposit: "Balance"
    },
    ContractCallRequest: {
      origin: "AccountId",
      dest: "AccountId",
      value: "Balance",
      gasLimit: "u64",
      storageDepositLimit: "Option<Balance>",
      inputData: "Bytes"
    },
    ContractExecResultSuccessTo255: {
      status: "u8",
      data: "Raw"
    },
    ContractExecResultTo255: {
      _enum: {
        Success: "ContractExecResultSuccessTo255",
        Error: "Null"
      }
    },
    ContractExecResultSuccessTo260: {
      flags: "ContractReturnFlags",
      data: "Bytes",
      gasConsumed: "u64"
    },
    ContractExecResultTo260: {
      _enum: {
        Success: "ContractExecResultSuccessTo260",
        Error: "Null"
      }
    },
    ContractExecResultOk: {
      flags: "ContractReturnFlags",
      data: "Bytes"
    },
    ContractExecResultResult: "Result<ContractExecResultOk, DispatchError>",
    ContractExecResultTo267: {
      gasConsumed: "u64",
      debugMessage: "Text",
      result: "ContractExecResultResult"
    },
    ContractExecResult: {
      gasConsumed: "Weight",
      gasRequired: "Weight",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "ContractExecResultResult"
    },
    ContractExecResultU64: {
      gasConsumed: "u64",
      gasRequired: "u64",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "ContractExecResultResult"
    },
    ContractInfo: {
      _enum: {
        Alive: "AliveContractInfo",
        Tombstone: "TombstoneContractInfo"
      }
    },
    ContractCallFlags: {
      _set: {
        _bitLength: 32,
        ForwardInput: 1,
        CloneInput: 2,
        TailCall: 4,
        AllowReentry: 8
      }
    },
    ContractReturnFlags: {
      _set: {
        _bitLength: 32,
        Revert: 1
      }
    },
    ContractStorageKey: "[u8; 32]",
    DeletedContract: {
      pairCount: "u32",
      trieId: "TrieId"
    },
    ExecReturnValue: {
      flags: "ContractReturnFlags",
      data: "Bytes"
    },
    Gas: "u64",
    HostFnWeightsTo264: {
      caller: "Weight",
      address: "Weight",
      gasLeft: "Weight",
      balance: "Weight",
      valueTransferred: "Weight",
      minimumBalance: "Weight",
      tombstoneDeposit: "Weight",
      rentAllowance: "Weight",
      blockNumber: "Weight",
      now: "Weight",
      weightToFee: "Weight",
      gas: "Weight",
      input: "Weight",
      inputPerByte: "Weight",
      return: "Weight",
      returnPerByte: "Weight",
      terminate: "Weight",
      restoreTo: "Weight",
      restoreToPerDelta: "Weight",
      random: "Weight",
      depositEvent: "Weight",
      depositEventPerTopic: "Weight",
      depositEventPerByte: "Weight",
      setRentAllowance: "Weight",
      setStorage: "Weight",
      setStoragePerByte: "Weight",
      clearStorage: "Weight",
      getStorage: "Weight",
      getStoragePerByte: "Weight",
      transfer: "Weight",
      call: "Weight",
      callTransferSurcharge: "Weight",
      callPerInputByte: "Weight",
      callPerOutputByte: "Weight",
      instantiate: "Weight",
      instantiatePerInputByte: "Weight",
      instantiatePerOutputByte: "Weight",
      hashSha2256: "Weight",
      hashSha2256PerByte: "Weight",
      hashKeccak256: "Weight",
      hashKeccak256PerByte: "Weight",
      hashBlake2256: "Weight",
      hashBlake2256PerByte: "Weight",
      hashBlake2128: "Weight",
      hashBlake2128PerByte: "Weight"
    },
    HostFnWeights: {
      caller: "Weight",
      address: "Weight",
      gasLeft: "Weight",
      balance: "Weight",
      valueTransferred: "Weight",
      minimumBalance: "Weight",
      tombstoneDeposit: "Weight",
      rentAllowance: "Weight",
      blockNumber: "Weight",
      now: "Weight",
      weightToFee: "Weight",
      gas: "Weight",
      input: "Weight",
      inputPerByte: "Weight",
      return: "Weight",
      returnPerByte: "Weight",
      terminate: "Weight",
      terminatePerCodeByte: "Weight",
      restoreTo: "Weight",
      restoreToPerCallerCodeByte: "Weight",
      restoreToPerTombstoneCodeByte: "Weight",
      restoreToPerDelta: "Weight",
      random: "Weight",
      depositEvent: "Weight",
      depositEventPerTopic: "Weight",
      depositEventPerByte: "Weight",
      setRentAllowance: "Weight",
      setStorage: "Weight",
      setStoragePerByte: "Weight",
      clearStorage: "Weight",
      getStorage: "Weight",
      getStoragePerByte: "Weight",
      transfer: "Weight",
      call: "Weight",
      callPerCodeByte: "Weight",
      callTransferSurcharge: "Weight",
      callPerInputByte: "Weight",
      callPerOutputByte: "Weight",
      instantiate: "Weight",
      instantiatePerCodeByte: "Weight",
      instantiatePerInputByte: "Weight",
      instantiatePerOutputByte: "Weight",
      instantiatePerSaltByte: "Weight",
      hashSha2256: "Weight",
      hashSha2256PerByte: "Weight",
      hashKeccak256: "Weight",
      hashKeccak256PerByte: "Weight",
      hashBlake2256: "Weight",
      hashBlake2256PerByte: "Weight",
      hashBlake2128: "Weight",
      hashBlake2128PerByte: "Weight",
      rentParams: "Weight"
    },
    InstantiateRequestV1: {
      origin: "AccountId",
      value: "Balance",
      gasLimit: "Gas",
      code: "Bytes",
      data: "Bytes",
      salt: "Bytes"
    },
    InstantiateRequestV2: {
      _fallback: "InstantiateRequestV1",
      origin: "AccountId",
      value: "Balance",
      gasLimit: "Gas",
      storageDepositLimit: "Option<Balance>",
      code: "Bytes",
      data: "Bytes",
      salt: "Bytes"
    },
    InstantiateRequest: {
      _fallback: "InstantiateRequestV2",
      origin: "AccountId",
      value: "Balance",
      gasLimit: "Gas",
      storageDepositLimit: "Option<Balance>",
      code: "CodeSource",
      data: "Bytes",
      salt: "Bytes"
    },
    ContractInstantiateResultTo267: "Result<InstantiateReturnValueTo267, Null>",
    ContractInstantiateResultTo299: "Result<InstantiateReturnValueOk, Null>",
    ContractInstantiateResult: {
      gasConsumed: "WeightV2",
      gasRequired: "WeightV2",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "InstantiateReturnValue"
    },
    ContractInstantiateResultU64: {
      _fallback: "ContractInstantiateResultTo299",
      gasConsumed: "u64",
      gasRequired: "u64",
      storageDeposit: "StorageDeposit",
      debugMessage: "Text",
      result: "InstantiateReturnValue"
    },
    InstantiateReturnValueTo267: {
      result: "ExecReturnValue",
      accountId: "AccountId",
      rentProjection: "Option<RentProjection>"
    },
    InstantiateReturnValueOk: {
      result: "ExecReturnValue",
      accountId: "AccountId"
    },
    InstantiateReturnValue: "Result<InstantiateReturnValueOk, DispatchError>",
    InstructionWeights: {
      i64const: "u32",
      i64load: "u32",
      i64store: "u32",
      select: "u32",
      rIf: "u32",
      br: "u32",
      brIf: "u32",
      brIable: "u32",
      brIablePerEntry: "u32",
      call: "u32",
      callIndirect: "u32",
      callIndirectPerParam: "u32",
      localGet: "u32",
      localSet: "u32",
      local_tee: "u32",
      globalGet: "u32",
      globalSet: "u32",
      memoryCurrent: "u32",
      memoryGrow: "u32",
      i64clz: "u32",
      i64ctz: "u32",
      i64popcnt: "u32",
      i64eqz: "u32",
      i64extendsi32: "u32",
      i64extendui32: "u32",
      i32wrapi64: "u32",
      i64eq: "u32",
      i64ne: "u32",
      i64lts: "u32",
      i64ltu: "u32",
      i64gts: "u32",
      i64gtu: "u32",
      i64les: "u32",
      i64leu: "u32",
      i64ges: "u32",
      i64geu: "u32",
      i64add: "u32",
      i64sub: "u32",
      i64mul: "u32",
      i64divs: "u32",
      i64divu: "u32",
      i64rems: "u32",
      i64remu: "u32",
      i64and: "u32",
      i64or: "u32",
      i64xor: "u32",
      i64shl: "u32",
      i64shrs: "u32",
      i64shru: "u32",
      i64rotl: "u32",
      i64rotr: "u32"
    },
    LimitsTo264: {
      eventTopics: "u32",
      stackHeight: "u32",
      globals: "u32",
      parameters: "u32",
      memoryPages: "u32",
      tableSize: "u32",
      brTableSize: "u32",
      subjectLen: "u32",
      codeSize: "u32"
    },
    Limits: {
      eventTopics: "u32",
      stackHeight: "u32",
      globals: "u32",
      parameters: "u32",
      memoryPages: "u32",
      tableSize: "u32",
      brTableSize: "u32",
      subjectLen: "u32"
    },
    PrefabWasmModule: {
      scheduleVersion: "Compact<u32>",
      initial: "Compact<u32>",
      maximum: "Compact<u32>",
      refcount: "Compact<u64>",
      _reserved: "Option<Null>",
      code: "Bytes",
      originalCodeLen: "u32"
    },
    RentProjection: {
      _enum: {
        EvictionAt: "BlockNumber",
        NoEviction: "Null"
      }
    },
    ScheduleTo212: {
      version: "u32",
      putCodePerByteCost: "Gas",
      growMemCost: "Gas",
      regularOpCost: "Gas",
      returnDataPerByteCost: "Gas",
      eventDataPerByteCost: "Gas",
      eventPerTopicCost: "Gas",
      eventBaseCost: "Gas",
      sandboxDataReadCost: "Gas",
      sandboxDataWriteCost: "Gas",
      maxEventTopics: "u32",
      maxStackHeight: "u32",
      maxMemoryPages: "u32",
      enablePrintln: "bool",
      maxSubjectLen: "u32"
    },
    ScheduleTo258: {
      version: "u32",
      putCodePerByteCost: "Gas",
      growMemCost: "Gas",
      regularOpCost: "Gas",
      returnDataPerByteCost: "Gas",
      eventDataPerByteCost: "Gas",
      eventPerTopicCost: "Gas",
      eventBaseCost: "Gas",
      sandboxDataReadCost: "Gas",
      sandboxDataWriteCost: "Gas",
      transferCost: "Gas",
      maxEventTopics: "u32",
      maxStackHeight: "u32",
      maxMemoryPages: "u32",
      enablePrintln: "bool",
      maxSubjectLen: "u32"
    },
    ScheduleTo264: {
      version: "u32",
      enablePrintln: "bool",
      limits: "LimitsTo264",
      instructionWeights: "InstructionWeights",
      hostFnWeights: "HostFnWeightsTo264"
    },
    Schedule: {
      version: "u32",
      enablePrintln: "bool",
      limits: "Limits",
      instructionWeights: "InstructionWeights",
      hostFnWeights: "HostFnWeights"
    },
    SeedOf: "Hash",
    StorageDeposit: {
      _enum: {
        Refund: "Balance",
        Charge: "Balance"
      }
    },
    TombstoneContractInfo: "Hash",
    TrieId: "Bytes"
  }
};

// node_modules/@polkadot/types/interfaces/democracy/definitions.js
var AllConvictions = [
  "None",
  "Locked1x",
  "Locked2x",
  "Locked3x",
  "Locked4x",
  "Locked5x",
  "Locked6x"
];
var definitions_default15 = {
  rpc: {},
  types: {
    AccountVote: {
      _enum: {
        Standard: "AccountVoteStandard",
        Split: "AccountVoteSplit"
      }
    },
    AccountVoteSplit: {
      aye: "Balance",
      nay: "Balance"
    },
    AccountVoteStandard: {
      vote: "Vote",
      balance: "Balance"
    },
    Conviction: {
      _enum: AllConvictions
    },
    Delegations: {
      votes: "Balance",
      capital: "Balance"
    },
    PreimageStatus: {
      _enum: {
        Missing: "BlockNumber",
        Available: "PreimageStatusAvailable"
      }
    },
    PreimageStatusAvailable: {
      data: "Bytes",
      provider: "AccountId",
      deposit: "Balance",
      since: "BlockNumber",
      expiry: "Option<BlockNumber>"
    },
    PriorLock: "(BlockNumber, Balance)",
    PropIndex: "u32",
    Proposal: "Call",
    ProxyState: {
      _enum: {
        Open: "AccountId",
        Active: "AccountId"
      }
    },
    ReferendumIndex: "u32",
    ReferendumInfoTo239: {
      end: "BlockNumber",
      proposalHash: "Hash",
      threshold: "VoteThreshold",
      delay: "BlockNumber"
    },
    ReferendumInfo: {
      _enum: {
        Ongoing: "ReferendumStatus",
        Finished: "ReferendumInfoFinished"
      }
    },
    ReferendumInfoFinished: {
      approved: "bool",
      end: "BlockNumber"
    },
    ReferendumStatus: {
      end: "BlockNumber",
      proposalHash: "Hash",
      threshold: "VoteThreshold",
      delay: "BlockNumber",
      tally: "Tally"
    },
    Tally: {
      ayes: "Balance",
      nays: "Balance",
      turnout: "Balance"
    },
    Voting: {
      _enum: {
        Direct: "VotingDirect",
        Delegating: "VotingDelegating"
      }
    },
    VotingDirect: {
      votes: "Vec<VotingDirectVote>",
      delegations: "Delegations",
      prior: "PriorLock"
    },
    VotingDirectVote: "(ReferendumIndex, AccountVote)",
    VotingDelegating: {
      balance: "Balance",
      target: "AccountId",
      conviction: "Conviction",
      delegations: "Delegations",
      prior: "PriorLock"
    }
  }
};

// node_modules/@polkadot/types/interfaces/dev/rpc.js
var rpc4 = {
  getBlockStats: {
    description: "Reexecute the specified `block_hash` and gather statistics while doing so",
    params: [{
      isHistoric: true,
      name: "at",
      type: "Hash"
    }],
    type: "Option<BlockStats>"
  }
};

// node_modules/@polkadot/types/interfaces/dev/definitions.js
var definitions_default16 = {
  rpc: rpc4,
  types: {
    BlockStats: {
      witnessLen: "u64",
      witnessCompactLen: "u64",
      blockLen: "u64",
      blockNumExtrinsics: "u64"
    }
  }
};

// node_modules/@polkadot/types/interfaces/discovery/runtime.js
var runtime9 = {
  AuthorityDiscoveryApi: [{
    methods: {
      authorities: {
        description: "Retrieve authority identifiers of the current and next authority set.",
        params: [],
        type: "Vec<AuthorityId>"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/discovery/definitions.js
var definitions_default17 = {
  rpc: {},
  runtime: runtime9,
  types: {}
};

// node_modules/@polkadot/types/interfaces/elections/definitions.js
var definitions_default18 = {
  rpc: {},
  types: {
    ApprovalFlag: "u32",
    DefunctVoter: {
      who: "AccountId",
      voteCount: "Compact<u32>",
      candidateCount: "Compact<u32>"
    },
    Renouncing: {
      _enum: {
        Member: "Null",
        RunnerUp: "Null",
        Candidate: "Compact<u32>"
      }
    },
    SetIndex: "u32",
    Vote: "GenericVote",
    VoteIndex: "u32",
    VoterInfo: {
      lastActive: "VoteIndex",
      lastWin: "VoteIndex",
      pot: "Balance",
      stake: "Balance"
    },
    VoteThreshold: {
      _enum: ["Super Majority Approve", "Super Majority Against", "Simple Majority"]
    }
  }
};

// node_modules/@polkadot/types/interfaces/engine/rpc.js
var rpc5 = {
  createBlock: {
    description: "Instructs the manual-seal authorship task to create a new block",
    params: [{
      name: "createEmpty",
      type: "bool"
    }, {
      name: "finalize",
      type: "bool"
    }, {
      isOptional: true,
      name: "parentHash",
      type: "BlockHash"
    }],
    type: "CreatedBlock"
  },
  finalizeBlock: {
    description: "Instructs the manual-seal authorship task to finalize a block",
    params: [{
      name: "hash",
      type: "BlockHash"
    }, {
      isOptional: true,
      name: "justification",
      type: "Justification"
    }],
    type: "bool"
  }
};

// node_modules/@polkadot/types/interfaces/engine/definitions.js
var definitions_default19 = {
  rpc: rpc5,
  types: {
    CreatedBlock: {
      _alias: {
        blockHash: "hash"
      },
      blockHash: "BlockHash",
      aux: "ImportedAux"
    },
    ImportedAux: {
      headerOnly: "bool",
      clearJustificationRequests: "bool",
      needsJustification: "bool",
      badJustification: "bool",
      needsFinalityProof: "bool",
      isNewBest: "bool"
    }
  }
};

// node_modules/@polkadot/types/interfaces/evm/definitions.js
var definitions_default20 = {
  rpc: {},
  types: {
    EvmAccount: {
      nonce: "u256",
      balance: "u256"
    },
    EvmCallInfo: {
      exitReason: "ExitReason",
      value: "Bytes",
      usedGas: "U256",
      logs: "Vec<EvmLog>"
    },
    EvmCreateInfo: {
      exitReason: "ExitReason",
      value: "H160",
      usedGas: "U256",
      logs: "Vec<EvmLog>"
    },
    EvmLog: {
      address: "H160",
      topics: "Vec<H256>",
      data: "Bytes"
    },
    EvmVicinity: {
      gasPrice: "u256",
      origin: "H160"
    },
    ExitError: {
      _enum: {
        StackUnderflow: "Null",
        StackOverflow: "Null",
        InvalidJump: "Null",
        InvalidRange: "Null",
        DesignatedInvalid: "Null",
        CallTooDeep: "Null",
        CreateCollision: "Null",
        CreateContractLimit: "Null",
        OutOfOffset: "Null",
        OutOfGas: "Null",
        OutOfFund: "Null",
        PCUnderflow: "Null",
        CreateEmpty: "Null",
        Other: "Text"
      }
    },
    ExitFatal: {
      _enum: {
        NotSupported: "Null",
        UnhandledInterrupt: "Null",
        CallErrorAsFatal: "ExitError",
        Other: "Text"
      }
    },
    ExitReason: {
      _enum: {
        Succeed: "ExitSucceed",
        Error: "ExitError",
        Revert: "ExitRevert",
        Fatal: "ExitFatal"
      }
    },
    ExitRevert: {
      _enum: ["Reverted"]
    },
    ExitSucceed: {
      _enum: ["Stopped", "Returned", "Suicided"]
    }
  }
};

// node_modules/@polkadot/types/interfaces/extrinsics/definitions.js
var definitions_default21 = {
  rpc: {},
  types: {
    Extrinsic: "GenericExtrinsic",
    ExtrinsicEra: "GenericExtrinsicEra",
    ExtrinsicPayload: "GenericExtrinsicPayload",
    ExtrinsicSignature: "MultiSignature",
    ExtrinsicV4: "GenericExtrinsicV4",
    ExtrinsicPayloadV4: "GenericExtrinsicPayloadV4",
    ExtrinsicSignatureV4: "GenericExtrinsicSignatureV4",
    ExtrinsicUnknown: "GenericExtrinsicUnknown",
    ExtrinsicPayloadUnknown: "GenericExtrinsicPayloadUnknown",
    Era: "ExtrinsicEra",
    ImmortalEra: "GenericImmortalEra",
    MortalEra: "GenericMortalEra",
    AnySignature: "H512",
    MultiSignature: {
      _enum: {
        Ed25519: "Ed25519Signature",
        Sr25519: "Sr25519Signature",
        Ecdsa: "EcdsaSignature"
      }
    },
    Signature: "H512",
    SignerPayload: "GenericSignerPayload",
    EcdsaSignature: "[u8; 65]",
    Ed25519Signature: "H512",
    Sr25519Signature: "H512"
  }
};

// node_modules/@polkadot/types/interfaces/genericAsset/definitions.js
var definitions_default22 = {
  rpc: {},
  types: {
    AssetOptions: {
      initalIssuance: "Compact<Balance>",
      permissions: "PermissionLatest"
    },
    Owner: {
      _enum: {
        None: "Null",
        Address: "AccountId"
      }
    },
    PermissionsV1: {
      update: "Owner",
      mint: "Owner",
      burn: "Owner"
    },
    PermissionVersions: {
      _enum: {
        V1: "PermissionsV1"
      }
    },
    PermissionLatest: "PermissionsV1"
  }
};

// node_modules/@polkadot/types/interfaces/gilt/definitions.js
var definitions_default23 = {
  rpc: {},
  types: {
    ActiveGilt: {
      proportion: "Perquintill",
      amount: "Balance",
      who: "AccountId",
      expiry: "BlockNumber"
    },
    ActiveGiltsTotal: {
      frozen: "Balance",
      proportion: "Perquintill",
      index: "ActiveIndex",
      target: "Perquintill"
    },
    ActiveIndex: "u32",
    GiltBid: {
      amount: "Balance",
      who: "AccountId"
    }
  }
};

// node_modules/@polkadot/types/interfaces/grandpa/rpc.js
var rpc6 = {
  proveFinality: {
    description: "Prove finality for the given block number, returning the Justification for the last block in the set.",
    params: [{
      name: "blockNumber",
      type: "BlockNumber"
    }],
    type: "Option<EncodedFinalityProofs>"
  },
  roundState: {
    description: "Returns the state of the current best round state as well as the ongoing background rounds",
    params: [],
    type: "ReportedRoundStates"
  },
  subscribeJustifications: {
    description: "Subscribes to grandpa justifications",
    params: [],
    pubsub: ["justifications", "subscribeJustifications", "unsubscribeJustifications"],
    type: "JustificationNotification"
  }
};

// node_modules/@polkadot/types/interfaces/grandpa/runtime.js
var GRANDPA_V2_V3 = {
  generate_key_ownership_proof: {
    description: "Generates a proof of key ownership for the given authority in the given set.",
    params: [{
      name: "setId",
      type: "SetId"
    }, {
      name: "authorityId",
      type: "AuthorityId"
    }],
    type: "Option<OpaqueKeyOwnershipProof>"
  },
  grandpa_authorities: {
    description: "Get the current GRANDPA authorities and weights. This should not change except for when changes are scheduled and the corresponding delay has passed.",
    params: [],
    type: "AuthorityList"
  },
  submit_report_equivocation_unsigned_extrinsic: {
    description: "Submits an unsigned extrinsic to report an equivocation.",
    params: [{
      name: "equivocationProof",
      type: "GrandpaEquivocationProof"
    }, {
      name: "keyOwnerProof",
      type: "OpaqueKeyOwnershipProof"
    }],
    type: "Option<Null>"
  }
};
var runtime10 = {
  GrandpaApi: [{
    methods: objectSpread({
      current_set_id: {
        description: "Get current GRANDPA authority set id.",
        params: [],
        type: "SetId"
      }
    }, GRANDPA_V2_V3),
    version: 3
  }, {
    methods: GRANDPA_V2_V3,
    version: 2
  }]
};

// node_modules/@polkadot/types/interfaces/grandpa/definitions.js
var definitions_default24 = {
  rpc: rpc6,
  runtime: runtime10,
  types: {
    AuthorityIndex: "u64",
    AuthorityList: "Vec<NextAuthority>",
    AuthoritySet: {
      currentAuthorities: "AuthorityList",
      setId: "u64",
      pendingStandardChanges: "ForkTreePendingChange",
      pendingForcedChanges: "Vec<PendingChange>",
      authoritySetChanges: "AuthoritySetChanges"
    },
    ForkTreePendingChange: {
      roots: "Vec<ForkTreePendingChangeNode>",
      bestFinalizedNumber: "Option<BlockNumber>"
    },
    ForkTreePendingChangeNode: {
      hash: "BlockHash",
      number: "BlockNumber",
      data: "PendingChange",
      children: "Vec<ForkTreePendingChangeNode>"
    },
    AuthoritySetChange: "(U64, BlockNumber)",
    AuthoritySetChanges: "Vec<AuthoritySetChange>",
    AuthorityWeight: "u64",
    DelayKind: {
      _enum: {
        Finalized: "Null",
        Best: "DelayKindBest"
      }
    },
    DelayKindBest: {
      medianLastFinalized: "BlockNumber"
    },
    EncodedFinalityProofs: "Bytes",
    GrandpaEquivocation: {
      _enum: {
        Prevote: "GrandpaEquivocationValue",
        Precommit: "GrandpaEquivocationValue"
      }
    },
    GrandpaEquivocationProof: {
      setId: "SetId",
      equivocation: "GrandpaEquivocation"
    },
    GrandpaEquivocationValue: {
      roundNumber: "u64",
      identity: "AuthorityId",
      first: "(GrandpaPrevote, AuthoritySignature)",
      second: "(GrandpaPrevote, AuthoritySignature)"
    },
    GrandpaPrevote: {
      targetHash: "Hash",
      targetNumber: "BlockNumber"
    },
    GrandpaCommit: {
      targetHash: "BlockHash",
      targetNumber: "BlockNumber",
      precommits: "Vec<GrandpaSignedPrecommit>"
    },
    GrandpaPrecommit: {
      targetHash: "BlockHash",
      targetNumber: "BlockNumber"
    },
    GrandpaSignedPrecommit: {
      precommit: "GrandpaPrecommit",
      signature: "AuthoritySignature",
      id: "AuthorityId"
    },
    GrandpaJustification: {
      round: "u64",
      commit: "GrandpaCommit",
      votesAncestries: "Vec<Header>"
    },
    JustificationNotification: "Bytes",
    KeyOwnerProof: "MembershipProof",
    NextAuthority: "(AuthorityId, AuthorityWeight)",
    PendingChange: {
      nextAuthorities: "AuthorityList",
      delay: "BlockNumber",
      canonHeight: "BlockNumber",
      canonHash: "BlockHash",
      delayKind: "DelayKind"
    },
    PendingPause: {
      scheduledAt: "BlockNumber",
      delay: "BlockNumber"
    },
    PendingResume: {
      scheduledAt: "BlockNumber",
      delay: "BlockNumber"
    },
    Precommits: {
      currentWeight: "u32",
      missing: "BTreeSet<AuthorityId>"
    },
    Prevotes: {
      currentWeight: "u32",
      missing: "BTreeSet<AuthorityId>"
    },
    ReportedRoundStates: {
      setId: "u32",
      best: "RoundState",
      background: "Vec<RoundState>"
    },
    RoundState: {
      round: "u32",
      totalWeight: "u32",
      thresholdWeight: "u32",
      prevotes: "Prevotes",
      precommits: "Precommits"
    },
    SetId: "u64",
    StoredPendingChange: {
      scheduledAt: "BlockNumber",
      delay: "BlockNumber",
      nextAuthorities: "AuthorityList"
    },
    StoredState: {
      _enum: {
        Live: "Null",
        PendingPause: "PendingPause",
        Paused: "Null",
        PendingResume: "PendingResume"
      }
    }
  }
};

// node_modules/@polkadot/types/interfaces/identity/definitions.js
var definitions_default25 = {
  rpc: {},
  types: {
    IdentityFields: {
      _set: {
        _bitLength: 64,
        Display: 1,
        Legal: 2,
        Web: 4,
        Riot: 8,
        Email: 16,
        PgpFingerprint: 32,
        Image: 64,
        Twitter: 128
      }
    },
    IdentityInfoAdditional: "(Data, Data)",
    IdentityInfoTo198: {
      additional: "Vec<IdentityInfoAdditional>",
      display: "Data",
      legal: "Data",
      web: "Data",
      riot: "Data",
      email: "Data",
      pgpFingerprint: "Option<H160>",
      image: "Data"
    },
    IdentityInfo: {
      _fallback: "IdentityInfoTo198",
      additional: "Vec<IdentityInfoAdditional>",
      display: "Data",
      legal: "Data",
      web: "Data",
      riot: "Data",
      email: "Data",
      pgpFingerprint: "Option<H160>",
      image: "Data",
      twitter: "Data"
    },
    IdentityJudgement: {
      _enum: {
        Unknown: "Null",
        FeePaid: "Balance",
        Reasonable: "Null",
        KnownGood: "Null",
        OutOfDate: "Null",
        LowQuality: "Null",
        Erroneous: "Null"
      }
    },
    RegistrationJudgement: "(RegistrarIndex, IdentityJudgement)",
    RegistrationTo198: {
      judgements: "Vec<RegistrationJudgement>",
      deposit: "Balance",
      info: "IdentityInfoTo198"
    },
    Registration: {
      _fallback: "RegistrationTo198",
      judgements: "Vec<RegistrationJudgement>",
      deposit: "Balance",
      info: "IdentityInfo"
    },
    RegistrarIndex: "u32",
    RegistrarInfo: {
      account: "AccountId",
      fee: "Balance",
      fields: "IdentityFields"
    }
  }
};

// node_modules/@polkadot/types/interfaces/imOnline/definitions.js
var definitions_default26 = {
  rpc: {},
  types: {
    AuthIndex: "u32",
    AuthoritySignature: "Signature",
    Heartbeat: {
      blockNumber: "BlockNumber",
      networkState: "OpaqueNetworkState",
      sessionIndex: "SessionIndex",
      authorityIndex: "AuthIndex",
      validatorsLen: "u32"
    },
    HeartbeatTo244: {
      blockNumber: "BlockNumber",
      networkState: "OpaqueNetworkState",
      sessionIndex: "SessionIndex",
      authorityIndex: "AuthIndex"
    },
    OpaqueMultiaddr: "Opaque<Bytes>",
    OpaquePeerId: "Opaque<Bytes>",
    OpaqueNetworkState: {
      peerId: "OpaquePeerId",
      externalAddresses: "Vec<OpaqueMultiaddr>"
    }
  }
};

// node_modules/@polkadot/types/interfaces/lottery/definitions.js
var definitions_default27 = {
  rpc: {},
  types: {
    CallIndex: "(u8, u8)",
    LotteryConfig: {
      price: "Balance",
      start: "BlockNumber",
      length: "BlockNumber",
      delay: "BlockNumber",
      repeat: "bool"
    }
  }
};

// node_modules/@polkadot/types/interfaces/mmr/rpc.js
var rpc7 = {
  generateBatchProof: {
    description: "Generate MMR proof for the given leaf indices.",
    params: [{
      name: "leafIndices",
      type: "Vec<u64>"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "MmrLeafProof"
  },
  generateProof: {
    description: "Generate MMR proof for given leaf index.",
    params: [{
      name: "leafIndex",
      type: "u64"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "MmrLeafBatchProof"
  }
};

// node_modules/@polkadot/types/interfaces/mmr/runtime.js
var runtime11 = {
  MmrApi: [{
    methods: {
      generate_batch_proof: {
        description: "Generate MMR proof for a series of leaves under given indices.",
        params: [{
          name: "leafIndices",
          type: "Vec<MmrLeafIndex>"
        }],
        type: "Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>"
      },
      generate_proof: {
        description: "Generate MMR proof for a leaf under given index.",
        params: [{
          name: "leafIndex",
          type: "MmrLeafIndex"
        }],
        type: "Result<(MmrEncodableOpaqueLeaf, MmrProof), MmrError>"
      },
      mmr_root: {
        description: "Return the on-chain MMR root hash.",
        params: [],
        type: "Result<Hash, MmrError>"
      },
      verify_batch_proof: {
        description: "Verify MMR proof against on-chain MMR for a batch of leaves.",
        params: [{
          name: "leaves",
          type: "Vec<MmrEncodableOpaqueLeaf>"
        }, {
          name: "proof",
          type: "MmrBatchProof"
        }],
        type: "Result<(), MmrError>"
      },
      verify_batch_proof_stateless: {
        description: "Verify MMR proof against given root hash or a batch of leaves.",
        params: [{
          name: "root",
          type: "Hash"
        }, {
          name: "leaves",
          type: "Vec<MmrEncodableOpaqueLeaf>"
        }, {
          name: "proof",
          type: "MmrBatchProof"
        }],
        type: "Result<(), MmrError>"
      },
      verify_proof: {
        description: "Verify MMR proof against on-chain MMR.",
        params: [{
          name: "leaf",
          type: "MmrEncodableOpaqueLeaf"
        }, {
          name: "proof",
          type: "MmrProof"
        }],
        type: "Result<(), MmrError>"
      },
      verify_proof_stateless: {
        description: "Verify MMR proof against given root hash.",
        params: [{
          name: "root",
          type: "Hash"
        }, {
          name: "leaf",
          type: "MmrEncodableOpaqueLeaf"
        }, {
          name: "proof",
          type: "MmrProof"
        }],
        type: "Result<(), MmrError>"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/mmr/definitions.js
var definitions_default28 = {
  rpc: rpc7,
  runtime: runtime11,
  types: {
    MmrBatchProof: {
      leafIndices: "Vec<MmrLeafIndex>",
      leafCount: "MmrNodeIndex",
      items: "Vec<Hash>"
    },
    MmrEncodableOpaqueLeaf: "Bytes",
    MmrError: {
      _enum: ["Push", "GetRoot", "Commit", "GenerateProof", "Verify", "LeafNotFound", " PalletNotIncluded", "InvalidLeafIndex"]
    },
    MmrLeafBatchProof: {
      blockHash: "BlockHash",
      leaves: "Bytes",
      proof: "Bytes"
    },
    MmrLeafIndex: "u64",
    MmrLeafProof: {
      blockHash: "BlockHash",
      leaf: "Bytes",
      proof: "Bytes"
    },
    MmrNodeIndex: "u64",
    MmrProof: {
      leafIndex: "MmrLeafIndex",
      leafCount: "MmrNodeIndex",
      items: "Vec<Hash>"
    }
  }
};

// node_modules/@polkadot/types/interfaces/nompools/runtime.js
var runtime12 = {
  NominationPoolsApi: [{
    methods: {
      pending_rewards: {
        description: "Returns the pending rewards for the given member.",
        params: [{
          name: "member",
          type: "AccountId"
        }],
        type: "Balance"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/nompools/definitions.js
var definitions_default29 = {
  rpc: {},
  runtime: runtime12,
  types: {
    NpApiError: {
      _enum: ["MemberNotFound", "OverflowInPendingRewards"]
    }
  }
};

// node_modules/@polkadot/types/interfaces/offences/definitions.js
var definitions_default30 = {
  rpc: {},
  types: {
    DeferredOffenceOf: "(Vec<OffenceDetails>, Vec<Perbill>, SessionIndex)",
    Kind: "[u8; 16]",
    OffenceDetails: {
      offender: "Offender",
      reporters: "Vec<Reporter>"
    },
    Offender: "IdentificationTuple",
    OpaqueTimeSlot: "Bytes",
    ReportIdOf: "Hash",
    Reporter: "AccountId"
  }
};

// node_modules/@polkadot/types/interfaces/pow/runtime.js
var runtime13 = {
  DifficultyApi: [{
    methods: {
      difficulty: {
        description: "Return the target difficulty of the next block.",
        params: [],
        type: "Raw"
      }
    },
    version: 1
  }],
  TimestampApi: [{
    methods: {
      timestamp: {
        description: "API necessary for timestamp-based difficulty adjustment algorithms.",
        params: [],
        type: "Moment"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/pow/definitions.js
var definitions_default31 = {
  rpc: {},
  runtime: runtime13,
  types: {}
};

// node_modules/@polkadot/types/interfaces/proxy/definitions.js
var definitions_default32 = {
  rpc: {},
  types: {
    ProxyDefinition: {
      delegate: "AccountId",
      proxyType: "ProxyType",
      delay: "BlockNumber"
    },
    ProxyType: {
      _enum: ["Any", "NonTransfer", "Governance", "Staking"]
    },
    ProxyAnnouncement: {
      real: "AccountId",
      callHash: "Hash",
      height: "BlockNumber"
    }
  }
};

// node_modules/@polkadot/types/interfaces/recovery/definitions.js
var definitions_default33 = {
  rpc: {},
  types: {
    ActiveRecovery: {
      created: "BlockNumber",
      deposit: "Balance",
      friends: "Vec<AccountId>"
    },
    RecoveryConfig: {
      delayPeriod: "BlockNumber",
      deposit: "Balance",
      friends: "Vec<AccountId>",
      threshold: "u16"
    }
  }
};

// node_modules/@polkadot/types/interfaces/scheduler/definitions.js
var definitions_default34 = {
  rpc: {},
  types: {
    Period: "(BlockNumber, u32)",
    Priority: "u8",
    SchedulePeriod: "Period",
    SchedulePriority: "Priority",
    Scheduled: {
      maybeId: "Option<Bytes>",
      priority: "SchedulePriority",
      call: "Call",
      maybePeriodic: "Option<SchedulePeriod>",
      origin: "PalletsOrigin"
    },
    ScheduledTo254: {
      maybeId: "Option<Bytes>",
      priority: "SchedulePriority",
      call: "Call",
      maybePeriodic: "Option<SchedulePeriod>"
    },
    TaskAddress: "(BlockNumber, u32)"
  }
};

// node_modules/@polkadot/types/interfaces/session/runtime.js
var runtime14 = {
  SessionKeys: [{
    methods: {
      decode_session_keys: {
        description: "Decode the given public session keys.",
        params: [{
          name: "encoded",
          type: "Bytes"
        }],
        type: "Option<Vec<(Bytes, KeyTypeId)>>"
      },
      generate_session_keys: {
        description: "Generate a set of session keys with optionally using the given seed.",
        params: [{
          name: "seed",
          type: "Option<Bytes>"
        }],
        type: "Bytes"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/session/definitions.js
var keyTypes = {
  BeefyKey: "[u8; 33]",
  Keys: "SessionKeys4",
  SessionKeys1: "(AccountId)",
  SessionKeys2: "(AccountId, AccountId)",
  SessionKeys3: "(AccountId, AccountId, AccountId)",
  SessionKeys4: "(AccountId, AccountId, AccountId, AccountId)",
  SessionKeys5: "(AccountId, AccountId, AccountId, AccountId, AccountId)",
  SessionKeys6: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
  SessionKeys6B: "(AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
  SessionKeys7: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
  SessionKeys7B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
  SessionKeys8: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
  SessionKeys8B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
  SessionKeys9: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
  SessionKeys9B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)",
  SessionKeys10: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)",
  SessionKeys10B: "(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)"
};
var definitions_default35 = {
  rpc: {},
  runtime: runtime14,
  types: objectSpread({}, keyTypes, {
    FullIdentification: "Exposure",
    IdentificationTuple: "(ValidatorId, FullIdentification)",
    MembershipProof: {
      session: "SessionIndex",
      trieNodes: "Vec<Bytes>",
      validatorCount: "ValidatorCount"
    },
    SessionIndex: "u32",
    ValidatorCount: "u32"
  })
};

// node_modules/@polkadot/types/interfaces/society/definitions.js
var definitions_default36 = {
  rpc: {},
  types: {
    Bid: {
      who: "AccountId",
      kind: "BidKind",
      value: "Balance"
    },
    BidKind: {
      _enum: {
        Deposit: "Balance",
        Vouch: "(AccountId, Balance)"
      }
    },
    SocietyJudgement: {
      _enum: ["Rebid", "Reject", "Approve"]
    },
    SocietyVote: {
      _enum: ["Skeptic", "Reject", "Approve"]
    },
    StrikeCount: "u32",
    VouchingStatus: {
      _enum: ["Vouching", "Banned"]
    }
  }
};

// node_modules/@polkadot/types/interfaces/staking/definitions.js
var deprecated = {
  Points: "u32",
  EraPoints: {
    total: "Points",
    individual: "Vec<Points>"
  }
};
var phragmen = {
  CompactAssignments: "CompactAssignmentsWith16",
  CompactAssignmentsWith16: {
    votes1: "Vec<(NominatorIndexCompact, ValidatorIndexCompact)>",
    votes2: "Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>",
    votes3: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>",
    votes4: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>",
    votes5: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>",
    votes6: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>",
    votes7: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>",
    votes8: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>",
    votes9: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>",
    votes10: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>",
    votes11: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>",
    votes12: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>",
    votes13: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>",
    votes14: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>",
    votes15: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>",
    votes16: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>"
  },
  CompactAssignmentsWith24: {
    votes1: "Vec<(NominatorIndexCompact, ValidatorIndexCompact)>",
    votes2: "Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>",
    votes3: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>",
    votes4: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>",
    votes5: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>",
    votes6: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>",
    votes7: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>",
    votes8: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>",
    votes9: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>",
    votes10: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>",
    votes11: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>",
    votes12: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>",
    votes13: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>",
    votes14: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>",
    votes15: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>",
    votes16: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>",
    votes17: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 16], ValidatorIndexCompact)>",
    votes18: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 17], ValidatorIndexCompact)>",
    votes19: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 18], ValidatorIndexCompact)>",
    votes20: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 19], ValidatorIndexCompact)>",
    votes21: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 20], ValidatorIndexCompact)>",
    votes22: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 21], ValidatorIndexCompact)>",
    votes23: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 22], ValidatorIndexCompact)>",
    votes24: "Vec<(NominatorIndexCompact, [CompactScoreCompact; 23], ValidatorIndexCompact)>"
  },
  CompactAssignmentsTo265: "CompactAssignmentsWith16",
  CompactAssignmentsTo257: {
    votes1: "Vec<(NominatorIndex, [CompactScore; 0], ValidatorIndex)>",
    votes2: "Vec<(NominatorIndex, [CompactScore; 1], ValidatorIndex)>",
    votes3: "Vec<(NominatorIndex, [CompactScore; 2], ValidatorIndex)>",
    votes4: "Vec<(NominatorIndex, [CompactScore; 3], ValidatorIndex)>",
    votes5: "Vec<(NominatorIndex, [CompactScore; 4], ValidatorIndex)>",
    votes6: "Vec<(NominatorIndex, [CompactScore; 5], ValidatorIndex)>",
    votes7: "Vec<(NominatorIndex, [CompactScore; 6], ValidatorIndex)>",
    votes8: "Vec<(NominatorIndex, [CompactScore; 7], ValidatorIndex)>",
    votes9: "Vec<(NominatorIndex, [CompactScore; 8], ValidatorIndex)>",
    votes10: "Vec<(NominatorIndex, [CompactScore; 9], ValidatorIndex)>",
    votes11: "Vec<(NominatorIndex, [CompactScore; 10], ValidatorIndex)>",
    votes12: "Vec<(NominatorIndex, [CompactScore; 11], ValidatorIndex)>",
    votes13: "Vec<(NominatorIndex, [CompactScore; 12], ValidatorIndex)>",
    votes14: "Vec<(NominatorIndex, [CompactScore; 13], ValidatorIndex)>",
    votes15: "Vec<(NominatorIndex, [CompactScore; 14], ValidatorIndex)>",
    votes16: "Vec<(NominatorIndex, [CompactScore; 15], ValidatorIndex)>"
  },
  CompactScore: "(ValidatorIndex, OffchainAccuracy)",
  CompactScoreCompact: "(ValidatorIndexCompact, OffchainAccuracyCompact)",
  ElectionCompute: {
    _enum: ["OnChain", "Signed", "Unsigned"]
  },
  ElectionPhase: {
    _enum: {
      Off: null,
      Signed: null,
      Unsigned: "(bool, BlockNumber)",
      Emergency: null
    }
  },
  ElectionResult: {
    compute: "ElectionCompute",
    slotStake: "Balance",
    electedStashes: "Vec<AccountId>",
    exposures: "Vec<(AccountId, Exposure)>"
  },
  ElectionScore: "[u128; 3]",
  ElectionSize: {
    validators: "Compact<ValidatorIndex>",
    nominators: "Compact<NominatorIndex>"
  },
  ElectionStatus: {
    _enum: {
      Close: "Null",
      Open: "BlockNumber"
    }
  },
  ExtendedBalance: "u128",
  RawSolution: "RawSolutionWith16",
  RawSolutionWith16: {
    compact: "CompactAssignmentsWith16",
    score: "ElectionScore",
    round: "u32"
  },
  RawSolutionWith24: {
    compact: "CompactAssignmentsWith24",
    score: "ElectionScore",
    round: "u32"
  },
  RawSolutionTo265: "RawSolutionWith16",
  ReadySolution: {
    supports: "SolutionSupports",
    score: "ElectionScore",
    compute: "ElectionCompute"
  },
  RoundSnapshot: {
    voters: "Vec<(AccountId, VoteWeight, Vec<AccountId>)>",
    targets: "Vec<AccountId>"
  },
  SeatHolder: {
    who: "AccountId",
    stake: "Balance",
    deposit: "Balance"
  },
  SignedSubmission: {
    _fallback: "SignedSubmissionTo276",
    who: "AccountId",
    deposit: "Balance",
    solution: "RawSolution",
    reward: "Balance"
  },
  SignedSubmissionTo276: {
    who: "AccountId",
    deposit: "Balance",
    solution: "RawSolution"
  },
  SignedSubmissionOf: "SignedSubmission",
  SolutionOrSnapshotSize: {
    voters: "Compact<u32>",
    targets: "Compact<u32>"
  },
  SolutionSupport: {
    total: "ExtendedBalance",
    voters: "Vec<(AccountId, ExtendedBalance)>"
  },
  SolutionSupports: "Vec<(AccountId, SolutionSupport)>",
  Supports: "SolutionSupports",
  SubmissionIndicesOf: "BTreeMap<ElectionScore, u32>",
  Voter: {
    votes: "Vec<AccountId>",
    stake: "Balance",
    deposit: "Balance"
  },
  VoteWeight: "u64"
};
var definitions_default37 = {
  rpc: {},
  types: objectSpread({}, deprecated, phragmen, {
    ActiveEraInfo: {
      index: "EraIndex",
      start: "Option<Moment>"
    },
    EraIndex: "u32",
    EraRewardPoints: {
      total: "RewardPoint",
      individual: "BTreeMap<AccountId, RewardPoint>"
    },
    EraRewards: {
      total: "u32",
      rewards: "Vec<u32>"
    },
    Exposure: {
      total: "Compact<Balance>",
      own: "Compact<Balance>",
      others: "Vec<IndividualExposure>"
    },
    Forcing: {
      _enum: ["NotForcing", "ForceNew", "ForceNone", "ForceAlways"]
    },
    IndividualExposure: {
      who: "AccountId",
      value: "Compact<Balance>"
    },
    KeyType: "AccountId",
    MomentOf: "Moment",
    Nominations: {
      targets: "Vec<AccountId>",
      submittedIn: "EraIndex",
      suppressed: "bool"
    },
    NominatorIndex: "u32",
    NominatorIndexCompact: "Compact<NominatorIndex>",
    OffchainAccuracy: "PerU16",
    OffchainAccuracyCompact: "Compact<OffchainAccuracy>",
    PhragmenScore: "[u128; 3]",
    Points: "u32",
    RewardDestination: {
      _enum: {
        Staked: "Null",
        Stash: "Null",
        Controller: "Null",
        Account: "AccountId",
        None: "Null"
      }
    },
    RewardPoint: "u32",
    SlashJournalEntry: {
      who: "AccountId",
      amount: "Balance",
      ownSlash: "Balance"
    },
    SlashingSpansTo204: {
      spanIndex: "SpanIndex",
      lastStart: "EraIndex",
      prior: "Vec<EraIndex>"
    },
    SlashingSpans: {
      spanIndex: "SpanIndex",
      lastStart: "EraIndex",
      lastNonzeroSlash: "EraIndex",
      prior: "Vec<EraIndex>"
    },
    SpanIndex: "u32",
    SpanRecord: {
      slashed: "Balance",
      paidOut: "Balance"
    },
    StakingLedgerTo223: {
      stash: "AccountId",
      total: "Compact<Balance>",
      active: "Compact<Balance>",
      unlocking: "Vec<UnlockChunk>"
    },
    StakingLedgerTo240: {
      _fallback: "StakingLedgerTo223",
      stash: "AccountId",
      total: "Compact<Balance>",
      active: "Compact<Balance>",
      unlocking: "Vec<UnlockChunk>",
      lastReward: "Option<EraIndex>"
    },
    StakingLedger: {
      stash: "AccountId",
      total: "Compact<Balance>",
      active: "Compact<Balance>",
      unlocking: "Vec<UnlockChunk>",
      claimedRewards: "Vec<EraIndex>"
    },
    UnappliedSlashOther: "(AccountId, Balance)",
    UnappliedSlash: {
      validator: "AccountId",
      own: "Balance",
      others: "Vec<UnappliedSlashOther>",
      reporters: "Vec<AccountId>",
      payout: "Balance"
    },
    UnlockChunk: {
      value: "Compact<Balance>",
      era: "Compact<BlockNumber>"
    },
    ValidatorIndex: "u16",
    ValidatorIndexCompact: "Compact<ValidatorIndex>",
    ValidatorPrefs: "ValidatorPrefsWithBlocked",
    ValidatorPrefsWithCommission: {
      commission: "Compact<Perbill>"
    },
    ValidatorPrefsWithBlocked: {
      commission: "Compact<Perbill>",
      blocked: "bool"
    },
    ValidatorPrefsTo196: {
      validatorPayment: "Compact<Balance>"
    },
    ValidatorPrefsTo145: {
      unstakeThreshold: "Compact<u32>",
      validatorPayment: "Compact<Balance>"
    }
  })
};

// node_modules/@polkadot/types/interfaces/support/definitions.js
var definitions_default38 = {
  rpc: {},
  types: {
    WeightToFeeCoefficient: {
      coeffInteger: "Balance",
      coeffFrac: "Perbill",
      negative: "bool",
      degree: "u8"
    }
  }
};

// node_modules/@polkadot/types/interfaces/syncstate/rpc.js
var rpc8 = {
  genSyncSpec: {
    description: "Returns the json-serialized chainspec running the node, with a sync state.",
    endpoint: "sync_state_genSyncSpec",
    params: [{
      name: "raw",
      type: "bool"
    }],
    type: "Json"
  }
};

// node_modules/@polkadot/types/interfaces/syncstate/definitions.js
var definitions_default39 = {
  rpc: rpc8,
  types: {}
};

// node_modules/@polkadot/types/interfaces/system/rpc.js
var rpc9 = {
  accountNextIndex: {
    alias: ["account_nextIndex"],
    description: "Retrieves the next accountIndex as available on the node",
    params: [{
      name: "accountId",
      type: "AccountId"
    }],
    type: "Index"
  },
  addLogFilter: {
    description: "Adds the supplied directives to the current log filter",
    params: [{
      name: "directives",
      type: "Text"
    }],
    type: "Null"
  },
  addReservedPeer: {
    description: "Adds a reserved peer",
    params: [{
      name: "peer",
      type: "Text"
    }],
    type: "Text"
  },
  chain: {
    description: "Retrieves the chain",
    params: [],
    type: "Text"
  },
  chainType: {
    description: "Retrieves the chain type",
    params: [],
    type: "ChainType"
  },
  dryRun: {
    alias: ["system_dryRunAt"],
    description: "Dry run an extrinsic at a given block",
    params: [{
      name: "extrinsic",
      type: "Bytes"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "ApplyExtrinsicResult"
  },
  health: {
    description: "Return health status of the node",
    noErrorLog: true,
    params: [],
    type: "Health"
  },
  localListenAddresses: {
    description: "The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example",
    params: [],
    type: "Vec<Text>"
  },
  localPeerId: {
    description: "Returns the base58-encoded PeerId of the node",
    params: [],
    type: "Text"
  },
  name: {
    description: "Retrieves the node name",
    params: [],
    type: "Text"
  },
  networkState: {
    alias: ["system_unstable_networkState"],
    description: "Returns current state of the network",
    params: [],
    type: "NetworkState"
  },
  nodeRoles: {
    description: "Returns the roles the node is running as",
    params: [],
    type: "Vec<NodeRole>"
  },
  peers: {
    description: "Returns the currently connected peers",
    params: [],
    type: "Vec<PeerInfo>"
  },
  properties: {
    description: "Get a custom set of properties as a JSON object, defined in the chain spec",
    params: [],
    type: "ChainProperties"
  },
  removeReservedPeer: {
    description: "Remove a reserved peer",
    params: [{
      name: "peerId",
      type: "Text"
    }],
    type: "Text"
  },
  reservedPeers: {
    description: "Returns the list of reserved peers",
    params: [],
    type: "Vec<Text>"
  },
  resetLogFilter: {
    description: "Resets the log filter to Substrate defaults",
    params: [],
    type: "Null"
  },
  syncState: {
    description: "Returns the state of the syncing of the node",
    params: [],
    type: "SyncState"
  },
  version: {
    description: "Retrieves the version of the node",
    params: [],
    type: "Text"
  }
};

// node_modules/@polkadot/types/interfaces/system/runtime.js
var runtime15 = {
  AccountNonceApi: [{
    methods: {
      account_nonce: {
        description: "The API to query account nonce (aka transaction index)",
        params: [{
          name: "accountId",
          type: "AccountId"
        }],
        type: "Index"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/system/definitions.js
var definitions_default40 = {
  rpc: rpc9,
  runtime: runtime15,
  types: {
    AccountInfo: "AccountInfoWithTripleRefCount",
    AccountInfoWithRefCountU8: {
      nonce: "Index",
      refcount: "u8",
      data: "AccountData"
    },
    AccountInfoWithRefCount: {
      _fallback: "AccountInfoWithRefCountU8",
      nonce: "Index",
      refcount: "RefCount",
      data: "AccountData"
    },
    AccountInfoWithDualRefCount: {
      _fallback: "AccountInfoWithRefCount",
      nonce: "Index",
      consumers: "RefCount",
      providers: "RefCount",
      data: "AccountData"
    },
    AccountInfoWithProviders: "AccountInfoWithDualRefCount",
    AccountInfoWithTripleRefCount: {
      _fallback: "AccountInfoWithDualRefCount",
      nonce: "Index",
      consumers: "RefCount",
      providers: "RefCount",
      sufficients: "RefCount",
      data: "AccountData"
    },
    ApplyExtrinsicResult: "Result<DispatchOutcome, TransactionValidityError>",
    ApplyExtrinsicResultPre6: "Result<DispatchOutcomePre6, TransactionValidityError>",
    ArithmeticError: {
      _enum: ["Underflow", "Overflow", "DivisionByZero"]
    },
    BlockLength: {
      max: "PerDispatchClassU32"
    },
    BlockWeights: {
      baseBlock: "Weight",
      maxBlock: "Weight",
      perClass: "PerDispatchClassWeightsPerClass"
    },
    ChainProperties: "GenericChainProperties",
    ChainType: {
      _enum: {
        Development: "Null",
        Local: "Null",
        Live: "Null",
        Custom: "Text"
      }
    },
    ConsumedWeight: "PerDispatchClassWeight",
    DigestOf: "Digest",
    DispatchClass: {
      _enum: ["Normal", "Operational", "Mandatory"]
    },
    DispatchError: {
      _enum: {
        Other: "Null",
        CannotLookup: "Null",
        BadOrigin: "Null",
        Module: "DispatchErrorModule",
        ConsumerRemaining: "Null",
        NoProviders: "Null",
        TooManyConsumers: "Null",
        Token: "TokenError",
        Arithmetic: "ArithmeticError",
        Transactional: "TransactionalError",
        Exhausted: "Null",
        Corruption: "Null",
        Unavailable: "Null"
      }
    },
    DispatchErrorPre6: {
      _enum: {
        Other: "Null",
        CannotLookup: "Null",
        BadOrigin: "Null",
        Module: "DispatchErrorModulePre6",
        ConsumerRemaining: "Null",
        NoProviders: "Null",
        TooManyConsumers: "Null",
        Token: "TokenError",
        Arithmetic: "ArithmeticError",
        Transactional: "TransactionalError"
      }
    },
    DispatchErrorPre6First: {
      _enum: {
        Other: "Null",
        CannotLookup: "Null",
        BadOrigin: "Null",
        Module: "DispatchErrorModulePre6",
        ConsumerRemaining: "Null",
        NoProviders: "Null",
        Token: "TokenError",
        Arithmetic: "ArithmeticError",
        Transactional: "TransactionalError"
      }
    },
    DispatchErrorModuleU8: {
      index: "u8",
      error: "u8"
    },
    DispatchErrorModuleU8a: {
      index: "u8",
      error: "[u8; 4]"
    },
    DispatchErrorModule: "DispatchErrorModuleU8a",
    DispatchErrorModulePre6: "DispatchErrorModuleU8",
    DispatchErrorTo198: {
      module: "Option<u8>",
      error: "u8"
    },
    DispatchInfo: {
      weight: "Weight",
      class: "DispatchClass",
      paysFee: "Pays"
    },
    DispatchInfoTo190: {
      weight: "Weight",
      class: "DispatchClass"
    },
    DispatchInfoTo244: {
      weight: "Weight",
      class: "DispatchClass",
      paysFee: "bool"
    },
    DispatchOutcome: "Result<(), DispatchError>",
    DispatchOutcomePre6: "Result<(), DispatchErrorPre6>",
    DispatchResult: "Result<(), DispatchError>",
    DispatchResultOf: "DispatchResult",
    DispatchResultTo198: "Result<(), Text>",
    Event: "GenericEvent",
    EventId: "[u8; 2]",
    EventIndex: "u32",
    EventRecord: {
      phase: "Phase",
      event: "Event",
      topics: "Vec<Hash>"
    },
    Health: {
      peers: "u64",
      isSyncing: "bool",
      shouldHavePeers: "bool"
    },
    InvalidTransaction: {
      _enum: {
        Call: "Null",
        Payment: "Null",
        Future: "Null",
        Stale: "Null",
        BadProof: "Null",
        AncientBirthBlock: "Null",
        ExhaustsResources: "Null",
        Custom: "u8",
        BadMandatory: "Null",
        MandatoryDispatch: "Null",
        BadSigner: "Null"
      }
    },
    Key: "Bytes",
    LastRuntimeUpgradeInfo: {
      specVersion: "Compact<u32>",
      specName: "Text"
    },
    NetworkState: {
      peerId: "Text",
      listenedAddresses: "Vec<Text>",
      externalAddresses: "Vec<Text>",
      connectedPeers: "HashMap<Text, Peer>",
      notConnectedPeers: "HashMap<Text, NotConnectedPeer>",
      averageDownloadPerSec: "u64",
      averageUploadPerSec: "u64",
      peerset: "NetworkStatePeerset"
    },
    NetworkStatePeerset: {
      messageQueue: "u64",
      nodes: "HashMap<Text, NetworkStatePeersetInfo>"
    },
    NetworkStatePeersetInfo: {
      connected: "bool",
      reputation: "i32"
    },
    NodeRole: {
      _enum: {
        Full: "Null",
        LightClient: "Null",
        Authority: "Null",
        UnknownRole: "u8"
      }
    },
    NotConnectedPeer: {
      knownAddresses: "Vec<Text>",
      latestPingTime: "Option<PeerPing>",
      versionString: "Option<Text>"
    },
    Peer: {
      enabled: "bool",
      endpoint: "PeerEndpoint",
      knownAddresses: "Vec<Text>",
      latestPingTime: "PeerPing",
      open: "bool",
      versionString: "Text"
    },
    PeerEndpoint: {
      listening: "PeerEndpointAddr"
    },
    PeerEndpointAddr: {
      _alias: {
        localAddr: "local_addr",
        sendBackAddr: "send_back_addr"
      },
      localAddr: "Text",
      sendBackAddr: "Text"
    },
    PeerPing: {
      nanos: "u64",
      secs: "u64"
    },
    PeerInfo: {
      peerId: "Text",
      roles: "Text",
      protocolVersion: "u32",
      bestHash: "Hash",
      bestNumber: "BlockNumber"
    },
    PerDispatchClassU32: {
      normal: "u32",
      operational: "u32",
      mandatory: "u32"
    },
    PerDispatchClassWeight: {
      normal: "Weight",
      operational: "Weight",
      mandatory: "Weight"
    },
    PerDispatchClassWeightsPerClass: {
      normal: "WeightPerClass",
      operational: "WeightPerClass",
      mandatory: "WeightPerClass"
    },
    Phase: {
      _enum: {
        ApplyExtrinsic: "u32",
        Finalization: "Null",
        Initialization: "Null"
      }
    },
    RawOrigin: {
      _enum: {
        Root: "Null",
        Signed: "AccountId",
        None: "Null"
      }
    },
    RefCount: "u32",
    RefCountTo259: "u8",
    SyncState: {
      startingBlock: "BlockNumber",
      currentBlock: "BlockNumber",
      highestBlock: "Option<BlockNumber>"
    },
    SystemOrigin: "RawOrigin",
    TokenError: {
      _enum: [
        "NoFunds",
        "WouldDie",
        "BelowMinimum",
        "CannotCreate",
        "UnknownAsset",
        "Frozen",
        "Unsupported",
        "Underflow",
        "Overflow"
      ]
    },
    TransactionValidityError: {
      _enum: {
        Invalid: "InvalidTransaction",
        Unknown: "UnknownTransaction"
      }
    },
    TransactionalError: {
      _enum: ["LimitReached", "NoLayer"]
    },
    UnknownTransaction: {
      _enum: {
        CannotLookup: "Null",
        NoUnsignedValidator: "Null",
        Custom: "u8"
      }
    },
    WeightPerClass: {
      baseExtrinsic: "Weight",
      maxExtrinsic: "Option<Weight>",
      maxTotal: "Option<Weight>",
      reserved: "Option<Weight>"
    }
  }
};

// node_modules/@polkadot/types/interfaces/treasury/definitions.js
var definitions_default41 = {
  rpc: {},
  types: {
    Bounty: {
      proposer: "AccountId",
      value: "Balance",
      fee: "Balance",
      curatorDeposit: "Balance",
      bond: "Balance",
      status: "BountyStatus"
    },
    BountyIndex: "u32",
    BountyStatus: {
      _enum: {
        Proposed: "Null",
        Approved: "Null",
        Funded: "Null",
        CuratorProposed: "BountyStatusCuratorProposed",
        Active: "BountyStatusActive",
        PendingPayout: "BountyStatusPendingPayout"
      }
    },
    BountyStatusActive: {
      curator: "AccountId",
      updateDue: "BlockNumber"
    },
    BountyStatusCuratorProposed: {
      curator: "AccountId"
    },
    BountyStatusPendingPayout: {
      curator: "AccountId",
      beneficiary: "AccountId",
      unlockAt: "BlockNumber"
    },
    OpenTip: {
      reason: "Hash",
      who: "AccountId",
      finder: "AccountId",
      deposit: "Balance",
      closes: "Option<BlockNumber>",
      tips: "Vec<OpenTipTip>",
      findersFee: "bool"
    },
    OpenTipTo225: {
      reason: "Hash",
      who: "AccountId",
      finder: "Option<OpenTipFinderTo225>",
      closes: "Option<BlockNumber>",
      tips: "Vec<OpenTipTip>"
    },
    OpenTipFinderTo225: "(AccountId, Balance)",
    OpenTipTip: "(AccountId, Balance)",
    TreasuryProposal: {
      proposer: "AccountId",
      value: "Balance",
      beneficiary: "AccountId",
      bond: "Balance"
    }
  }
};

// node_modules/@polkadot/types/interfaces/txpayment/definitions.js
var definitions_default42 = {
  rpc: {},
  types: {
    Multiplier: "Fixed128"
  }
};

// node_modules/@polkadot/types/interfaces/txqueue/runtime.js
var runtime16 = {
  TaggedTransactionQueue: [{
    methods: {
      validate_transaction: {
        description: "Validate the transaction.",
        params: [{
          name: "source",
          type: "TransactionSource"
        }, {
          name: "tx",
          type: "Extrinsic"
        }, {
          name: "blockHash",
          type: "BlockHash"
        }],
        type: "TransactionValidity"
      }
    },
    version: 3
  }, {
    methods: {
      validate_transaction: {
        description: "Validate the transaction.",
        params: [{
          name: "source",
          type: "TransactionSource"
        }, {
          name: "tx",
          type: "Extrinsic"
        }],
        type: "TransactionValidity"
      }
    },
    version: 2
  }, {
    methods: {
      validate_transaction: {
        description: "Validate the transaction.",
        params: [{
          name: "tx",
          type: "Extrinsic"
        }],
        type: "TransactionValidity"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/txqueue/definitions.js
var definitions_default43 = {
  rpc: {},
  runtime: runtime16,
  types: {
    TransactionSource: {
      _enum: ["InBlock", "Local", "External"]
    },
    TransactionValidity: "Result<ValidTransaction, TransactionValidityError>",
    ValidTransaction: {
      priority: "TransactionPriority",
      requires: "Vec<TransactionTag>",
      provides: "Vec<TransactionTag>",
      longevity: "TransactionLongevity",
      propagate: "bool"
    }
  }
};

// node_modules/@polkadot/types/interfaces/uniques/definitions.js
var definitions_default44 = {
  rpc: {},
  types: {
    ClassId: "u32",
    InstanceId: "u32",
    DepositBalance: "Balance",
    DepositBalanceOf: "Balance",
    ClassDetails: {
      owner: "AccountId",
      issuer: "AccountId",
      admin: "AccountId",
      freezer: "AccountId",
      totalDeposit: "DepositBalance",
      freeHolding: "bool",
      instances: "u32",
      instanceMetadatas: "u32",
      attributes: "u32",
      isFrozen: "bool"
    },
    DestroyWitness: {
      instances: "Compact<u32>",
      instanceMetadatas: "Compact<u32>",
      attributes: "Compact<u32>"
    },
    InstanceDetails: {
      owner: "AccountId",
      approved: "Option<AccountId>",
      isFrozen: "bool",
      deposit: "DepositBalance"
    },
    ClassMetadata: {
      deposit: "DepositBalance",
      data: "Vec<u8>",
      isFrozen: "bool"
    },
    InstanceMetadata: {
      deposit: "DepositBalance",
      data: "Vec<u8>",
      isFrozen: "bool"
    }
  }
};

// node_modules/@polkadot/types/interfaces/utility/definitions.js
var definitions_default45 = {
  rpc: {},
  types: {
    Multisig: {
      when: "Timepoint",
      deposit: "Balance",
      depositor: "AccountId",
      approvals: "Vec<AccountId>"
    },
    Timepoint: {
      height: "BlockNumber",
      index: "u32"
    }
  }
};

// node_modules/@polkadot/types/interfaces/vesting/definitions.js
var definitions_default46 = {
  rpc: {},
  types: {
    VestingInfo: {
      locked: "Balance",
      perBlock: "Balance",
      startingBlock: "BlockNumber"
    }
  }
};

// node_modules/@polkadot/types/interfaces/attestations/definitions.js
var definitions_default47 = {
  rpc: {},
  types: {
    BlockAttestations: {
      receipt: "CandidateReceipt",
      valid: "Vec<AccountId>",
      invalid: "Vec<AccountId>"
    },
    IncludedBlocks: {
      actualNumber: "BlockNumber",
      session: "SessionIndex",
      randomSeed: "H256",
      activeParachains: "Vec<ParaId>",
      paraBlocks: "Vec<Hash>"
    },
    MoreAttestations: {}
  }
};

// node_modules/@polkadot/types/interfaces/bridges/definitions.js
var definitions_default48 = {
  rpc: {},
  types: {
    BridgedBlockHash: "H256",
    BridgedBlockNumber: "BlockNumber",
    BridgedHeader: "Header",
    BridgeMessageId: "(LaneId, MessageNonce)",
    CallOrigin: {
      _enum: {
        SourceRoot: "Null",
        TargetAccount: "(AccountId, MultiSigner, MultiSignature)",
        SourceAccount: "AccountId"
      }
    },
    ChainId: "[u8; 4]",
    DeliveredMessages: {
      begin: "MessageNonce",
      end: "MessageNonce",
      dispatchResults: "BitVec"
    },
    DispatchFeePayment: {
      _enum: ["AtSourceChain", "AtTargetChain"]
    },
    InboundLaneData: {
      relayers: "Vec<UnrewardedRelayer>",
      lastConfirmedNonce: "MessageNonce"
    },
    InboundRelayer: "AccountId",
    InitializationData: {
      header: "Header",
      authorityList: "AuthorityList",
      setId: "SetId",
      isHalted: "bool"
    },
    LaneId: "[u8; 4]",
    MessageData: {
      payload: "Bytes",
      fee: "Balance"
    },
    MessagesDeliveryProofOf: {
      bridgedHeaderHash: "BlockHash",
      storageProof: "Vec<Bytes>",
      lane: "LaneId"
    },
    MessageKey: {
      laneId: "LaneId",
      nonce: "MessageNonce"
    },
    MessageNonce: "u64",
    MessagesProofOf: {
      bridgedHeaderHash: "BridgedBlockHash",
      storageProof: "Vec<Bytes>",
      lane: "LaneId",
      noncesStart: "MessageNonce",
      noncesEnd: "MessageNonce"
    },
    OperatingMode: {
      _enum: ["Normal", "RejectingOutboundMessages", "Halted"]
    },
    OutboundLaneData: {
      oldestUnprunedNonce: "MessageNonce",
      latestReceivedNonce: "MessageNonce",
      latestGeneratedNonce: "MessageNonce"
    },
    OutboundMessageFee: "Balance",
    OutboundPayload: {
      specVersion: "u32",
      weight: "Weight",
      origin: "CallOrigin",
      dispatchFeePayment: "DispatchFeePayment",
      call: "Bytes"
    },
    Parameter: "Null",
    RelayerId: "AccountId",
    UnrewardedRelayer: {
      relayer: "RelayerId",
      messages: "DeliveredMessages"
    },
    UnrewardedRelayersState: {
      unrewardedRelayer_Entries: "MessageNonce",
      messagesInOldestEntry: "MessageNonce",
      totalMessages: "MessageNonce"
    }
  }
};

// node_modules/@polkadot/types/interfaces/claims/definitions.js
var definitions_default49 = {
  rpc: {},
  types: {
    StatementKind: {
      _enum: ["Regular", "Saft"]
    }
  }
};

// node_modules/@polkadot/types/interfaces/crowdloan/definitions.js
var definitions_default50 = {
  rpc: {},
  types: {
    FundIndex: "u32",
    LastContribution: {
      _enum: {
        Never: "Null",
        PreEnding: "u32",
        Ending: "BlockNumber"
      }
    },
    FundInfo: {
      depositor: "AccountId",
      verifier: "Option<MultiSigner>",
      deposit: "Balance",
      raised: "Balance",
      end: "BlockNumber",
      cap: "Balance",
      lastContribution: "LastContribution",
      firstPeriod: "LeasePeriod",
      lastPeriod: "LeasePeriod",
      trieIndex: "TrieIndex"
    },
    TrieIndex: "u32"
  }
};

// node_modules/@polkadot/types/interfaces/cumulus/runtime.js
var runtime17 = {
  CollectCollationInfo: [{
    methods: {
      collect_collation_info: {
        description: "Collect information about a collation.",
        params: [{
          name: "header",
          type: "Header"
        }],
        type: "CollationInfo"
      }
    },
    version: 2
  }, {
    methods: {
      collect_collation_info: {
        description: "Collect information about a collation.",
        params: [],
        type: "CollationInfoV1"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/cumulus/definitions.js
var dmpQueue = {
  CollationInfo: {
    upwardMessages: "Vec<UpwardMessage>",
    horizontalMessages: "Vec<OutboundHrmpMessage>",
    newValidationCode: "Option<ValidationCode>",
    processedDownwardMessages: "u32",
    hrmpWatermark: "RelayBlockNumber",
    headData: "HeadData"
  },
  CollationInfoV1: {
    upwardMessages: "Vec<UpwardMessage>",
    horizontalMessages: "Vec<OutboundHrmpMessage>",
    newValidationCode: "Option<ValidationCode>",
    processedDownwardMessages: "u32",
    hrmpWatermark: "RelayBlockNumber"
  },
  ConfigData: {
    maxIndividual: "Weight"
  },
  MessageId: "[u8; 32]",
  OverweightIndex: "u64",
  PageCounter: "u32",
  PageIndexData: {
    beginUsed: "PageCounter",
    endUsed: "PageCounter",
    overweightCount: "OverweightIndex"
  }
};
var definitions_default51 = {
  rpc: {},
  runtime: runtime17,
  types: dmpQueue
};

// node_modules/@polkadot/types/interfaces/finality/runtime.js
var finalityV1 = {
  methods: {
    best_finalized: {
      description: "Returns number and hash of the best finalized header known to the bridge module.",
      params: [],
      type: "(BlockNumber, Hash)"
    }
  },
  version: 1
};
var runtime18 = {
  KusamaFinalityApi: [finalityV1],
  PolkadotFinalityApi: [finalityV1],
  RococoFinalityApi: [finalityV1],
  WestendFinalityApi: [finalityV1]
};

// node_modules/@polkadot/types/interfaces/finality/definitions.js
var definitions_default52 = {
  rpc: {},
  runtime: runtime18,
  types: {}
};

// node_modules/@polkadot/types/interfaces/parachains/hrmp.js
var hrmp_default = {
  HrmpChannel: {
    maxCapacity: "u32",
    maxTotalSize: "u32",
    maxMessageSize: "u32",
    msgCount: "u32",
    totalSize: "u32",
    mqcHead: "Option<Hash>",
    senderDeposit: "Balance",
    recipientDeposit: "Balance"
  },
  HrmpChannelId: {
    sender: "u32",
    receiver: "u32"
  },
  HrmpOpenChannelRequest: {
    confirmed: "bool",
    age: "SessionIndex",
    senderDeposit: "Balance",
    maxMessageSize: "u32",
    maxCapacity: "u32",
    maxTotalSize: "u32"
  }
};

// node_modules/@polkadot/types/interfaces/parachains/runtime.js
var PH_V1_TO_V2 = {
  assumed_validation_data: {
    description: "Returns the persisted validation data for the given `ParaId` along with the corresponding validation code hash.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }, {
      name: "hash",
      type: "Hash"
    }],
    type: "Option<(PersistedValidationData, ValidationCodeHash)>"
  },
  availability_cores: {
    description: "Yields information on all availability cores as relevant to the child block.",
    params: [],
    type: "Vec<CoreState>"
  },
  candidate_events: {
    description: "Get a vector of events concerning candidates that occurred within a block.",
    params: [],
    type: "Vec<CandidateEvent>"
  },
  candidate_pending_availability: {
    description: "Get the receipt of a candidate pending availability.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }],
    type: "Option<CommittedCandidateReceipt>"
  },
  check_validation_outputs: {
    description: "Checks if the given validation outputs pass the acceptance criteria.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }, {
      name: "outputs",
      type: "CandidateCommitments"
    }],
    type: "bool"
  },
  dmq_contents: {
    description: "Get all the pending inbound messages in the downward message queue for a para.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }],
    type: "Vec<InboundDownwardMessage>"
  },
  inbound_hrmp_channels_contents: {
    description: "Get the contents of all channels addressed to the given recipient.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }],
    type: "Vec<InboundHrmpMessage>"
  },
  on_chain_votes: {
    description: "Scrape dispute relevant from on-chain, backing votes and resolved disputes.",
    params: [],
    type: "Option<ScrapedOnChainVotes>"
  },
  persisted_validation_data: {
    description: "Yields the persisted validation data for the given `ParaId` along with an assumption that should be used if the para currently occupies a core.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }, {
      name: "assumption",
      type: "OccupiedCoreAssumption"
    }],
    type: "Option<PersistedValidationData>"
  },
  session_index_for_child: {
    description: "Returns the session index expected at a child of the block.",
    params: [],
    type: "SessionIndex"
  },
  validation_code: {
    description: "Fetch the validation code used by a para, making the given `OccupiedCoreAssumption`.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }, {
      name: "assumption",
      type: "OccupiedCoreAssumption"
    }],
    type: "ValidationCode"
  },
  validation_code_by_hash: {
    description: "Get the validation code from its hash.",
    params: [{
      name: "hash",
      type: "ValidationCodeHash"
    }],
    type: "Option<ValidationCode>"
  },
  validator_groups: {
    description: "Returns the validator groups and rotation info localized based on the hypothetical child of a block whose state  this is invoked on",
    params: [],
    type: "(Vec<Vec<ParaValidatorIndex>>, GroupRotationInfo)"
  },
  validators: {
    description: "Get the current validators.",
    params: [],
    type: "Vec<ValidatorId>"
  }
};
var PH_V2_TO_V3 = {
  pvfs_require_precheck: {
    description: "Returns code hashes of PVFs that require pre-checking by validators in the active set.",
    params: [],
    type: "Vec<ValidationCodeHash>"
  },
  session_info: {
    description: "Get the session info for the given session, if stored.",
    params: [{
      name: "index",
      type: "SessionIndex"
    }],
    type: "Option<SessionInfo>"
  },
  submit_pvf_check_statement: {
    description: "Submits a PVF pre-checking statement into the transaction pool.",
    params: [{
      name: "stmt",
      type: "PvfCheckStatement"
    }, {
      name: "signature",
      type: "ValidatorSignature"
    }],
    type: "Null"
  },
  validation_code_hash: {
    description: "Fetch the hash of the validation code used by a para, making the given `OccupiedCoreAssumption`.",
    params: [{
      name: "paraId",
      type: "ParaId"
    }, {
      name: "assumption",
      type: "OccupiedCoreAssumption"
    }],
    type: "Option<ValidationCodeHash>"
  }
};
var runtime19 = {
  ParachainHost: [{
    methods: objectSpread({
      disputes: {
        description: "Returns all onchain disputes.",
        params: [],
        type: "Vec<(SessionIndex, CandidateHash, DisputeState)>"
      }
    }, PH_V1_TO_V2, PH_V2_TO_V3),
    version: 3
  }, {
    methods: objectSpread({}, PH_V1_TO_V2, PH_V2_TO_V3),
    version: 2
  }, {
    methods: objectSpread({
      session_info: {
        description: "Get the session info for the given session, if stored.",
        params: [{
          name: "index",
          type: "SessionIndex"
        }],
        type: "Option<OldV1SessionInfo>"
      }
    }, PH_V1_TO_V2),
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/parachains/slots.js
var SlotRange10 = {
  _enum: ["ZeroZero", "ZeroOne", "ZeroTwo", "ZeroThree", "OneOne", "OneTwo", "OneThree", "TwoTwo", "TwoThree", "ThreeThree"]
};
var SlotRange = {
  _enum: ["ZeroZero", "ZeroOne", "ZeroTwo", "ZeroThree", "ZeroFour", "ZeroFive", "ZeroSix", "ZeroSeven", "OneOne", "OneTwo", "OneThree", "OneFour", "OneFive", "OneSix", "OneSeven", "TwoTwo", "TwoThree", "TwoFour", "TwoFive", "TwoSix", "TwoSeven", "ThreeThree", "ThreeFour", "ThreeFive", "ThreeSix", "ThreeSeven", "FourFour", "FourFive", "FourSix", "FourSeven", "FiveFive", "FiveSix", "FiveSeven", "SixSix", "SixSeven", "SevenSeven"]
};
var oldTypes = {
  Bidder: {
    _enum: {
      New: "NewBidder",
      Existing: "ParaId"
    }
  },
  IncomingParachain: {
    _enum: {
      Unset: "NewBidder",
      Fixed: "IncomingParachainFixed",
      Deploy: "IncomingParachainDeploy"
    }
  },
  IncomingParachainDeploy: {
    code: "ValidationCode",
    initialHeadData: "HeadData"
  },
  IncomingParachainFixed: {
    codeHash: "Hash",
    codeSize: "u32",
    initialHeadData: "HeadData"
  },
  NewBidder: {
    who: "AccountId",
    sub: "SubId"
  },
  SubId: "u32"
};
var slots_default = objectSpread({}, oldTypes, {
  AuctionIndex: "u32",
  LeasePeriod: "BlockNumber",
  LeasePeriodOf: "BlockNumber",
  SlotRange10,
  SlotRange,
  WinningData10: `[WinningDataEntry; ${SlotRange10._enum.length}]`,
  WinningData: `[WinningDataEntry; ${SlotRange._enum.length}]`,
  WinningDataEntry: "Option<(AccountId, ParaId, BalanceOf)>",
  WinnersData10: "Vec<WinnersDataTuple10>",
  WinnersData: "Vec<WinnersDataTuple>",
  WinnersDataTuple10: "(AccountId, ParaId, BalanceOf, SlotRange10)",
  WinnersDataTuple: "(AccountId, ParaId, BalanceOf, SlotRange)"
});

// node_modules/@polkadot/types/interfaces/parachains/definitions.js
var proposeTypes = {
  ParachainProposal: {
    proposer: "AccountId",
    genesisHead: "HeadData",
    validators: "Vec<ValidatorId>",
    name: "Bytes",
    balance: "Balance"
  },
  RegisteredParachainInfo: {
    validators: "Vec<ValidatorId>",
    proposer: "AccountId"
  }
};
var cumulusTypes = {
  ServiceQuality: {
    _enum: ["Ordered", "Fast"]
  }
};
var disputeTypes = {
  DisputeLocation: {
    _enum: ["Local", "Remote"]
  },
  DisputeResult: {
    _enum: ["Valid", "Invalid"]
  },
  DisputeState: {
    validatorsFor: "BitVec",
    validatorsAgainst: "BitVec",
    start: "BlockNumber",
    concludedAt: "Option<BlockNumber>"
  },
  DisputeStatement: {
    _enum: {
      Valid: "ValidDisputeStatementKind",
      Invalid: "InvalidDisputeStatementKind"
    }
  },
  DisputeStatementSet: {
    candidateHash: "CandidateHash",
    session: "SessionIndex",
    statements: "Vec<(DisputeStatement, ParaValidatorIndex, ValidatorSignature)>"
  },
  ExplicitDisputeStatement: {
    valid: "bool",
    candidateHash: "CandidateHash",
    session: "SessionIndex"
  },
  InvalidDisputeStatementKind: {
    _enum: ["Explicit"]
  },
  MultiDisputeStatementSet: "Vec<DisputeStatementSet>",
  ValidDisputeStatementKind: {
    _enum: {
      Explicit: "Null",
      BackingSeconded: "Hash",
      BackingValid: "Hash",
      ApprovalChecking: "Null"
    }
  }
};
var definitions_default53 = {
  rpc: {},
  runtime: runtime19,
  types: objectSpread({}, cumulusTypes, disputeTypes, hrmp_default, proposeTypes, slots_default, {
    AbridgedCandidateReceipt: {
      parachainIndex: "ParaId",
      relayParent: "Hash",
      headData: "HeadData",
      collator: "CollatorId",
      signature: "CollatorSignature",
      povBlockHash: "Hash",
      commitments: "CandidateCommitments"
    },
    AbridgedHostConfiguration: {
      maxCodeSize: "u32",
      maxHeadDataSize: "u32",
      maxUpwardQueueCount: "u32",
      maxUpwardQueueSize: "u32",
      maxUpwardMessageSize: "u32",
      maxUpwardMessageNumPerCandidate: "u32",
      hrmpMaxMessageNumPerCandidate: "u32",
      validationUpgradeFrequency: "BlockNumber",
      validationUpgradeDelay: "BlockNumber"
    },
    AbridgedHrmpChannel: {
      maxCapacity: "u32",
      maxTotalSize: "u32",
      maxMessageSize: "u32",
      msgCount: "u32",
      totalSize: "u32",
      mqcHead: "Option<Hash>"
    },
    AssignmentId: "AccountId",
    AssignmentKind: {
      _enum: {
        Parachain: "Null",
        Parathread: "(CollatorId, u32)"
      }
    },
    AttestedCandidate: {
      candidate: "AbridgedCandidateReceipt",
      validityVotes: "Vec<ValidityAttestation>",
      validatorIndices: "BitVec"
    },
    AuthorityDiscoveryId: "AccountId",
    AvailabilityBitfield: "BitVec",
    AvailabilityBitfieldRecord: {
      bitfield: "AvailabilityBitfield",
      submittedTt: "BlockNumber"
    },
    BackedCandidate: {
      candidate: "CommittedCandidateReceipt",
      validityVotes: "Vec<ValidityAttestation>",
      validatorIndices: "BitVec"
    },
    BufferedSessionChange: {
      applyAt: "BlockNumber",
      validators: "Vec<ValidatorId>",
      queued: "Vec<ValidatorId>",
      sessionIndex: "SessionIndex"
    },
    CandidateCommitments: {
      upwardMessages: "Vec<UpwardMessage>",
      horizontalMessages: "Vec<OutboundHrmpMessage>",
      newValidationCode: "Option<ValidationCode>",
      headData: "HeadData",
      processedDownwardMessages: "u32",
      hrmpWatermark: "BlockNumber"
    },
    CandidateDescriptor: {
      paraId: "ParaId",
      relayParent: "RelayChainHash",
      collatorId: "CollatorId",
      persistedValidationDataHash: "Hash",
      povHash: "Hash",
      erasureRoot: "Hash",
      signature: "CollatorSignature",
      paraHead: "Hash",
      validationCodeHash: "ValidationCodeHash"
    },
    CandidateEvent: {
      _enum: {
        CandidateBacked: "(CandidateReceipt, HeadData, CoreIndex, GroupIndex)",
        CandidateIncluded: "(CandidateReceipt, HeadData, CoreIndex, GroupIndex)",
        CandidateTimedOut: "(CandidateReceipt, HeadData, CoreIndex)"
      }
    },
    CandidateHash: "Hash",
    CandidateInfo: {
      who: "AccountId",
      deposit: "Balance"
    },
    CandidatePendingAvailability: {
      core: "CoreIndex",
      hash: "CandidateHash",
      descriptor: "CandidateDescriptor",
      availabilityVotes: "BitVec",
      backers: "BitVec",
      relayParentNumber: "BlockNumber",
      backedInNumber: "BlockNumber",
      backingGroup: "GroupIndex"
    },
    CandidateReceipt: {
      descriptor: "CandidateDescriptor",
      commitmentsHash: "Hash"
    },
    GlobalValidationData: {
      maxCodeSize: "u32",
      maxHeadDataSize: "u32",
      blockNumber: "BlockNumber"
    },
    CollatorId: "H256",
    CollatorSignature: "Signature",
    CommittedCandidateReceipt: {
      descriptor: "CandidateDescriptor",
      commitments: "CandidateCommitments"
    },
    CoreAssignment: {
      core: "CoreIndex",
      paraId: "ParaId",
      kind: "AssignmentKind",
      groupIdx: "GroupIndex"
    },
    CoreIndex: "u32",
    CoreOccupied: {
      _enum: {
        Parathread: "ParathreadEntry",
        Parachain: "Null"
      }
    },
    CoreState: {
      _enum: {
        Occupied: "OccupiedCore",
        Scheduled: "ScheduledCore",
        Free: "Null"
      }
    },
    DoubleVoteReport: {
      identity: "ValidatorId",
      first: "(Statement, ValidatorSignature)",
      second: "(Statement, ValidatorSignature)",
      proof: "MembershipProof",
      signingContext: "SigningContext"
    },
    DownwardMessage: "Bytes",
    GroupIndex: "u32",
    GroupRotationInfo: {
      sessionStartBlock: "BlockNumber",
      groupRotationFrequency: "BlockNumber",
      now: "BlockNumber"
    },
    GlobalValidationSchedule: {
      maxCodeSize: "u32",
      maxHeadDataSize: "u32",
      blockNumber: "BlockNumber"
    },
    HeadData: "Bytes",
    HostConfiguration: {
      maxCodeSize: "u32",
      maxHeadDataSize: "u32",
      maxUpwardQueueCount: "u32",
      maxUpwardQueueSize: "u32",
      maxUpwardMessageSize: "u32",
      maxUpwardMessageNumPerCandidate: "u32",
      hrmpMaxMessageNumPerCandidate: "u32",
      validationUpgradeFrequency: "BlockNumber",
      validationUpgradeDelay: "BlockNumber",
      maxPovSize: "u32",
      maxDownwardMessageSize: "u32",
      preferredDispatchableUpwardMessagesStepWeight: "Weight",
      hrmpMaxParachainOutboundChannels: "u32",
      hrmpMaxParathreadOutboundChannels: "u32",
      hrmpOpenRequestTtl: "u32",
      hrmpSenderDeposit: "Balance",
      hrmpRecipientDeposit: "Balance",
      hrmpChannelMaxCapacity: "u32",
      hrmpChannelMaxTotalSize: "u32",
      hrmpMaxParachainInboundChannels: "u32",
      hrmpMaxParathreadInboundChannels: "u32",
      hrmpChannelMaxMessageSize: "u32",
      codeRetentionPeriod: "BlockNumber",
      parathreadCores: "u32",
      parathreadRetries: "u32",
      groupRotationFrequency: "BlockNumber",
      chainAvailabilityPeriod: "BlockNumber",
      threadAvailabilityPeriod: "BlockNumber",
      schedulingLookahead: "u32",
      maxValidatorsPerCore: "Option<u32>",
      maxValidators: "Option<u32>",
      disputePeriod: "SessionIndex",
      disputePostConclusionAcceptancePeriod: "BlockNumber",
      disputeMaxSpamSlots: "u32",
      disputeConclusionByTimeOutPeriod: "BlockNumber",
      noShowSlots: "u32",
      nDelayTranches: "u32",
      zerothDelayTrancheWidth: "u32",
      neededApprovals: "u32",
      relayVrfModuloSamples: "u32"
    },
    InboundDownwardMessage: {
      pubSentAt: "BlockNumber",
      pubMsg: "DownwardMessage"
    },
    InboundHrmpMessage: {
      sentAt: "BlockNumber",
      data: "Bytes"
    },
    InboundHrmpMessages: "Vec<InboundHrmpMessage>",
    LocalValidationData: {
      parentHead: "HeadData",
      balance: "Balance",
      codeUpgradeAllowed: "Option<BlockNumber>"
    },
    MessageIngestionType: {
      downwardMessages: "Vec<InboundDownwardMessage>",
      horizontalMessages: "BTreeMap<ParaId, InboundHrmpMessages>"
    },
    MessageQueueChain: "RelayChainHash",
    OccupiedCore: {
      nextUpOnAvailable: "Option<ScheduledCore>",
      occupiedSince: "BlockNumber",
      timeOutAt: "BlockNumber",
      nextUpOnTimeOut: "Option<ScheduledCore>",
      availability: "BitVec",
      groupResponsible: "GroupIndex",
      candidateHash: "CandidateHash",
      candidateDescriptor: "CandidateDescriptor"
    },
    OccupiedCoreAssumption: {
      _enum: ["Included,", "TimedOut", "Free"]
    },
    OutboundHrmpMessage: {
      recipient: "u32",
      data: "Bytes"
    },
    ParachainDispatchOrigin: {
      _enum: ["Signed", "Parachain", "Root"]
    },
    ParachainInherentData: {
      validationData: "PersistedValidationData",
      relayChainState: "StorageProof",
      downwardMessages: "Vec<InboundDownwardMessage>",
      horizontalMessages: "BTreeMap<ParaId, VecInboundHrmpMessage>"
    },
    ParachainsInherentData: {
      bitfields: "SignedAvailabilityBitfields",
      backedCandidates: "Vec<BackedCandidate>",
      disputes: "MultiDisputeStatementSet",
      parentHeader: "Header"
    },
    ParaGenesisArgs: {
      genesisHead: "Bytes",
      validationCode: "Bytes",
      parachain: "bool"
    },
    ParaId: "u32",
    ParaInfo: {
      manager: "AccountId",
      deposit: "Balance",
      locked: "bool"
    },
    ParaLifecycle: {
      _enum: ["Onboarding", "Parathread", "Parachain", "UpgradingToParachain", "DowngradingToParathread", "OutgoingParathread", "OutgoingParachain"]
    },
    ParaPastCodeMeta: {
      upgradeTimes: "Vec<ReplacementTimes>",
      lastPruned: "Option<BlockNumber>"
    },
    ParaScheduling: {
      _enum: ["Always", "Dynamic"]
    },
    ParathreadClaim: "(ParaId, CollatorId)",
    ParathreadClaimQueue: {
      queue: "Vec<QueuedParathread>",
      nextCoreOffset: "u32"
    },
    ParathreadEntry: {
      claim: "ParathreadClaim",
      retries: "u32"
    },
    ParaValidatorIndex: "u32",
    PersistedValidationData: {
      parentHead: "HeadData",
      relayParentNumber: "RelayChainBlockNumber",
      relayParentStorageRoot: "Hash",
      maxPovSize: "u32"
    },
    PvfCheckStatement: {
      accept: "bool",
      subject: "ValidationCodeHash",
      sessionIndex: "SessionIndex",
      validatorIndex: "ParaValidatorIndex"
    },
    QueuedParathread: {
      claim: "ParathreadEntry",
      coreOffset: "u32"
    },
    RelayBlockNumber: "u32",
    RelayChainBlockNumber: "RelayBlockNumber",
    RelayHash: "Hash",
    RelayChainHash: "RelayHash",
    Remark: "[u8; 32]",
    ReplacementTimes: {
      expectedAt: "BlockNumber",
      activatedAt: "BlockNumber"
    },
    Retriable: {
      _enum: {
        Never: "Null",
        WithRetries: "u32"
      }
    },
    ScheduledCore: {
      paraId: "ParaId",
      collator: "Option<CollatorId>"
    },
    Scheduling: {
      _enum: ["Always", "Dynamic"]
    },
    ScrapedOnChainVotes: {
      session: "SessionIndex",
      backingValidatorsPerCandidate: "Vec<(CandidateReceipt, Vec<(ParaValidatorIndex, ValidityAttestation)>)>",
      disputes: "MultiDisputeStatementSet"
    },
    SessionInfo: {
      activeValidatorIndices: "Vec<ParaValidatorIndex>",
      randomSeed: "[u8; 32]",
      disputePeriod: "SessionIndex",
      validators: "Vec<ValidatorId>",
      discoveryKeys: "Vec<AuthorityDiscoveryId>",
      assignmentKeys: "Vec<AssignmentId>",
      validatorGroups: "Vec<Vec<ValidatorIndex>>",
      nCores: "u32",
      zerothDelayTrancheWidth: "u32",
      relayVrfModuloSamples: "u32",
      nDelayTranches: "u32",
      noShowSlots: "u32",
      neededApprovals: "u32"
    },
    OldV1SessionInfo: {
      validators: "Vec<ValidatorId>",
      discoveryKeys: "Vec<AuthorityDiscoveryId>",
      assignmentKeys: "Vec<AssignmentId>",
      validatorGroups: "Vec<Vec<ParaValidatorIndex>>",
      nCores: "u32",
      zerothDelayTrancheWidth: "u32",
      relayVrfModuloSamples: "u32",
      nDelayTranches: "u32",
      noShowSlots: "u32",
      neededApprovals: "u32"
    },
    SessionInfoValidatorGroup: "Vec<ParaValidatorIndex>",
    SignedAvailabilityBitfield: {
      payload: "BitVec",
      validatorIndex: "ParaValidatorIndex",
      signature: "ValidatorSignature"
    },
    SignedAvailabilityBitfields: "Vec<SignedAvailabilityBitfield>",
    SigningContext: {
      sessionIndex: "SessionIndex",
      parentHash: "Hash"
    },
    Statement: {
      _enum: {
        Never: "Null",
        Candidate: "Hash",
        Valid: "Hash",
        Invalid: "Hash"
      }
    },
    TransientValidationData: {
      maxCodeSize: "u32",
      maxHeadDataSize: "u32",
      balance: "Balance",
      codeUpgradeAllowed: "Option<BlockNumber>",
      dmqLength: "u32"
    },
    UpgradeGoAhead: {
      _enum: ["Abort", "GoAhead"]
    },
    UpgradeRestriction: {
      _enum: ["Present"]
    },
    UpwardMessage: "Bytes",
    ValidationFunctionParams: {
      maxCodeSize: "u32",
      relayChainHeight: "RelayChainBlockNumber",
      codeUpgradeAllowed: "Option<RelayChainBlockNumber>"
    },
    ValidationCode: "Bytes",
    ValidationCodeHash: "Hash",
    ValidationData: {
      persisted: "PersistedValidationData",
      transient: "TransientValidationData"
    },
    ValidationDataType: {
      validationData: "ValidationData",
      relayChainState: "Vec<Bytes>"
    },
    ValidatorSignature: "Signature",
    ValidityAttestation: {
      _enum: {
        Never: "Null",
        Implicit: "ValidatorSignature",
        Explicit: "ValidatorSignature"
      }
    },
    MessagingStateSnapshot: {
      relayDispatchQueueSize: "(u32, u32)",
      egressChannels: "Vec<MessagingStateSnapshotEgressEntry>"
    },
    MessagingStateSnapshotEgressEntry: "(ParaId, AbridgedHrmpChannel)",
    SystemInherentData: "ParachainInherentData",
    VecInboundHrmpMessage: "Vec<InboundHrmpMessage>"
  })
};

// node_modules/@polkadot/types/interfaces/poll/definitions.js
var definitions_default54 = {
  rpc: {},
  types: {
    Approvals: "[bool; 4]"
  }
};

// node_modules/@polkadot/types/interfaces/purchase/definitions.js
var definitions_default55 = {
  rpc: {},
  types: {
    AccountStatus: {
      validity: "AccountValidity",
      freeBalance: "Balance",
      lockedBalance: "Balance",
      signature: "Vec<u8>",
      vat: "Permill"
    },
    AccountValidity: {
      _enum: ["Invalid", "Initiated", "Pending", "ValidLow", "ValidHigh", "Completed"]
    }
  }
};

// node_modules/@polkadot/types-create/detectOther.js
var detectOther_default14 = [packageInfo25];

// node_modules/@polkadot/types-create/detectPackage.js
detectPackage(packageInfo26, null, detectOther_default14);

// node_modules/@polkadot/types-create/types/types.js
var TypeDefInfo;
(function(TypeDefInfo2) {
  TypeDefInfo2[TypeDefInfo2["BTreeMap"] = 0] = "BTreeMap";
  TypeDefInfo2[TypeDefInfo2["BTreeSet"] = 1] = "BTreeSet";
  TypeDefInfo2[TypeDefInfo2["Compact"] = 2] = "Compact";
  TypeDefInfo2[TypeDefInfo2["DoNotConstruct"] = 3] = "DoNotConstruct";
  TypeDefInfo2[TypeDefInfo2["Enum"] = 4] = "Enum";
  TypeDefInfo2[TypeDefInfo2["HashMap"] = 5] = "HashMap";
  TypeDefInfo2[TypeDefInfo2["Int"] = 6] = "Int";
  TypeDefInfo2[TypeDefInfo2["Linkage"] = 7] = "Linkage";
  TypeDefInfo2[TypeDefInfo2["Null"] = 8] = "Null";
  TypeDefInfo2[TypeDefInfo2["Option"] = 9] = "Option";
  TypeDefInfo2[TypeDefInfo2["Plain"] = 10] = "Plain";
  TypeDefInfo2[TypeDefInfo2["Range"] = 11] = "Range";
  TypeDefInfo2[TypeDefInfo2["RangeInclusive"] = 12] = "RangeInclusive";
  TypeDefInfo2[TypeDefInfo2["Result"] = 13] = "Result";
  TypeDefInfo2[TypeDefInfo2["Set"] = 14] = "Set";
  TypeDefInfo2[TypeDefInfo2["Si"] = 15] = "Si";
  TypeDefInfo2[TypeDefInfo2["Struct"] = 16] = "Struct";
  TypeDefInfo2[TypeDefInfo2["Tuple"] = 17] = "Tuple";
  TypeDefInfo2[TypeDefInfo2["UInt"] = 18] = "UInt";
  TypeDefInfo2[TypeDefInfo2["Vec"] = 19] = "Vec";
  TypeDefInfo2[TypeDefInfo2["VecFixed"] = 20] = "VecFixed";
  TypeDefInfo2[TypeDefInfo2["WrapperKeepOpaque"] = 21] = "WrapperKeepOpaque";
  TypeDefInfo2[TypeDefInfo2["WrapperOpaque"] = 22] = "WrapperOpaque";
})(TypeDefInfo || (TypeDefInfo = {}));

// node_modules/@polkadot/types-codec/detectOther.js
var detectOther_default15 = [];

// node_modules/@polkadot/types-codec/detectPackage.js
detectPackage(packageInfo25, null, detectOther_default15);

// node_modules/@polkadot/types-codec/utils/util.js
function hasEq(o) {
  return isFunction(o.eq);
}

// node_modules/@polkadot/types-codec/utils/compareArray.js
function compareArray(a, b) {
  if (Array.isArray(b)) {
    return a.length === b.length && isUndefined(a.find((v, index) => hasEq(v) ? !v.eq(b[index]) : v !== b[index]));
  }
  return false;
}

// node_modules/@polkadot/types-codec/abstract/Array.js
var AbstractArray = class extends Array {
  static get [Symbol.species]() {
    return Array;
  }
  constructor(registry, length) {
    super(length);
    this.registry = registry;
  }
  get encodedLength() {
    let total = compactToU8a(this.length).length;
    for (let i = 0; i < this.length; i++) {
      total += this[i].encodedLength;
    }
    return total;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.length === 0;
  }
  get length() {
    return super.length;
  }
  eq(other) {
    return compareArray(this, other);
  }
  inspect() {
    return {
      inner: this.inspectInner(),
      outer: [compactToU8a(this.length)]
    };
  }
  inspectInner() {
    const inner = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      inner[i] = this[i].inspect();
    }
    return inner;
  }
  toArray() {
    return Array.from(this);
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman(isExtended) {
    const result = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      result[i] = this[i] && this[i].toHuman(isExtended);
    }
    return result;
  }
  toJSON() {
    const result = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      result[i] = this[i] && this[i].toJSON();
    }
    return result;
  }
  toPrimitive() {
    const result = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      result[i] = this[i] && this[i].toPrimitive();
    }
    return result;
  }
  toString() {
    const result = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      result[i] = this[i].toString();
    }
    return `[${result.join(", ")}]`;
  }
  toU8a(isBare) {
    const encoded = this.toU8aInner();
    return isBare ? u8aConcatStrict(encoded) : u8aConcatStrict([compactToU8a(this.length), ...encoded]);
  }
  toU8aInner(isBare) {
    const encoded = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      encoded[i] = this[i].toU8a(isBare);
    }
    return encoded;
  }
};

// node_modules/@polkadot/types-codec/abstract/Base.js
var _raw;
var AbstractBase = class {
  constructor(registry, value, initialU8aLength) {
    __privateAdd(this, _raw, void 0);
    __privateSet(this, _raw, value);
    this.initialU8aLength = initialU8aLength;
    this.registry = registry;
  }
  get encodedLength() {
    return this.toU8a().length;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get inner() {
    return __privateGet(this, _raw);
  }
  get isEmpty() {
    return __privateGet(this, _raw).isEmpty;
  }
  eq(other) {
    return __privateGet(this, _raw).eq(other);
  }
  inspect() {
    return __privateGet(this, _raw).inspect();
  }
  toHex(isLe) {
    return __privateGet(this, _raw).toHex(isLe);
  }
  toHuman(isExtended) {
    return __privateGet(this, _raw).toHuman(isExtended);
  }
  toJSON() {
    return __privateGet(this, _raw).toJSON();
  }
  toPrimitive() {
    return __privateGet(this, _raw).toPrimitive();
  }
  toString() {
    return __privateGet(this, _raw).toString();
  }
  toU8a(isBare) {
    return __privateGet(this, _raw).toU8a(isBare);
  }
  toRawType() {
    return "Base";
  }
  unwrap() {
    return __privateGet(this, _raw);
  }
};
_raw = new WeakMap();

// node_modules/@polkadot/types-codec/abstract/Int.js
var DEFAULT_UINT_BITS = 64;
var MAX_NUMBER_BITS = 52;
var MUL_P = new import_bn.default(1e4);
var FORMATTERS = [["Perquintill", BN_QUINTILL], ["Perbill", BN_BILLION], ["Permill", BN_MILLION], ["Percent", BN_HUNDRED]];
function toPercentage(value, divisor) {
  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;
}
function decodeAbstractInt(value, isNegative) {
  if (isNumber(value)) {
    if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {
      throw new Error("Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1");
    }
    return value;
  } else if (isString(value)) {
    if (isHex(value, -1, true)) {
      return hexToBn(value, {
        isLe: false,
        isNegative
      }).toString();
    }
    if (value.includes(".") || value.includes(",") || value.includes("e")) {
      throw new Error("String should not contain decimal points or scientific notation");
    }
    return value;
  } else if (isBn(value)) {
    return value.toString();
  } else if (isObject(value) && !isFunction(value.toBn)) {
    const keys2 = Object.keys(value);
    if (keys2.length !== 1) {
      throw new Error("Unable to construct number from multi-key object");
    }
    const inner = value[keys2[0]];
    if (!isString(inner) && !isNumber(inner)) {
      throw new Error("Unable to construct from object with non-string/non-number value");
    }
    return decodeAbstractInt(inner, isNegative);
  }
  return bnToBn(value).toString();
}
var _bitLength;
var AbstractInt = class extends import_bn.default {
  constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {
    super(isU8a(value) ? bitLength <= 48 ? u8aToNumber(value.subarray(0, bitLength / 8), {
      isNegative: isSigned
    }) : u8aToBn(value.subarray(0, bitLength / 8), {
      isLe: true,
      isNegative: isSigned
    }).toString() : decodeAbstractInt(value, isSigned));
    __privateAdd(this, _bitLength, void 0);
    this.registry = registry;
    __privateSet(this, _bitLength, bitLength);
    this.encodedLength = __privateGet(this, _bitLength) / 8;
    this.isUnsigned = !isSigned;
    const isNegative = this.isNeg();
    const maxBits = bitLength - (isSigned && !isNegative ? 1 : 0);
    if (isNegative && !isSigned) {
      throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);
    } else if (super.bitLength() > maxBits) {
      throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);
    }
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.isZero();
  }
  bitLength() {
    return __privateGet(this, _bitLength);
  }
  eq(other) {
    return super.eq(isHex(other) ? hexToBn(other.toString(), {
      isLe: false,
      isNegative: !this.isUnsigned
    }) : bnToBn(other));
  }
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  isMax() {
    const u8a = this.toU8a().filter((b) => b === 255);
    return u8a.length === __privateGet(this, _bitLength) / 8;
  }
  toBigInt() {
    return BigInt(this.toString());
  }
  toBn() {
    return this;
  }
  toHex(isLe = false) {
    return bnToHex(this, {
      bitLength: this.bitLength(),
      isLe,
      isNegative: !this.isUnsigned
    });
  }
  toHuman(isExpanded) {
    const rawType = this.toRawType();
    if (rawType === "Balance") {
      return this.isMax() ? "everything" : formatBalance(this, {
        decimals: this.registry.chainDecimals[0],
        withSi: true,
        withUnit: this.registry.chainTokens[0]
      });
    }
    const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];
    return divisor ? toPercentage(this, divisor) : formatNumber(this);
  }
  toJSON(onlyHex = false) {
    return onlyHex || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();
  }
  toPrimitive() {
    return super.bitLength() > MAX_NUMBER_BITS ? this.toString() : this.toNumber();
  }
  toRawType() {
    return this instanceof this.registry.createClassUnsafe("Balance") ? "Balance" : `${this.isUnsigned ? "u" : "i"}${this.bitLength()}`;
  }
  toString(base) {
    return super.toString(base);
  }
  toU8a(isBare) {
    return bnToU8a(this, {
      bitLength: this.bitLength(),
      isLe: true,
      isNegative: !this.isUnsigned
    });
  }
};
_bitLength = new WeakMap();

// node_modules/@polkadot/types-codec/utils/compareMap.js
function hasMismatch(a, b) {
  return isUndefined(a) || (hasEq(a) ? !a.eq(b) : a !== b);
}
function notEntry(value) {
  return !Array.isArray(value) || value.length !== 2;
}
function compareMapArray(a, b) {
  return a.size === b.length && !b.some((e) => notEntry(e) || hasMismatch(a.get(e[0]), e[1]));
}
function compareMap(a, b) {
  if (Array.isArray(b)) {
    return compareMapArray(a, b);
  } else if (b instanceof Map) {
    return compareMapArray(a, [...b.entries()]);
  } else if (isObject(b)) {
    return compareMapArray(a, Object.entries(b));
  }
  return false;
}

// node_modules/@polkadot/types-codec/utils/compareSet.js
function compareSetArray(a, b) {
  return a.size === b.length && !b.some((e) => !a.has(e));
}
function compareSet(a, b) {
  if (Array.isArray(b)) {
    return compareSetArray(a, b);
  } else if (b instanceof Set) {
    return compareSetArray(a, [...b.values()]);
  } else if (isObject(b)) {
    return compareSetArray(a, Object.values(b));
  }
  return false;
}

// node_modules/@polkadot/types-codec/utils/decodeU8a.js
function formatFailure(registry, fn, result, {
  message
}, u8a, i, count2, Type2, key) {
  let type = "";
  try {
    type = `: ${new Type2(registry).toRawType()}`;
  } catch {
  }
  return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}\u2026${key ? ` on ${key}` : ""} (index ${i + 1}/${count2})${type}:: ${message}`;
}
function decodeU8a(registry, result, u8a, [Types, keys2]) {
  const count2 = result.length;
  let offset = 0;
  let i = 0;
  try {
    while (i < count2) {
      const value = new Types[i](registry, u8a.subarray(offset));
      offset += value.initialU8aLength || value.encodedLength;
      result[i] = value;
      i++;
    }
  } catch (error) {
    throw new Error(formatFailure(registry, "decodeU8a", result, error, u8a.subarray(offset), i, count2, Types[i], keys2[i]));
  }
  return [result, offset];
}
function decodeU8aStruct(registry, result, u8a, [Types, keys2]) {
  const count2 = result.length;
  let offset = 0;
  let i = 0;
  try {
    while (i < count2) {
      const value = new Types[i](registry, u8a.subarray(offset));
      offset += value.initialU8aLength || value.encodedLength;
      result[i] = [keys2[i], value];
      i++;
    }
  } catch (error) {
    throw new Error(formatFailure(registry, "decodeU8aStruct", result, error, u8a.subarray(offset), i, count2, Types[i], keys2[i]));
  }
  return [result, offset];
}
function decodeU8aVec(registry, result, u8a, startAt, Type2) {
  const count2 = result.length;
  let offset = startAt;
  let i = 0;
  try {
    while (i < count2) {
      const value = new Type2(registry, u8a.subarray(offset));
      offset += value.initialU8aLength || value.encodedLength;
      result[i] = value;
      i++;
    }
  } catch (error) {
    throw new Error(formatFailure(registry, "decodeU8aVec", result, error, u8a.subarray(offset), i, count2, Type2));
  }
  return [offset, offset - startAt];
}

// node_modules/@polkadot/types-codec/utils/typeToConstructor.js
function typeToConstructor(registry, type) {
  return isString(type) ? registry.createClassUnsafe(type) : type;
}

// node_modules/@polkadot/types-codec/utils/mapToTypeMap.js
function mapToTypeMap(registry, input) {
  const entries = Object.entries(input);
  const count2 = entries.length;
  const output2 = [new Array(count2), new Array(count2)];
  for (let i = 0; i < count2; i++) {
    output2[1][i] = entries[i][0];
    output2[0][i] = typeToConstructor(registry, entries[i][1]);
  }
  return output2;
}

// node_modules/@polkadot/types-codec/utils/sanitize.js
var BOUNDED = ["BTreeMap", "BTreeSet", "HashMap", "Vec"];
var ALLOWED_BOXES = BOUNDED.concat(["Compact", "DoNotConstruct", "Int", "Linkage", "Range", "RangeInclusive", "Result", "Opaque", "Option", "UInt", "WrapperKeepOpaque", "WrapperOpaque"]);
var BOX_PRECEDING = ["<", "(", "[", '"', ",", " "];
var mappings = [
  alias("<T::InherentOfflineReport as InherentOfflineReport>::Inherent", "InherentOfflineReport", false),
  alias("VecDeque<", "Vec<", false),
  cleanupCompact(),
  removeExtensions("Bounded", true),
  removeExtensions("Weak", false),
  removeTraits(),
  removePairOf(),
  removeWrap("Box<"),
  removeGenerics(),
  alias("String", "Text"),
  alias("Vec<u8>", "Bytes"),
  alias("&\\[u8\\]", "Bytes"),
  alias("&'static\\[u8\\]", "Bytes"),
  alias("RawAddress", "Address"),
  alias("Lookup::Source", "LookupSource"),
  alias("Lookup::Target", "LookupTarget"),
  alias("exec::StorageKey", "ContractStorageKey"),
  flattenSingleTuple(),
  removeColons(),
  trim()
];
function trim() {
  return (value) => value.trim();
}
function findClosing(value, start) {
  let depth = 0;
  for (let index = start; index < value.length; index++) {
    if (value[index] === ">") {
      if (!depth) {
        return index;
      }
      depth--;
    } else if (value[index] === "<") {
      depth++;
    }
  }
  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);
}
function alias(src, dest, withChecks = true) {
  const from2 = new RegExp(`(^${src}|${BOX_PRECEDING.map((box) => `\\${box}${src}`).join("|")})`, "g");
  const to = (src2) => {
    from2.lastIndex = 0;
    return withChecks && BOX_PRECEDING.includes(src2[0]) ? `${src2[0]}${dest}` : dest;
  };
  return (value) => value.replace(from2, to);
}
function cleanupCompact() {
  return (value) => {
    if (value.includes(" as HasCompact")) {
      for (let index = 0; index < value.length; index++) {
        if (value[index] === "<") {
          const end = findClosing(value, index + 1) - 14;
          if (value.substring(end, end + 14) === " as HasCompact") {
            value = `Compact<${value.substring(index + 1, end)}>`;
          }
        }
      }
    }
    return value;
  };
}
function flattenSingleTuple() {
  const from1 = /,\)/g;
  const from2 = /\(([^,]+)\)/;
  return (value) => {
    from1.lastIndex = 0;
    return value.replace(from1, ")").replace(from2, "$1");
  };
}
function replaceTagWith(value, matcher, replacer2) {
  let index = -1;
  while (true) {
    index = value.indexOf(matcher, index + 1);
    if (index === -1) {
      return value;
    }
    const start = index + matcher.length;
    const end = findClosing(value, start);
    value = `${value.substring(0, index)}${replacer2(value.substring(start, end))}${value.substring(end + 1)}`;
  }
}
function removeExtensions(type, isSized) {
  return (value) => {
    for (let i = 0; i < BOUNDED.length; i++) {
      const tag = BOUNDED[i];
      value = replaceTagWith(value, `${type}${tag}<`, (v) => {
        const parts = v.split(",").map((s) => s.trim()).filter((s) => s);
        if (isSized) {
          parts.pop();
        }
        return `${tag}<${parts.join(",")}>`;
      });
    }
    return value;
  };
}
function removeColons() {
  return (value) => {
    let index = 0;
    while (index !== -1) {
      index = value.indexOf("::");
      if (index === 0) {
        value = value.substring(2);
      } else if (index !== -1) {
        let start = index;
        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {
          start--;
        }
        value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;
      }
    }
    return value;
  };
}
function removeGenerics() {
  return (value) => {
    for (let index = 0; index < value.length; index++) {
      if (value[index] === "<") {
        const box = ALLOWED_BOXES.find((box2) => {
          const start = index - box2.length;
          return start >= 0 && value.substring(start, index) === box2 && (start === 0 || BOX_PRECEDING.includes(value[start - 1]));
        });
        if (!box) {
          const end = findClosing(value, index + 1);
          value = `${value.substring(0, index)}${value.substring(end + 1)}`;
        }
      }
    }
    return value;
  };
}
function removePairOf() {
  const replacer2 = (v) => `(${v},${v})`;
  return (value) => replaceTagWith(value, "PairOf<", replacer2);
}
function removeTraits() {
  const from1 = /\s/g;
  const from2 = /(T|Self)::/g;
  const from3 = /<(T|Self)asTrait>::/g;
  const from4 = /<Tas[a-z]+::Trait>::/g;
  const from5 = /<LookupasStaticLookup>/g;
  const from6 = /::Type/g;
  return (value) => {
    from1.lastIndex = 0;
    from2.lastIndex = 0;
    from3.lastIndex = 0;
    from4.lastIndex = 0;
    from5.lastIndex = 0;
    from6.lastIndex = 0;
    return value.replace(from1, "").replace(from2, "").replace(from3, "").replace(from4, "").replace(from5, "Lookup").replace(from6, "");
  };
}
function removeWrap(check) {
  const replacer2 = (v) => v;
  return (value) => replaceTagWith(value, check, replacer2);
}
var sanitizeMap = new Map();
function sanitize(value) {
  const startValue = value.toString();
  const memoized = sanitizeMap.get(startValue);
  if (memoized) {
    return memoized;
  }
  let result = startValue;
  for (let i = 0; i < mappings.length; i++) {
    result = mappings[i](result);
  }
  sanitizeMap.set(startValue, result);
  return result;
}

// node_modules/@polkadot/types-codec/utils/sortValues.js
function isArrayLike2(arg) {
  return arg instanceof Uint8Array || Array.isArray(arg);
}
function isCodec2(arg) {
  return isFunction(arg && arg.toU8a);
}
function isEnum(arg) {
  return isCodec2(arg) && isNumber(arg.index) && isCodec2(arg.value);
}
function isNumberLike(arg) {
  return isNumber(arg) || isBn(arg) || isBigInt(arg);
}
function sortArray(a, b) {
  let sortRes = 0;
  const minLen = Math.min(a.length, b.length);
  for (let i = 0; i < minLen; ++i) {
    sortRes = sortAsc(a[i], b[i]);
    if (sortRes !== 0) {
      return sortRes;
    }
  }
  return a.length - b.length;
}
function sortAsc(a, b) {
  if (isNumberLike(a) && isNumberLike(b)) {
    return bnToBn(a).cmp(bnToBn(b));
  } else if (a instanceof Map && b instanceof Map) {
    return sortAsc(Array.from(a.values()), Array.from(b.values()));
  } else if (isEnum(a) && isEnum(b)) {
    return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);
  } else if (isArrayLike2(a) && isArrayLike2(b)) {
    return sortArray(a, b);
  } else if (isCodec2(a) && isCodec2(b)) {
    return sortAsc(a.toU8a(true), b.toU8a(true));
  }
  throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);
}
function sortSet(set) {
  return new Set(Array.from(set).sort(sortAsc));
}
function sortMap(map3) {
  return new Map(Array.from(map3.entries()).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));
}

// node_modules/@polkadot/types-codec/utils/typesToMap.js
function typesToMap(registry, [Types, keys2]) {
  const result = {};
  for (let i = 0; i < keys2.length; i++) {
    result[keys2[i]] = registry.getClassName(Types[i]) || new Types[i](registry).toRawType();
  }
  return result;
}

// node_modules/@polkadot/types-codec/base/Compact.js
function noopSetDefinition(d) {
  return d;
}
function decodeCompact(registry, Type2, value) {
  if (isU8a(value)) {
    const [decodedLength, bn] = (value[0] & 3) < 3 ? compactFromU8aLim(value) : compactFromU8a(value);
    return [new Type2(registry, bn), decodedLength];
  } else if (value instanceof Compact) {
    const raw = value.unwrap();
    return raw instanceof Type2 ? [raw, 0] : [new Type2(registry, raw), 0];
  } else if (value instanceof Type2) {
    return [value, 0];
  }
  return [new Type2(registry, value), 0];
}
var _Type, _raw2;
var _Compact = class {
  constructor(registry, Type2, value = 0, {
    definition,
    setDefinition = noopSetDefinition
  } = {}) {
    __privateAdd(this, _Type, void 0);
    __privateAdd(this, _raw2, void 0);
    this.registry = registry;
    __privateSet(this, _Type, definition || setDefinition(typeToConstructor(registry, Type2)));
    const [raw, decodedLength] = decodeCompact(registry, __privateGet(this, _Type), value);
    this.initialU8aLength = decodedLength;
    __privateSet(this, _raw2, raw);
  }
  static with(Type2) {
    let definition;
    const setDefinition = (d) => definition = d;
    return class extends _Compact {
      constructor(registry, value) {
        super(registry, Type2, value, {
          definition,
          setDefinition
        });
      }
    };
  }
  get encodedLength() {
    return this.toU8a().length;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return __privateGet(this, _raw2).isEmpty;
  }
  bitLength() {
    return __privateGet(this, _raw2).bitLength();
  }
  eq(other) {
    return __privateGet(this, _raw2).eq(other instanceof _Compact ? __privateGet(other, _raw2) : other);
  }
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  toBigInt() {
    return __privateGet(this, _raw2).toBigInt();
  }
  toBn() {
    return __privateGet(this, _raw2).toBn();
  }
  toHex(isLe) {
    return __privateGet(this, _raw2).toHex(isLe);
  }
  toHuman(isExtended) {
    return __privateGet(this, _raw2).toHuman(isExtended);
  }
  toJSON() {
    return __privateGet(this, _raw2).toJSON();
  }
  toNumber() {
    return __privateGet(this, _raw2).toNumber();
  }
  toPrimitive() {
    return __privateGet(this, _raw2).toPrimitive();
  }
  toRawType() {
    return `Compact<${this.registry.getClassName(__privateGet(this, _Type)) || __privateGet(this, _raw2).toRawType()}>`;
  }
  toString() {
    return __privateGet(this, _raw2).toString();
  }
  toU8a(isBare) {
    return compactToU8a(__privateGet(this, _raw2).toBn());
  }
  unwrap() {
    return __privateGet(this, _raw2);
  }
};
var Compact = _Compact;
_Type = new WeakMap();
_raw2 = new WeakMap();

// node_modules/@polkadot/types-codec/base/DoNotConstruct.js
var _neverError;
var _DoNotConstruct = class {
  constructor(registry, typeName = "DoNotConstruct") {
    __privateAdd(this, _neverError, void 0);
    this.registry = registry;
    __privateSet(this, _neverError, new Error(`DoNotConstruct: Cannot construct unknown type ${typeName}`));
    throw __privateGet(this, _neverError);
  }
  static with(typeName) {
    return class extends _DoNotConstruct {
      constructor(registry) {
        super(registry, typeName);
      }
    };
  }
  get encodedLength() {
    throw __privateGet(this, _neverError);
  }
  get hash() {
    throw __privateGet(this, _neverError);
  }
  get isEmpty() {
    throw __privateGet(this, _neverError);
  }
  eq() {
    throw __privateGet(this, _neverError);
  }
  inspect() {
    throw __privateGet(this, _neverError);
  }
  toHex() {
    throw __privateGet(this, _neverError);
  }
  toHuman() {
    throw __privateGet(this, _neverError);
  }
  toJSON() {
    throw __privateGet(this, _neverError);
  }
  toPrimitive() {
    throw __privateGet(this, _neverError);
  }
  toRawType() {
    throw __privateGet(this, _neverError);
  }
  toString() {
    throw __privateGet(this, _neverError);
  }
  toU8a() {
    throw __privateGet(this, _neverError);
  }
};
var DoNotConstruct = _DoNotConstruct;
_neverError = new WeakMap();

// node_modules/@polkadot/types-codec/base/Null.js
var Null = class {
  constructor(registry) {
    __publicField(this, "encodedLength", 0);
    __publicField(this, "isEmpty", true);
    __publicField(this, "initialU8aLength", 0);
    this.registry = registry;
  }
  get hash() {
    throw new Error(".hash is not implemented on Null");
  }
  eq(other) {
    return other instanceof Null || isNull(other);
  }
  inspect() {
    return {};
  }
  toHex() {
    return "0x";
  }
  toHuman() {
    return this.toJSON();
  }
  toJSON() {
    return null;
  }
  toPrimitive() {
    return null;
  }
  toRawType() {
    return "Null";
  }
  toString() {
    return "";
  }
  toU8a(isBare) {
    return new Uint8Array();
  }
};

// node_modules/@polkadot/types-codec/base/Enum.js
function noopSetDefinition2(d) {
  return d;
}
function isRustEnum(def) {
  const defValues = Object.values(def);
  if (defValues.some((v) => isNumber(v))) {
    if (!defValues.every((v) => isNumber(v) && v >= 0 && v <= 255)) {
      throw new Error("Invalid number-indexed enum definition");
    }
    return false;
  }
  return true;
}
function extractDef(registry, _def2) {
  const def = {};
  let isBasic;
  let isIndexed;
  if (Array.isArray(_def2)) {
    for (let i = 0; i < _def2.length; i++) {
      def[_def2[i]] = {
        Type: Null,
        index: i
      };
    }
    isBasic = true;
    isIndexed = false;
  } else if (isRustEnum(_def2)) {
    const [Types, keys2] = mapToTypeMap(registry, _def2);
    for (let i = 0; i < keys2.length; i++) {
      def[keys2[i]] = {
        Type: Types[i],
        index: i
      };
    }
    isBasic = !Object.values(def).some(({
      Type: Type2
    }) => Type2 !== Null);
    isIndexed = false;
  } else {
    const entries = Object.entries(_def2);
    for (let i = 0; i < entries.length; i++) {
      const [key, index] = entries[i];
      def[key] = {
        Type: Null,
        index
      };
    }
    isBasic = true;
    isIndexed = true;
  }
  return {
    def,
    isBasic,
    isIndexed
  };
}
function getEntryType(def, checkIdx) {
  const values = Object.values(def);
  for (let i = 0; i < values.length; i++) {
    const {
      Type: Type2,
      index
    } = values[i];
    if (index === checkIdx) {
      return Type2;
    }
  }
  throw new Error(`Unable to create Enum via index ${checkIdx}, in ${Object.keys(def).join(", ")}`);
}
function createFromU8a(registry, def, index, value) {
  const Type2 = getEntryType(def, index);
  return {
    index,
    value: new Type2(registry, value)
  };
}
function createFromValue(registry, def, index = 0, value) {
  const Type2 = getEntryType(def, index);
  return {
    index,
    value: value instanceof Type2 ? value : new Type2(registry, value)
  };
}
function decodeFromJSON(registry, def, key, value) {
  const keys2 = Object.keys(def).map((k) => k.toLowerCase());
  const keyLower = key.toLowerCase();
  const index = keys2.indexOf(keyLower);
  if (index === -1) {
    throw new Error(`Cannot map Enum JSON, unable to find '${key}' in ${keys2.join(", ")}`);
  }
  try {
    return createFromValue(registry, def, Object.values(def)[index].index, value);
  } catch (error) {
    throw new Error(`Enum(${key}):: ${error.message}`);
  }
}
function decodeEnum(registry, def, value, index) {
  if (isNumber(index)) {
    return createFromValue(registry, def, index, value);
  } else if (isU8a(value) || isHex(value)) {
    const u8a = u8aToU8a(value);
    if (u8a.length) {
      return createFromU8a(registry, def, u8a[0], u8a.subarray(1));
    }
  } else if (value instanceof Enum) {
    return createFromValue(registry, def, value.index, value.value);
  } else if (isNumber(value)) {
    return createFromValue(registry, def, value);
  } else if (isString(value)) {
    return decodeFromJSON(registry, def, value.toString());
  } else if (isObject(value)) {
    const key = Object.keys(value)[0];
    return decodeFromJSON(registry, def, key, value[key]);
  }
  return createFromValue(registry, def, Object.values(def)[0].index);
}
var _def, _entryIndex, _indexes, _isBasic, _isIndexed, _raw3;
var _Enum = class {
  constructor(registry, Types, value, index, {
    definition,
    setDefinition = noopSetDefinition2
  } = {}) {
    __privateAdd(this, _def, void 0);
    __privateAdd(this, _entryIndex, void 0);
    __privateAdd(this, _indexes, void 0);
    __privateAdd(this, _isBasic, void 0);
    __privateAdd(this, _isIndexed, void 0);
    __privateAdd(this, _raw3, void 0);
    const {
      def,
      isBasic,
      isIndexed
    } = definition || setDefinition(extractDef(registry, Types));
    const decoded = isU8a(value) && value.length && !isNumber(index) ? createFromU8a(registry, def, value[0], value.subarray(1)) : decodeEnum(registry, def, value, index);
    this.registry = registry;
    __privateSet(this, _def, def);
    __privateSet(this, _isBasic, isBasic);
    __privateSet(this, _isIndexed, isIndexed);
    __privateSet(this, _indexes, Object.values(def).map(({
      index: index2
    }) => index2));
    __privateSet(this, _entryIndex, __privateGet(this, _indexes).indexOf(decoded.index));
    __privateSet(this, _raw3, decoded.value);
    if (__privateGet(this, _raw3).initialU8aLength) {
      this.initialU8aLength = 1 + __privateGet(this, _raw3).initialU8aLength;
    }
  }
  static with(Types) {
    var _class;
    let definition;
    const setDefinition = (d) => definition = d;
    return _class = class extends _Enum {
      constructor(registry, value, index) {
        super(registry, Types, value, index, {
          definition,
          setDefinition
        });
      }
    }, (() => {
      const keys2 = Array.isArray(Types) ? Types : Object.keys(Types);
      const asKeys = new Array(keys2.length);
      const isKeys = new Array(keys2.length);
      for (let i = 0; i < keys2.length; i++) {
        const name = stringPascalCase(keys2[i]);
        asKeys[i] = `as${name}`;
        isKeys[i] = `is${name}`;
      }
      objectProperties(_class.prototype, isKeys, (_, i, self2) => self2.type === keys2[i]);
      objectProperties(_class.prototype, asKeys, (k, i, self2) => {
        if (self2.type !== keys2[i]) {
          throw new Error(`Cannot convert '${self2.type}' via ${k}`);
        }
        return self2.value;
      });
    })(), _class;
  }
  get encodedLength() {
    return 1 + __privateGet(this, _raw3).encodedLength;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get index() {
    return __privateGet(this, _indexes)[__privateGet(this, _entryIndex)];
  }
  get inner() {
    return __privateGet(this, _raw3);
  }
  get isBasic() {
    return __privateGet(this, _isBasic);
  }
  get isEmpty() {
    return __privateGet(this, _raw3).isEmpty;
  }
  get isNone() {
    return __privateGet(this, _raw3) instanceof Null;
  }
  get defIndexes() {
    return __privateGet(this, _indexes);
  }
  get defKeys() {
    return Object.keys(__privateGet(this, _def));
  }
  get type() {
    return this.defKeys[__privateGet(this, _entryIndex)];
  }
  get value() {
    return __privateGet(this, _raw3);
  }
  eq(other) {
    if (isU8a(other)) {
      return !this.toU8a().some((entry, index) => entry !== other[index]);
    } else if (isNumber(other)) {
      return this.toNumber() === other;
    } else if (__privateGet(this, _isBasic) && isString(other)) {
      return this.type === other;
    } else if (isHex(other)) {
      return this.toHex() === other;
    } else if (other instanceof _Enum) {
      return this.index === other.index && this.value.eq(other.value);
    } else if (isObject(other)) {
      return this.value.eq(other[this.type]);
    }
    return this.value.eq(other);
  }
  inspect() {
    if (__privateGet(this, _isBasic)) {
      return {
        outer: [new Uint8Array([this.index])]
      };
    }
    const {
      inner,
      outer = []
    } = __privateGet(this, _raw3).inspect();
    return {
      inner,
      outer: [new Uint8Array([this.index]), ...outer]
    };
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman(isExtended) {
    return __privateGet(this, _isBasic) || this.isNone ? this.type : {
      [this.type]: __privateGet(this, _raw3).toHuman(isExtended)
    };
  }
  toJSON() {
    return __privateGet(this, _isBasic) ? this.type : {
      [stringCamelCase(this.type)]: __privateGet(this, _raw3).toJSON()
    };
  }
  toNumber() {
    return this.index;
  }
  toPrimitive() {
    return __privateGet(this, _isBasic) ? this.type : {
      [stringCamelCase(this.type)]: __privateGet(this, _raw3).toPrimitive()
    };
  }
  _toRawStruct() {
    if (__privateGet(this, _isBasic)) {
      return __privateGet(this, _isIndexed) ? this.defKeys.reduce((out, key, index) => {
        out[key] = __privateGet(this, _indexes)[index];
        return out;
      }, {}) : this.defKeys;
    }
    const entries = Object.entries(__privateGet(this, _def));
    return typesToMap(this.registry, entries.reduce((out, [key, {
      Type: Type2
    }], i) => {
      out[0][i] = Type2;
      out[1][i] = key;
      return out;
    }, [new Array(entries.length), new Array(entries.length)]));
  }
  toRawType() {
    return stringify({
      _enum: this._toRawStruct()
    });
  }
  toString() {
    return this.isNone ? this.type : stringify(this.toJSON());
  }
  toU8a(isBare) {
    return isBare ? __privateGet(this, _raw3).toU8a(isBare) : u8aConcatStrict([new Uint8Array([this.index]), __privateGet(this, _raw3).toU8a(isBare)]);
  }
};
var Enum = _Enum;
_def = new WeakMap();
_entryIndex = new WeakMap();
_indexes = new WeakMap();
_isBasic = new WeakMap();
_isIndexed = new WeakMap();
_raw3 = new WeakMap();

// node_modules/@polkadot/types-codec/base/Int.js
var Int = class extends AbstractInt {
  constructor(registry, value = 0, bitLength) {
    super(registry, value, bitLength, true);
  }
  static with(bitLength, typeName) {
    return class extends Int {
      constructor(registry, value) {
        super(registry, value, bitLength);
      }
      toRawType() {
        return typeName || super.toRawType();
      }
    };
  }
};

// node_modules/@polkadot/types-codec/base/Option.js
function noopSetDefinition3(d) {
  return d;
}
var None = class extends Null {
  toRawType() {
    return "None";
  }
};
function decodeOption(registry, Type2, value) {
  if (value instanceof Type2) {
    return value;
  } else if (value instanceof Option) {
    if (value.value instanceof Type2) {
      return value.value;
    } else if (value.isNone) {
      return new None(registry);
    }
    return new Type2(registry, value.value);
  } else if (isNull(value) || isUndefined(value) || value === "0x" || value instanceof None) {
    return new None(registry);
  } else if (isU8a(value)) {
    return !value.length || value[0] === 0 ? new None(registry) : new Type2(registry, value.subarray(1));
  }
  return new Type2(registry, value);
}
var _Type2, _raw4;
var _Option = class {
  constructor(registry, typeName, value, {
    definition,
    setDefinition = noopSetDefinition3
  } = {}) {
    __privateAdd(this, _Type2, void 0);
    __privateAdd(this, _raw4, void 0);
    const Type2 = definition || setDefinition(typeToConstructor(registry, typeName));
    const decoded = isU8a(value) && value.length && !isCodec(value) ? value[0] === 0 ? new None(registry) : new Type2(registry, value.subarray(1)) : decodeOption(registry, Type2, value);
    this.registry = registry;
    __privateSet(this, _Type2, Type2);
    __privateSet(this, _raw4, decoded);
    if (decoded && decoded.initialU8aLength) {
      this.initialU8aLength = 1 + decoded.initialU8aLength;
    }
  }
  static with(Type2) {
    let definition;
    const setDefinition = (d) => {
      definition = d;
      return d;
    };
    return class extends _Option {
      constructor(registry, value) {
        super(registry, Type2, value, {
          definition,
          setDefinition
        });
      }
    };
  }
  get encodedLength() {
    return 1 + __privateGet(this, _raw4).encodedLength;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.isNone;
  }
  get isNone() {
    return __privateGet(this, _raw4) instanceof None;
  }
  get isSome() {
    return !this.isNone;
  }
  get value() {
    return __privateGet(this, _raw4);
  }
  eq(other) {
    if (other instanceof _Option) {
      return this.isSome === other.isSome && this.value.eq(other.value);
    }
    return this.value.eq(other);
  }
  inspect() {
    if (this.isNone) {
      return {
        outer: [new Uint8Array([0])]
      };
    }
    const {
      inner,
      outer = []
    } = __privateGet(this, _raw4).inspect();
    return {
      inner,
      outer: [new Uint8Array([1]), ...outer]
    };
  }
  toHex() {
    return this.isNone ? "0x" : u8aToHex(this.toU8a().subarray(1));
  }
  toHuman(isExtended) {
    return __privateGet(this, _raw4).toHuman(isExtended);
  }
  toJSON() {
    return this.isNone ? null : __privateGet(this, _raw4).toJSON();
  }
  toPrimitive() {
    return this.isNone ? null : __privateGet(this, _raw4).toPrimitive();
  }
  toRawType(isBare) {
    const wrapped = this.registry.getClassName(__privateGet(this, _Type2)) || new (__privateGet(this, _Type2))(this.registry).toRawType();
    return isBare ? wrapped : `Option<${wrapped}>`;
  }
  toString() {
    return __privateGet(this, _raw4).toString();
  }
  toU8a(isBare) {
    if (isBare) {
      return __privateGet(this, _raw4).toU8a(true);
    }
    const u8a = new Uint8Array(this.encodedLength);
    if (this.isSome) {
      u8a.set([1]);
      u8a.set(__privateGet(this, _raw4).toU8a(), 1);
    }
    return u8a;
  }
  unwrap() {
    if (this.isNone) {
      throw new Error("Option: unwrapping a None value");
    }
    return __privateGet(this, _raw4);
  }
  unwrapOr(defaultValue) {
    return this.isSome ? this.unwrap() : defaultValue;
  }
  unwrapOrDefault() {
    return this.isSome ? this.unwrap() : new (__privateGet(this, _Type2))(this.registry);
  }
};
var Option = _Option;
_Type2 = new WeakMap();
_raw4 = new WeakMap();

// node_modules/@polkadot/types-codec/base/Result.js
var Result = class extends Enum {
  constructor(registry, Ok, Err, value) {
    super(registry, {
      Ok,
      Err
    }, value);
  }
  static with(Types) {
    return class extends Result {
      constructor(registry, value) {
        super(registry, Types.Ok, Types.Err, value);
      }
    };
  }
  get asErr() {
    if (!this.isErr) {
      throw new Error("Cannot extract Err value from Ok result, check isErr first");
    }
    return this.value;
  }
  get asOk() {
    if (!this.isOk) {
      throw new Error("Cannot extract Ok value from Err result, check isOk first");
    }
    return this.value;
  }
  get isEmpty() {
    return this.isOk && this.value.isEmpty;
  }
  get isErr() {
    return !this.isOk;
  }
  get isOk() {
    return this.index === 0;
  }
  toRawType() {
    const Types = this._toRawStruct();
    return `Result<${Types.Ok},${Types.Err}>`;
  }
};

// node_modules/@polkadot/types-codec/base/Tuple.js
function noopSetDefinition4(d) {
  return d;
}
function decodeTuple(registry, result, value, Classes) {
  if (isU8a(value) || isHex(value)) {
    return decodeU8a(registry, result, u8aToU8a(value), Classes);
  }
  const Types = Classes[0];
  for (let i = 0; i < Types.length; i++) {
    try {
      const entry = value == null ? void 0 : value[i];
      result[i] = entry instanceof Types[i] ? entry : new Types[i](registry, entry);
    } catch (error) {
      throw new Error(`Tuple: failed on ${i}:: ${error.message}`);
    }
  }
  return [result, 0];
}
var _Types;
var _Tuple = class extends AbstractArray {
  constructor(registry, Types, value, {
    definition,
    setDefinition = noopSetDefinition4
  } = {}) {
    const Classes = definition || setDefinition(Array.isArray(Types) ? [Types.map((t) => typeToConstructor(registry, t)), []] : isFunction(Types) || isString(Types) ? [[typeToConstructor(registry, Types)], []] : mapToTypeMap(registry, Types));
    super(registry, Classes[0].length);
    __privateAdd(this, _Types, void 0);
    this.initialU8aLength = (isU8a(value) ? decodeU8a(registry, this, value, Classes) : decodeTuple(registry, this, value, Classes))[1];
    __privateSet(this, _Types, Classes);
  }
  static with(Types) {
    let definition;
    const setDefinition = (d) => definition = d;
    return class extends _Tuple {
      constructor(registry, value) {
        super(registry, Types, value, {
          definition,
          setDefinition
        });
      }
    };
  }
  get encodedLength() {
    let total = 0;
    for (let i = 0; i < this.length; i++) {
      total += this[i].encodedLength;
    }
    return total;
  }
  get Types() {
    return __privateGet(this, _Types)[1].length ? __privateGet(this, _Types)[1] : __privateGet(this, _Types)[0].map((T) => new T(this.registry).toRawType());
  }
  inspect() {
    return {
      inner: this.inspectInner()
    };
  }
  toRawType() {
    const types2 = __privateGet(this, _Types)[0].map((T) => this.registry.getClassName(T) || new T(this.registry).toRawType());
    return `(${types2.join(",")})`;
  }
  toString() {
    return stringify(this.toJSON());
  }
  toU8a(isBare) {
    return u8aConcatStrict(this.toU8aInner(isBare));
  }
};
var Tuple = _Tuple;
_Types = new WeakMap();

// node_modules/@polkadot/types-codec/base/UInt.js
var UInt = class extends AbstractInt {
  static with(bitLength, typeName) {
    return class extends UInt {
      constructor(registry, value) {
        super(registry, value, bitLength);
      }
      toRawType() {
        return typeName || super.toRawType();
      }
    };
  }
};

// node_modules/@polkadot/types-codec/base/Vec.js
var MAX_LENGTH = 64 * 1024;
var l5 = logger("Vec");
function noopSetDefinition5(d) {
  return d;
}
function decodeVecLength(value) {
  if (Array.isArray(value)) {
    return [value, value.length, 0];
  }
  const u8a = u8aToU8a(value);
  const [startAt, length] = compactFromU8aLim(u8a);
  if (length > MAX_LENGTH) {
    throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);
  }
  return [u8a, length, startAt];
}
function decodeVec(registry, result, value, startAt, Type2) {
  if (Array.isArray(value)) {
    const count2 = result.length;
    for (let i = 0; i < count2; i++) {
      const entry = value[i];
      try {
        result[i] = entry instanceof Type2 ? entry : new Type2(registry, entry);
      } catch (error) {
        l5.error(`Unable to decode on index ${i}`, error.message);
        throw error;
      }
    }
    return [0, 0];
  }
  return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type2);
}
var _Type3;
var _Vec = class extends AbstractArray {
  constructor(registry, Type2, value = [], {
    definition,
    setDefinition = noopSetDefinition5
  } = {}) {
    const [decodeFrom, length, startAt] = decodeVecLength(value);
    super(registry, length);
    __privateAdd(this, _Type3, void 0);
    __privateSet(this, _Type3, definition || setDefinition(typeToConstructor(registry, Type2)));
    this.initialU8aLength = (isU8a(decodeFrom) ? decodeU8aVec(registry, this, decodeFrom, startAt, __privateGet(this, _Type3)) : decodeVec(registry, this, decodeFrom, startAt, __privateGet(this, _Type3)))[0];
  }
  static with(Type2) {
    let definition;
    const setDefinition = (d) => definition = d;
    return class extends _Vec {
      constructor(registry, value) {
        super(registry, Type2, value, {
          definition,
          setDefinition
        });
      }
    };
  }
  get Type() {
    return __privateGet(this, _Type3).name;
  }
  indexOf(_other) {
    const other = _other instanceof __privateGet(this, _Type3) ? _other : new (__privateGet(this, _Type3))(this.registry, _other);
    for (let i = 0; i < this.length; i++) {
      if (other.eq(this[i])) {
        return i;
      }
    }
    return -1;
  }
  toRawType() {
    return `Vec<${this.registry.getClassName(__privateGet(this, _Type3)) || new (__privateGet(this, _Type3))(this.registry).toRawType()}>`;
  }
};
var Vec = _Vec;
_Type3 = new WeakMap();

// node_modules/@polkadot/types-codec/base/VecFixed.js
function noopSetDefinition6(d) {
  return d;
}
var _Type4;
var _VecFixed = class extends AbstractArray {
  constructor(registry, Type2, length, value = [], {
    definition,
    setDefinition = noopSetDefinition6
  } = {}) {
    super(registry, length);
    __privateAdd(this, _Type4, void 0);
    __privateSet(this, _Type4, definition || setDefinition(typeToConstructor(registry, Type2)));
    this.initialU8aLength = (isU8a(value) ? decodeU8aVec(registry, this, value, 0, __privateGet(this, _Type4)) : decodeVec(registry, this, value, 0, __privateGet(this, _Type4)))[1];
  }
  static with(Type2, length) {
    let definition;
    const setDefinition = (d) => definition = d;
    return class extends _VecFixed {
      constructor(registry, value) {
        super(registry, Type2, length, value, {
          definition,
          setDefinition
        });
      }
    };
  }
  get Type() {
    return new (__privateGet(this, _Type4))(this.registry).toRawType();
  }
  get encodedLength() {
    let total = 0;
    for (let i = 0; i < this.length; i++) {
      total += this[i].encodedLength;
    }
    return total;
  }
  inspect() {
    return {
      inner: this.inspectInner()
    };
  }
  toU8a() {
    const encoded = this.toU8aInner();
    return encoded.length ? u8aConcatStrict(encoded) : new Uint8Array([]);
  }
  toRawType() {
    return `[${this.Type};${this.length}]`;
  }
};
var VecFixed = _VecFixed;
_Type4 = new WeakMap();

// node_modules/@polkadot/types-codec/native/Raw.js
var Raw = class extends Uint8Array {
  static get [Symbol.species]() {
    return Uint8Array;
  }
  constructor(registry, value, initialU8aLength) {
    super(u8aToU8a(value));
    this.registry = registry;
    this.initialU8aLength = initialU8aLength;
  }
  get encodedLength() {
    return this.length;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isAscii() {
    return isAscii(this);
  }
  get isEmpty() {
    return !this.length || isUndefined(this.find((b) => !!b));
  }
  get isUtf8() {
    return isUtf8(this);
  }
  bitLength() {
    return this.length * 8;
  }
  eq(other) {
    if (other instanceof Uint8Array) {
      return this.length === other.length && !this.some((b, index) => b !== other[index]);
    }
    return this.eq(u8aToU8a(other));
  }
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  toHex() {
    return u8aToHex(this);
  }
  toHuman() {
    return this.toPrimitive();
  }
  toJSON() {
    return this.toHex();
  }
  toPrimitive() {
    if (this.isAscii) {
      const text = this.toUtf8();
      if (isAscii(text)) {
        return text;
      }
    }
    return this.toJSON();
  }
  toRawType() {
    return "Raw";
  }
  toString() {
    return this.toHex();
  }
  toU8a(isBare) {
    return Uint8Array.from(this);
  }
  toUtf8() {
    if (!this.isUtf8) {
      throw new Error("The character sequence is not a valid Utf8 string");
    }
    return u8aToString(this);
  }
};

// node_modules/@polkadot/types-codec/extended/BitVec.js
function decodeBitVecU8a(value) {
  if (!value || !value.length) {
    return [0, new Uint8Array()];
  }
  const [offset, length] = compactFromU8aLim(value);
  const total = offset + Math.ceil(length / 8);
  if (total > value.length) {
    throw new Error(`BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);
  }
  return [length, value.subarray(offset, total)];
}
function decodeBitVec(value) {
  if (Array.isArray(value) || isString(value)) {
    const u8a = u8aToU8a(value);
    return [u8a.length / 8, u8a];
  }
  return decodeBitVecU8a(value);
}
var _decodedLength, _isMsb;
var BitVec = class extends Raw {
  constructor(registry, value, isMsb = false) {
    const [decodedLength, u8a] = decodeBitVec(value);
    super(registry, u8a);
    __privateAdd(this, _decodedLength, void 0);
    __privateAdd(this, _isMsb, void 0);
    __privateSet(this, _decodedLength, decodedLength);
    __privateSet(this, _isMsb, isMsb);
  }
  get encodedLength() {
    return this.length + compactToU8a(__privateGet(this, _decodedLength)).length;
  }
  inspect() {
    return {
      outer: [compactToU8a(__privateGet(this, _decodedLength)), super.toU8a()]
    };
  }
  toHuman() {
    return `0b${[...this.toU8a(true)].map((d) => `00000000${d.toString(2)}`.slice(-8)).map((s) => __privateGet(this, _isMsb) ? s : s.split("").reverse().join("")).join("_")}`;
  }
  toRawType() {
    return "BitVec";
  }
  toU8a(isBare) {
    const bitVec = super.toU8a();
    return isBare ? bitVec : u8aConcatStrict([compactToU8a(__privateGet(this, _decodedLength)), bitVec]);
  }
};
_decodedLength = new WeakMap();
_isMsb = new WeakMap();

// node_modules/@polkadot/types-codec/native/Struct.js
function noopSetDefinition7(d) {
  return d;
}
function decodeStructFromObject(registry, [Types, keys2], value, jsonMap) {
  let jsonObj;
  const typeofArray = Array.isArray(value);
  const typeofMap = value instanceof Map;
  if (!typeofArray && !typeofMap && !isObject(value)) {
    throw new Error(`Struct: Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object, map or array`);
  } else if (typeofArray && value.length !== keys2.length) {
    throw new Error(`Struct: Unable to map ${stringify(value)} array to object with known keys ${keys2.join(", ")}`);
  }
  const raw = new Array(keys2.length);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const jsonKey = jsonMap.get(key) || key;
    const Type2 = Types[i];
    let assign;
    try {
      if (typeofArray) {
        assign = value[i];
      } else if (typeofMap) {
        assign = jsonKey && value.get(jsonKey);
      } else {
        assign = jsonKey && value[jsonKey];
        if (isUndefined(assign)) {
          if (isUndefined(jsonObj)) {
            const entries = Object.entries(value);
            jsonObj = {};
            for (let e = 0; e < entries.length; e++) {
              jsonObj[stringCamelCase(entries[e][0])] = entries[e][1];
            }
          }
          assign = jsonKey && jsonObj[jsonKey];
        }
      }
      raw[i] = [key, assign instanceof Type2 ? assign : new Type2(registry, assign)];
    } catch (error) {
      let type = Type2.name;
      try {
        type = new Type2(registry).toRawType();
      } catch (error2) {
      }
      throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);
    }
  }
  return [raw, 0];
}
var _jsonMap, _Types2;
var _Struct = class extends Map {
  constructor(registry, Types, value, jsonMap = new Map(), {
    definition,
    setDefinition = noopSetDefinition7
  } = {}) {
    const typeMap = definition || setDefinition(mapToTypeMap(registry, Types));
    const [decoded, decodedLength] = isU8a(value) || isHex(value) ? decodeU8aStruct(registry, new Array(typeMap[0].length), u8aToU8a(value), typeMap) : value instanceof _Struct ? [value, 0] : decodeStructFromObject(registry, typeMap, value || {}, jsonMap);
    super(decoded);
    __privateAdd(this, _jsonMap, void 0);
    __privateAdd(this, _Types2, void 0);
    this.initialU8aLength = decodedLength;
    this.registry = registry;
    __privateSet(this, _jsonMap, jsonMap);
    __privateSet(this, _Types2, typeMap);
  }
  static with(Types, jsonMap) {
    var _class;
    let definition;
    const setDefinition = (d) => definition = d;
    return _class = class extends _Struct {
      constructor(registry, value) {
        super(registry, Types, value, jsonMap, {
          definition,
          setDefinition
        });
      }
    }, (() => {
      const keys2 = Object.keys(Types);
      objectProperties(_class.prototype, keys2, (k, _, self2) => self2.get(k));
    })(), _class;
  }
  get defKeys() {
    return __privateGet(this, _Types2)[1];
  }
  get isEmpty() {
    for (const v of this.values()) {
      if (!v.isEmpty) {
        return false;
      }
    }
    return true;
  }
  get encodedLength() {
    let total = 0;
    for (const v of this.values()) {
      total += v.encodedLength;
    }
    return total;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get Type() {
    const result = {};
    const [Types, keys2] = __privateGet(this, _Types2);
    for (let i = 0; i < keys2.length; i++) {
      result[keys2[i]] = new Types[i](this.registry).toRawType();
    }
    return result;
  }
  eq(other) {
    return compareMap(this, other);
  }
  get(key) {
    return super.get(key);
  }
  getAtIndex(index) {
    return this.toArray()[index];
  }
  getT(key) {
    return super.get(key);
  }
  inspect(isBare) {
    const inner = new Array();
    for (const [k, v] of this.entries()) {
      inner.push(__spreadProps(__spreadValues({}, v.inspect(!isBare || isBoolean(isBare) ? isBare : isBare[k])), {
        name: stringCamelCase(k)
      }));
    }
    return {
      inner
    };
  }
  toArray() {
    return [...this.values()];
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman(isExtended) {
    const json = {};
    for (const [k, v] of this.entries()) {
      json[k] = v && v.toHuman(isExtended);
    }
    return json;
  }
  toJSON() {
    const json = {};
    for (const [k, v] of this.entries()) {
      const jsonKey = __privateGet(this, _jsonMap).get(k) || k;
      json[jsonKey] = v && v.toJSON();
    }
    return json;
  }
  toPrimitive() {
    const json = {};
    for (const [k, v] of this.entries()) {
      const jsonKey = __privateGet(this, _jsonMap).get(k) || k;
      json[jsonKey] = v && v.toPrimitive();
    }
    return json;
  }
  toRawType() {
    return stringify(typesToMap(this.registry, __privateGet(this, _Types2)));
  }
  toString() {
    return stringify(this.toJSON());
  }
  toU8a(isBare) {
    const encoded = [];
    for (const [k, v] of this.entries()) {
      if (v && isFunction(v.toU8a)) {
        encoded.push(v.toU8a(!isBare || isBoolean(isBare) ? isBare : isBare[k]));
      }
    }
    return u8aConcatStrict(encoded);
  }
};
var Struct = _Struct;
_jsonMap = new WeakMap();
_Types2 = new WeakMap();

// node_modules/@polkadot/types-codec/extended/Map.js
var l6 = logger("Map");
function decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {
  const output2 = new Map();
  const [offset, count2] = compactFromU8aLim(u8a);
  const types2 = [];
  for (let i = 0; i < count2; i++) {
    types2.push(KeyClass, ValClass);
  }
  const [values, decodedLength] = decodeU8a(registry, new Array(types2.length), u8a.subarray(offset), [types2, []]);
  for (let i = 0; i < values.length; i += 2) {
    output2.set(values[i], values[i + 1]);
  }
  return [KeyClass, ValClass, output2, offset + decodedLength];
}
function decodeMapFromMap(registry, KeyClass, ValClass, value) {
  const output2 = new Map();
  for (const [key, val] of value.entries()) {
    const isComplex = KeyClass.prototype instanceof AbstractArray || KeyClass.prototype instanceof Struct || KeyClass.prototype instanceof Enum;
    try {
      output2.set(key instanceof KeyClass ? key : new KeyClass(registry, isComplex && typeof key === "string" ? JSON.parse(key) : key), val instanceof ValClass ? val : new ValClass(registry, val));
    } catch (error) {
      l6.error("Failed to decode key or value:", error.message);
      throw error;
    }
  }
  return [KeyClass, ValClass, output2, 0];
}
function decodeMap(registry, keyType, valType, value) {
  const KeyClass = typeToConstructor(registry, keyType);
  const ValClass = typeToConstructor(registry, valType);
  if (!value) {
    return [KeyClass, ValClass, new Map(), 0];
  } else if (isU8a(value) || isHex(value)) {
    return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));
  } else if (value instanceof Map) {
    return decodeMapFromMap(registry, KeyClass, ValClass, value);
  } else if (isObject(value)) {
    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));
  }
  throw new Error("Map: cannot decode type");
}
var _KeyClass, _ValClass, _type3;
var CodecMap = class extends Map {
  constructor(registry, keyType, valType, rawValue, type = "HashMap") {
    const [KeyClass, ValClass, decoded, decodedLength] = decodeMap(registry, keyType, valType, rawValue);
    super(type === "BTreeMap" ? sortMap(decoded) : decoded);
    __privateAdd(this, _KeyClass, void 0);
    __privateAdd(this, _ValClass, void 0);
    __privateAdd(this, _type3, void 0);
    this.registry = registry;
    this.initialU8aLength = decodedLength;
    __privateSet(this, _KeyClass, KeyClass);
    __privateSet(this, _ValClass, ValClass);
    __privateSet(this, _type3, type);
  }
  get encodedLength() {
    let len = compactToU8a(this.size).length;
    for (const [k, v] of this.entries()) {
      len += k.encodedLength + v.encodedLength;
    }
    return len;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.size === 0;
  }
  eq(other) {
    return compareMap(this, other);
  }
  inspect() {
    const inner = new Array();
    for (const [k, v] of this.entries()) {
      inner.push(k.inspect());
      inner.push(v.inspect());
    }
    return {
      inner,
      outer: [compactToU8a(this.size)]
    };
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman(isExtended) {
    const json = {};
    for (const [k, v] of this.entries()) {
      json[k instanceof Raw && k.isAscii ? k.toUtf8() : k.toString()] = v.toHuman(isExtended);
    }
    return json;
  }
  toJSON() {
    const json = {};
    for (const [k, v] of this.entries()) {
      json[k.toString()] = v.toJSON();
    }
    return json;
  }
  toPrimitive() {
    const json = {};
    for (const [k, v] of this.entries()) {
      json[k instanceof Raw && k.isAscii ? k.toUtf8() : k.toString()] = v.toPrimitive();
    }
    return json;
  }
  toRawType() {
    return `${__privateGet(this, _type3)}<${this.registry.getClassName(__privateGet(this, _KeyClass)) || new (__privateGet(this, _KeyClass))(this.registry).toRawType()},${this.registry.getClassName(__privateGet(this, _ValClass)) || new (__privateGet(this, _ValClass))(this.registry).toRawType()}>`;
  }
  toString() {
    return stringify(this.toJSON());
  }
  toU8a(isBare) {
    const encoded = new Array();
    if (!isBare) {
      encoded.push(compactToU8a(this.size));
    }
    for (const [k, v] of this.entries()) {
      encoded.push(k.toU8a(isBare), v.toU8a(isBare));
    }
    return u8aConcatStrict(encoded);
  }
};
_KeyClass = new WeakMap();
_ValClass = new WeakMap();
_type3 = new WeakMap();

// node_modules/@polkadot/types-codec/extended/BTreeMap.js
var BTreeMap = class extends CodecMap {
  static with(keyType, valType) {
    return class extends BTreeMap {
      constructor(registry, value) {
        super(registry, keyType, valType, value, "BTreeMap");
      }
    };
  }
};

// node_modules/@polkadot/types-codec/extended/BTreeSet.js
var l7 = logger("BTreeSet");
function decodeSetFromU8a(registry, ValClass, u8a) {
  const output2 = new Set();
  const [offset, count2] = compactFromU8aLim(u8a);
  const result = new Array(count2);
  const [decodedLength] = decodeU8aVec(registry, result, u8a, offset, ValClass);
  for (let i = 0; i < count2; i++) {
    output2.add(result[i]);
  }
  return [ValClass, output2, decodedLength];
}
function decodeSetFromSet(registry, ValClass, value) {
  const output2 = new Set();
  value.forEach((val) => {
    try {
      output2.add(val instanceof ValClass ? val : new ValClass(registry, val));
    } catch (error) {
      l7.error("Failed to decode key or value:", error.message);
      throw error;
    }
  });
  return [ValClass, output2, 0];
}
function decodeSet(registry, valType, value) {
  const ValClass = typeToConstructor(registry, valType);
  if (!value) {
    return [ValClass, new Set(), 0];
  } else if (isU8a(value) || isHex(value)) {
    return decodeSetFromU8a(registry, ValClass, u8aToU8a(value));
  } else if (Array.isArray(value) || value instanceof Set) {
    return decodeSetFromSet(registry, ValClass, value);
  }
  throw new Error("BTreeSet: cannot decode type");
}
var _ValClass2;
var _BTreeSet = class extends Set {
  constructor(registry, valType, rawValue) {
    const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);
    super(sortSet(values));
    __privateAdd(this, _ValClass2, void 0);
    this.registry = registry;
    this.initialU8aLength = decodedLength;
    __privateSet(this, _ValClass2, ValClass);
  }
  static with(valType) {
    return class extends _BTreeSet {
      constructor(registry, value) {
        super(registry, valType, value);
      }
    };
  }
  get encodedLength() {
    let len = compactToU8a(this.size).length;
    for (const v of this.values()) {
      len += v.encodedLength;
    }
    return len;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.size === 0;
  }
  get strings() {
    return [...super.values()].map((v) => v.toString());
  }
  eq(other) {
    return compareSet(this, other);
  }
  inspect() {
    const inner = new Array();
    for (const v of this.values()) {
      inner.push(v.inspect());
    }
    return {
      inner,
      outer: [compactToU8a(this.size)]
    };
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman(isExtended) {
    const json = [];
    for (const v of this.values()) {
      json.push(v.toHuman(isExtended));
    }
    return json;
  }
  toJSON() {
    const json = [];
    for (const v of this.values()) {
      json.push(v.toJSON());
    }
    return json;
  }
  toRawType() {
    return `BTreeSet<${this.registry.getClassName(__privateGet(this, _ValClass2)) || new (__privateGet(this, _ValClass2))(this.registry).toRawType()}>`;
  }
  toPrimitive() {
    const json = [];
    for (const v of this.values()) {
      json.push(v.toPrimitive());
    }
    return json;
  }
  toString() {
    return stringify(this.toJSON());
  }
  toU8a(isBare) {
    const encoded = new Array();
    if (!isBare) {
      encoded.push(compactToU8a(this.size));
    }
    for (const v of this.values()) {
      encoded.push(v.toU8a(isBare));
    }
    return u8aConcatStrict(encoded);
  }
};
var BTreeSet = _BTreeSet;
_ValClass2 = new WeakMap();

// node_modules/@polkadot/types-codec/extended/Bytes.js
var MAX_LENGTH2 = 10 * 1024 * 1024;
function decodeBytesU8a(value) {
  if (!value.length) {
    return [new Uint8Array(), 0];
  }
  const [offset, length] = compactFromU8aLim(value);
  const total = offset + length;
  if (length > MAX_LENGTH2) {
    throw new Error(`Bytes length ${length.toString()} exceeds ${MAX_LENGTH2}`);
  } else if (total > value.length) {
    throw new Error(`Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);
  }
  return [value.subarray(offset, total), total];
}
var Bytes = class extends Raw {
  constructor(registry, value) {
    const [u8a, decodedLength] = isU8a(value) && !(value instanceof Raw) ? decodeBytesU8a(value) : Array.isArray(value) || isString(value) ? [u8aToU8a(value), 0] : [value, 0];
    super(registry, u8a, decodedLength);
  }
  get encodedLength() {
    return this.length + compactToU8a(this.length).length;
  }
  inspect(isBare) {
    const clength = compactToU8a(this.length);
    return {
      outer: isBare ? [super.toU8a()] : this.length ? [clength, super.toU8a()] : [clength]
    };
  }
  toRawType() {
    return "Bytes";
  }
  toU8a(isBare) {
    return isBare ? super.toU8a(isBare) : compactAddLength(this);
  }
};

// node_modules/@polkadot/types-codec/extended/HashMap.js
var HashMap = class extends CodecMap {
  static with(keyType, valType) {
    return class extends HashMap {
      constructor(registry, value) {
        super(registry, keyType, valType, value);
      }
    };
  }
};

// node_modules/@polkadot/types-codec/extended/Linkage.js
var EMPTY2 = new Uint8Array();

// node_modules/@polkadot/types-codec/native/Bool.js
var bool2 = class extends Boolean {
  constructor(registry, value = false) {
    super(isU8a(value) ? value[0] === 1 : value instanceof Boolean ? value.valueOf() : !!value);
    this.registry = registry;
  }
  get encodedLength() {
    return 1;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.isFalse;
  }
  get isFalse() {
    return !this.isTrue;
  }
  get isTrue() {
    return this.valueOf();
  }
  eq(other) {
    return this.valueOf() === (other instanceof Boolean ? other.valueOf() : other);
  }
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman() {
    return this.toJSON();
  }
  toJSON() {
    return this.valueOf();
  }
  toPrimitive() {
    return this.toJSON();
  }
  toRawType() {
    return "bool";
  }
  toString() {
    return this.toJSON().toString();
  }
  toU8a(isBare) {
    return new Uint8Array([this.valueOf() ? 1 : 0]);
  }
};

// node_modules/@polkadot/types-codec/extended/OptionBool.js
function decodeU8a2(registry, value) {
  return value[0] === 0 ? null : new bool2(registry, value[0] === 1);
}
var OptionBool = class extends Option {
  constructor(registry, value) {
    super(registry, bool2, isU8a(value) || isHex(value) ? decodeU8a2(registry, u8aToU8a(value)) : value);
    this.initialU8aLength = 1;
  }
  get encodedLength() {
    return 1;
  }
  get isFalse() {
    return this.isSome ? !this.value.valueOf() : false;
  }
  get isTrue() {
    return this.isSome ? this.value.valueOf() : false;
  }
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  toRawType(isBare) {
    return isBare ? "bool" : "Option<bool>";
  }
  toU8a(isBare) {
    if (isBare) {
      return super.toU8a(true);
    }
    return this.isSome ? new Uint8Array([this.isTrue ? 1 : 2]) : new Uint8Array([0]);
  }
};

// node_modules/@polkadot/types-codec/extended/Range.js
var _rangeName;
var _Range = class extends Tuple {
  constructor(registry, Type2, value, {
    rangeName = "Range"
  } = {}) {
    super(registry, [Type2, Type2], value);
    __privateAdd(this, _rangeName, void 0);
    __privateSet(this, _rangeName, rangeName);
  }
  static with(Type2) {
    return class extends _Range {
      constructor(registry, value) {
        super(registry, Type2, value);
      }
    };
  }
  get start() {
    return this[0];
  }
  get end() {
    return this[1];
  }
  toRawType() {
    return `${__privateGet(this, _rangeName)}<${this.start.toRawType()}>`;
  }
};
var Range = _Range;
_rangeName = new WeakMap();

// node_modules/@polkadot/types-codec/extended/RangeInclusive.js
var RangeInclusive = class extends Range {
  constructor(registry, Type2, value) {
    super(registry, Type2, value, {
      rangeName: "RangeInclusive"
    });
  }
  static with(Type2) {
    return class extends RangeInclusive {
      constructor(registry, value) {
        super(registry, Type2, value);
      }
    };
  }
};

// node_modules/@polkadot/types-codec/native/Text.js
var MAX_LENGTH3 = 128 * 1024;
function decodeText(value) {
  if (isU8a(value)) {
    if (!value.length) {
      return ["", 0];
    }
    if (value instanceof Raw) {
      return [u8aToString(value), 0];
    }
    const [offset, length] = compactFromU8aLim(value);
    const total = offset + length;
    if (length > MAX_LENGTH3) {
      throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH3}`);
    } else if (total > value.length) {
      throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);
    }
    return [u8aToString(value.subarray(offset, total)), total];
  } else if (isHex(value)) {
    return [u8aToString(hexToU8a(value)), 0];
  }
  return [value ? value.toString() : "", 0];
}
var _override;
var Text = class extends String {
  constructor(registry, value) {
    const [str, decodedLength] = decodeText(value);
    super(str);
    __privateAdd(this, _override, null);
    this.registry = registry;
    this.initialU8aLength = decodedLength;
  }
  get encodedLength() {
    return this.toU8a().length;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.length === 0;
  }
  get length() {
    return super.length;
  }
  eq(other) {
    return isString(other) ? this.toString() === other.toString() : false;
  }
  inspect() {
    const value = stringToU8a(super.toString());
    return {
      outer: value.length ? [compactToU8a(value.length), value] : [compactToU8a(value.length)]
    };
  }
  setOverride(override) {
    __privateSet(this, _override, override);
  }
  toHex() {
    return u8aToHex(this.toU8a(true));
  }
  toHuman() {
    return this.toJSON();
  }
  toJSON() {
    return this.toString();
  }
  toPrimitive() {
    return this.toJSON();
  }
  toRawType() {
    return "Text";
  }
  toString() {
    return __privateGet(this, _override) || super.toString();
  }
  toU8a(isBare) {
    const encoded = stringToU8a(super.toString());
    return isBare ? encoded : compactAddLength(encoded);
  }
};
_override = new WeakMap();

// node_modules/@polkadot/types-codec/extended/Type.js
var Type = class extends Text {
  constructor(registry, value = "") {
    super(registry, value);
    this.setOverride(sanitize(this.toString()));
  }
  toRawType() {
    return "Type";
  }
};

// node_modules/@polkadot/types-codec/extended/U8aFixed.js
function decodeU8aFixed(value, bitLength) {
  const u8a = u8aToU8a(value);
  const byteLength = bitLength / 8;
  if (!u8a.length) {
    return [new Uint8Array(byteLength), 0];
  }
  if (isU8a(value) ? u8a.length < byteLength : u8a.length !== byteLength) {
    throw new Error(`Expected input with ${byteLength} bytes (${bitLength} bits), found ${u8a.length} bytes`);
  }
  return [u8a.subarray(0, byteLength), byteLength];
}
var U8aFixed = class extends Raw {
  constructor(registry, value = new Uint8Array(), bitLength = 256) {
    const [u8a, decodedLength] = decodeU8aFixed(value, bitLength);
    super(registry, u8a, decodedLength);
  }
  static with(bitLength, typeName) {
    return class extends U8aFixed {
      constructor(registry, value) {
        super(registry, value, bitLength);
      }
      toRawType() {
        return typeName || super.toRawType();
      }
    };
  }
  toRawType() {
    return `[u8;${this.length}]`;
  }
};

// node_modules/@polkadot/types-codec/extended/WrapperKeepOpaque.js
function decodeRaw(registry, typeName, value) {
  const Type2 = typeToConstructor(registry, typeName);
  if (isU8a(value) || isHex(value)) {
    try {
      const [, u8a] = isHex(value) ? [0, u8aToU8a(value)] : value instanceof Raw ? [0, value.subarray()] : compactStripLength(value);
      return [Type2, new Type2(registry, u8a), value];
    } catch {
      return [Type2, null, value];
    }
  }
  const instance = new Type2(registry, value);
  return [Type2, instance, compactAddLength(instance.toU8a())];
}
var _Type5, _decoded, _opaqueName;
var _WrapperKeepOpaque = class extends Bytes {
  constructor(registry, typeName, value, {
    opaqueName = "WrapperKeepOpaque"
  } = {}) {
    const [Type2, decoded, u8a] = decodeRaw(registry, typeName, value);
    super(registry, u8a);
    __privateAdd(this, _Type5, void 0);
    __privateAdd(this, _decoded, void 0);
    __privateAdd(this, _opaqueName, void 0);
    __privateSet(this, _Type5, Type2);
    __privateSet(this, _decoded, decoded);
    __privateSet(this, _opaqueName, opaqueName);
  }
  static with(Type2) {
    return class extends _WrapperKeepOpaque {
      constructor(registry, value) {
        super(registry, Type2, value);
      }
    };
  }
  get isDecoded() {
    return !!__privateGet(this, _decoded);
  }
  inspect() {
    return __privateGet(this, _decoded) ? {
      inner: [__privateGet(this, _decoded).inspect()],
      outer: [compactToU8a(this.length)]
    } : {
      outer: [compactToU8a(this.length), this.toU8a(true)]
    };
  }
  toHuman(isExtended) {
    return __privateGet(this, _decoded) ? __privateGet(this, _decoded).toHuman(isExtended) : super.toHuman();
  }
  toPrimitive() {
    return __privateGet(this, _decoded) ? __privateGet(this, _decoded).toPrimitive() : super.toPrimitive();
  }
  toRawType() {
    return `${__privateGet(this, _opaqueName)}<${this.registry.getClassName(__privateGet(this, _Type5)) || (__privateGet(this, _decoded) ? __privateGet(this, _decoded).toRawType() : new (__privateGet(this, _Type5))(this.registry).toRawType())}>`;
  }
  toString() {
    return __privateGet(this, _decoded) ? __privateGet(this, _decoded).toString() : super.toString();
  }
  unwrap() {
    if (!__privateGet(this, _decoded)) {
      throw new Error(`${__privateGet(this, _opaqueName)}: unwrapping an undecodable value`);
    }
    return __privateGet(this, _decoded);
  }
};
var WrapperKeepOpaque = _WrapperKeepOpaque;
_Type5 = new WeakMap();
_decoded = new WeakMap();
_opaqueName = new WeakMap();

// node_modules/@polkadot/types-codec/extended/WrapperOpaque.js
var WrapperOpaque = class extends WrapperKeepOpaque {
  constructor(registry, typeName, value) {
    super(registry, typeName, value, {
      opaqueName: "WrapperOpaque"
    });
  }
  static with(Type2) {
    return class extends WrapperOpaque {
      constructor(registry, value) {
        super(registry, Type2, value);
      }
    };
  }
  get inner() {
    return this.unwrap();
  }
};

// node_modules/@polkadot/types-codec/native/Float.js
var _bitLength2;
var _Float = class extends Number {
  constructor(registry, value, {
    bitLength = 32
  } = {}) {
    super(isU8a(value) || isHex(value) ? value.length === 0 ? 0 : u8aToFloat(u8aToU8a(value), {
      bitLength
    }) : value || 0);
    __privateAdd(this, _bitLength2, void 0);
    __privateSet(this, _bitLength2, bitLength);
    this.encodedLength = bitLength / 8;
    this.initialU8aLength = this.encodedLength;
    this.registry = registry;
  }
  static with(bitLength) {
    return class extends _Float {
      constructor(registry, value) {
        super(registry, value, {
          bitLength
        });
      }
    };
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.valueOf() === 0;
  }
  eq(other) {
    return this.valueOf() === Number(other);
  }
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman() {
    return this.toString();
  }
  toJSON() {
    return this.toHex();
  }
  toNumber() {
    return this.valueOf();
  }
  toPrimitive() {
    return this.toNumber();
  }
  toRawType() {
    return `f${__privateGet(this, _bitLength2)}`;
  }
  toU8a() {
    return floatToU8a(this, {
      bitLength: __privateGet(this, _bitLength2)
    });
  }
};
var Float = _Float;
_bitLength2 = new WeakMap();

// node_modules/@polkadot/types-codec/native/Json.js
function decodeJson(value) {
  return Object.entries(value || {});
}
var Json = class extends Map {
  constructor(registry, value) {
    const decoded = decodeJson(value);
    super(decoded);
    this.registry = registry;
    objectProperties(this, decoded.map(([k]) => k), (k) => this.get(k));
  }
  get encodedLength() {
    return 0;
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return [...this.keys()].length === 0;
  }
  eq(other) {
    return compareMap(this, other);
  }
  getT(key) {
    return this.get(key);
  }
  inspect() {
    throw new Error("Unimplemented");
  }
  toHex() {
    throw new Error("Unimplemented");
  }
  toHuman() {
    return [...this.entries()].reduce((json, [key, value]) => {
      json[key] = isFunction(value.toHuman) ? value.toHuman() : value;
      return json;
    }, {});
  }
  toJSON() {
    return [...this.entries()].reduce((json, [key, value]) => {
      json[key] = value;
      return json;
    }, {});
  }
  toPrimitive() {
    return [...this.entries()].reduce((json, [key, value]) => {
      json[key] = isFunction(value.toHuman) ? value.toPrimitive() : value;
      return json;
    }, {});
  }
  toRawType() {
    return "Json";
  }
  toString() {
    return stringify(this.toJSON());
  }
  toU8a(isBare) {
    throw new Error("Unimplemented");
  }
};

// node_modules/@polkadot/types-codec/native/Set.js
function encodeSet(setValues, values) {
  const encoded = new import_bn.default(0);
  for (let i = 0; i < values.length; i++) {
    encoded.ior(bnToBn(setValues[values[i]] || 0));
  }
  return encoded;
}
function decodeSetArray(setValues, values) {
  const result = new Array(values.length);
  for (let i = 0; i < values.length; i++) {
    const key = values[i];
    if (isUndefined(setValues[key])) {
      throw new Error(`Set: Invalid key '${key}' passed to Set, allowed ${Object.keys(setValues).join(", ")}`);
    }
    result[i] = key;
  }
  return result;
}
function decodeSetNumber(setValues, _value) {
  const bn = bnToBn(_value);
  const keys2 = Object.keys(setValues);
  const result = [];
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    if (bn.and(bnToBn(setValues[key])).eq(bnToBn(setValues[key]))) {
      result.push(key);
    }
  }
  const computed = encodeSet(setValues, result);
  if (!bn.eq(computed)) {
    throw new Error(`Set: Mismatch decoding '${bn.toString()}', computed as '${computed.toString()}' with ${result.join(", ")}`);
  }
  return result;
}
function decodeSet2(setValues, value = 0, bitLength) {
  if (bitLength % 8 !== 0) {
    throw new Error(`Expected valid bitLength, power of 8, found ${bitLength}`);
  }
  const byteLength = bitLength / 8;
  if (isU8a(value)) {
    return value.length === 0 ? [] : decodeSetNumber(setValues, u8aToBn(value.subarray(0, byteLength), {
      isLe: true
    }));
  } else if (isString(value)) {
    return decodeSet2(setValues, u8aToU8a(value), byteLength);
  } else if (value instanceof Set || Array.isArray(value)) {
    const input = Array.isArray(value) ? value : [...value.values()];
    return decodeSetArray(setValues, input);
  }
  return decodeSetNumber(setValues, value);
}
var _allowed, _byteLength;
var _CodecSet = class extends Set {
  constructor(registry, setValues, value, bitLength = 8) {
    super(decodeSet2(setValues, value, bitLength));
    __privateAdd(this, _allowed, void 0);
    __privateAdd(this, _byteLength, void 0);
    __publicField(this, "add", (key) => {
      if (__privateGet(this, _allowed) && isUndefined(__privateGet(this, _allowed)[key])) {
        throw new Error(`Set: Invalid key '${key}' on add`);
      }
      super.add(key);
      return this;
    });
    this.registry = registry;
    __privateSet(this, _allowed, setValues);
    __privateSet(this, _byteLength, bitLength / 8);
  }
  static with(values, bitLength) {
    var _class;
    return _class = class extends _CodecSet {
      constructor(registry, value) {
        super(registry, values, value, bitLength);
      }
    }, (() => {
      const keys2 = Object.keys(values);
      const isKeys = new Array(keys2.length);
      for (let i = 0; i < keys2.length; i++) {
        isKeys[i] = `is${stringPascalCase(keys2[i])}`;
      }
      objectProperties(_class.prototype, isKeys, (_, i, self2) => self2.strings.includes(keys2[i]));
    })(), _class;
  }
  get encodedLength() {
    return __privateGet(this, _byteLength);
  }
  get hash() {
    return this.registry.hash(this.toU8a());
  }
  get isEmpty() {
    return this.size === 0;
  }
  get strings() {
    return [...super.values()];
  }
  get valueEncoded() {
    return encodeSet(__privateGet(this, _allowed), this.strings);
  }
  eq(other) {
    if (Array.isArray(other)) {
      return compareArray(this.strings.sort(), other.sort());
    } else if (other instanceof Set) {
      return this.eq([...other.values()]);
    } else if (isNumber(other) || isBn(other)) {
      return this.valueEncoded.eq(bnToBn(other));
    }
    return false;
  }
  inspect() {
    return {
      outer: [this.toU8a()]
    };
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toHuman() {
    return this.toJSON();
  }
  toJSON() {
    return this.strings;
  }
  toNumber() {
    return this.valueEncoded.toNumber();
  }
  toPrimitive() {
    return this.toJSON();
  }
  toRawType() {
    return stringify({
      _set: __privateGet(this, _allowed)
    });
  }
  toString() {
    return `[${this.strings.join(", ")}]`;
  }
  toU8a(isBare) {
    return bnToU8a(this.valueEncoded, {
      bitLength: __privateGet(this, _byteLength) * 8,
      isLe: true
    });
  }
};
var CodecSet = _CodecSet;
_allowed = new WeakMap();
_byteLength = new WeakMap();

// node_modules/@polkadot/types-codec/primitive/F32.js
var f32 = class extends Float.with(32) {
  constructor() {
    super(...arguments);
    __publicField(this, "__FloatType", "f32");
  }
};

// node_modules/@polkadot/types-codec/primitive/F64.js
var f64 = class extends Float.with(64) {
  constructor() {
    super(...arguments);
    __publicField(this, "__FloatType", "f64");
  }
};

// node_modules/@polkadot/types-codec/primitive/I8.js
var i8 = class extends Int.with(8) {
  constructor() {
    super(...arguments);
    __publicField(this, "__IntType", "i8");
  }
};

// node_modules/@polkadot/types-codec/primitive/I16.js
var i16 = class extends Int.with(16) {
  constructor() {
    super(...arguments);
    __publicField(this, "__IntType", "i16");
  }
};

// node_modules/@polkadot/types-codec/primitive/I32.js
var i32 = class extends Int.with(32) {
  constructor() {
    super(...arguments);
    __publicField(this, "__IntType", "i32");
  }
};

// node_modules/@polkadot/types-codec/primitive/I64.js
var i64 = class extends Int.with(64) {
  constructor() {
    super(...arguments);
    __publicField(this, "__IntType", "i64");
  }
};

// node_modules/@polkadot/types-codec/primitive/I128.js
var i128 = class extends Int.with(128) {
  constructor() {
    super(...arguments);
    __publicField(this, "__IntType", "i128");
  }
};

// node_modules/@polkadot/types-codec/primitive/I256.js
var i256 = class extends Int.with(256) {
  constructor() {
    super(...arguments);
    __publicField(this, "__IntType", "i256");
  }
};

// node_modules/@polkadot/types-codec/primitive/U8.js
var u82 = class extends UInt.with(8) {
  constructor() {
    super(...arguments);
    __publicField(this, "__UIntType", "u8");
  }
};

// node_modules/@polkadot/types-codec/primitive/U16.js
var u162 = class extends UInt.with(16) {
  constructor() {
    super(...arguments);
    __publicField(this, "__UIntType", "u16");
  }
};

// node_modules/@polkadot/types-codec/primitive/U32.js
var u323 = class extends UInt.with(32) {
  constructor() {
    super(...arguments);
    __publicField(this, "__UIntType", "u32");
  }
};

// node_modules/@polkadot/types-codec/primitive/U64.js
var u642 = class extends UInt.with(64) {
  constructor() {
    super(...arguments);
    __publicField(this, "__UIntType", "u64");
  }
};

// node_modules/@polkadot/types-codec/primitive/U128.js
var u128 = class extends UInt.with(128) {
  constructor() {
    super(...arguments);
    __publicField(this, "__UIntType", "u128");
  }
};

// node_modules/@polkadot/types-codec/primitive/U256.js
var u256 = class extends UInt.with(256) {
  constructor() {
    super(...arguments);
    __publicField(this, "__UIntType", "u256");
  }
};

// node_modules/@polkadot/types-codec/primitive/USize.js
var usize = class extends u323 {
  constructor(registry, value) {
    super(registry, value);
    throw new Error("The `usize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally u64) and WASM (always u32) code. Use one of the `u32` or `u64` types explicitly.");
  }
};

// node_modules/@polkadot/types-create/util/typeSplit.js
function typeSplit(type) {
  const result = [];
  let c = 0;
  let f = 0;
  let s = 0;
  let t = 0;
  let start = 0;
  for (let i = 0; i < type.length; i++) {
    switch (type[i]) {
      case ",": {
        if (!(c || f || s || t)) {
          result.push(type.substring(start, i).trim());
          start = i + 1;
        }
        break;
      }
      case "<":
        c++;
        break;
      case ">":
        c--;
        break;
      case "[":
        f++;
        break;
      case "]":
        f--;
        break;
      case "{":
        s++;
        break;
      case "}":
        s--;
        break;
      case "(":
        t++;
        break;
      case ")":
        t--;
        break;
    }
  }
  if (c || f || s || t) {
    throw new Error(`Invalid definition (missing terminators) found in ${type}`);
  }
  result.push(type.substring(start, type.length).trim());
  return result;
}

// node_modules/@polkadot/types-create/util/getTypeDef.js
var KNOWN_INTERNALS = ["_alias", "_fallback"];
function getTypeString(typeOrObj) {
  return isString(typeOrObj) ? typeOrObj.toString() : JSON.stringify(typeOrObj);
}
function isRustEnum2(details) {
  const values = Object.values(details);
  if (values.some((v) => isNumber(v))) {
    if (!values.every((v) => isNumber(v) && v >= 0 && v <= 255)) {
      throw new Error("Invalid number-indexed enum definition");
    }
    return false;
  }
  return true;
}
function _decodeEnum(value, details, count2, fallbackType) {
  value.info = TypeDefInfo.Enum;
  value.fallbackType = fallbackType;
  if (Array.isArray(details)) {
    value.sub = details.map((name, index) => ({
      index,
      info: TypeDefInfo.Plain,
      name,
      type: "Null"
    }));
  } else if (isRustEnum2(details)) {
    value.sub = Object.entries(details).map(([name, typeOrObj], index) => objectSpread({}, getTypeDef(getTypeString(typeOrObj || "Null"), {
      name
    }, count2), {
      index
    }));
  } else {
    value.sub = Object.entries(details).map(([name, index]) => ({
      index,
      info: TypeDefInfo.Plain,
      name,
      type: "Null"
    }));
  }
  return value;
}
function _decodeSet(value, details, fallbackType) {
  value.info = TypeDefInfo.Set;
  value.fallbackType = fallbackType;
  value.length = details._bitLength;
  value.sub = Object.entries(details).filter(([name]) => !name.startsWith("_")).map(([name, index]) => ({
    index,
    info: TypeDefInfo.Plain,
    name,
    type: "Null"
  }));
  return value;
}
function _decodeStruct(value, type, _, count2) {
  const parsed = JSON.parse(type);
  const keys2 = Object.keys(parsed);
  if (keys2.includes("_enum")) {
    return _decodeEnum(value, parsed._enum, count2, parsed._fallback);
  } else if (keys2.includes("_set")) {
    return _decodeSet(value, parsed._set, parsed._fallback);
  }
  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : void 0;
  value.fallbackType = parsed._fallback;
  value.sub = keys2.filter((name) => !KNOWN_INTERNALS.includes(name)).map((name) => getTypeDef(getTypeString(parsed[name]), {
    name
  }, count2));
  return value;
}
function _decodeFixedVec(value, type, _, count2) {
  const max3 = type.length - 1;
  let index = -1;
  let inner = 0;
  for (let i = 1; i < max3 && index === -1; i++) {
    switch (type[i]) {
      case ";": {
        if (inner === 0) {
          index = i;
        }
        break;
      }
      case "[":
      case "(":
      case "<":
        inner++;
        break;
      case "]":
      case ")":
      case ">":
        inner--;
        break;
    }
  }
  if (index === -1) {
    throw new Error(`${type}: Unable to extract location of ';'`);
  }
  const vecType = type.substring(1, index);
  const [strLength, displayName] = type.substring(index + 1, max3).split(";");
  const length = parseInt(strLength.trim(), 10);
  if (length > 2048) {
    throw new Error(`${type}: Only support for [Type; <length>], where length <= 2048`);
  }
  value.displayName = displayName;
  value.length = length;
  value.sub = getTypeDef(vecType, {}, count2);
  return value;
}
function _decodeTuple(value, _, subType, count2) {
  value.sub = subType.length === 0 ? [] : typeSplit(subType).map((inner) => getTypeDef(inner, {}, count2));
  return value;
}
function _decodeAnyInt(value, type, _, clazz) {
  const [strLength, displayName] = type.substring(clazz.length + 1, type.length - 1).split(",");
  const length = parseInt(strLength.trim(), 10);
  if (length > 8192 || length % 8) {
    throw new Error(`${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);
  }
  value.displayName = displayName;
  value.length = length;
  return value;
}
function _decodeInt(value, type, subType) {
  return _decodeAnyInt(value, type, subType, "Int");
}
function _decodeUInt(value, type, subType) {
  return _decodeAnyInt(value, type, subType, "UInt");
}
function _decodeDoNotConstruct(value, type, _) {
  const NAME_LENGTH = "DoNotConstruct".length;
  value.displayName = type.substring(NAME_LENGTH + 1, type.length - 1);
  return value;
}
function hasWrapper(type, [start, end]) {
  return type.substring(0, start.length) === start && type.slice(-1 * end.length) === end;
}
var nestedExtraction = [
  ["[", "]", TypeDefInfo.VecFixed, _decodeFixedVec],
  ["{", "}", TypeDefInfo.Struct, _decodeStruct],
  ["(", ")", TypeDefInfo.Tuple, _decodeTuple],
  ["BTreeMap<", ">", TypeDefInfo.BTreeMap, _decodeTuple],
  ["HashMap<", ">", TypeDefInfo.HashMap, _decodeTuple],
  ["Int<", ">", TypeDefInfo.Int, _decodeInt],
  ["Result<", ">", TypeDefInfo.Result, _decodeTuple],
  ["UInt<", ">", TypeDefInfo.UInt, _decodeUInt],
  ["DoNotConstruct<", ">", TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]
];
var wrappedExtraction = [["BTreeSet<", ">", TypeDefInfo.BTreeSet], ["Compact<", ">", TypeDefInfo.Compact], ["Linkage<", ">", TypeDefInfo.Linkage], ["Opaque<", ">", TypeDefInfo.WrapperOpaque], ["Option<", ">", TypeDefInfo.Option], ["Range<", ">", TypeDefInfo.Range], ["RangeInclusive<", ">", TypeDefInfo.RangeInclusive], ["Vec<", ">", TypeDefInfo.Vec], ["WrapperKeepOpaque<", ">", TypeDefInfo.WrapperKeepOpaque], ["WrapperOpaque<", ">", TypeDefInfo.WrapperOpaque]];
function extractSubType(type, [start, end]) {
  return type.substring(start.length, type.length - end.length);
}
function getTypeDef(_type4, {
  displayName,
  name
} = {}, count2 = 0) {
  const type = sanitize(_type4);
  const value = {
    displayName,
    info: TypeDefInfo.Plain,
    name,
    type
  };
  if (++count2 > 64) {
    throw new Error("getTypeDef: Maximum nested limit reached");
  }
  const nested = nestedExtraction.find((nested2) => hasWrapper(type, nested2));
  if (nested) {
    value.info = nested[2];
    return nested[3](value, type, extractSubType(type, nested), count2);
  }
  const wrapped = wrappedExtraction.find((wrapped2) => hasWrapper(type, wrapped2));
  if (wrapped) {
    value.info = wrapped[2];
    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count2);
  }
  return value;
}

// node_modules/@polkadot/types-create/create/class.js
function getTypeDefType({
  lookupName,
  type
}) {
  return lookupName || type;
}
function getSubDefArray(value) {
  if (!Array.isArray(value.sub)) {
    throw new Error(`Expected subtype as TypeDef[] in ${stringify(value)}`);
  }
  return value.sub;
}
function getSubDef(value) {
  if (!value.sub || Array.isArray(value.sub)) {
    throw new Error(`Expected subtype as TypeDef in ${stringify(value)}`);
  }
  return value.sub;
}
function getSubType(value) {
  return getTypeDefType(getSubDef(value));
}
function getTypeClassMap(value) {
  const subs = getSubDefArray(value);
  const map3 = {};
  for (let i = 0; i < subs.length; i++) {
    map3[subs[i].name] = getTypeDefType(subs[i]);
  }
  return map3;
}
function getTypeClassArray(value) {
  return getSubDefArray(value).map(getTypeDefType);
}
function createInt(Clazz, {
  displayName,
  length
}) {
  if (!isNumber(length)) {
    throw new Error(`Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);
  }
  return Clazz.with(length, displayName);
}
function createHashMap(Clazz, value) {
  const [keyType, valueType] = getTypeClassArray(value);
  return Clazz.with(keyType, valueType);
}
function createWithSub(Clazz, value) {
  return Clazz.with(getSubType(value));
}
var infoMapping = {
  [TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(BTreeMap, value),
  [TypeDefInfo.BTreeSet]: (registry, value) => createWithSub(BTreeSet, value),
  [TypeDefInfo.Compact]: (registry, value) => createWithSub(Compact, value),
  [TypeDefInfo.DoNotConstruct]: (registry, value) => DoNotConstruct.with(value.displayName || value.type),
  [TypeDefInfo.Enum]: (registry, value) => {
    const subs = getSubDefArray(value);
    return Enum.with(subs.every(({
      type
    }) => type === "Null") ? subs.reduce((out, {
      index,
      name
    }, count2) => {
      out[name] = index || count2;
      return out;
    }, {}) : getTypeClassMap(value));
  },
  [TypeDefInfo.HashMap]: (registry, value) => createHashMap(HashMap, value),
  [TypeDefInfo.Int]: (registry, value) => createInt(Int, value),
  [TypeDefInfo.Linkage]: (registry, value) => {
    const type = `Option<${getSubType(value)}>`;
    const Clazz = Struct.with({
      previous: type,
      next: type
    });
    Clazz.prototype.toRawType = function() {
      return `Linkage<${this.next.toRawType(true)}>`;
    };
    return Clazz;
  },
  [TypeDefInfo.Null]: (registry, _) => Null,
  [TypeDefInfo.Option]: (registry, value) => {
    if (!value.sub || Array.isArray(value.sub)) {
      throw new Error("Expected type information for Option");
    }
    return createWithSub(Option, value);
  },
  [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),
  [TypeDefInfo.Range]: (registry, value) => createWithSub(Range, value),
  [TypeDefInfo.RangeInclusive]: (registry, value) => createWithSub(RangeInclusive, value),
  [TypeDefInfo.Result]: (registry, value) => {
    const [Ok, Err] = getTypeClassArray(value);
    return Result.with({
      Err,
      Ok
    });
  },
  [TypeDefInfo.Set]: (registry, value) => CodecSet.with(getSubDefArray(value).reduce((result, {
    index,
    name
  }) => {
    result[name] = index;
    return result;
  }, {}), value.length),
  [TypeDefInfo.Si]: (registry, value) => getTypeClass(registry, registry.lookup.getTypeDef(value.type)),
  [TypeDefInfo.Struct]: (registry, value) => Struct.with(getTypeClassMap(value), value.alias),
  [TypeDefInfo.Tuple]: (registry, value) => Tuple.with(getTypeClassArray(value)),
  [TypeDefInfo.UInt]: (registry, value) => createInt(UInt, value),
  [TypeDefInfo.Vec]: (registry, {
    sub
  }) => {
    if (!sub || Array.isArray(sub)) {
      throw new Error("Expected type information for vector");
    }
    return sub.type === "u8" ? Bytes : Vec.with(getTypeDefType(sub));
  },
  [TypeDefInfo.VecFixed]: (registry, {
    displayName,
    length,
    sub
  }) => {
    if (!isNumber(length) || !sub || Array.isArray(sub)) {
      throw new Error("Expected length & type information for fixed vector");
    }
    return sub.type === "u8" ? U8aFixed.with(length * 8, displayName) : VecFixed.with(getTypeDefType(sub), length);
  },
  [TypeDefInfo.WrapperKeepOpaque]: (registry, value) => createWithSub(WrapperKeepOpaque, value),
  [TypeDefInfo.WrapperOpaque]: (registry, value) => createWithSub(WrapperOpaque, value)
};
function constructTypeClass(registry, typeDef) {
  try {
    const Type2 = infoMapping[typeDef.info](registry, typeDef);
    if (!Type2) {
      throw new Error("No class created");
    }
    if (!Type2.__fallbackType && typeDef.fallbackType) {
      Type2.__fallbackType = typeDef.fallbackType;
    }
    return Type2;
  } catch (error) {
    throw new Error(`Unable to construct class from ${stringify(typeDef)}: ${error.message}`);
  }
}
function getTypeClass(registry, typeDef) {
  return registry.getUnsafe(typeDef.type, false, typeDef);
}
function createClassUnsafe(registry, type) {
  return registry.getUnsafe(type) || getTypeClass(registry, registry.isLookupType(type) ? registry.lookup.getTypeDef(type) : getTypeDef(type));
}

// node_modules/@polkadot/types-create/create/type.js
function checkInstance(created, matcher) {
  const u8a = created.toU8a();
  const rawType = created.toRawType();
  const isOk = u8aEq(u8a, matcher) || ["Bytes", "Text", "Type"].includes(rawType) && matcher.length === created.length || created.isEmpty && matcher.every((v) => !v);
  if (!isOk) {
    throw new Error(`${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);
  }
}
function checkPedantic(created, [value]) {
  if (isU8a(value)) {
    checkInstance(created, value);
  } else if (isHex(value)) {
    checkInstance(created, u8aToU8a(value));
  }
}
function initType(registry, Type2, params = [], {
  blockHash,
  isOptional,
  isPedantic
} = {}) {
  const created = new (isOptional ? Option.with(Type2) : Type2)(registry, ...params);
  isPedantic && checkPedantic(created, params);
  if (blockHash) {
    created.createdAtHash = createTypeUnsafe(registry, "Hash", [blockHash]);
  }
  return created;
}
function createTypeUnsafe(registry, type, params = [], options = {}) {
  let Clazz = null;
  let firstError = null;
  try {
    Clazz = createClassUnsafe(registry, type);
    return initType(registry, Clazz, params, options);
  } catch (error) {
    firstError = new Error(`createType(${type}):: ${error.message}`);
  }
  if (Clazz && Clazz.__fallbackType) {
    try {
      Clazz = createClassUnsafe(registry, Clazz.__fallbackType);
      return initType(registry, Clazz, params, options);
    } catch {
    }
  }
  throw firstError;
}

// node_modules/@polkadot/types-create/util/encodeTypes.js
var stringIdentity = (value) => value.toString();
var INFO_WRAP = ["BTreeMap", "BTreeSet", "Compact", "HashMap", "Option", "Result", "Vec"];
function paramsNotation(outer, inner, transform = stringIdentity) {
  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(", ")}>` : ""}`;
}
function encodeWithParams(registry, typeDef, outer) {
  const {
    info: info6,
    sub
  } = typeDef;
  switch (info6) {
    case TypeDefInfo.BTreeMap:
    case TypeDefInfo.BTreeSet:
    case TypeDefInfo.Compact:
    case TypeDefInfo.HashMap:
    case TypeDefInfo.Linkage:
    case TypeDefInfo.Option:
    case TypeDefInfo.Range:
    case TypeDefInfo.RangeInclusive:
    case TypeDefInfo.Result:
    case TypeDefInfo.Vec:
    case TypeDefInfo.WrapperKeepOpaque:
    case TypeDefInfo.WrapperOpaque:
      return paramsNotation(outer, sub, (p) => encodeTypeDef(registry, p));
  }
  throw new Error(`Unable to encode ${stringify(typeDef)} with params`);
}
function encodeSubTypes(registry, sub, asEnum, extra) {
  const names = sub.map(({
    name
  }) => name);
  if (!names.every((n) => !!n)) {
    throw new Error(`Subtypes does not have consistent names, ${names.join(", ")}`);
  }
  const inner = objectSpread({}, extra);
  for (let i = 0; i < sub.length; i++) {
    const def = sub[i];
    inner[def.name] = encodeTypeDef(registry, def);
  }
  return stringify(asEnum ? {
    _enum: inner
  } : inner);
}
var encoders = {
  [TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, "BTreeMap"),
  [TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, "BTreeSet"),
  [TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Compact"),
  [TypeDefInfo.DoNotConstruct]: (registry, {
    displayName,
    lookupIndex,
    lookupName
  }) => `DoNotConstruct<${lookupName || displayName || (isUndefined(lookupIndex) ? "Unknown" : registry.createLookupType(lookupIndex))}>`,
  [TypeDefInfo.Enum]: (registry, {
    sub
  }) => {
    if (!Array.isArray(sub)) {
      throw new Error("Unable to encode Enum type");
    }
    return sub.every(({
      type
    }) => type === "Null") ? stringify({
      _enum: sub.map(({
        name
      }, index) => `${name || `Empty${index}`}`)
    }) : encodeSubTypes(registry, sub, true);
  },
  [TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, "HashMap"),
  [TypeDefInfo.Int]: (registry, {
    length = 32
  }) => `Int<${length}>`,
  [TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Linkage"),
  [TypeDefInfo.Null]: (registry, typeDef) => "Null",
  [TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Option"),
  [TypeDefInfo.Plain]: (registry, {
    displayName,
    type
  }) => displayName || type,
  [TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Range"),
  [TypeDefInfo.RangeInclusive]: (registry, typeDef) => encodeWithParams(registry, typeDef, "RangeInclusive"),
  [TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Result"),
  [TypeDefInfo.Set]: (registry, {
    length = 8,
    sub
  }) => {
    if (!Array.isArray(sub)) {
      throw new Error("Unable to encode Set type");
    }
    return stringify({
      _set: sub.reduce((all3, {
        index,
        name
      }, count2) => objectSpread(all3, {
        [`${name || `Unknown${index || count2}`}`]: index || count2
      }), {
        _bitLength: length || 8
      })
    });
  },
  [TypeDefInfo.Si]: (registry, {
    lookupName,
    type
  }) => lookupName || type,
  [TypeDefInfo.Struct]: (registry, {
    alias: alias2,
    sub
  }) => {
    if (!Array.isArray(sub)) {
      throw new Error("Unable to encode Struct type");
    }
    return encodeSubTypes(registry, sub, false, alias2 ? {
      _alias: [...alias2.entries()].reduce((all3, [k, v]) => objectSpread(all3, {
        [k]: v
      }), {})
    } : {});
  },
  [TypeDefInfo.Tuple]: (registry, {
    sub
  }) => {
    if (!Array.isArray(sub)) {
      throw new Error("Unable to encode Tuple type");
    }
    return `(${sub.map((type) => encodeTypeDef(registry, type)).join(",")})`;
  },
  [TypeDefInfo.UInt]: (registry, {
    length = 32
  }) => `UInt<${length}>`,
  [TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, "Vec"),
  [TypeDefInfo.VecFixed]: (registry, {
    length,
    sub
  }) => {
    if (!isNumber(length) || !sub || Array.isArray(sub)) {
      throw new Error("Unable to encode VecFixed type");
    }
    return `[${sub.type};${length}]`;
  },
  [TypeDefInfo.WrapperKeepOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, "WrapperKeepOpaque"),
  [TypeDefInfo.WrapperOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, "WrapperOpaque")
};
function encodeType(registry, typeDef, withLookup = true) {
  return withLookup && typeDef.lookupName ? typeDef.lookupName : encoders[typeDef.info](registry, typeDef);
}
function encodeTypeDef(registry, typeDef) {
  return typeDef.displayName && !INFO_WRAP.some((i) => typeDef.displayName === i) ? typeDef.displayName : encodeType(registry, typeDef);
}
function withTypeString(registry, typeDef) {
  return objectSpread({}, typeDef, {
    type: encodeType(registry, typeDef, false)
  });
}

// node_modules/@polkadot/types-create/util/xcm.js
var XCM_MAPPINGS = ["AssetInstance", "Fungibility", "Junction", "Junctions", "MultiAsset", "MultiAssetFilter", "MultiLocation", "Response", "WildFungibility", "WildMultiAsset", "Xcm", "XcmError", "XcmOrder"];
function mapXcmTypes(version) {
  return XCM_MAPPINGS.reduce((all3, key) => objectSpread(all3, {
    [key]: `${key}${version}`
  }), {});
}

// node_modules/@polkadot/types/interfaces/xcm/v0.js
var v02 = {
  FungibilityV0: "FungibilityV1",
  WildFungibilityV0: "WildFungibilityV1",
  AssetInstanceV0: {
    _enum: {
      Undefined: "Null",
      Index8: "u8",
      Index16: "Compact<u16>",
      Index32: "Compact<u32>",
      Index64: "Compact<u64>",
      Index128: "Compact<u128>",
      Array4: "[u8; 4]",
      Array8: "[u8; 8]",
      Array16: "[u8; 16]",
      Array32: "[u8; 32]",
      Blob: "Vec<u8>"
    }
  },
  JunctionV0: {
    _enum: {
      Parent: "Null",
      Parachain: "Compact<u32>",
      AccountId32: {
        network: "NetworkId",
        id: "AccountId"
      },
      AccountIndex64: {
        network: "NetworkId",
        index: "Compact<u64>"
      },
      AccountKey20: {
        network: "NetworkId",
        key: "[u8; 20]"
      },
      PalletInstance: "u8",
      GeneralIndex: "Compact<u128>",
      GeneralKey: "Vec<u8>",
      OnlyChild: "Null",
      Plurality: {
        id: "BodyId",
        part: "BodyPart"
      }
    }
  },
  MultiAssetV0: {
    _enum: {
      None: "Null",
      All: "Null",
      AllFungible: "Null",
      AllNonFungible: "Null",
      AllAbstractFungible: "Vec<u8>",
      AllAbstractNonFungible: "Vec<u8>",
      AllConcreteFungible: "MultiLocationV0",
      AllConcreteNonFungible: "MultiLocationV0",
      AbstractFungible: {
        id: "Vec<u8>",
        instance: "Compact<u128>"
      },
      AbstractNonFungible: {
        class: "Vec<u8>",
        instance: "AssetInstanceV0"
      },
      ConcreteFungible: {
        id: "MultiLocationV0",
        amount: "Compact<u128>"
      },
      ConcreteNonFungible: {
        class: "MultiLocationV0",
        instance: "AssetInstanceV0"
      }
    }
  },
  MultiLocationV0: {
    _enum: {
      Here: "Null",
      X1: "JunctionV0",
      X2: "(JunctionV0, JunctionV0)",
      X3: "(JunctionV0, JunctionV0, JunctionV0)",
      X4: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
      X5: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
      X6: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
      X7: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)",
      X8: "(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)"
    }
  },
  OriginKindV0: {
    _enum: ["Native", "SovereignAccount", "Superuser", "Xcm"]
  },
  ResponseV0: {
    _enum: {
      Assets: "Vec<MultiAssetV0>"
    }
  },
  XcmV0: {
    _enum: {
      WithdrawAsset: {
        assets: "Vec<MultiAssetV0>",
        effects: "Vec<XcmOrderV0>"
      },
      ReserveAssetDeposit: {
        assets: "Vec<MultiAssetV0>",
        effects: "Vec<XcmOrderV0>"
      },
      ReceiveTeleportedAsset: {
        assets: "Vec<MultiAssetV0>",
        effects: "Vec<XcmOrderV0>"
      },
      QueryResponse: {
        queryId: "Compact<u64>",
        response: "ResponseV0"
      },
      TransferAsset: {
        assets: "Vec<MultiAssetV0>",
        dest: "MultiLocationV0"
      },
      TransferReserveAsset: {
        assets: "Vec<MultiAssetV0>",
        dest: "MultiLocationV0",
        effects: "Vec<XcmOrderV0>"
      },
      Transact: {
        originType: "XcmOriginKind",
        requireWeightAtMost: "u64",
        call: "DoubleEncodedCall"
      },
      HrmpNewChannelOpenRequest: {
        sender: "Compact<u32>",
        maxMessageSize: "Compact<u32>",
        maxCapacity: "Compact<u32>"
      },
      HrmpChannelAccepted: {
        recipient: "Compact<u32>"
      },
      HrmpChannelClosing: {
        initiator: "Compact<u32>",
        sender: "Compact<u32>",
        recipient: "Compact<u32>"
      },
      RelayedFrom: {
        who: "MultiLocationV0",
        message: "XcmV0"
      }
    }
  },
  XcmErrorV0: {
    _enum: {
      Undefined: "Null",
      Overflow: "Null",
      Unimplemented: "Null",
      UnhandledXcmVersion: "Null",
      UnhandledXcmMessage: "Null",
      UnhandledEffect: "Null",
      EscalationOfPrivilege: "Null",
      UntrustedReserveLocation: "Null",
      UntrustedTeleportLocation: "Null",
      DestinationBufferOverflow: "Null",
      SendFailed: "Null",
      CannotReachDestination: "(MultiLocation, Xcm)",
      MultiLocationFull: "Null",
      FailedToDecode: "Null",
      BadOrigin: "Null",
      ExceedsMaxMessageSize: "Null",
      FailedToTransactAsset: "Null",
      WeightLimitReached: "Weight",
      Wildcard: "Null",
      TooMuchWeightRequired: "Null",
      NotHoldingFees: "Null",
      WeightNotComputable: "Null",
      Barrier: "Null",
      NotWithdrawable: "Null",
      LocationCannotHold: "Null",
      TooExpensive: "Null",
      AssetNotFound: "Null",
      RecursionLimitReached: "Null"
    }
  },
  XcmOrderV0: {
    _enum: {
      Null: "Null",
      DepositAsset: {
        assets: "Vec<MultiAssetV0>",
        dest: "MultiLocationV0"
      },
      DepositReserveAsset: {
        assets: "Vec<MultiAssetV0>",
        dest: "MultiLocationV0",
        effects: "Vec<XcmOrderV0>"
      },
      ExchangeAsset: {
        give: "Vec<MultiAssetV0>",
        receive: "Vec<MultiAssetV0>"
      },
      InitiateReserveWithdraw: {
        assets: "Vec<MultiAssetV0>",
        reserve: "MultiLocationV0",
        effects: "Vec<XcmOrderV0>"
      },
      InitiateTeleport: {
        assets: "Vec<MultiAssetV0>",
        dest: "MultiLocationV0",
        effects: "Vec<XcmOrderV0>"
      },
      QueryHolding: {
        queryId: "Compact<u64>",
        dest: "MultiLocationV0",
        assets: "Vec<MultiAssetV0>"
      },
      BuyExecution: {
        fees: "MultiAssetV0",
        weight: "u64",
        debt: "u64",
        haltOnError: "bool",
        xcm: "Vec<XcmV0>"
      }
    }
  }
};

// node_modules/@polkadot/types/interfaces/xcm/v1.js
var v15 = {
  AssetInstanceV1: {
    _enum: {
      Undefined: "Null",
      Index: "Compact<u128>",
      Array4: "[u8; 4]",
      Array8: "[u8; 8]",
      Array16: "[u8; 16]",
      Array32: "[u8; 32]",
      Blob: "Bytes"
    }
  },
  FungibilityV1: {
    _enum: {
      Fungible: "Compact<u128>",
      NonFungible: "AssetInstanceV1"
    }
  },
  JunctionV1: {
    _enum: {
      Parachain: "Compact<u32>",
      AccountId32: {
        network: "NetworkId",
        id: "AccountId"
      },
      AccountIndex64: {
        network: "NetworkId",
        index: "Compact<u64>"
      },
      AccountKey20: {
        network: "NetworkId",
        key: "[u8; 20]"
      },
      PalletInstance: "u8",
      GeneralIndex: "Compact<u128>",
      GeneralKey: "Vec<u8>",
      OnlyChild: "Null",
      Plurality: {
        id: "BodyId",
        part: "BodyPart"
      }
    }
  },
  JunctionsV1: {
    _enum: {
      Here: "Null",
      X1: "JunctionV1",
      X2: "(JunctionV1, JunctionV1)",
      X3: "(JunctionV1, JunctionV1, JunctionV1)",
      X4: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
      X5: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
      X6: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
      X7: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)",
      X8: "(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)"
    }
  },
  MultiAssetsV1: "Vec<MultiAssetV1>",
  MultiAssetV1: {
    id: "XcmAssetId",
    fungibility: "FungibilityV1"
  },
  MultiAssetFilterV1: {
    _enum: {
      Definite: "MultiAssetsV1",
      Wild: "WildMultiAssetV1"
    }
  },
  MultiLocationV1: {
    parents: "u8",
    interior: "JunctionsV1"
  },
  OriginKindV1: "OriginKindV0",
  ResponseV1: {
    _enum: {
      Assets: "MultiAssetsV1"
    }
  },
  WildFungibilityV1: {
    _enum: ["Fungible", "NonFungible"]
  },
  WildMultiAssetV1: {
    _enum: {
      All: "Null",
      AllOf: {
        id: "XcmAssetId",
        fungibility: "WildFungibilityV1"
      }
    }
  },
  XcmV1: {
    _enum: {
      WithdrawAsset: {
        assets: "MultiAssetsV1",
        effects: "Vec<XcmOrderV1>"
      },
      ReserveAssetDeposit: {
        assets: "MultiAssetsV1",
        effects: "Vec<XcmOrderV1>"
      },
      ReceiveTeleportedAsset: {
        assets: "MultiAssetsV1",
        effects: "Vec<XcmOrderV1>"
      },
      QueryResponse: {
        queryId: "Compact<u64>",
        response: "ResponseV1"
      },
      TransferAsset: {
        assets: "MultiAssetsV1",
        dest: "MultiLocationV1"
      },
      TransferReserveAsset: {
        assets: "MultiAssetsV1",
        dest: "MultiLocationV1",
        effects: "Vec<XcmOrderV1>"
      },
      Transact: {
        originType: "XcmOriginKind",
        requireWeightAtMost: "u64",
        call: "DoubleEncodedCall"
      },
      HrmpNewChannelOpenRequest: {
        sender: "Compact<u32>",
        maxMessageSize: "Compact<u32>",
        maxCapacity: "Compact<u32>"
      },
      HrmpChannelAccepted: {
        recipient: "Compact<u32>"
      },
      HrmpChannelClosing: {
        initiator: "Compact<u32>",
        sender: "Compact<u32>",
        recipient: "Compact<u32>"
      },
      RelayedFrom: {
        who: "MultiLocationV1",
        message: "XcmV1"
      }
    }
  },
  XcmErrorV1: {
    _enum: {
      Undefined: "Null",
      Overflow: "Null",
      Unimplemented: "Null",
      UnhandledXcmVersion: "Null",
      UnhandledXcmMessage: "Null",
      UnhandledEffect: "Null",
      EscalationOfPrivilege: "Null",
      UntrustedReserveLocation: "Null",
      UntrustedTeleportLocation: "Null",
      DestinationBufferOverflow: "Null",
      SendFailed: "Null",
      CannotReachDestination: "(MultiLocationV1, XcmV1)",
      MultiLocationFull: "Null",
      FailedToDecode: "Null",
      BadOrigin: "Null",
      ExceedsMaxMessageSize: "Null",
      FailedToTransactAsset: "Null",
      WeightLimitReached: "Weight",
      Wildcard: "Null",
      TooMuchWeightRequired: "Null",
      NotHoldingFees: "Null",
      WeightNotComputable: "Null",
      Barrier: "Null",
      NotWithdrawable: "Null",
      LocationCannotHold: "Null",
      TooExpensive: "Null",
      AssetNotFound: "Null",
      DestinationUnsupported: "Null",
      RecursionLimitReached: "Null"
    }
  },
  XcmOrderV1: {
    _enum: {
      Noop: "Null",
      DepositAsset: {
        assets: "MultiAssetFilterV1",
        maxAssets: "u32",
        beneficiary: "MultiLocationV1"
      },
      DepositReserveAsset: {
        assets: "MultiAssetFilterV1",
        maxAssets: "u32",
        dest: "MultiLocationV1",
        effects: "Vec<XcmOrderV1>"
      },
      ExchangeAsset: {
        give: "MultiAssetFilterV1",
        receive: "MultiAssetsV1"
      },
      InitiateReserveWithdraw: {
        assets: "MultiAssetFilterV1",
        reserve: "MultiLocationV1",
        effects: "Vec<XcmOrderV1>"
      },
      InitiateTeleport: {
        assets: "MultiAssetFilterV1",
        dest: "MultiLocationV1",
        effects: "Vec<XcmOrderV1>"
      },
      QueryHolding: {
        queryId: "Compact<u64>",
        dest: "MultiLocationV1",
        assets: "MultiAssetFilterV1"
      },
      BuyExecution: {
        fees: "MultiAssetV1",
        weight: "u64",
        debt: "u64",
        haltOnError: "bool",
        instructions: "Vec<XcmV1>"
      }
    }
  }
};

// node_modules/@polkadot/types/interfaces/xcm/v2.js
var v2 = {
  AssetInstanceV2: "AssetInstanceV1",
  FungibilityV2: "FungibilityV1",
  JunctionV2: "JunctionV1",
  JunctionsV2: "JunctionsV1",
  MultiAssetsV2: "MultiAssetsV1",
  MultiAssetV2: "MultiAssetV1",
  MultiAssetFilterV2: "MultiAssetFilterV1",
  MultiLocationV2: "MultiLocationV1",
  OriginKindV2: "OriginKindV1",
  WildFungibilityV2: "WildFungibilityV1",
  ResponseV2: {
    _enum: {
      Null: "Null",
      Assets: "MultiAssetsV2",
      ExecutionResult: "ResponseV2Result"
    }
  },
  ResponseV2Error: "(u32, XcmErrorV2)",
  ResponseV2Result: "Result<Null, ResponseV2Error>",
  WeightLimitV2: {
    _enum: {
      Unlimited: "Null",
      Limited: "Compact<u64>"
    }
  },
  InstructionV2: {
    _enum: {
      WithdrawAsset: "MultiAssetsV2",
      ReserveAssetDeposited: "MultiAssetsV2",
      ReceiveTeleportedAsset: "MultiAssetsV2",
      QueryResponse: {
        queryId: "Compact<u64>",
        response: "ResponseV2",
        maxWeight: "Compact<u64>"
      },
      TransferAsset: {
        assets: "MultiAssetsV2",
        beneficiary: "MultiLocationV2"
      },
      TransferReserveAsset: {
        assets: "MultiAssetsV2",
        dest: "MultiLocationV2",
        xcm: "XcmV2"
      },
      Transact: {
        originType: "OriginKindV2",
        requireWeightAtMost: "u64",
        call: "DoubleEncodedCall"
      },
      HrmpNewChannelOpenRequest: {
        sender: "Compact<u32>",
        maxMessageSize: "Compact<u32>",
        maxCapacity: "Compact<u32>"
      },
      HrmpChannelAccepted: {
        recipient: "Compact<u32>"
      },
      HrmpChannelClosing: {
        initiator: "Compact<u32>",
        sender: "Compact<u32>",
        recipient: "Compact<u32>"
      },
      ClearOrigin: "Null",
      DescendOrigin: "InteriorMultiLocation",
      ReportError: {
        queryId: "Compact<u64>",
        dest: "MultiLocationV2",
        maxResponseWeight: "Compact<u64>"
      },
      DepositAsset: {
        assets: "MultiAssetFilterV2",
        maxAssets: "u32",
        beneficiary: "MultiLocationV2"
      },
      DepositReserveAsset: {
        assets: "MultiAssetFilterV2",
        maxAssets: "u32",
        dest: "MultiLocationV2",
        xcm: "XcmV2"
      },
      ExchangeAsset: {
        give: "MultiAssetFilterV2",
        receive: "MultiAssetsV2"
      },
      InitiateReserveWithdraw: {
        assets: "MultiAssetFilterV2",
        reserve: "MultiLocationV2",
        xcm: "XcmV2"
      },
      InitiateTeleport: {
        assets: "MultiAssetFilterV2",
        dest: "MultiLocationV2",
        xcm: "XcmV2"
      },
      QueryHolding: {
        query_id: "Compact<u64>",
        dest: "MultiLocationV2",
        assets: "MultiAssetFilterV2",
        maxResponse_Weight: "Compact<u64>"
      },
      BuyExecution: {
        fees: "MultiAssetV2",
        weightLimit: "WeightLimitV2"
      },
      RefundSurplus: "Null",
      SetErrorHandler: "XcmV2",
      SetAppendix: "XcmV2",
      ClearError: "Null",
      ClaimAsset: {
        assets: "MultiAssetsV2",
        ticket: "MultiLocationV2"
      },
      Trap: "u64"
    }
  },
  WildMultiAssetV2: "WildMultiAssetV1",
  XcmV2: "Vec<InstructionV2>",
  XcmErrorV2: {
    _enum: {
      Undefined: "Null",
      Overflow: "Null",
      Unimplemented: "Null",
      UnhandledXcmVersion: "Null",
      UnhandledXcmMessage: "Null",
      UnhandledEffect: "Null",
      EscalationOfPrivilege: "Null",
      UntrustedReserveLocation: "Null",
      UntrustedTeleportLocation: "Null",
      DestinationBufferOverflow: "Null",
      MultiLocationFull: "Null",
      MultiLocationNotInvertible: "Null",
      FailedToDecode: "Null",
      BadOrigin: "Null",
      ExceedsMaxMessageSize: "Null",
      FailedToTransactAsset: "Null",
      WeightLimitReached: "Weight",
      Wildcard: "Null",
      TooMuchWeightRequired: "Null",
      NotHoldingFees: "Null",
      WeightNotComputable: "Null",
      Barrier: "Null",
      NotWithdrawable: "Null",
      LocationCannotHold: "Null",
      TooExpensive: "Null",
      AssetNotFound: "Null",
      DestinationUnsupported: "Null",
      RecursionLimitReached: "Null",
      Transport: "Null",
      Unroutable: "Null",
      UnknownWeightRequired: "Null",
      Trap: "u64",
      UnknownClaim: "Null",
      InvalidLocation: "Null"
    }
  },
  XcmOrderV2: "XcmOrderV1"
};

// node_modules/@polkadot/types/interfaces/xcm/definitions.js
var XCM_LATEST = "V2";
var xcm = {
  XcmOrigin: {
    _enum: {
      Xcm: "MultiLocation"
    }
  },
  XcmpMessageFormat: {
    _enum: ["ConcatenatedVersionedXcm", "ConcatenatedEncodedBlob", "Signals"]
  },
  XcmAssetId: {
    _enum: {
      Concrete: "MultiLocation",
      Abstract: "Bytes"
    }
  },
  InboundStatus: {
    _enum: ["Ok", "Suspended"]
  },
  OutboundStatus: {
    _enum: ["Ok", "Suspended"]
  },
  MultiAssets: "Vec<MultiAsset>"
};
var location = {
  BodyId: {
    _enum: {
      Unit: "Null",
      Named: "Vec<u8>",
      Index: "Compact<u32>",
      Executive: "Null",
      Technical: "Null",
      Legislative: "Null",
      Judicial: "Null"
    }
  },
  BodyPart: {
    _enum: {
      Voice: "Null",
      Members: "Compact<u32>",
      Fraction: {
        nom: "Compact<u32>",
        denom: "Compact<u32>"
      },
      AtLeastProportion: {
        nom: "Compact<u32>",
        denom: "Compact<u32>"
      },
      MoreThanProportion: {
        nom: "Compact<u32>",
        denom: "Compact<u32>"
      }
    }
  },
  InteriorMultiLocation: "Junctions",
  NetworkId: {
    _enum: {
      Any: "Null",
      Named: "Vec<u8>",
      Polkadot: "Null",
      Kusama: "Null"
    }
  }
};
var definitions_default56 = {
  rpc: {},
  types: objectSpread({}, location, xcm, v02, v15, v2, mapXcmTypes(XCM_LATEST), {
    DoubleEncodedCall: {
      encoded: "Vec<u8>"
    },
    XcmOriginKind: {
      _enum: ["Native", "SovereignAccount", "Superuser", "Xcm"]
    },
    Outcome: {
      _enum: {
        Complete: "Weight",
        Incomplete: "(Weight, XcmErrorV0)",
        Error: "XcmErrorV0"
      }
    },
    QueryId: "u64",
    QueryStatus: {
      _enum: {
        Pending: {
          responder: "VersionedMultiLocation",
          maybeNotify: "Option<(u8, u8)>",
          timeout: "BlockNumber"
        },
        Ready: {
          response: "VersionedResponse",
          at: "BlockNumber"
        }
      }
    },
    QueueConfigData: {
      suspendThreshold: "u32",
      dropThreshold: "u32",
      resumeThreshold: "u32",
      thresholdWeight: "Weight",
      weightRestrictDecay: "Weight"
    },
    VersionMigrationStage: {
      _enum: {
        MigrateSupportedVersion: "Null",
        MigrateVersionNotifiers: "Null",
        NotifyCurrentTargets: "Option<Bytes>",
        MigrateAndNotifyOldTargets: "Null"
      }
    },
    VersionedMultiAsset: {
      _enum: {
        V0: "MultiAssetV0",
        V1: "MultiAssetV1",
        V2: "MultiAssetV2"
      }
    },
    VersionedMultiAssets: {
      _enum: {
        V0: "Vec<MultiAssetV0>",
        V1: "MultiAssetsV1",
        V2: "MultiAssetsV2"
      }
    },
    VersionedMultiLocation: {
      _enum: {
        V0: "MultiLocationV0",
        V1: "MultiLocationV1",
        V2: "MultiLocationV2"
      }
    },
    VersionedResponse: {
      V0: "ResponseV0",
      V1: "ResponseV1",
      V2: "ResponseV2"
    },
    VersionedXcm: {
      _enum: {
        V0: "XcmV0",
        V1: "XcmV1",
        V2: "XcmV2"
      }
    },
    XcmVersion: "u32"
  })
};

// node_modules/@polkadot/types/interfaces/contractsAbi/definitions.js
var layout = {
  ContractCryptoHasher: {
    _enum: ["Blake2x256", "Sha2x256", "Keccak256"]
  },
  ContractDiscriminant: "u32",
  ContractLayoutArray: {
    offset: "ContractLayoutKey",
    len: "u32",
    cellsPerElem: "u64",
    layout: "ContractStorageLayout"
  },
  ContractLayoutCell: {
    key: "ContractLayoutKey",
    ty: "SiLookupTypeId"
  },
  ContractLayoutEnum: {
    dispatchKey: "ContractLayoutKey",
    variants: "BTreeMap<ContractDiscriminant, ContractLayoutStruct>"
  },
  ContractLayoutHash: {
    offset: "ContractLayoutKey",
    strategy: "ContractLayoutHashingStrategy",
    layout: "ContractStorageLayout"
  },
  ContractLayoutHashingStrategy: {
    hasher: "ContractCryptoHasher",
    postfix: "Vec<u8>",
    prefix: "Vec<u8>"
  },
  ContractLayoutKey: "[u8; 32]",
  ContractLayoutStruct: {
    fields: "Vec<ContractLayoutStructField>"
  },
  ContractLayoutStructField: {
    layout: "ContractStorageLayout",
    name: "Text"
  },
  ContractStorageLayout: {
    _enum: {
      Cell: "ContractLayoutCell",
      Hash: "ContractLayoutHash",
      Array: "ContractLayoutArray",
      Struct: "ContractLayoutStruct",
      Enum: "ContractLayoutEnum"
    }
  }
};
var spec = {
  ContractConstructorSpecV0: {
    name: "Text",
    selector: "ContractSelector",
    args: "Vec<ContractMessageParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractConstructorSpecV1: {
    name: "Vec<Text>",
    selector: "ContractSelector",
    args: "Vec<ContractMessageParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractConstructorSpecV2: {
    label: "Text",
    selector: "ContractSelector",
    args: "Vec<ContractMessageParamSpecV2>",
    docs: "Vec<Text>"
  },
  ContractConstructorSpecV3: {
    label: "Text",
    selector: "ContractSelector",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV2>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV0: {
    constructors: "Vec<ContractConstructorSpecV0>",
    messages: "Vec<ContractMessageSpecV0>",
    events: "Vec<ContractEventSpecV0>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV1: {
    constructors: "Vec<ContractConstructorSpecV1>",
    messages: "Vec<ContractMessageSpecV1>",
    events: "Vec<ContractEventSpecV1>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV2: {
    constructors: "Vec<ContractConstructorSpecV2>",
    messages: "Vec<ContractMessageSpecV2>",
    events: "Vec<ContractEventSpecV2>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV3: {
    constructors: "Vec<ContractConstructorSpecV3>",
    messages: "Vec<ContractMessageSpecV2>",
    events: "Vec<ContractEventSpecV2>",
    docs: "Vec<Text>"
  },
  ContractContractSpecV4: "ContractContractSpecV3",
  ContractDisplayName: "SiPath",
  ContractEventParamSpecV0: {
    name: "Text",
    indexed: "bool",
    type: "ContractTypeSpec",
    docs: "Vec<Text>"
  },
  ContractEventParamSpecV2: {
    label: "Text",
    indexed: "bool",
    type: "ContractTypeSpec",
    docs: "Vec<Text>"
  },
  ContractEventSpecV0: {
    name: "Text",
    args: "Vec<ContractEventParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractEventSpecV1: {
    name: "Text",
    args: "Vec<ContractEventParamSpecV0>",
    docs: "Vec<Text>"
  },
  ContractEventSpecV2: {
    label: "Text",
    args: "Vec<ContractEventParamSpecV2>",
    docs: "Vec<Text>"
  },
  ContractMessageParamSpecV0: {
    name: "Text",
    type: "ContractTypeSpec"
  },
  ContractMessageParamSpecV2: {
    label: "Text",
    type: "ContractTypeSpec"
  },
  ContractMessageSpecV0: {
    name: "Text",
    selector: "ContractSelector",
    mutates: "bool",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV0>",
    returnType: "Option<ContractTypeSpec>",
    docs: "Vec<Text>"
  },
  ContractMessageSpecV1: {
    name: "Vec<Text>",
    selector: "ContractSelector",
    mutates: "bool",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV0>",
    returnType: "Option<ContractTypeSpec>",
    docs: "Vec<Text>"
  },
  ContractMessageSpecV2: {
    label: "Text",
    selector: "ContractSelector",
    mutates: "bool",
    payable: "bool",
    args: "Vec<ContractMessageParamSpecV2>",
    returnType: "Option<ContractTypeSpec>",
    docs: "Vec<Text>"
  },
  ContractSelector: "[u8; 4]",
  ContractTypeSpec: {
    type: "SiLookupTypeId",
    displayName: "ContractDisplayName"
  }
};
var ContractMetadataV0 = {
  metadataVersion: "Text",
  types: "Vec<Si0Type>",
  spec: "ContractContractSpecV0"
};
var ContractMetadataV1 = {
  types: "Vec<PortableType>",
  spec: "ContractContractSpecV1"
};
var ContractMetadataV2 = {
  types: "Vec<PortableType>",
  spec: "ContractContractSpecV2"
};
var ContractMetadataV3 = {
  types: "Vec<PortableType>",
  spec: "ContractContractSpecV3"
};
var ContractMetadataV4 = ContractMetadataV3;
var ContractProjectInfo = {
  source: "ContractProjectSource",
  contract: "ContractProjectContract"
};
var latest = {
  ContractConstructorSpecLatest: "ContractConstructorSpecV3",
  ContractEventSpecLatest: "ContractEventSpecV2",
  ContractEventParamSpecLatest: "ContractEventParamSpecV2",
  ContractMessageParamSpecLatest: "ContractMessageParamSpecV2",
  ContractMessageSpecLatest: "ContractMessageSpecV2",
  ContractMetadataLatest: "ContractMetadataV4"
};
var definitions_default57 = {
  rpc: {},
  types: objectSpread({}, layout, spec, latest, {
    ContractProjectInfo,
    ContractMetadataV0,
    ContractMetadataV1,
    ContractMetadataV2,
    ContractMetadataV3,
    ContractMetadataV4,
    ContractMetadata: {
      _enum: {
        V0: "ContractMetadataV0",
        V1: "ContractMetadataV1",
        V2: "ContractMetadataV2",
        V3: "ContractMetadataV3",
        V4: "ContractMetadataV4"
      }
    },
    ContractProjectV0: objectSpread({
      metadataVersion: "Text"
    }, ContractProjectInfo, ContractMetadataV0),
    ContractProject: "(ContractProjectInfo, ContractMetadata)",
    ContractProjectContract: {
      _alias: {
        docs: "documentation"
      },
      name: "Text",
      version: "Text",
      authors: "Vec<Text>",
      description: "Option<Text>",
      docs: "Option<Text>",
      repository: "Option<Text>",
      homepage: "Option<Text>",
      license: "Option<Text>"
    },
    ContractProjectSource: {
      _alias: {
        wasmHash: "hash"
      },
      wasmHash: "[u8; 32]",
      language: "Text",
      compiler: "Text",
      wasm: "Raw"
    }
  })
};

// node_modules/@polkadot/types/interfaces/eth/rpc.js
var netRpc = {
  listening: {
    aliasSection: "net",
    description: "Returns true if client is actively listening for network connections. Otherwise false.",
    params: [],
    type: "bool"
  },
  peerCount: {
    aliasSection: "net",
    description: "Returns number of peers connected to node.",
    params: [],
    type: "Text"
  },
  version: {
    aliasSection: "net",
    description: "Returns protocol version.",
    params: [],
    type: "Text"
  }
};
var web3Rpc = {
  clientVersion: {
    aliasSection: "web3",
    description: "Returns current client version.",
    params: [],
    type: "Text"
  },
  sha3: {
    aliasSection: "web3",
    description: "Returns sha3 of the given data",
    params: [{
      name: "data",
      type: "Bytes"
    }],
    type: "H256"
  }
};
var rpc10 = objectSpread({}, netRpc, web3Rpc, {
  accounts: {
    description: "Returns accounts list.",
    params: [],
    type: "Vec<H160>"
  },
  blockNumber: {
    description: "Returns the blockNumber",
    params: [],
    type: "U256"
  },
  call: {
    description: "Call contract, returning the output data.",
    params: [{
      name: "request",
      type: "EthCallRequest"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "number",
      type: "BlockNumber"
    }],
    type: "Bytes"
  },
  chainId: {
    description: "Returns the chain ID used for transaction signing at the current best block. None is returned if not available.",
    params: [],
    type: "U64"
  },
  coinbase: {
    description: "Returns block author.",
    params: [],
    type: "H160"
  },
  estimateGas: {
    description: "Estimate gas needed for execution of given contract.",
    params: [{
      name: "request",
      type: "EthCallRequest"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "number",
      type: "BlockNumber"
    }],
    type: "U256"
  },
  feeHistory: {
    description: "Returns fee history for given block count & reward percentiles",
    params: [{
      name: "blockCount",
      type: "U256"
    }, {
      name: "newestBlock",
      type: "BlockNumber"
    }, {
      name: "rewardPercentiles",
      type: "Option<Vec<f64>>"
    }],
    type: "EthFeeHistory"
  },
  gasPrice: {
    description: "Returns current gas price.",
    params: [],
    type: "U256"
  },
  getBalance: {
    description: "Returns balance of the given account.",
    params: [{
      name: "address",
      type: "H160"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "number",
      type: "BlockNumber"
    }],
    type: "U256"
  },
  getBlockByHash: {
    description: "Returns block with given hash.",
    params: [{
      name: "hash",
      type: "H256"
    }, {
      name: "full",
      type: "bool"
    }],
    type: "Option<EthRichBlock>"
  },
  getBlockByNumber: {
    description: "Returns block with given number.",
    params: [{
      name: "block",
      type: "BlockNumber"
    }, {
      name: "full",
      type: "bool"
    }],
    type: "Option<EthRichBlock>"
  },
  getBlockTransactionCountByHash: {
    description: "Returns the number of transactions in a block with given hash.",
    params: [{
      name: "hash",
      type: "H256"
    }],
    type: "U256"
  },
  getBlockTransactionCountByNumber: {
    description: "Returns the number of transactions in a block with given block number.",
    params: [{
      name: "block",
      type: "BlockNumber"
    }],
    type: "U256"
  },
  getCode: {
    description: "Returns the code at given address at given time (block number).",
    params: [{
      name: "address",
      type: "H160"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "number",
      type: "BlockNumber"
    }],
    type: "Bytes"
  },
  getFilterChanges: {
    description: "Returns filter changes since last poll.",
    params: [{
      name: "index",
      type: "U256"
    }],
    type: "EthFilterChanges"
  },
  getFilterLogs: {
    description: "Returns all logs matching given filter (in a range 'from' - 'to').",
    params: [{
      name: "index",
      type: "U256"
    }],
    type: "Vec<EthLog>"
  },
  getLogs: {
    description: "Returns logs matching given filter object.",
    params: [{
      name: "filter",
      type: "EthFilter"
    }],
    type: "Vec<EthLog>"
  },
  getProof: {
    description: "Returns proof for account and storage.",
    params: [{
      name: "address",
      type: "H160"
    }, {
      name: "storageKeys",
      type: "Vec<H256>"
    }, {
      name: "number",
      type: "BlockNumber"
    }],
    type: "EthAccount"
  },
  getStorageAt: {
    description: "Returns content of the storage at given address.",
    params: [{
      name: "address",
      type: "H160"
    }, {
      name: "index",
      type: "U256"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "number",
      type: "BlockNumber"
    }],
    type: "H256"
  },
  getTransactionByBlockHashAndIndex: {
    description: "Returns transaction at given block hash and index.",
    params: [{
      name: "hash",
      type: "H256"
    }, {
      name: "index",
      type: "U256"
    }],
    type: "EthTransaction"
  },
  getTransactionByBlockNumberAndIndex: {
    description: "Returns transaction by given block number and index.",
    params: [{
      name: "number",
      type: "BlockNumber"
    }, {
      name: "index",
      type: "U256"
    }],
    type: "EthTransaction"
  },
  getTransactionByHash: {
    description: "Get transaction by its hash.",
    params: [{
      name: "hash",
      type: "H256"
    }],
    type: "EthTransaction"
  },
  getTransactionCount: {
    description: "Returns the number of transactions sent from given address at given time (block number).",
    params: [{
      name: "hash",
      type: "H256"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "number",
      type: "BlockNumber"
    }],
    type: "U256"
  },
  getTransactionReceipt: {
    description: "Returns transaction receipt by transaction hash.",
    params: [{
      name: "hash",
      type: "H256"
    }],
    type: "EthReceipt"
  },
  getUncleByBlockHashAndIndex: {
    description: "Returns an uncles at given block and index.",
    params: [{
      name: "hash",
      type: "H256"
    }, {
      name: "index",
      type: "U256"
    }],
    type: "EthRichBlock"
  },
  getUncleByBlockNumberAndIndex: {
    description: "Returns an uncles at given block and index.",
    params: [{
      name: "number",
      type: "BlockNumber"
    }, {
      name: "index",
      type: "U256"
    }],
    type: "EthRichBlock"
  },
  getUncleCountByBlockHash: {
    description: "Returns the number of uncles in a block with given hash.",
    params: [{
      name: "hash",
      type: "H256"
    }],
    type: "U256"
  },
  getUncleCountByBlockNumber: {
    description: "Returns the number of uncles in a block with given block number.",
    params: [{
      name: "number",
      type: "BlockNumber"
    }],
    type: "U256"
  },
  getWork: {
    description: "Returns the hash of the current block, the seedHash, and the boundary condition to be met.",
    params: [],
    type: "EthWork"
  },
  hashrate: {
    description: "Returns the number of hashes per second that the node is mining with.",
    params: [],
    type: "U256"
  },
  maxPriorityFeePerGas: {
    description: "Returns max priority fee per gas",
    params: [],
    type: "U256"
  },
  mining: {
    description: "Returns true if client is actively mining new blocks.",
    params: [],
    type: "bool"
  },
  newBlockFilter: {
    description: "Returns id of new block filter.",
    params: [],
    type: "U256"
  },
  newFilter: {
    description: "Returns id of new filter.",
    params: [{
      name: "filter",
      type: "EthFilter"
    }],
    type: "U256"
  },
  newPendingTransactionFilter: {
    description: "Returns id of new block filter.",
    params: [],
    type: "U256"
  },
  protocolVersion: {
    description: "Returns protocol version encoded as a string (quotes are necessary).",
    params: [],
    type: "u64"
  },
  sendRawTransaction: {
    description: "Sends signed transaction, returning its hash.",
    params: [{
      name: "bytes",
      type: "Bytes"
    }],
    type: "H256"
  },
  sendTransaction: {
    description: "Sends transaction; will block waiting for signer to return the transaction hash",
    params: [{
      name: "tx",
      type: "EthTransactionRequest"
    }],
    type: "H256"
  },
  submitHashrate: {
    description: "Used for submitting mining hashrate.",
    params: [{
      name: "index",
      type: "U256"
    }, {
      name: "hash",
      type: "H256"
    }],
    type: "bool"
  },
  submitWork: {
    description: "Used for submitting a proof-of-work solution.",
    params: [{
      name: "nonce",
      type: "H64"
    }, {
      name: "headerHash",
      type: "H256"
    }, {
      name: "mixDigest",
      type: "H256"
    }],
    type: "bool"
  },
  subscribe: {
    description: "Subscribe to Eth subscription.",
    params: [{
      name: "kind",
      type: "EthSubKind"
    }, {
      isOptional: true,
      name: "params",
      type: "EthSubParams"
    }],
    pubsub: ["subscription", "subscribe", "unsubscribe"],
    type: "Null"
  },
  syncing: {
    description: "Returns an object with data about the sync status or false.",
    params: [],
    type: "EthSyncStatus"
  },
  uninstallFilter: {
    description: "Uninstalls filter.",
    params: [{
      name: "index",
      type: "U256"
    }],
    type: "bool"
  }
});

// node_modules/@polkadot/types/interfaces/eth/runtime.js
var runtime20 = {
  ConvertTransactionRuntimeApi: [{
    methods: {
      convert_transaction: {
        description: "Converts an Ethereum-style transaction to Extrinsic",
        params: [{
          name: "transaction",
          type: "TransactionV2"
        }],
        type: "Extrinsic"
      }
    },
    version: 2
  }],
  DebugRuntimeApi: [{
    methods: {
      trace_block: {
        description: "Trace all block extrinsics",
        params: [{
          name: "extrinsics",
          type: "Vec<Extrinsic>"
        }, {
          name: "knownTransactions",
          type: "Vec<H256>"
        }],
        type: "Result<(), DispatchError>"
      },
      trace_transaction: {
        description: "Trace transaction extrinsics",
        params: [{
          name: "extrinsics",
          type: "Vec<Extrinsic>"
        }, {
          name: "transaction",
          type: "EthTransaction"
        }],
        type: "Result<(), DispatchError>"
      }
    },
    version: 4
  }],
  EthereumRuntimeRPCApi: [{
    methods: {
      account_basic: {
        description: "Returns pallet_evm::Accounts by address.",
        params: [{
          name: "address",
          type: "H160"
        }],
        type: "EvmAccount"
      },
      account_code_at: {
        description: "For a given account address, returns pallet_evm::AccountCodes.",
        params: [{
          name: "address",
          type: "H160"
        }],
        type: "Bytes"
      },
      author: {
        description: "Returns the converted FindAuthor::find_author authority id.",
        params: [],
        type: "H160"
      },
      call: {
        description: "Returns a frame_ethereum::call response. If `estimate` is true,",
        params: [{
          name: "from",
          type: "H160"
        }, {
          name: "to",
          type: "H160"
        }, {
          name: "data",
          type: "Vec<u8>"
        }, {
          name: "value",
          type: "U256"
        }, {
          name: "gasLimit",
          type: "U256"
        }, {
          name: "maxFeePerGas",
          type: "Option<U256>"
        }, {
          name: "maxPriorityFeePerGas",
          type: "Option<U256>"
        }, {
          name: "nonce",
          type: "Option<U256>"
        }, {
          name: "estimate",
          type: "bool"
        }, {
          name: "accessList",
          type: "Option<Vec<(H160, Vec<H256>)>>"
        }],
        type: "Result<EvmCallInfo, DispatchError>"
      },
      chain_id: {
        description: "Returns runtime defined pallet_evm::ChainId.",
        params: [],
        type: "u64"
      },
      create: {
        description: "Returns a frame_ethereum::call response. If `estimate` is true,",
        params: [{
          name: "from",
          type: "H160"
        }, {
          name: "data",
          type: "Vec<u8>"
        }, {
          name: "value",
          type: "U256"
        }, {
          name: "gasLimit",
          type: "U256"
        }, {
          name: "maxFeePerGas",
          type: "Option<U256>"
        }, {
          name: "maxPriorityFeePerGas",
          type: "Option<U256>"
        }, {
          name: "nonce",
          type: "Option<U256>"
        }, {
          name: "estimate",
          type: "bool"
        }, {
          name: "accessList",
          type: "Option<Vec<(H160, Vec<H256>)>>"
        }],
        type: "Result<EvmCreateInfo, DispatchError>"
      },
      current_all: {
        description: "Return all the current data for a block in a single runtime call.",
        params: [],
        type: "(Option<BlockV2>, Option<Vec<EthReceiptV3>>, Option<Vec<EthTransactionStatus>>)"
      },
      current_block: {
        description: "Return the current block.",
        params: [],
        type: "BlockV2"
      },
      current_receipts: {
        description: "Return the current receipt.",
        params: [],
        type: "Option<Vec<EthReceiptV3>>"
      },
      current_transaction_statuses: {
        description: "Return the current transaction status.",
        params: [],
        type: "Option<Vec<EthTransactionStatus>>"
      },
      elasticity: {
        description: "Return the elasticity multiplier.",
        params: [],
        type: "Option<Permill>"
      },
      extrinsic_filter: {
        description: "Receives a `Vec<OpaqueExtrinsic>` and filters all the ethereum transactions.",
        params: [{
          name: "xts",
          type: "Vec<Extrinsic>"
        }],
        type: "Vec<TransactionV2>"
      },
      gas_price: {
        description: "Returns FixedGasPrice::min_gas_price",
        params: [],
        type: "u256"
      },
      storage_at: {
        description: "For a given account address and index, returns pallet_evm::AccountStorages.",
        params: [{
          name: "address",
          type: "H160"
        }, {
          name: "index",
          type: "u256"
        }],
        type: "H256"
      }
    },
    version: 4
  }]
};

// node_modules/@polkadot/types/interfaces/eth/definitions.js
var V0 = {
  BlockV0: {
    header: "EthHeader",
    transactions: "Vec<TransactionV0>",
    ommers: "Vec<EthHeader>"
  },
  LegacyTransaction: {
    nonce: "U256",
    gasPrice: "U256",
    gasLimit: "U256",
    action: "EthTransactionAction",
    value: "U256",
    input: "Bytes",
    signature: "EthTransactionSignature"
  },
  TransactionV0: "LegacyTransaction"
};
var V1 = {
  BlockV1: {
    header: "EthHeader",
    transactions: "Vec<TransactionV1>",
    ommers: "Vec<EthHeader>"
  },
  EIP2930Transaction: {
    chainId: "u64",
    nonce: "U256",
    gasPrice: "U256",
    gasLimit: "U256",
    action: "EthTransactionAction",
    value: "U256",
    input: "Bytes",
    accessList: "EthAccessList",
    oddYParity: "bool",
    r: "H256",
    s: "H256"
  },
  TransactionV1: {
    _enum: {
      Legacy: "LegacyTransaction",
      EIP2930: "EIP2930Transaction"
    }
  }
};
var V2 = {
  BlockV2: {
    header: "EthHeader",
    transactions: "Vec<TransactionV2>",
    ommers: "Vec<EthHeader>"
  },
  EIP1559Transaction: {
    chainId: "u64",
    nonce: "U256",
    maxPriorityFeePerGas: "U256",
    maxFeePerGas: "U256",
    gasLimit: "U256",
    action: "EthTransactionAction",
    value: "U256",
    input: "Bytes",
    accessList: "EthAccessList",
    oddYParity: "bool",
    r: "H256",
    s: "H256"
  },
  TransactionV2: {
    _enum: {
      Legacy: "LegacyTransaction",
      EIP2930: "EIP2930Transaction",
      EIP1559: "EIP1559Transaction"
    }
  }
};
var types = objectSpread({}, V0, V1, V2, {
  EthereumAccountId: "GenericEthereumAccountId",
  EthereumAddress: "GenericEthereumAccountId",
  EthereumLookupSource: "GenericEthereumLookupSource",
  EthereumSignature: "[u8; 65]",
  EthAccessListItem: {
    address: "EthAddress",
    slots: "Vec<H256>"
  },
  EthAccessList: "Vec<EthAccessListItem>",
  EthAccount: {
    address: "EthAddress",
    balance: "U256",
    nonce: "U256",
    codeHash: "H256",
    storageHash: "H256",
    accountProof: "Vec<Bytes>",
    storageProof: "Vec<EthStorageProof>"
  },
  EthAddress: "H160",
  EthBlock: {
    header: "EthHeader",
    transactions: "Vec<EthTransaction>",
    ommers: "Vec<EthHeader>"
  },
  EthHeader: {
    parentHash: "H256",
    ommersHash: "H256",
    beneficiary: "EthAddress",
    stateRoot: "H256",
    transactionsRoot: "H256",
    receiptsRoot: "H256",
    logsBloom: "EthBloom",
    difficulty: "U256",
    number: "U256",
    gasLimit: "U256",
    gasUsed: "U256",
    timestamp: "u64",
    extraData: "Bytes",
    mixMash: "H256",
    nonce: "H64"
  },
  EthRichBlock: {
    _alias: {
      blockHash: "hash",
      blockSize: "size"
    },
    blockHash: "Option<H256>",
    parentHash: "H256",
    sha3Uncles: "H256",
    author: "EthAddress",
    miner: "EthAddress",
    stateRoot: "H256",
    transactionsRoot: "H256",
    receiptsRoot: "H256",
    number: "Option<U256>",
    gasUsed: "U256",
    gasLimit: "U256",
    extraData: "Bytes",
    logsBloom: "EthBloom",
    timestamp: "U256",
    difficulty: "U256",
    totalDifficulty: "Option<U256>",
    sealFields: "Vec<Bytes>",
    uncles: "Vec<H256>",
    transactions: "Vec<EthTransaction>",
    blockSize: "Option<U256>"
  },
  EthBloom: "H2048",
  EthCallRequest: {
    from: "Option<EthAddress>",
    to: "Option<EthAddress>",
    gasPrice: "Option<U256>",
    gas: "Option<U256>",
    value: "Option<U256>",
    data: "Option<Bytes>",
    nonce: "Option<U256>"
  },
  EthFeeHistory: {
    oldestBlock: "U256",
    baseFeePerGas: "Vec<U256>",
    gasUsedRatio: "Vec<f64>",
    reward: "Option<Vec<Vec<U256>>>"
  },
  EthFilter: {
    fromBlock: "Option<BlockNumber>",
    toBlock: "Option<BlockNumber>",
    blockHash: "Option<H256>",
    address: "Option<EthFilterAddress>",
    topics: "Option<EthFilterTopic>"
  },
  EthFilterAddress: {
    _enum: {
      Single: "EthAddress",
      Multiple: "Vec<EthAddress>",
      Null: "Null"
    }
  },
  EthFilterChanges: {
    _enum: {
      Logs: "Vec<EthLog>",
      Hashes: "Vec<H256>",
      Empty: "Null"
    }
  },
  EthFilterTopic: {
    _enum: {
      Single: "EthFilterTopicInner",
      Multiple: "Vec<EthFilterTopicInner>",
      Null: "Null"
    }
  },
  EthFilterTopicEntry: "Option<H256>",
  EthFilterTopicInner: {
    _enum: {
      Single: "EthFilterTopicEntry",
      Multiple: "Vec<EthFilterTopicEntry>",
      Null: "Null"
    }
  },
  EthRichHeader: {
    _alias: {
      blockHash: "hash",
      blockSize: "size"
    },
    blockHash: "Option<H256>",
    parentHash: "H256",
    sha3Uncles: "H256",
    author: "EthAddress",
    miner: "EthAddress",
    stateRoot: "H256",
    transactionsRoot: "H256",
    receiptsRoot: "H256",
    number: "Option<U256>",
    gasUsed: "U256",
    gasLimit: "U256",
    extraData: "Bytes",
    logsBloom: "EthBloom",
    timestamp: "U256",
    difficulty: "U256",
    sealFields: "Vec<Bytes>",
    blockSize: "Option<U256>"
  },
  EthLog: {
    address: "EthAddress",
    topics: "Vec<H256>",
    data: "Bytes",
    blockHash: "Option<H256>",
    blockNumber: "Option<U256>",
    transactionHash: "Option<H256>",
    transactionIndex: "Option<U256>",
    logIndex: "Option<U256>",
    transactionLogIndex: "Option<U256>",
    removed: "bool"
  },
  EthReceipt: {
    transactionHash: "Option<H256>",
    transactionIndex: "Option<U256>",
    blockHash: "Option<H256>",
    from: "Option<EthAddress>",
    to: "Option<EthAddress>",
    blockNumber: "Option<U256>",
    cumulativeGasUsed: "U256",
    gasUsed: "Option<U256>",
    contractAddress: "Option<EthAddress>",
    logs: "Vec<EthLog>",
    root: "Option<H256>",
    logsBloom: "EthBloom",
    statusCode: "Option<U64>"
  },
  EthReceiptV0: "EthReceipt",
  EthReceiptV3: "EthReceipt",
  EthStorageProof: {
    key: "U256",
    value: "U256",
    proof: "Vec<Bytes>"
  },
  EthSubKind: {
    _enum: ["newHeads", "logs", "newPendingTransactions", "syncing"]
  },
  EthSubParams: {
    _enum: {
      None: "Null",
      Logs: "EthFilter"
    }
  },
  EthSubResult: {
    _enum: {
      Header: "EthRichHeader",
      Log: "EthLog",
      TransactionHash: "H256",
      SyncState: "EthSyncStatus"
    }
  },
  EthSyncInfo: {
    startingBlock: "U256",
    currentBlock: "U256",
    highestBlock: "U256",
    warpChunksAmount: "Option<U256>",
    warpChunksProcessed: "Option<U256>"
  },
  EthSyncStatus: {
    _enum: {
      Info: "EthSyncInfo",
      None: "Null"
    }
  },
  EthTransaction: {
    hash: "H256",
    nonce: "U256",
    blockHash: "Option<H256>",
    blockNumber: "Option<U256>",
    transactionIndex: "Option<U256>",
    from: "H160",
    to: "Option<H160>",
    value: "U256",
    gasPrice: "Option<U256>",
    maxFeePerGas: "Option<U256>",
    maxPriorityFeePerGas: "Option<U256>",
    gas: "U256",
    input: "Bytes",
    creates: "Option<H160>",
    raw: "Bytes",
    publicKey: "Option<H512>",
    chainId: "Option<U64>",
    standardV: "U256",
    v: "U256",
    r: "U256",
    s: "U256",
    accessList: "Option<Vec<EthAccessListItem>>",
    transactionType: "Option<U256>"
  },
  EthTransactionSignature: {
    v: "u64",
    r: "H256",
    s: "H256"
  },
  EthTransactionAction: {
    _enum: {
      Call: "H160",
      Create: "Null"
    }
  },
  EthTransactionCondition: {
    _enum: {
      block: "u64",
      time: "u64"
    }
  },
  EthTransactionRequest: {
    from: "Option<EthAddress>",
    to: "Option<EthAddress>",
    gasPrice: "Option<U256>",
    gas: "Option<U256>",
    value: "Option<U256>",
    data: "Option<Bytes>",
    nonce: "Option<U256>"
  },
  EthTransactionStatus: {
    transactionHash: "H256",
    transactionIndex: "u32",
    from: "EthAddress",
    to: "Option<EthAddress>",
    contractAddress: "Option<EthAddress>",
    logs: "Vec<EthLog>",
    logsBloom: "EthBloom"
  },
  EthWork: {
    powHash: "H256",
    seedHash: "H256",
    target: "H256",
    number: "Option<u64>"
  }
});
var definitions_default58 = {
  rpc: rpc10,
  runtime: runtime20,
  types
};

// node_modules/@polkadot/types/interfaces/nimbus/runtime.js
var runtime21 = {
  AuthorFilterAPI: [{
    methods: {
      can_author: {
        description: "The runtime api used to predict whether an author will be eligible in the given slot",
        params: [{
          name: "author",
          type: "AccountId"
        }, {
          name: "relayParent",
          type: "u32"
        }, {
          name: "parentHeader",
          type: "Header"
        }],
        type: "bool"
      }
    },
    version: 2
  }, {
    methods: {
      can_author: {
        description: "The runtime api used to predict whether an author will be eligible in the given slot",
        params: [{
          name: "author",
          type: "AccountId"
        }, {
          name: "relayParent",
          type: "u32"
        }],
        type: "bool"
      }
    },
    version: 1
  }],
  NimbusApi: [{
    methods: {
      can_author: {
        description: "The runtime api used to predict whether a Nimbus author will be eligible in the given slot",
        params: [{
          name: "author",
          type: "AccountId"
        }, {
          name: "relayParent",
          type: "u32"
        }, {
          name: "parentHeader",
          type: "Header"
        }],
        type: "bool"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/nimbus/definitions.js
var definitions_default59 = {
  rpc: {},
  runtime: runtime21,
  types: {}
};

// node_modules/@polkadot/types/interfaces/ormlOracle/runtime.js
var runtime22 = {
  OracleApi: [{
    methods: {
      get_all_values: {
        description: "Retrieves all values",
        params: [{
          name: "providerId",
          type: "Raw"
        }],
        type: "Raw"
      },
      get_value: {
        description: "Retrieves a single value",
        params: [{
          name: "providerId",
          type: "Raw"
        }, {
          name: "key",
          type: "Raw"
        }],
        type: "Option<Raw>"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/ormlOracle/definitions.js
var definitions_default60 = {
  rpc: {},
  runtime: runtime22,
  types: {}
};

// node_modules/@polkadot/types/interfaces/ormlTokens/runtime.js
var runtime23 = {
  TokensApi: [{
    methods: {
      query_existential_deposit: {
        description: "Query the existential amount for a specific currency",
        params: [{
          name: "currencyId",
          type: "Raw"
        }],
        type: "u128"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/ormlTokens/definitions.js
var definitions_default61 = {
  rpc: {},
  runtime: runtime23,
  types: {}
};

// node_modules/@polkadot/types/interfaces/rpc/rpc.js
var rpc11 = {
  methods: {
    description: "Retrieves the list of RPC methods that are exposed by the node",
    params: [],
    type: "RpcMethods"
  }
};

// node_modules/@polkadot/types/interfaces/rpc/definitions.js
var definitions_default62 = {
  rpc: rpc11,
  types: {
    RpcMethods: {
      version: "u32",
      methods: "Vec<Text>"
    }
  }
};

// node_modules/@polkadot/types/interfaces/author/rpc.js
var rpc12 = {
  hasKey: {
    description: "Returns true if the keystore has private keys for the given public key and key type.",
    params: [{
      name: "publicKey",
      type: "Bytes"
    }, {
      name: "keyType",
      type: "Text"
    }],
    type: "bool"
  },
  hasSessionKeys: {
    description: "Returns true if the keystore has private keys for the given session public keys.",
    params: [{
      name: "sessionKeys",
      type: "Bytes"
    }],
    type: "bool"
  },
  insertKey: {
    description: "Insert a key into the keystore.",
    params: [{
      name: "keyType",
      type: "Text"
    }, {
      name: "suri",
      type: "Text"
    }, {
      name: "publicKey",
      type: "Bytes"
    }],
    type: "Bytes"
  },
  pendingExtrinsics: {
    description: "Returns all pending extrinsics, potentially grouped by sender",
    params: [],
    type: "Vec<Extrinsic>"
  },
  removeExtrinsic: {
    description: "Remove given extrinsic from the pool and temporarily ban it to prevent reimporting",
    params: [{
      name: "bytesOrHash",
      type: "Vec<ExtrinsicOrHash>"
    }],
    type: "Vec<Hash>"
  },
  rotateKeys: {
    description: "Generate new session keys and returns the corresponding public keys",
    params: [],
    type: "Bytes"
  },
  submitAndWatchExtrinsic: {
    description: "Submit and subscribe to watch an extrinsic until unsubscribed",
    isSigned: true,
    params: [{
      name: "extrinsic",
      type: "Extrinsic"
    }],
    pubsub: ["extrinsicUpdate", "submitAndWatchExtrinsic", "unwatchExtrinsic"],
    type: "ExtrinsicStatus"
  },
  submitExtrinsic: {
    description: "Submit a fully formatted extrinsic for block inclusion",
    isSigned: true,
    params: [{
      name: "extrinsic",
      type: "Extrinsic"
    }],
    type: "Hash"
  }
};

// node_modules/@polkadot/types/interfaces/author/definitions.js
var definitions_default63 = {
  rpc: rpc12,
  types: {
    ExtrinsicOrHash: {
      _enum: {
        Hash: "Hash",
        Extrinsic: "Bytes"
      }
    },
    ExtrinsicStatus: {
      _enum: {
        Future: "Null",
        Ready: "Null",
        Broadcast: "Vec<Text>",
        InBlock: "Hash",
        Retracted: "Hash",
        FinalityTimeout: "Hash",
        Finalized: "Hash",
        Usurped: "Hash",
        Dropped: "Null",
        Invalid: "Null"
      }
    }
  }
};

// node_modules/@polkadot/types/interfaces/chain/rpc.js
var rpc13 = {
  getBlock: {
    description: "Get header and body of a relay chain block",
    params: [{
      isHistoric: true,
      isOptional: true,
      name: "hash",
      type: "BlockHash"
    }],
    type: "SignedBlock"
  },
  getBlockHash: {
    description: "Get the block hash for a specific block",
    params: [{
      isOptional: true,
      name: "blockNumber",
      type: "BlockNumber"
    }],
    type: "BlockHash"
  },
  getFinalizedHead: {
    alias: ["chain_getFinalisedHead"],
    description: "Get hash of the last finalized block in the canon chain",
    params: [],
    type: "BlockHash"
  },
  getHeader: {
    alias: ["chain_getHead"],
    description: "Retrieves the header for a specific block",
    params: [{
      isHistoric: true,
      isOptional: true,
      name: "hash",
      type: "BlockHash"
    }],
    type: "Header"
  },
  subscribeAllHeads: {
    description: "Retrieves the newest header via subscription",
    params: [],
    pubsub: ["allHead", "subscribeAllHeads", "unsubscribeAllHeads"],
    type: "Header"
  },
  subscribeFinalizedHeads: {
    alias: ["chain_subscribeFinalisedHeads", "chain_unsubscribeFinalisedHeads"],
    description: "Retrieves the best finalized header via subscription",
    params: [],
    pubsub: ["finalizedHead", "subscribeFinalizedHeads", "unsubscribeFinalizedHeads"],
    type: "Header"
  },
  subscribeNewHeads: {
    alias: ["chain_unsubscribeNewHeads", "subscribe_newHead", "unsubscribe_newHead"],
    description: "Retrieves the best header via subscription",
    params: [],
    pubsub: ["newHead", "subscribeNewHead", "unsubscribeNewHead"],
    type: "Header"
  }
};

// node_modules/@polkadot/types/interfaces/chain/definitions.js
var definitions_default64 = {
  rpc: rpc13,
  types: {
    BlockHash: "Hash"
  }
};

// node_modules/@polkadot/types/interfaces/childstate/rpc.js
var rpc14 = {
  getKeys: {
    description: "Returns the keys with prefix from a child storage, leave empty to get all the keys",
    params: [{
      name: "childKey",
      type: "PrefixedStorageKey"
    }, {
      name: "prefix",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "Hash"
    }],
    type: "Vec<StorageKey>"
  },
  getKeysPaged: {
    alias: ["childstate_getKeysPagedAt"],
    description: "Returns the keys with prefix from a child storage with pagination support",
    params: [{
      name: "childKey",
      type: "PrefixedStorageKey"
    }, {
      name: "prefix",
      type: "StorageKey"
    }, {
      name: "count",
      type: "u32"
    }, {
      isOptional: true,
      name: "startKey",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "Hash"
    }],
    type: "Vec<StorageKey>"
  },
  getStorage: {
    description: "Returns a child storage entry at a specific block state",
    params: [{
      name: "childKey",
      type: "PrefixedStorageKey"
    }, {
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "Hash"
    }],
    type: "Option<StorageData>"
  },
  getStorageEntries: {
    description: "Returns child storage entries for multiple keys at a specific block state",
    params: [{
      name: "childKey",
      type: "PrefixedStorageKey"
    }, {
      name: "keys",
      type: "Vec<StorageKey>"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "Hash"
    }],
    type: "Vec<Option<StorageData>>"
  },
  getStorageHash: {
    description: "Returns the hash of a child storage entry at a block state",
    params: [{
      name: "childKey",
      type: "PrefixedStorageKey"
    }, {
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "Hash"
    }],
    type: "Option<Hash>"
  },
  getStorageSize: {
    description: "Returns the size of a child storage entry at a block state",
    params: [{
      name: "childKey",
      type: "PrefixedStorageKey"
    }, {
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "Hash"
    }],
    type: "Option<u64>"
  }
};

// node_modules/@polkadot/types/interfaces/childstate/definitions.js
var definitions_default65 = {
  rpc: rpc14,
  types: {
    PrefixedStorageKey: "StorageKey"
  }
};

// node_modules/@polkadot/types/interfaces/offchain/rpc.js
var rpc15 = {
  localStorageGet: {
    description: "Get offchain local storage under given key and prefix",
    params: [{
      name: "kind",
      type: "StorageKind"
    }, {
      name: "key",
      type: "Bytes"
    }],
    type: "Option<Bytes>"
  },
  localStorageSet: {
    description: "Set offchain local storage under given key and prefix",
    params: [{
      name: "kind",
      type: "StorageKind"
    }, {
      name: "key",
      type: "Bytes"
    }, {
      name: "value",
      type: "Bytes"
    }],
    type: "Null"
  }
};

// node_modules/@polkadot/types/interfaces/offchain/runtime.js
var runtime24 = {
  OffchainWorkerApi: [{
    methods: {
      offchain_worker: {
        description: "Starts the off-chain task for given block header.",
        params: [{
          name: "header",
          type: "Header"
        }],
        type: "Null"
      }
    },
    version: 2
  }, {
    methods: {
      offchain_worker: {
        description: "Starts the off-chain task for given block header.",
        params: [{
          name: "number",
          type: "BlockNumber"
        }],
        type: "Null"
      }
    },
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/offchain/definitions.js
var definitions_default66 = {
  rpc: rpc15,
  runtime: runtime24,
  types: {
    StorageKind: {
      _enum: {
        PERSISTENT: 1,
        LOCAL: 2
      }
    }
  }
};

// node_modules/@polkadot/types/interfaces/payment/rpc.js
var rpc16 = {
  queryFeeDetails: {
    deprecated: "Use `api.call.transactionPaymentApi.queryFeeDetails` instead",
    description: "Query the detailed fee of a given encoded extrinsic",
    params: [{
      name: "extrinsic",
      type: "Bytes"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "FeeDetails"
  },
  queryInfo: {
    deprecated: "Use `api.call.transactionPaymentApi.queryInfo` instead",
    description: "Retrieves the fee information for an encoded extrinsic",
    params: [{
      name: "extrinsic",
      type: "Bytes"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "RuntimeDispatchInfoV1"
  }
};

// node_modules/@polkadot/types/interfaces/payment/runtime.js
var V1_V2_SHARED_PAY = {
  query_fee_details: {
    description: "The transaction fee details",
    params: [{
      name: "uxt",
      type: "Extrinsic"
    }, {
      name: "len",
      type: "u32"
    }],
    type: "FeeDetails"
  }
};
var V1_V2_SHARED_CALL = {
  query_call_fee_details: {
    description: "The call fee details",
    params: [{
      name: "call",
      type: "Call"
    }, {
      name: "len",
      type: "u32"
    }],
    type: "FeeDetails"
  }
};
var runtime25 = {
  TransactionPaymentApi: [{
    methods: objectSpread({
      query_info: {
        description: "The transaction info",
        params: [{
          name: "uxt",
          type: "Extrinsic"
        }, {
          name: "len",
          type: "u32"
        }],
        type: "RuntimeDispatchInfo"
      }
    }, V1_V2_SHARED_PAY),
    version: 2
  }, {
    methods: objectSpread({
      query_info: {
        description: "The transaction info",
        params: [{
          name: "uxt",
          type: "Extrinsic"
        }, {
          name: "len",
          type: "u32"
        }],
        type: "RuntimeDispatchInfo"
      }
    }, V1_V2_SHARED_PAY),
    version: 1
  }],
  TransactionPaymentCallApi: [{
    methods: objectSpread({
      query_call_info: {
        description: "The call info",
        params: [{
          name: "call",
          type: "Call"
        }, {
          name: "len",
          type: "u32"
        }],
        type: "RuntimeDispatchInfo"
      }
    }, V1_V2_SHARED_CALL),
    version: 2
  }, {
    methods: objectSpread({
      query_call_info: {
        description: "The call info",
        params: [{
          name: "call",
          type: "Call"
        }, {
          name: "len",
          type: "u32"
        }],
        type: "RuntimeDispatchInfo"
      }
    }, V1_V2_SHARED_CALL),
    version: 1
  }]
};

// node_modules/@polkadot/types/interfaces/payment/definitions.js
var definitions_default67 = {
  rpc: rpc16,
  runtime: runtime25,
  types: {
    FeeDetails: {
      inclusionFee: "Option<InclusionFee>"
    },
    InclusionFee: {
      baseFee: "Balance",
      lenFee: "Balance",
      adjustedWeightFee: "Balance"
    },
    RuntimeDispatchInfo: {
      weight: "Weight",
      class: "DispatchClass",
      partialFee: "Balance"
    },
    RuntimeDispatchInfoV1: {
      weight: "WeightV1",
      class: "DispatchClass",
      partialFee: "Balance"
    },
    RuntimeDispatchInfoV2: {
      weight: "WeightV2",
      class: "DispatchClass",
      partialFee: "Balance"
    }
  }
};

// node_modules/@polkadot/types/interfaces/state/rpc.js
var rpc17 = {
  call: {
    alias: ["state_callAt"],
    description: "Perform a call to a builtin on the chain",
    params: [{
      name: "method",
      type: "Text"
    }, {
      name: "data",
      type: "Bytes"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Bytes"
  },
  getChildKeys: {
    description: "Retrieves the keys with prefix of a specific child storage",
    params: [{
      name: "childStorageKey",
      type: "StorageKey"
    }, {
      name: "childDefinition",
      type: "StorageKey"
    }, {
      name: "childType",
      type: "u32"
    }, {
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Vec<StorageKey>"
  },
  getChildReadProof: {
    description: "Returns proof of storage for child key entries at a specific block state.",
    params: [{
      name: "childStorageKey",
      type: "PrefixedStorageKey"
    }, {
      name: "keys",
      type: "Vec<StorageKey>"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "ReadProof"
  },
  getChildStorage: {
    description: "Retrieves the child storage for a key",
    params: [{
      name: "childStorageKey",
      type: "StorageKey"
    }, {
      name: "childDefinition",
      type: "StorageKey"
    }, {
      name: "childType",
      type: "u32"
    }, {
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "StorageData"
  },
  getChildStorageHash: {
    description: "Retrieves the child storage hash",
    params: [{
      name: "childStorageKey",
      type: "StorageKey"
    }, {
      name: "childDefinition",
      type: "StorageKey"
    }, {
      name: "childType",
      type: "u32"
    }, {
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Hash"
  },
  getChildStorageSize: {
    description: "Retrieves the child storage size",
    params: [{
      name: "childStorageKey",
      type: "StorageKey"
    }, {
      name: "childDefinition",
      type: "StorageKey"
    }, {
      name: "childType",
      type: "u32"
    }, {
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "u64"
  },
  getKeys: {
    deprecated: "Use `api.rpc.state.getKeysPaged` to retrieve keys",
    description: "Retrieves the keys with a certain prefix",
    params: [{
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Vec<StorageKey>"
  },
  getKeysPaged: {
    alias: ["state_getKeysPagedAt"],
    description: "Returns the keys with prefix with pagination support.",
    params: [{
      name: "key",
      type: "StorageKey"
    }, {
      name: "count",
      type: "u32"
    }, {
      isOptional: true,
      name: "startKey",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Vec<StorageKey>"
  },
  getMetadata: {
    description: "Returns the runtime metadata",
    params: [{
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Metadata"
  },
  getPairs: {
    deprecated: "Use `api.rpc.state.getKeysPaged` to retrieve keys",
    description: "Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)",
    params: [{
      name: "prefix",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Vec<KeyValue>"
  },
  getReadProof: {
    description: "Returns proof of storage entries at a specific block state",
    params: [{
      name: "keys",
      type: "Vec<StorageKey>"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "ReadProof"
  },
  getRuntimeVersion: {
    alias: ["chain_getRuntimeVersion"],
    description: "Get the runtime version",
    params: [{
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "RuntimeVersion"
  },
  getStorage: {
    alias: ["state_getStorageAt"],
    description: "Retrieves the storage for a key",
    params: [{
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "StorageData"
  },
  getStorageHash: {
    alias: ["state_getStorageHashAt"],
    description: "Retrieves the storage hash",
    params: [{
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Hash"
  },
  getStorageSize: {
    alias: ["state_getStorageSizeAt"],
    description: "Retrieves the storage size",
    params: [{
      name: "key",
      type: "StorageKey"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "u64"
  },
  queryStorage: {
    description: "Query historical storage entries (by key) starting from a start block",
    params: [{
      name: "keys",
      type: "Vec<StorageKey>"
    }, {
      name: "fromBlock",
      type: "Hash"
    }, {
      isOptional: true,
      name: "toBlock",
      type: "BlockHash"
    }],
    type: "Vec<StorageChangeSet>"
  },
  queryStorageAt: {
    description: "Query storage entries (by key) starting at block hash given as the second parameter",
    params: [{
      name: "keys",
      type: "Vec<StorageKey>"
    }, {
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "Vec<StorageChangeSet>"
  },
  subscribeRuntimeVersion: {
    alias: ["chain_subscribeRuntimeVersion", "chain_unsubscribeRuntimeVersion"],
    description: "Retrieves the runtime version via subscription",
    params: [],
    pubsub: ["runtimeVersion", "subscribeRuntimeVersion", "unsubscribeRuntimeVersion"],
    type: "RuntimeVersion"
  },
  subscribeStorage: {
    description: "Subscribes to storage changes for the provided keys",
    params: [{
      isOptional: true,
      name: "keys",
      type: "Vec<StorageKey>"
    }],
    pubsub: ["storage", "subscribeStorage", "unsubscribeStorage"],
    type: "StorageChangeSet"
  },
  traceBlock: {
    description: "Provides a way to trace the re-execution of a single block",
    params: [{
      name: "block",
      type: "Hash"
    }, {
      name: "targets",
      type: "Option<Text>"
    }, {
      name: "storageKeys",
      type: "Option<Text>"
    }, {
      name: "methods",
      type: "Option<Text>"
    }],
    type: "TraceBlockResponse"
  },
  trieMigrationStatus: {
    description: "Check current migration state",
    params: [{
      isHistoric: true,
      isOptional: true,
      name: "at",
      type: "BlockHash"
    }],
    type: "MigrationStatusResult"
  }
};

// node_modules/@polkadot/types/interfaces/state/definitions.js
var definitions_default68 = {
  rpc: rpc17,
  types: {
    ApiId: "[u8; 8]",
    BlockTrace: {
      blockHash: "Text",
      parentHash: "Text",
      tracingTargets: "Text",
      storageKeys: "Text",
      spans: "Vec<BlockTraceSpan>",
      events: "Vec<BlockTraceEvent>"
    },
    BlockTraceEvent: {
      target: "Text",
      data: "BlockTraceEventData",
      parentId: "Option<u64>"
    },
    BlockTraceEventData: {
      stringValues: "HashMap<Text, Text>"
    },
    BlockTraceSpan: {
      id: "u64",
      parentId: "Option<u64>",
      name: "Text",
      target: "Text",
      wasm: "bool"
    },
    KeyValueOption: "(StorageKey, Option<StorageData>)",
    MigrationStatusResult: {
      topRemainingToMigrate: "u64",
      childRemainingToMigrate: "u64"
    },
    ReadProof: {
      at: "Hash",
      proof: "Vec<Bytes>"
    },
    RuntimeVersionApi: "(ApiId, u32)",
    RuntimeVersion: {
      specName: "Text",
      implName: "Text",
      authoringVersion: "u32",
      specVersion: "u32",
      implVersion: "u32",
      apis: "Vec<RuntimeVersionApi>",
      transactionVersion: "u32",
      stateVersion: "u8"
    },
    RuntimeVersionPre4: {
      specName: "Text",
      implName: "Text",
      authoringVersion: "u32",
      specVersion: "u32",
      implVersion: "u32",
      apis: "Vec<RuntimeVersionApi>",
      transactionVersion: "u32"
    },
    RuntimeVersionPre3: {
      specName: "Text",
      implName: "Text",
      authoringVersion: "u32",
      specVersion: "u32",
      implVersion: "u32",
      apis: "Vec<RuntimeVersionApi>"
    },
    RuntimeVersionPartial: {
      specName: "Text",
      specVersion: "u32",
      apis: "Vec<RuntimeVersionApi>"
    },
    SpecVersion: "u32",
    StorageChangeSet: {
      block: "Hash",
      changes: "Vec<KeyValueOption>"
    },
    TraceBlockResponse: {
      _enum: {
        TraceError: "TraceError",
        BlockTrace: "BlockTrace"
      }
    },
    TraceError: {
      error: "Text"
    }
  }
};

// node_modules/@polkadot/types/interfaces/jsonrpc.js
var jsonrpc = {};
Object.keys(definitions_exports).forEach((s) => Object.entries(definitions_exports[s].rpc || {}).forEach(([method, def]) => {
  const section2 = def.aliasSection || s;
  if (!jsonrpc[section2]) {
    jsonrpc[section2] = {};
  }
  jsonrpc[section2][method] = objectSpread({}, def, {
    isSubscription: !!def.pubsub,
    jsonrpc: `${section2}_${method}`,
    method,
    section: section2
  });
}));
var jsonrpc_default = jsonrpc;

// node_modules/@polkadot/types/create/lazy.js
function lazyVariants(lookup, {
  type
}, getName, creator) {
  const result = {};
  const variants = lookup.getSiType(type).def.asVariant.variants;
  for (let i = 0; i < variants.length; i++) {
    lazyMethod(result, variants[i], creator, getName, i);
  }
  return result;
}

// node_modules/@polkadot/types/extrinsic/signedExtensions/emptyCheck.js
var emptyCheck = {
  extrinsic: {},
  payload: {}
};

// node_modules/@polkadot/types/extrinsic/signedExtensions/polkadot.js
var polkadot = {
  LimitParathreadCommits: emptyCheck,
  OnlyStakingAndClaims: emptyCheck,
  PrevalidateAttests: emptyCheck,
  RestrictFunctionality: emptyCheck,
  TransactionCallFilter: emptyCheck,
  ValidateDoubleVoteReports: emptyCheck
};

// node_modules/@polkadot/types/extrinsic/signedExtensions/shell.js
var shell = {
  DisallowSigned: emptyCheck
};

// node_modules/@polkadot/types/extrinsic/signedExtensions/statemint.js
var statemint = {
  ChargeAssetTxPayment: {
    extrinsic: {
      tip: "Compact<Balance>",
      assetId: "Option<AssetId>"
    },
    payload: {}
  }
};

// node_modules/@polkadot/types/extrinsic/signedExtensions/substrate.js
var CheckMortality = {
  extrinsic: {
    era: "ExtrinsicEra"
  },
  payload: {
    blockHash: "Hash"
  }
};
var substrate = {
  ChargeTransactionPayment: {
    extrinsic: {
      tip: "Compact<Balance>"
    },
    payload: {}
  },
  CheckBlockGasLimit: emptyCheck,
  CheckEra: CheckMortality,
  CheckGenesis: {
    extrinsic: {},
    payload: {
      genesisHash: "Hash"
    }
  },
  CheckMortality,
  CheckNonZeroSender: emptyCheck,
  CheckNonce: {
    extrinsic: {
      nonce: "Compact<Index>"
    },
    payload: {}
  },
  CheckSpecVersion: {
    extrinsic: {},
    payload: {
      specVersion: "u32"
    }
  },
  CheckTxVersion: {
    extrinsic: {},
    payload: {
      transactionVersion: "u32"
    }
  },
  CheckVersion: {
    extrinsic: {},
    payload: {
      specVersion: "u32"
    }
  },
  CheckWeight: emptyCheck,
  LockStakingStatus: emptyCheck,
  ValidateEquivocationReport: emptyCheck
};

// node_modules/@polkadot/types/extrinsic/signedExtensions/index.js
var allExtensions = objectSpread({}, substrate, polkadot, shell, statemint);
var fallbackExtensions = ["CheckVersion", "CheckGenesis", "CheckEra", "CheckNonce", "CheckWeight", "ChargeTransactionPayment", "CheckBlockGasLimit"];
function findUnknownExtensions(extensions, userExtensions = {}) {
  const names = [...Object.keys(allExtensions), ...Object.keys(userExtensions)];
  return extensions.filter((k) => !names.includes(k));
}
function expandExtensionTypes(extensions, type, userExtensions = {}) {
  return extensions.map((k) => userExtensions[k] || allExtensions[k]).filter((info6) => !!info6).reduce((result, info6) => objectSpread(result, info6[type]), {});
}

// node_modules/@polkadot/types/generic/Event.js
function decodeEvent(registry, value) {
  if (!value || !value.length) {
    return {
      DataType: Null
    };
  }
  const index = value.subarray(0, 2);
  return {
    DataType: registry.findMetaEvent(index),
    value: {
      data: value.subarray(2),
      index
    }
  };
}
var _meta, _method, _names, _section, _typeDef;
var GenericEventData = class extends Tuple {
  constructor(registry, value, meta, section2 = "<unknown>", method = "<unknown>") {
    const fields = (meta == null ? void 0 : meta.fields) || [];
    super(registry, fields.map(({
      type
    }) => registry.createLookupType(type)), value);
    __privateAdd(this, _meta, void 0);
    __privateAdd(this, _method, void 0);
    __privateAdd(this, _names, null);
    __privateAdd(this, _section, void 0);
    __privateAdd(this, _typeDef, void 0);
    __privateSet(this, _meta, meta);
    __privateSet(this, _method, method);
    __privateSet(this, _section, section2);
    __privateSet(this, _typeDef, fields.map(({
      type
    }) => registry.lookup.getTypeDef(type)));
    const names = fields.map(({
      name
    }) => registry.lookup.sanitizeField(name)[0]).filter((n) => !!n);
    if (names.length === fields.length) {
      __privateSet(this, _names, names);
      objectProperties(this, names, (_, i) => this[i]);
    }
  }
  get meta() {
    return __privateGet(this, _meta);
  }
  get method() {
    return __privateGet(this, _method);
  }
  get names() {
    return __privateGet(this, _names);
  }
  get section() {
    return __privateGet(this, _section);
  }
  get typeDef() {
    return __privateGet(this, _typeDef);
  }
  toHuman(isExtended) {
    if (__privateGet(this, _names) !== null) {
      const json = {};
      for (let i = 0; i < __privateGet(this, _names).length; i++) {
        json[__privateGet(this, _names)[i]] = this[i].toHuman(isExtended);
      }
      return json;
    }
    return super.toHuman(isExtended);
  }
};
_meta = new WeakMap();
_method = new WeakMap();
_names = new WeakMap();
_section = new WeakMap();
_typeDef = new WeakMap();
var GenericEvent = class extends Struct {
  constructor(registry, _value) {
    const {
      DataType,
      value
    } = decodeEvent(registry, _value);
    super(registry, {
      index: "EventId",
      data: DataType
    }, value);
  }
  get data() {
    return this.getT("data");
  }
  get index() {
    return this.getT("index");
  }
  get meta() {
    return this.data.meta;
  }
  get method() {
    return this.data.method;
  }
  get section() {
    return this.data.section;
  }
  get typeDef() {
    return this.data.typeDef;
  }
  toHuman(isExpanded) {
    return objectSpread({
      method: this.method,
      section: this.section
    }, isExpanded ? {
      docs: this.meta.docs.map((d) => d.toString())
    } : null, super.toHuman(isExpanded));
  }
};

// node_modules/@polkadot/types/index.types.js
var index_types_exports = {};
__export(index_types_exports, {
  BitVec: () => BitVec,
  Bool: () => bool2,
  Bytes: () => Bytes,
  Data: () => Data,
  F32: () => f32,
  F64: () => f64,
  GenericAccountId: () => GenericAccountId,
  GenericAccountId32: () => GenericAccountId,
  GenericAccountId33: () => GenericAccountId33,
  GenericAccountIndex: () => GenericAccountIndex,
  GenericAddress: () => GenericMultiAddress,
  GenericBlock: () => GenericBlock,
  GenericCall: () => GenericCall,
  GenericChainProperties: () => GenericChainProperties,
  GenericConsensusEngineId: () => GenericConsensusEngineId,
  GenericEthereumAccountId: () => GenericEthereumAccountId,
  GenericEthereumLookupSource: () => GenericEthereumLookupSource,
  GenericEvent: () => GenericEvent,
  GenericEventData: () => GenericEventData,
  GenericExtrinsic: () => GenericExtrinsic,
  GenericExtrinsicEra: () => GenericExtrinsicEra,
  GenericExtrinsicPayload: () => GenericExtrinsicPayload,
  GenericExtrinsicPayloadUnknown: () => GenericExtrinsicPayloadUnknown,
  GenericExtrinsicPayloadV4: () => GenericExtrinsicPayloadV4,
  GenericExtrinsicSignatureV4: () => GenericExtrinsicSignatureV4,
  GenericExtrinsicUnknown: () => GenericExtrinsicUnknown,
  GenericExtrinsicV4: () => GenericExtrinsicV4,
  GenericImmortalEra: () => ImmortalEra,
  GenericLookupSource: () => GenericLookupSource,
  GenericMortalEra: () => MortalEra,
  GenericMultiAddress: () => GenericMultiAddress,
  GenericSignerPayload: () => GenericSignerPayload,
  GenericVote: () => GenericVote,
  I128: () => i128,
  I16: () => i16,
  I256: () => i256,
  I32: () => i32,
  I64: () => i64,
  I8: () => i8,
  Null: () => Null,
  OptionBool: () => OptionBool,
  StorageKey: () => StorageKey,
  Text: () => Text,
  Type: () => Type,
  U128: () => u128,
  U16: () => u162,
  U256: () => u256,
  U32: () => u323,
  U64: () => u642,
  U8: () => u82,
  USize: () => usize,
  bool: () => bool2,
  f32: () => f32,
  f64: () => f64,
  i128: () => i128,
  i16: () => i16,
  i256: () => i256,
  i32: () => i32,
  i64: () => i64,
  i8: () => i8,
  u128: () => u128,
  u16: () => u162,
  u256: () => u256,
  u32: () => u323,
  u64: () => u642,
  u8: () => u82,
  usize: () => usize
});

// node_modules/@polkadot/types/extrinsic/v4/Extrinsic.js
var EXTRINSIC_VERSION = 4;
var GenericExtrinsicV4 = class extends Struct {
  constructor(registry, value, {
    isSigned
  } = {}) {
    super(registry, {
      signature: "ExtrinsicSignatureV4",
      method: "Call"
    }, GenericExtrinsicV4.decodeExtrinsic(registry, value, isSigned));
  }
  static decodeExtrinsic(registry, value, isSigned = false) {
    if (value instanceof GenericExtrinsicV4) {
      return value;
    } else if (value instanceof registry.createClassUnsafe("Call")) {
      return {
        method: value
      };
    } else if (isU8a(value)) {
      const signature = registry.createTypeUnsafe("ExtrinsicSignatureV4", [value, {
        isSigned
      }]);
      const method = registry.createTypeUnsafe("Call", [value.subarray(signature.encodedLength)]);
      return {
        method,
        signature
      };
    }
    return value || {};
  }
  get encodedLength() {
    return this.toU8a().length;
  }
  get method() {
    return this.getT("method");
  }
  get signature() {
    return this.getT("signature");
  }
  get version() {
    return EXTRINSIC_VERSION;
  }
  addSignature(signer, signature, payload) {
    this.signature.addSignature(signer, signature, payload);
    return this;
  }
  sign(account3, options) {
    this.signature.sign(this.method, account3, options);
    return this;
  }
  signFake(signer, options) {
    this.signature.signFake(this.method, signer, options);
    return this;
  }
};

// node_modules/@polkadot/types/extrinsic/constants.js
var BIT_SIGNED = 128;
var BIT_UNSIGNED = 0;
var EMPTY_U8A3 = new Uint8Array();
var DEFAULT_VERSION = 4;
var IMMORTAL_ERA = new Uint8Array([0]);
var UNMASK_VERSION = 127;

// node_modules/@polkadot/types/extrinsic/Extrinsic.js
var VERSIONS = [
  "ExtrinsicUnknown",
  "ExtrinsicUnknown",
  "ExtrinsicUnknown",
  "ExtrinsicUnknown",
  "ExtrinsicV4"
];
function newFromValue(registry, value, version) {
  if (value instanceof GenericExtrinsic) {
    return value.unwrap();
  }
  const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;
  const type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0];
  return registry.createTypeUnsafe(type, [value, {
    isSigned,
    version
  }]);
}
function decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {
  if (isU8a(value) || Array.isArray(value) || isHex(value)) {
    return decodeU8a3(registry, u8aToU8a(value), version);
  } else if (value instanceof registry.createClassUnsafe("Call")) {
    return newFromValue(registry, {
      method: value
    }, version);
  }
  return newFromValue(registry, value, version);
}
function decodeU8a3(registry, value, version) {
  if (!value.length) {
    return newFromValue(registry, new Uint8Array(), version);
  }
  const [offset, length] = compactFromU8a(value);
  const total = offset + length.toNumber();
  if (total > value.length) {
    throw new Error(`Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);
  }
  const data = value.subarray(offset, total);
  return newFromValue(registry, data.subarray(1), data[0]);
}
var ExtrinsicBase = class extends AbstractBase {
  constructor(registry, value, initialU8aLength) {
    super(registry, value, initialU8aLength);
    const signKeys = Object.keys(registry.getSignedExtensionTypes());
    const getter = (key) => this.inner.signature[key];
    for (let i = 0; i < signKeys.length; i++) {
      objectProperty(this, signKeys[i], getter);
    }
  }
  get args() {
    return this.method.args;
  }
  get argsDef() {
    return this.method.argsDef;
  }
  get callIndex() {
    return this.method.callIndex;
  }
  get data() {
    return this.method.data;
  }
  get era() {
    return this.inner.signature.era;
  }
  get encodedLength() {
    return this.toU8a().length;
  }
  get isSigned() {
    return this.inner.signature.isSigned;
  }
  get length() {
    return this.toU8a(true).length;
  }
  get meta() {
    return this.method.meta;
  }
  get method() {
    return this.inner.method;
  }
  get nonce() {
    return this.inner.signature.nonce;
  }
  get signature() {
    return this.inner.signature.signature;
  }
  get signer() {
    return this.inner.signature.signer;
  }
  get tip() {
    return this.inner.signature.tip;
  }
  get type() {
    return this.inner.version;
  }
  get inner() {
    return this.unwrap();
  }
  get version() {
    return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);
  }
  is(other) {
    return this.method.is(other);
  }
  unwrap() {
    return super.unwrap();
  }
};
var _hashCache;
var GenericExtrinsic = class extends ExtrinsicBase {
  constructor(registry, value, {
    version
  } = {}) {
    super(registry, decodeExtrinsic(registry, value, version));
    __privateAdd(this, _hashCache, void 0);
  }
  get hash() {
    if (!__privateGet(this, _hashCache)) {
      __privateSet(this, _hashCache, super.hash);
    }
    return __privateGet(this, _hashCache);
  }
  addSignature(signer, signature, payload) {
    this.inner.addSignature(signer, signature, payload);
    __privateSet(this, _hashCache, void 0);
    return this;
  }
  inspect() {
    const encoded = u8aConcat(...this.toU8aInner());
    return {
      inner: this.isSigned ? this.inner.inspect().inner : this.inner.method.inspect().inner,
      outer: [compactToU8a(encoded.length), new Uint8Array([this.version])]
    };
  }
  sign(account3, options) {
    this.inner.sign(account3, options);
    __privateSet(this, _hashCache, void 0);
    return this;
  }
  signFake(signer, options) {
    this.inner.signFake(signer, options);
    __privateSet(this, _hashCache, void 0);
    return this;
  }
  toHex(isBare) {
    return u8aToHex(this.toU8a(isBare));
  }
  toHuman(isExpanded) {
    return objectSpread({}, {
      isSigned: this.isSigned,
      method: this.method.toHuman(isExpanded)
    }, this.isSigned ? {
      era: this.era.toHuman(isExpanded),
      nonce: this.nonce.toHuman(isExpanded),
      signature: this.signature.toHex(),
      signer: this.signer.toHuman(isExpanded),
      tip: this.tip.toHuman(isExpanded)
    } : null);
  }
  toJSON() {
    return this.toHex();
  }
  toRawType() {
    return "Extrinsic";
  }
  toU8a(isBare) {
    const encoded = u8aConcat(...this.toU8aInner());
    return isBare ? encoded : compactAddLength(encoded);
  }
  toU8aInner() {
    return [new Uint8Array([this.version]), this.inner.toU8a()];
  }
};
_hashCache = new WeakMap();
__publicField(GenericExtrinsic, "LATEST_EXTRINSIC_VERSION", EXTRINSIC_VERSION);

// node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js
function getTrailingZeros(period) {
  const binary = period.toString(2);
  let index = 0;
  while (binary[binary.length - 1 - index] === "0") {
    index++;
  }
  return index;
}
function decodeMortalEra(registry, value) {
  if (isU8a(value) || isHex(value) || Array.isArray(value)) {
    return decodeMortalU8a(registry, u8aToU8a(value));
  } else if (!value) {
    return [new u642(registry), new u642(registry)];
  } else if (isObject(value)) {
    return decodeMortalObject(registry, value);
  }
  throw new Error("Invalid data passed to Mortal era");
}
function decodeMortalObject(registry, value) {
  const {
    current,
    period
  } = value;
  let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));
  calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);
  const phase = current % calPeriod;
  const quantizeFactor = Math.max(calPeriod >> 12, 1);
  const quantizedPhase = phase / quantizeFactor * quantizeFactor;
  return [new u642(registry, calPeriod), new u642(registry, quantizedPhase)];
}
function decodeMortalU8a(registry, value) {
  if (value.length === 0) {
    return [new u642(registry), new u642(registry)];
  }
  const first2 = u8aToBn(value.subarray(0, 1)).toNumber();
  const second = u8aToBn(value.subarray(1, 2)).toNumber();
  const encoded = first2 + (second << 8);
  const period = 2 << encoded % (1 << 4);
  const quantizeFactor = Math.max(period >> 12, 1);
  const phase = (encoded >> 4) * quantizeFactor;
  if (period < 4 || phase >= period) {
    throw new Error("Invalid data passed to Mortal era");
  }
  return [new u642(registry, period), new u642(registry, phase)];
}
function decodeExtrinsicEra(value = new Uint8Array()) {
  if (isU8a(value)) {
    return !value.length || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);
  } else if (!value) {
    return new Uint8Array([0]);
  } else if (value instanceof GenericExtrinsicEra) {
    return decodeExtrinsicEra(value.toU8a());
  } else if (isHex(value)) {
    return decodeExtrinsicEra(hexToU8a(value));
  } else if (isObject(value)) {
    const entries = Object.entries(value).map(([k, v]) => [k.toLowerCase(), v]);
    const mortal = entries.find(([k]) => k.toLowerCase() === "mortalera");
    const immortal = entries.find(([k]) => k.toLowerCase() === "immortalera");
    return mortal ? {
      MortalEra: mortal[1]
    } : immortal ? {
      ImmortalEra: immortal[1]
    } : {
      MortalEra: value
    };
  }
  throw new Error("Invalid data passed to Era");
}
var ImmortalEra = class extends Raw {
  constructor(registry, value) {
    super(registry, IMMORTAL_ERA);
  }
};
var MortalEra = class extends Tuple {
  constructor(registry, value) {
    super(registry, {
      period: u642,
      phase: u642
    }, decodeMortalEra(registry, value));
  }
  get encodedLength() {
    return 2;
  }
  get period() {
    return this[0];
  }
  get phase() {
    return this[1];
  }
  toHuman() {
    return {
      period: formatNumber(this.period),
      phase: formatNumber(this.phase)
    };
  }
  toJSON() {
    return this.toHex();
  }
  toU8a(isBare) {
    const period = this.period.toNumber();
    const encoded = Math.min(15, Math.max(1, getTrailingZeros(period) - 1)) + (this.phase.toNumber() / Math.max(period >> 12, 1) << 4);
    return new Uint8Array([encoded & 255, encoded >> 8]);
  }
  birth(current) {
    const phase = this.phase.toNumber();
    const period = this.period.toNumber();
    return ~~((Math.max(bnToBn(current).toNumber(), phase) - phase) / period) * period + phase;
  }
  death(current) {
    return this.birth(current) + this.period.toNumber();
  }
};
var GenericExtrinsicEra = class extends Enum {
  constructor(registry, value) {
    super(registry, {
      ImmortalEra,
      MortalEra
    }, decodeExtrinsicEra(value));
  }
  get encodedLength() {
    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;
  }
  get asImmortalEra() {
    if (!this.isImmortalEra) {
      throw new Error(`Cannot convert '${this.type}' via asImmortalEra`);
    }
    return this.inner;
  }
  get asMortalEra() {
    if (!this.isMortalEra) {
      throw new Error(`Cannot convert '${this.type}' via asMortalEra`);
    }
    return this.inner;
  }
  get isImmortalEra() {
    return this.index === 0;
  }
  get isMortalEra() {
    return this.index > 0;
  }
  toU8a(isBare) {
    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);
  }
};

// node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js
var VERSIONS2 = [
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadUnknown",
  "ExtrinsicPayloadV4"
];
function decodeExtrinsicPayload(registry, value, version = DEFAULT_VERSION) {
  if (value instanceof GenericExtrinsicPayload) {
    return value.unwrap();
  }
  return registry.createTypeUnsafe(VERSIONS2[version] || VERSIONS2[0], [value, {
    version
  }]);
}
var GenericExtrinsicPayload = class extends AbstractBase {
  constructor(registry, value, {
    version
  } = {}) {
    super(registry, decodeExtrinsicPayload(registry, value, version));
  }
  get blockHash() {
    return this.inner.blockHash;
  }
  get era() {
    return this.inner.era;
  }
  get genesisHash() {
    return this.inner.genesisHash || this.registry.createTypeUnsafe("Hash", []);
  }
  get method() {
    return this.inner.method;
  }
  get nonce() {
    return this.inner.nonce;
  }
  get specVersion() {
    return this.inner.specVersion || this.registry.createTypeUnsafe("u32", []);
  }
  get tip() {
    return this.inner.tip || this.registry.createTypeUnsafe("Compact<Balance>", []);
  }
  get transactionVersion() {
    return this.inner.transactionVersion || this.registry.createTypeUnsafe("u32", []);
  }
  eq(other) {
    return this.inner.eq(other);
  }
  sign(signerPair) {
    const signature = this.inner.sign(signerPair);
    return {
      signature: u8aToHex(signature)
    };
  }
  toHuman(isExtended) {
    return this.inner.toHuman(isExtended);
  }
  toJSON() {
    return this.toHex();
  }
  toString() {
    return this.toHex();
  }
  toU8a(isBare) {
    return super.toU8a(isBare ? {
      method: true
    } : false);
  }
};

// node_modules/@polkadot/types/extrinsic/ExtrinsicPayloadUnknown.js
var GenericExtrinsicPayloadUnknown = class extends Struct {
  constructor(registry, value, {
    version = 0
  } = {}) {
    super(registry, {});
    throw new Error(`Unsupported extrinsic payload version ${version}`);
  }
};

// node_modules/@polkadot/types/extrinsic/ExtrinsicUnknown.js
var GenericExtrinsicUnknown = class extends Struct {
  constructor(registry, value, {
    isSigned = false,
    version = 0
  } = {}) {
    super(registry, {});
    throw new Error(`Unsupported ${isSigned ? "" : "un"}signed extrinsic version ${version & UNMASK_VERSION}`);
  }
};

// node_modules/@polkadot/types/extrinsic/SignerPayload.js
var knownTypes = {
  address: "Address",
  blockHash: "Hash",
  blockNumber: "BlockNumber",
  era: "ExtrinsicEra",
  genesisHash: "Hash",
  method: "Call",
  nonce: "Compact<Index>",
  runtimeVersion: "RuntimeVersion",
  signedExtensions: "Vec<Text>",
  tip: "Compact<Balance>",
  version: "u8"
};
var _extraTypes;
var GenericSignerPayload = class extends Struct {
  constructor(registry, value) {
    const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());
    super(registry, objectSpread({}, extensionTypes, knownTypes), value);
    __privateAdd(this, _extraTypes, void 0);
    __privateSet(this, _extraTypes, {});
    const getter = (key) => this.get(key);
    for (const [key, type] of Object.entries(extensionTypes)) {
      if (!knownTypes[key]) {
        __privateGet(this, _extraTypes)[key] = type;
      }
      objectProperty(this, key, getter);
    }
  }
  get address() {
    return this.getT("address");
  }
  get blockHash() {
    return this.getT("blockHash");
  }
  get blockNumber() {
    return this.getT("blockNumber");
  }
  get era() {
    return this.getT("era");
  }
  get genesisHash() {
    return this.getT("genesisHash");
  }
  get method() {
    return this.getT("method");
  }
  get nonce() {
    return this.getT("nonce");
  }
  get runtimeVersion() {
    return this.getT("runtimeVersion");
  }
  get signedExtensions() {
    return this.getT("signedExtensions");
  }
  get tip() {
    return this.getT("tip");
  }
  get version() {
    return this.getT("version");
  }
  toPayload() {
    const result = {};
    const keys2 = Object.keys(__privateGet(this, _extraTypes));
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      const value = this.get(key);
      const isOption = value instanceof Option;
      if (!isOption || value.isSome) {
        result[key] = value.toHex();
      }
    }
    return objectSpread(result, {
      address: this.address.toString(),
      blockHash: this.blockHash.toHex(),
      blockNumber: this.blockNumber.toHex(),
      era: this.era.toHex(),
      genesisHash: this.genesisHash.toHex(),
      method: this.method.toHex(),
      nonce: this.nonce.toHex(),
      signedExtensions: this.signedExtensions.map((e) => e.toString()),
      specVersion: this.runtimeVersion.specVersion.toHex(),
      tip: this.tip.toHex(),
      transactionVersion: this.runtimeVersion.transactionVersion.toHex(),
      version: this.version.toNumber()
    });
  }
  toRaw() {
    const payload = this.toPayload();
    const data = u8aToHex(this.registry.createTypeUnsafe("ExtrinsicPayload", [payload, {
      version: payload.version
    }]).toU8a({
      method: true
    }));
    return {
      address: payload.address,
      data,
      type: "payload"
    };
  }
};
_extraTypes = new WeakMap();

// node_modules/@polkadot/types/extrinsic/util.js
function sign(registry, signerPair, u8a, options) {
  const encoded = u8a.length > 256 ? registry.hash(u8a) : u8a;
  return signerPair.sign(encoded, options);
}

// node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js
var _signOptions;
var GenericExtrinsicPayloadV4 = class extends Struct {
  constructor(registry, value) {
    super(registry, objectSpread({
      method: "Bytes"
    }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value);
    __privateAdd(this, _signOptions, void 0);
    __privateSet(this, _signOptions, {
      withType: registry.createTypeUnsafe("ExtrinsicSignature", []) instanceof Enum
    });
  }
  inspect() {
    return super.inspect({
      method: true
    });
  }
  get blockHash() {
    return this.getT("blockHash");
  }
  get era() {
    return this.getT("era");
  }
  get genesisHash() {
    return this.getT("genesisHash");
  }
  get method() {
    return this.getT("method");
  }
  get nonce() {
    return this.getT("nonce");
  }
  get specVersion() {
    return this.getT("specVersion");
  }
  get tip() {
    return this.getT("tip");
  }
  get transactionVersion() {
    return this.getT("transactionVersion");
  }
  get assetId() {
    return this.getT("assetId");
  }
  sign(signerPair) {
    return sign(this.registry, signerPair, this.toU8a({
      method: true
    }), __privateGet(this, _signOptions));
  }
};
_signOptions = new WeakMap();

// node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js
var FAKE_SIGNATURE = new Uint8Array(256).fill(1);
function toAddress(registry, address) {
  return registry.createTypeUnsafe("Address", [isU8a(address) ? u8aToHex(address) : address]);
}
var _signKeys;
var _GenericExtrinsicSignatureV4 = class extends Struct {
  constructor(registry, value, {
    isSigned
  } = {}) {
    const signTypes = registry.getSignedExtensionTypes();
    super(registry, objectSpread({
      signer: "Address",
      signature: "ExtrinsicSignature"
    }, signTypes), _GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));
    __privateAdd(this, _signKeys, void 0);
    __privateSet(this, _signKeys, Object.keys(signTypes));
    objectProperties(this, __privateGet(this, _signKeys), (k) => this.get(k));
  }
  static decodeExtrinsicSignature(value, isSigned = false) {
    if (!value) {
      return EMPTY_U8A3;
    } else if (value instanceof _GenericExtrinsicSignatureV4) {
      return value;
    }
    return isSigned ? value : EMPTY_U8A3;
  }
  get encodedLength() {
    return this.isSigned ? super.encodedLength : 0;
  }
  get isSigned() {
    return !this.signature.isEmpty;
  }
  get era() {
    return this.getT("era");
  }
  get nonce() {
    return this.getT("nonce");
  }
  get signature() {
    return this.multiSignature.value || this.multiSignature;
  }
  get multiSignature() {
    return this.getT("signature");
  }
  get signer() {
    return this.getT("signer");
  }
  get tip() {
    return this.getT("tip");
  }
  _injectSignature(signer, signature, payload) {
    for (let i = 0; i < __privateGet(this, _signKeys).length; i++) {
      const k = __privateGet(this, _signKeys)[i];
      const v = payload.get(k);
      if (!isUndefined(v)) {
        this.set(k, v);
      }
    }
    this.set("signer", signer);
    this.set("signature", signature);
    return this;
  }
  addSignature(signer, signature, payload) {
    return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe("ExtrinsicSignature", [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));
  }
  createPayload(method, options) {
    const {
      era,
      runtimeVersion: {
        specVersion,
        transactionVersion
      }
    } = options;
    return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {
      era: era || IMMORTAL_ERA,
      method: method.toHex(),
      specVersion,
      transactionVersion
    }));
  }
  sign(method, account3, options) {
    if (!account3 || !account3.addressRaw) {
      throw new Error(`Expected a valid keypair for signing, found ${stringify(account3)}`);
    }
    const payload = this.createPayload(method, options);
    return this._injectSignature(toAddress(this.registry, account3.addressRaw), this.registry.createTypeUnsafe("ExtrinsicSignature", [payload.sign(account3)]), payload);
  }
  signFake(method, address, options) {
    if (!address) {
      throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);
    }
    const payload = this.createPayload(method, options);
    return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe("ExtrinsicSignature", [FAKE_SIGNATURE]), payload);
  }
  toU8a(isBare) {
    return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A3;
  }
};
var GenericExtrinsicSignatureV4 = _GenericExtrinsicSignatureV4;
_signKeys = new WeakMap();

// node_modules/@polkadot/types/ethereum/AccountId.js
function decodeAccountId(value) {
  if (isU8a(value) || Array.isArray(value)) {
    return u8aToU8a(value);
  } else if (isHex(value) || isEthereumAddress(value.toString())) {
    return hexToU8a(value.toString());
  } else if (isString(value)) {
    return u8aToU8a(value);
  }
  return value;
}
var GenericEthereumAccountId = class extends U8aFixed {
  constructor(registry, value = new Uint8Array()) {
    super(registry, decodeAccountId(value), 160);
  }
  eq(other) {
    return super.eq(decodeAccountId(other));
  }
  toHuman() {
    return this.toJSON();
  }
  toJSON() {
    return this.toString();
  }
  toPrimitive() {
    return this.toJSON();
  }
  toString() {
    return ethereumEncode(this);
  }
  toRawType() {
    return "AccountId";
  }
};

// node_modules/@polkadot/types/generic/AccountIndex.js
var PREFIX_1BYTE = 239;
var PREFIX_2BYTE = 252;
var PREFIX_4BYTE = 253;
var PREFIX_8BYTE = 254;
var MAX_1BYTE = new import_bn.default(PREFIX_1BYTE);
var MAX_2BYTE = new import_bn.default(1).shln(16);
var MAX_4BYTE = new import_bn.default(1).shln(32);
function decodeAccountIndex(value) {
  if (value instanceof GenericAccountIndex) {
    return value.toBn();
  } else if (isBn(value) || isNumber(value) || isHex(value) || isU8a(value) || isBigInt(value)) {
    return value;
  }
  return decodeAccountIndex(decodeAddress(value));
}
var GenericAccountIndex = class extends u323 {
  constructor(registry, value = new import_bn.default(0)) {
    super(registry, decodeAccountIndex(value));
  }
  static calcLength(_value) {
    const value = bnToBn(_value);
    if (value.lte(MAX_1BYTE)) {
      return 1;
    } else if (value.lt(MAX_2BYTE)) {
      return 2;
    } else if (value.lt(MAX_4BYTE)) {
      return 4;
    }
    return 8;
  }
  static readLength(input) {
    const first2 = input[0];
    if (first2 === PREFIX_2BYTE) {
      return [1, 2];
    } else if (first2 === PREFIX_4BYTE) {
      return [1, 4];
    } else if (first2 === PREFIX_8BYTE) {
      return [1, 8];
    }
    return [0, 1];
  }
  static writeLength(input) {
    switch (input.length) {
      case 2:
        return new Uint8Array([PREFIX_2BYTE]);
      case 4:
        return new Uint8Array([PREFIX_4BYTE]);
      case 8:
        return new Uint8Array([PREFIX_8BYTE]);
      default:
        return new Uint8Array([]);
    }
  }
  eq(other) {
    if (isBn(other) || isNumber(other)) {
      return super.eq(other);
    }
    return super.eq(this.registry.createTypeUnsafe("AccountIndex", [other]));
  }
  toHuman() {
    return this.toJSON();
  }
  toJSON() {
    return this.toString();
  }
  toPrimitive() {
    return this.toJSON();
  }
  toString() {
    const length = GenericAccountIndex.calcLength(this);
    return encodeAddress(this.toU8a().subarray(0, length), this.registry.chainSS58);
  }
  toRawType() {
    return "AccountIndex";
  }
};

// node_modules/@polkadot/types/ethereum/LookupSource.js
var ACCOUNT_ID_PREFIX = new Uint8Array([255]);
function decodeString(registry, value) {
  const decoded = decodeAddress(value);
  return decoded.length === 20 ? registry.createTypeUnsafe("EthereumAccountId", [decoded]) : registry.createTypeUnsafe("AccountIndex", [u8aToBn(decoded)]);
}
function decodeU8a4(registry, value) {
  if (value.length === 20) {
    return registry.createTypeUnsafe("EthereumAccountId", [value]);
  } else if (value[0] === 255) {
    return registry.createTypeUnsafe("EthereumAccountId", [value.subarray(1)]);
  }
  const [offset, length] = GenericAccountIndex.readLength(value);
  return registry.createTypeUnsafe("AccountIndex", [u8aToBn(value.subarray(offset, offset + length))]);
}
function decodeAddressOrIndex(registry, value) {
  return value instanceof GenericEthereumLookupSource ? value.inner : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isU8a(value) || Array.isArray(value) || isHex(value) ? decodeU8a4(registry, u8aToU8a(value)) : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createTypeUnsafe("AccountIndex", [value]) : decodeString(registry, value);
}
var GenericEthereumLookupSource = class extends AbstractBase {
  constructor(registry, value = new Uint8Array()) {
    super(registry, decodeAddressOrIndex(registry, value));
  }
  get encodedLength() {
    const rawLength = this._rawLength;
    return rawLength + (rawLength > 1 ? 1 : 0);
  }
  get _rawLength() {
    return this.inner instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this.inner) : this.inner.encodedLength;
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toRawType() {
    return "Address";
  }
  toU8a(isBare) {
    const encoded = this.inner.toU8a().subarray(0, this._rawLength);
    return isBare ? encoded : u8aConcat(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);
  }
};

// node_modules/@polkadot/types/generic/AccountId.js
function decodeAccountId2(value) {
  if (isU8a(value) || Array.isArray(value)) {
    return u8aToU8a(value);
  } else if (!value) {
    return new Uint8Array();
  } else if (isHex(value)) {
    return hexToU8a(value);
  } else if (isString(value)) {
    return decodeAddress(value.toString());
  }
  throw new Error(`Unknown type passed to AccountId constructor, found typeof ${typeof value}`);
}
var BaseAccountId = class extends U8aFixed {
  constructor(registry, allowedBits = 256 | 264, value) {
    const decoded = decodeAccountId2(value);
    const decodedBits = decoded.length * 8;
    if (decodedBits < allowedBits && decoded.some((b) => b)) {
      throw new Error(`Invalid AccountId provided, expected ${allowedBits >> 3} bytes, found ${decoded.length}`);
    }
    super(registry, decoded, allowedBits);
  }
  eq(other) {
    return super.eq(decodeAccountId2(other));
  }
  toHuman() {
    return this.toJSON();
  }
  toJSON() {
    return this.toString();
  }
  toPrimitive() {
    return this.toJSON();
  }
  toString() {
    return encodeAddress(this, this.registry.chainSS58);
  }
  toRawType() {
    return "AccountId";
  }
};
var GenericAccountId = class extends BaseAccountId {
  constructor(registry, value) {
    super(registry, 256, value);
  }
};
var GenericAccountId33 = class extends BaseAccountId {
  constructor(registry, value) {
    super(registry, 264, value);
  }
};

// node_modules/@polkadot/types/generic/Block.js
var GenericBlock = class extends Struct {
  constructor(registry, value) {
    super(registry, {
      header: "Header",
      extrinsics: "Vec<Extrinsic>"
    }, value);
  }
  get contentHash() {
    return this.registry.hash(this.toU8a());
  }
  get extrinsics() {
    return this.getT("extrinsics");
  }
  get hash() {
    return this.header.hash;
  }
  get header() {
    return this.getT("header");
  }
};

// node_modules/@polkadot/types/generic/Call.js
function getArgsDef(registry, meta) {
  return meta.fields.reduce((result, {
    name,
    type
  }, index) => {
    result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);
    return result;
  }, {});
}
function decodeCallViaObject(registry, value, _meta3) {
  const {
    args,
    callIndex
  } = value;
  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex;
  const meta = _meta3 || registry.findMetaCall(lookupIndex).meta;
  return {
    args,
    argsDef: getArgsDef(registry, meta),
    callIndex,
    meta
  };
}
function decodeCallViaU8a(registry, value, _meta3) {
  const callIndex = registry.firstCallIndex.slice();
  callIndex.set(value.subarray(0, 2), 0);
  const meta = _meta3 || registry.findMetaCall(callIndex).meta;
  return {
    args: value.subarray(2),
    argsDef: getArgsDef(registry, meta),
    callIndex,
    meta
  };
}
function decodeCall(registry, value = new Uint8Array(), _meta3) {
  if (isU8a(value) || isHex(value)) {
    return decodeCallViaU8a(registry, u8aToU8a(value), _meta3);
  } else if (isObject(value) && value.callIndex && value.args) {
    return decodeCallViaObject(registry, value, _meta3);
  }
  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);
}
var GenericCallIndex = class extends U8aFixed {
  constructor(registry, value) {
    super(registry, value, 16);
  }
  toPrimitive() {
    return this.toHex();
  }
};
var GenericCall = class extends Struct {
  constructor(registry, value, meta) {
    const decoded = decodeCall(registry, value, meta);
    try {
      super(registry, {
        callIndex: GenericCallIndex,
        args: Struct.with(decoded.argsDef)
      }, decoded);
    } catch (error) {
      let method = "unknown.unknown";
      try {
        const c = registry.findMetaCall(decoded.callIndex);
        method = `${c.section}.${c.method}`;
      } catch (error2) {
      }
      throw new Error(`Call: failed decoding ${method}:: ${error.message}`);
    }
    this._meta = decoded.meta;
  }
  get args() {
    return [...this.getT("args").values()];
  }
  get argsDef() {
    return getArgsDef(this.registry, this.meta);
  }
  get argsEntries() {
    return [...this.getT("args").entries()];
  }
  get callIndex() {
    return this.getT("callIndex").toU8a();
  }
  get data() {
    return this.getT("args").toU8a();
  }
  get meta() {
    return this._meta;
  }
  get method() {
    return this.registry.findMetaCall(this.callIndex).method;
  }
  get section() {
    return this.registry.findMetaCall(this.callIndex).section;
  }
  is(other) {
    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];
  }
  toHuman(isExpanded) {
    var _call, _call2;
    let call;
    try {
      call = this.registry.findMetaCall(this.callIndex);
    } catch (error) {
    }
    return objectSpread({
      args: this.argsEntries.reduce((args, [n, a]) => objectSpread(args, {
        [n]: a.toHuman(isExpanded)
      }), {}),
      method: (_call = call) == null ? void 0 : _call.method,
      section: (_call2 = call) == null ? void 0 : _call2.section
    }, isExpanded && call ? {
      docs: call.meta.docs.map((d) => d.toString())
    } : null);
  }
  toRawType() {
    return "Call";
  }
};

// node_modules/@polkadot/types/generic/ChainProperties.js
function createValue(registry, type, value, asArray = true) {
  if (value && isFunction(value.unwrapOrDefault)) {
    return value;
  }
  return registry.createTypeUnsafe(type, [asArray ? isNull(value) || isUndefined(value) ? null : Array.isArray(value) ? value : [value] : value]);
}
function decodeValue(registry, key, value) {
  return key === "ss58Format" ? createValue(registry, "Option<u32>", value, false) : key === "tokenDecimals" ? createValue(registry, "Option<Vec<u32>>", value) : key === "tokenSymbol" ? createValue(registry, "Option<Vec<Text>>", value) : value;
}
function decode(registry, value) {
  return (value && isFunction(value.entries) ? [...value.entries()] : Object.entries(value || {})).reduce((all3, [key, value2]) => {
    all3[key] = decodeValue(registry, key, value2);
    return all3;
  }, {
    ss58Format: registry.createTypeUnsafe("Option<u32>", []),
    tokenDecimals: registry.createTypeUnsafe("Option<Vec<u32>>", []),
    tokenSymbol: registry.createTypeUnsafe("Option<Vec<Text>>", [])
  });
}
var GenericChainProperties = class extends Json {
  constructor(registry, value) {
    super(registry, decode(registry, value));
  }
  get ss58Format() {
    return this.getT("ss58Format");
  }
  get tokenDecimals() {
    return this.getT("tokenDecimals");
  }
  get tokenSymbol() {
    return this.getT("tokenSymbol");
  }
};

// node_modules/@polkadot/types/generic/ConsensusEngineId.js
var CID_AURA = stringToU8a("aura");
var CID_BABE = stringToU8a("BABE");
var CID_GRPA = stringToU8a("FRNK");
var CID_POW = stringToU8a("pow_");
function getAuraAuthor(registry, bytes3, sessionValidators) {
  return sessionValidators[registry.createTypeUnsafe("RawAuraPreDigest", [bytes3.toU8a(true)]).slotNumber.mod(new import_bn.default(sessionValidators.length)).toNumber()];
}
function getBabeAuthor(registry, bytes3, sessionValidators) {
  const digest = registry.createTypeUnsafe("RawBabePreDigestCompat", [bytes3.toU8a(true)]);
  return sessionValidators[digest.value.toNumber()];
}
function getBytesAsAuthor(registry, bytes3) {
  return registry.createTypeUnsafe("AccountId", [bytes3]);
}
var GenericConsensusEngineId = class extends U8aFixed {
  constructor(registry, value) {
    super(registry, isNumber(value) ? bnToU8a(value, {
      isLe: false
    }) : value, 32);
  }
  get isAura() {
    return this.eq(CID_AURA);
  }
  get isBabe() {
    return this.eq(CID_BABE);
  }
  get isGrandpa() {
    return this.eq(CID_GRPA);
  }
  get isPow() {
    return this.eq(CID_POW);
  }
  extractAuthor(bytes3, sessionValidators) {
    if (sessionValidators != null && sessionValidators.length) {
      if (this.isAura) {
        return getAuraAuthor(this.registry, bytes3, sessionValidators);
      } else if (this.isBabe) {
        return getBabeAuthor(this.registry, bytes3, sessionValidators);
      }
    }
    if (this.isPow || bytes3.length === 20) {
      return getBytesAsAuthor(this.registry, bytes3);
    }
    return void 0;
  }
  toHuman() {
    return this.toString();
  }
  toRawType() {
    return "ConsensusEngineId";
  }
  toString() {
    return this.isAscii ? u8aToString(this) : u8aToHex(this);
  }
};

// node_modules/@polkadot/types/generic/LookupSource.js
var ACCOUNT_ID_PREFIX2 = new Uint8Array([255]);
function decodeString2(registry, value) {
  const decoded = decodeAddress(value);
  return decoded.length === 32 ? registry.createTypeUnsafe("AccountId", [decoded]) : registry.createTypeUnsafe("AccountIndex", [u8aToBn(decoded)]);
}
function decodeU8a5(registry, value) {
  if (value.length === 32) {
    return registry.createTypeUnsafe("AccountId", [value]);
  } else if (value[0] === 255) {
    return registry.createTypeUnsafe("AccountId", [value.subarray(1)]);
  }
  const [offset, length] = GenericAccountIndex.readLength(value);
  return registry.createTypeUnsafe("AccountIndex", [u8aToBn(value.subarray(offset, offset + length))]);
}
function decodeAddressOrIndex2(registry, value) {
  return value instanceof GenericLookupSource ? value.inner : value instanceof GenericAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createTypeUnsafe("AccountIndex", [value]) : Array.isArray(value) || isHex(value) || isU8a(value) ? decodeU8a5(registry, u8aToU8a(value)) : decodeString2(registry, value);
}
var GenericLookupSource = class extends AbstractBase {
  constructor(registry, value = new Uint8Array()) {
    super(registry, decodeAddressOrIndex2(registry, value));
  }
  get encodedLength() {
    const rawLength = this._rawLength;
    return rawLength + (rawLength > 1 ? 1 : 0);
  }
  get _rawLength() {
    return this.inner instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this.inner) : this.inner.encodedLength;
  }
  inspect() {
    const value = this.inner.toU8a().subarray(0, this._rawLength);
    return {
      outer: [new Uint8Array(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(value) : ACCOUNT_ID_PREFIX2), value]
    };
  }
  toHex() {
    return u8aToHex(this.toU8a());
  }
  toRawType() {
    return "Address";
  }
  toU8a(isBare) {
    const encoded = this.inner.toU8a().subarray(0, this._rawLength);
    return isBare ? encoded : u8aConcat(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX2, encoded);
  }
};

// node_modules/@polkadot/types/generic/MultiAddress.js
function decodeU8a6(registry, u8a) {
  if ([0, 32].includes(u8a.length)) {
    return {
      Id: u8a
    };
  } else if (u8a.length === 20) {
    return {
      Address20: u8a
    };
  } else if (u8a.length <= 8) {
    return {
      Index: registry.createTypeUnsafe("AccountIndex", [u8a]).toNumber()
    };
  }
  return u8a;
}
function decodeMultiAny(registry, value) {
  if (value instanceof GenericAccountId) {
    return {
      Id: value
    };
  } else if (isU8a(value)) {
    return decodeU8a6(registry, value);
  } else if (value instanceof GenericMultiAddress) {
    return value;
  } else if (value instanceof GenericAccountIndex || isBn(value) || isNumber(value)) {
    return {
      Index: isNumber(value) ? value : value.toNumber()
    };
  } else if (isString(value)) {
    return decodeU8a6(registry, decodeAddress(value.toString()));
  }
  return value;
}
var GenericMultiAddress = class extends Enum {
  constructor(registry, value) {
    super(registry, {
      Id: "AccountId",
      Index: "Compact<AccountIndex>",
      Raw: "Bytes",
      Address32: "H256",
      Address20: "H160"
    }, decodeMultiAny(registry, value));
  }
  inspect() {
    const {
      inner,
      outer = []
    } = this.inner.inspect();
    return {
      inner,
      outer: [new Uint8Array([this.index]), ...outer]
    };
  }
  toString() {
    return this.value.toString();
  }
};

// node_modules/@polkadot/types/generic/Vote.js
var AYE_BITS = 128;
var NAY_BITS = 0;
var CON_MASK = 127;
var DEF_CONV = 0;
function decodeVoteBool(value) {
  return value ? new Uint8Array([AYE_BITS | DEF_CONV]) : new Uint8Array([NAY_BITS]);
}
function decodeVoteU8a(value) {
  return value.length ? value.subarray(0, 1) : new Uint8Array([NAY_BITS]);
}
function decodeVoteType(registry, value) {
  return new Uint8Array([(new bool2(registry, value.aye).isTrue ? AYE_BITS : NAY_BITS) | registry.createTypeUnsafe("Conviction", [value.conviction || DEF_CONV]).index]);
}
function decodeVote(registry, value) {
  if (isU8a(value)) {
    return decodeVoteU8a(value);
  } else if (isUndefined(value) || value instanceof Boolean || isBoolean(value)) {
    return decodeVoteBool(new bool2(registry, value).isTrue);
  } else if (isNumber(value)) {
    return decodeVoteBool(value < 0);
  }
  return decodeVoteType(registry, value);
}
var _aye, _conviction;
var GenericVote = class extends U8aFixed {
  constructor(registry, value) {
    const decoded = decodeVote(registry, value);
    super(registry, decoded, 8);
    __privateAdd(this, _aye, void 0);
    __privateAdd(this, _conviction, void 0);
    __privateSet(this, _aye, (decoded[0] & AYE_BITS) === AYE_BITS);
    __privateSet(this, _conviction, this.registry.createTypeUnsafe("Conviction", [decoded[0] & CON_MASK]));
  }
  get conviction() {
    return __privateGet(this, _conviction);
  }
  get isAye() {
    return __privateGet(this, _aye);
  }
  get isNay() {
    return !this.isAye;
  }
  toHuman(isExpanded) {
    return {
      conviction: this.conviction.toHuman(isExpanded),
      vote: this.isAye ? "Aye" : "Nay"
    };
  }
  toPrimitive() {
    return {
      aye: this.isAye,
      conviction: this.conviction.toPrimitive()
    };
  }
  toRawType() {
    return "Vote";
  }
};
_aye = new WeakMap();
_conviction = new WeakMap();

// node_modules/@polkadot/types/primitive/Data.js
function decodeDataU8a(registry, value) {
  const indicator = value[0];
  if (!indicator) {
    return [void 0, void 0];
  } else if (indicator >= 1 && indicator <= 33) {
    const length = indicator - 1;
    const data = value.subarray(1, length + 1);
    return [registry.createTypeUnsafe("Raw", [data]), 1];
  } else if (indicator >= 34 && indicator <= 37) {
    return [value.subarray(1, 32 + 1), indicator - 32];
  }
  throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);
}
function decodeData(registry, value) {
  if (isU8a(value) || isString(value)) {
    return decodeDataU8a(registry, u8aToU8a(value));
  } else if (!value) {
    return [void 0, void 0];
  }
  return [value, void 0];
}
var Data = class extends Enum {
  constructor(registry, value) {
    super(registry, {
      None: "Null",
      Raw: "Bytes",
      BlakeTwo256: "H256",
      Sha256: "H256",
      Keccak256: "H256",
      ShaThree256: "H256"
    }, ...decodeData(registry, value));
    if (this.isRaw && this.asRaw.length > 32) {
      throw new Error("Data.Raw values are limited to a maximum length of 32 bytes");
    }
  }
  get asBlakeTwo256() {
    return this.value;
  }
  get asKeccak256() {
    return this.value;
  }
  get asRaw() {
    return this.value;
  }
  get asSha256() {
    return this.value;
  }
  get asShaThree256() {
    return this.value;
  }
  get isBlakeTwo256() {
    return this.index === 2;
  }
  get isKeccak256() {
    return this.index === 4;
  }
  get isNone() {
    return this.index === 0;
  }
  get isRaw() {
    return this.index === 1;
  }
  get isSha256() {
    return this.index === 3;
  }
  get isShaThree256() {
    return this.index === 5;
  }
  get encodedLength() {
    return this.toU8a().length;
  }
  toU8a() {
    if (this.index === 0) {
      return new Uint8Array(1);
    } else if (this.index === 1) {
      const data = this.value.toU8a(true);
      const length = Math.min(data.length, 32);
      const u8a2 = new Uint8Array(length + 1);
      u8a2.set([length + 1], 0);
      u8a2.set(data.subarray(0, length), 1);
      return u8a2;
    }
    const u8a = new Uint8Array(33);
    u8a.set([this.index + 32], 0);
    u8a.set(this.value.toU8a(), 1);
    return u8a;
  }
};

// node_modules/@polkadot/types/metadata/util/flattenUniq.js
function flattenUniq(list, result = []) {
  for (let i = 0; i < list.length; i++) {
    const entry = list[i];
    if (Array.isArray(entry)) {
      flattenUniq(entry, result);
    } else {
      result.push(entry);
    }
  }
  return [...new Set(result)];
}

// node_modules/@polkadot/types/metadata/util/getSiName.js
function getSiName(lookup, type) {
  const typeDef = lookup.getTypeDef(type);
  return typeDef.lookupName || typeDef.type;
}

// node_modules/@polkadot/types/metadata/util/extractTypes.js
function extractSubSingle(_, {
  sub
}) {
  const {
    lookupName,
    type
  } = sub;
  return extractTypes([lookupName || type]);
}
function extractSubArray(_, {
  sub
}) {
  return extractTypes(sub.map(({
    lookupName,
    type
  }) => lookupName || type));
}
function unhandled(type, {
  info: info6
}) {
  throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${TypeDefInfo[info6]})`);
}
var mapping = {
  [TypeDefInfo.BTreeMap]: extractSubArray,
  [TypeDefInfo.BTreeSet]: extractSubSingle,
  [TypeDefInfo.Compact]: extractSubSingle,
  [TypeDefInfo.DoNotConstruct]: unhandled,
  [TypeDefInfo.Enum]: extractSubArray,
  [TypeDefInfo.HashMap]: extractSubArray,
  [TypeDefInfo.Int]: unhandled,
  [TypeDefInfo.Linkage]: extractSubSingle,
  [TypeDefInfo.Null]: unhandled,
  [TypeDefInfo.Option]: extractSubSingle,
  [TypeDefInfo.Plain]: (_, typeDef) => typeDef.lookupName || typeDef.type,
  [TypeDefInfo.Range]: extractSubSingle,
  [TypeDefInfo.RangeInclusive]: extractSubSingle,
  [TypeDefInfo.Result]: extractSubArray,
  [TypeDefInfo.Set]: extractSubArray,
  [TypeDefInfo.Si]: unhandled,
  [TypeDefInfo.Struct]: extractSubArray,
  [TypeDefInfo.Tuple]: extractSubArray,
  [TypeDefInfo.UInt]: unhandled,
  [TypeDefInfo.Vec]: extractSubSingle,
  [TypeDefInfo.VecFixed]: extractSubSingle,
  [TypeDefInfo.WrapperKeepOpaque]: extractSubSingle,
  [TypeDefInfo.WrapperOpaque]: extractSubSingle
};
function extractTypes(types2) {
  const count2 = types2.length;
  const result = new Array(count2);
  for (let i = 0; i < count2; i++) {
    const type = types2[i];
    const typeDef = getTypeDef(type);
    result[i] = mapping[typeDef.info](type, typeDef);
  }
  return result;
}

// node_modules/@polkadot/types/metadata/util/validateTypes.js
var l8 = logger("metadata");
function validateTypes(registry, throwError2, types2) {
  const missing = flattenUniq(extractTypes(types2)).filter((type) => !registry.hasType(type) && !registry.isLookupType(type)).sort();
  if (missing.length !== 0) {
    const message = `Unknown types found, no types for ${missing.join(", ")}`;
    if (throwError2) {
      throw new Error(message);
    } else {
      l8.warn(message);
    }
  }
  return types2;
}

// node_modules/@polkadot/types/metadata/util/getUniqTypes.js
function extractTypes2(lookup, types2) {
  return types2.map(({
    type
  }) => lookup.getTypeDef(type).type);
}
function extractFieldTypes(lookup, type) {
  return lookup.getSiType(type).def.asVariant.variants.map(({
    fields
  }) => extractTypes2(lookup, fields));
}
function getPalletNames({
  lookup,
  pallets
}) {
  return pallets.reduce((all3, {
    calls,
    constants,
    events: events2,
    storage
  }) => {
    all3.push([extractTypes2(lookup, constants)]);
    if (calls.isSome) {
      all3.push(extractFieldTypes(lookup, calls.unwrap().type));
    }
    if (events2.isSome) {
      all3.push(extractFieldTypes(lookup, events2.unwrap().type));
    }
    if (storage.isSome) {
      all3.push(storage.unwrap().items.map(({
        type
      }) => {
        if (type.isPlain) {
          return [lookup.getTypeDef(type.asPlain).type];
        }
        const {
          hashers,
          key,
          value
        } = type.asMap;
        return hashers.length === 1 ? [lookup.getTypeDef(value).type, lookup.getTypeDef(key).type] : [lookup.getTypeDef(value).type, ...lookup.getSiType(key).def.asTuple.map((t) => lookup.getTypeDef(t).type)];
      }));
    }
    return all3;
  }, []);
}
function getUniqTypes(registry, meta, throwError2) {
  return validateTypes(registry, throwError2, flattenUniq(getPalletNames(meta)));
}

// node_modules/@polkadot/types/metadata/util/toCallsOnly.js
function trimDocs(docs) {
  const strings = docs.map((d) => d.toString().trim());
  const firstEmpty = strings.findIndex((d) => !d.length);
  return firstEmpty === -1 ? strings : strings.slice(0, firstEmpty);
}
function toCallsOnly(registry, {
  extrinsic,
  lookup,
  pallets
}) {
  return registry.createTypeUnsafe("MetadataLatest", [{
    extrinsic,
    lookup: {
      types: lookup.types.map(({
        id: id2,
        type
      }) => registry.createTypeUnsafe("PortableType", [{
        id: id2,
        type: objectSpread({}, type, {
          docs: trimDocs(type.docs)
        })
      }]))
    },
    pallets: pallets.map(({
      calls,
      index,
      name
    }) => ({
      calls: registry.createTypeUnsafe("Option<PalletCallMetadataLatest>", [calls.unwrapOr(null)]),
      index,
      name
    }))
  }]).toJSON();
}

// node_modules/@polkadot/types/primitive/StorageKey.js
var HASHER_MAP = {
  Blake2_128: [16, false],
  Blake2_128Concat: [16, true],
  Blake2_256: [32, false],
  Identity: [0, true],
  Twox128: [16, false],
  Twox256: [32, false],
  Twox64Concat: [8, true]
};
function unwrapStorageSi(type) {
  return type.isPlain ? type.asPlain : type.asMap.value;
}
function unwrapStorageType(registry, type, isOptional) {
  const outputType = getSiName(registry.lookup, unwrapStorageSi(type));
  return isOptional ? `Option<${outputType}>` : outputType;
}
function decodeStorageKey(value) {
  if (isU8a(value) || !value || isString(value)) {
    return {
      key: value
    };
  } else if (value instanceof StorageKey) {
    return {
      key: value,
      method: value.method,
      section: value.section
    };
  } else if (isFunction(value)) {
    return {
      key: value(),
      method: value.method,
      section: value.section
    };
  } else if (Array.isArray(value)) {
    const [fn, args = []] = value;
    if (!isFunction(fn)) {
      throw new Error("Expected function input for key construction");
    }
    if (fn.meta && fn.meta.type.isMap) {
      const map3 = fn.meta.type.asMap;
      if (!Array.isArray(args) || args.length !== map3.hashers.length) {
        throw new Error(`Expected an array of ${map3.hashers.length} values as params to a Map query`);
      }
    }
    return {
      key: fn(...args),
      method: fn.method,
      section: fn.section
    };
  }
  throw new Error(`Unable to convert input ${value} to StorageKey`);
}
function decodeHashers(registry, value, hashers) {
  let offset = 32;
  const result = new Array(hashers.length);
  for (let i = 0; i < hashers.length; i++) {
    const [hasher2, type] = hashers[i];
    const [hashLen, canDecode] = HASHER_MAP[hasher2.type];
    const decoded = canDecode ? registry.createTypeUnsafe(getSiName(registry.lookup, type), [value.subarray(offset + hashLen)]) : registry.createTypeUnsafe("Raw", [value.subarray(offset, offset + hashLen)]);
    offset += hashLen + (canDecode ? decoded.encodedLength : 0);
    result[i] = decoded;
  }
  return result;
}
function decodeArgsFromMeta(registry, value, meta) {
  if (!meta || !meta.type.isMap) {
    return [];
  }
  const {
    hashers,
    key
  } = meta.type.asMap;
  const keys2 = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;
  return decodeHashers(registry, value, hashers.map((h, i) => [h, keys2[i]]));
}
function getMeta(value) {
  if (value instanceof StorageKey) {
    return value.meta;
  } else if (isFunction(value)) {
    return value.meta;
  } else if (Array.isArray(value)) {
    const [fn] = value;
    return fn.meta;
  }
  return void 0;
}
function getType(registry, value) {
  if (value instanceof StorageKey) {
    return value.outputType;
  } else if (isFunction(value)) {
    return unwrapStorageType(registry, value.meta.type);
  } else if (Array.isArray(value)) {
    const [fn] = value;
    if (fn.meta) {
      return unwrapStorageType(registry, fn.meta.type);
    }
  }
  return "Raw";
}
var _args, _meta2, _outputType, _method2, _section2;
var StorageKey = class extends Bytes {
  constructor(registry, value, override = {}) {
    const {
      key,
      method,
      section: section2
    } = decodeStorageKey(value);
    super(registry, key);
    __privateAdd(this, _args, void 0);
    __privateAdd(this, _meta2, void 0);
    __privateAdd(this, _outputType, void 0);
    __privateAdd(this, _method2, void 0);
    __privateAdd(this, _section2, void 0);
    __privateSet(this, _outputType, getType(registry, value));
    this.setMeta(getMeta(value), override.section || section2, override.method || method);
  }
  get args() {
    return __privateGet(this, _args);
  }
  get meta() {
    return __privateGet(this, _meta2);
  }
  get method() {
    return __privateGet(this, _method2);
  }
  get outputType() {
    return __privateGet(this, _outputType);
  }
  get section() {
    return __privateGet(this, _section2);
  }
  is(key) {
    return key.section === this.section && key.method === this.method;
  }
  setMeta(meta, section2, method) {
    __privateSet(this, _meta2, meta);
    __privateSet(this, _method2, method || __privateGet(this, _method2));
    __privateSet(this, _section2, section2 || __privateGet(this, _section2));
    if (meta) {
      __privateSet(this, _outputType, unwrapStorageType(this.registry, meta.type));
    }
    try {
      __privateSet(this, _args, decodeArgsFromMeta(this.registry, this.toU8a(true), meta));
    } catch (error) {
    }
    return this;
  }
  toHuman() {
    return __privateGet(this, _args).length ? __privateGet(this, _args).map((a) => a.toHuman()) : super.toHuman();
  }
  toRawType() {
    return "StorageKey";
  }
};
_args = new WeakMap();
_meta2 = new WeakMap();
_outputType = new WeakMap();
_method2 = new WeakMap();
_section2 = new WeakMap();

// node_modules/@polkadot/types/metadata/v9/toV10.js
function createStorageHasher(registry, hasher2) {
  if (hasher2.toNumber() >= 2) {
    return registry.createTypeUnsafe("StorageHasherV10", [hasher2.toNumber() + 1]);
  }
  return registry.createTypeUnsafe("StorageHasherV10", [hasher2]);
}
function createStorageType(registry, entryType) {
  if (entryType.isMap) {
    return [objectSpread({}, entryType.asMap, {
      hasher: createStorageHasher(registry, entryType.asMap.hasher)
    }), 1];
  }
  if (entryType.isDoubleMap) {
    return [objectSpread({}, entryType.asDoubleMap, {
      hasher: createStorageHasher(registry, entryType.asDoubleMap.hasher),
      key2Hasher: createStorageHasher(registry, entryType.asDoubleMap.key2Hasher)
    }), 2];
  }
  return [entryType.asPlain, 0];
}
function convertModule(registry, mod2) {
  const storage = mod2.storage.unwrapOr(null);
  return registry.createTypeUnsafe("ModuleMetadataV10", [objectSpread({}, mod2, {
    storage: storage ? objectSpread({}, storage, {
      items: storage.items.map((item) => objectSpread({}, item, {
        type: registry.createTypeUnsafe("StorageEntryTypeV10", createStorageType(registry, item.type))
      }))
    }) : null
  })]);
}
function toV10(registry, {
  modules
}) {
  return registry.createTypeUnsafe("MetadataV10", [{
    modules: modules.map((mod2) => convertModule(registry, mod2))
  }]);
}

// node_modules/@polkadot/types/metadata/v10/toV11.js
function toV11(registry, {
  modules
}) {
  return registry.createTypeUnsafe("MetadataV11", [{
    extrinsic: {
      signedExtensions: [],
      version: 0
    },
    modules
  }]);
}

// node_modules/@polkadot/types/metadata/v11/toV12.js
function toV12(registry, {
  extrinsic,
  modules
}) {
  return registry.createTypeUnsafe("MetadataV12", [{
    extrinsic,
    modules: modules.map((mod2) => registry.createTypeUnsafe("ModuleMetadataV12", [objectSpread({}, mod2, {
      index: 255
    })]))
  }]);
}

// node_modules/@polkadot/types/metadata/v12/toV13.js
function toV13(registry, metadata) {
  return registry.createTypeUnsafe("MetadataV13", [metadata]);
}

// node_modules/@polkadot/types/interfaces/alias.js
var typesAlias = {
  assets: {
    Approval: "AssetApproval",
    ApprovalKey: "AssetApprovalKey",
    Balance: "TAssetBalance",
    DestroyWitness: "AssetDestroyWitness"
  },
  babe: {
    EquivocationProof: "BabeEquivocationProof"
  },
  balances: {
    Status: "BalanceStatus"
  },
  beefy: {
    AuthorityId: "BeefyId"
  },
  contracts: {
    StorageKey: "ContractStorageKey"
  },
  electionProviderMultiPhase: {
    Phase: "ElectionPhase"
  },
  ethereum: {
    Block: "EthBlock",
    Header: "EthHeader",
    Receipt: "EthReceipt",
    Transaction: "EthTransaction",
    TransactionStatus: "EthTransactionStatus"
  },
  evm: {
    Account: "EvmAccount",
    Log: "EvmLog",
    Vicinity: "EvmVicinity"
  },
  grandpa: {
    Equivocation: "GrandpaEquivocation",
    EquivocationProof: "GrandpaEquivocationProof"
  },
  identity: {
    Judgement: "IdentityJudgement"
  },
  inclusion: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraDisputes: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraInclusion: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraScheduler: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  paraShared: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parachains: {
    Id: "ParaId"
  },
  parasDisputes: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parasInclusion: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parasScheduler: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  parasShared: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  proposeParachain: {
    Proposal: "ParachainProposal"
  },
  proxy: {
    Announcement: "ProxyAnnouncement"
  },
  scheduler: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  shared: {
    ValidatorIndex: "ParaValidatorIndex"
  },
  society: {
    Judgement: "SocietyJudgement",
    Vote: "SocietyVote"
  },
  staking: {
    Compact: "CompactAssignments"
  },
  treasury: {
    Proposal: "TreasuryProposal"
  },
  xcm: {
    AssetId: "XcmAssetId"
  },
  xcmPallet: {
    AssetId: "XcmAssetId"
  }
};
function getAliasTypes({
  knownTypes: knownTypes2
}, section2) {
  var _knownTypes$typesAlia;
  return objectSpread({}, typesAlias[section2], (_knownTypes$typesAlia = knownTypes2.typesAlias) == null ? void 0 : _knownTypes$typesAlia[section2]);
}

// node_modules/@polkadot/types/metadata/v13/toV14.js
var BOXES = [["<", ">"], ["<", ","], [",", ">"], ["(", ")"], ["(", ","], [",", ","], [",", ")"]];
function compatType(specs, _type4) {
  const type = _type4.toString();
  const index = specs.findIndex(({
    def
  }) => def.HistoricMetaCompat === type);
  if (index !== -1) {
    return index;
  }
  return specs.push({
    def: {
      HistoricMetaCompat: type
    }
  }) - 1;
}
function compatTypes(specs, ...types2) {
  for (let i = 0; i < types2.length; i++) {
    compatType(specs, types2[i]);
  }
}
function makeTupleType(specs, entries) {
  return specs.push({
    def: {
      Tuple: entries
    }
  }) - 1;
}
function makeVariantType(modName, variantType, specs, variants) {
  return specs.push({
    def: {
      Variant: {
        variants
      }
    },
    path: [`pallet_${modName.toString()}`, "pallet", variantType]
  }) - 1;
}
function registerOriginCaller(registry, modules, metaVersion) {
  registry.register({
    OriginCaller: {
      _enum: modules.map((mod2, index) => [mod2.name.toString(), metaVersion >= 12 ? mod2.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {
        for (let i = Object.keys(result).length; i < index; i++) {
          result[`Empty${i}`] = "Null";
        }
        result[name] = knownOrigins[name] || "Null";
        return result;
      }, {})
    }
  });
}
function setTypeOverride(sectionTypes, types2) {
  types2.forEach((type) => {
    const override = Object.keys(sectionTypes).find((aliased) => type.eq(aliased));
    if (override) {
      type.setOverride(sectionTypes[override]);
    } else {
      const orig = type.toString();
      const alias2 = Object.entries(sectionTypes).reduce((result, [src, dst]) => BOXES.reduce((result2, [a, z]) => result2.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);
      if (orig !== alias2) {
        type.setOverride(alias2);
      }
    }
  });
}
function convertCalls(specs, registry, modName, calls, sectionTypes) {
  const variants = calls.map(({
    args,
    docs,
    name
  }, index) => {
    setTypeOverride(sectionTypes, args.map(({
      type
    }) => type));
    return registry.createTypeUnsafe("SiVariant", [{
      docs,
      fields: args.map(({
        name: name2,
        type
      }) => registry.createTypeUnsafe("SiField", [{
        name: name2,
        type: compatType(specs, type)
      }])),
      index,
      name
    }]);
  });
  return registry.createTypeUnsafe("PalletCallMetadataV14", [{
    type: makeVariantType(modName, "Call", specs, variants)
  }]);
}
function convertConstants(specs, registry, constants, sectionTypes) {
  return constants.map(({
    docs,
    name,
    type,
    value
  }) => {
    setTypeOverride(sectionTypes, [type]);
    return registry.createTypeUnsafe("PalletConstantMetadataV14", [{
      docs,
      name,
      type: compatType(specs, type),
      value
    }]);
  });
}
function convertErrors(specs, registry, modName, errors, _sectionTypes) {
  const variants = errors.map(({
    docs,
    name
  }, index) => registry.createTypeUnsafe("SiVariant", [{
    docs,
    fields: [],
    index,
    name
  }]));
  return registry.createTypeUnsafe("PalletErrorMetadataV14", [{
    type: makeVariantType(modName, "Error", specs, variants)
  }]);
}
function convertEvents(specs, registry, modName, events2, sectionTypes) {
  const variants = events2.map(({
    args,
    docs,
    name
  }, index) => {
    setTypeOverride(sectionTypes, args);
    return registry.createTypeUnsafe("SiVariant", [{
      docs,
      fields: args.map((t) => registry.createTypeUnsafe("SiField", [{
        type: compatType(specs, t)
      }])),
      index,
      name
    }]);
  });
  return registry.createTypeUnsafe("PalletEventMetadataV14", [{
    type: makeVariantType(modName, "Event", specs, variants)
  }]);
}
function createMapEntry(specs, registry, sectionTypes, {
  hashers,
  isLinked,
  isOptional,
  keys: keys2,
  value
}) {
  setTypeOverride(sectionTypes, [value, ...Array.isArray(keys2) ? keys2 : [keys2]]);
  return registry.createTypeUnsafe("StorageEntryTypeV14", [{
    Map: {
      hashers,
      key: hashers.length === 1 ? compatType(specs, keys2[0]) : makeTupleType(specs, keys2.map((t) => compatType(specs, t))),
      value: isLinked ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys2[0].toString()}>)`) : compatType(specs, value)
    }
  }]);
}
function convertStorage(specs, registry, {
  items,
  prefix: prefix2
}, sectionTypes) {
  return registry.createTypeUnsafe("PalletStorageMetadataV14", [{
    items: items.map(({
      docs,
      fallback,
      modifier,
      name,
      type
    }) => {
      let entryType;
      if (type.isPlain) {
        const plain = type.asPlain;
        setTypeOverride(sectionTypes, [plain]);
        entryType = registry.createTypeUnsafe("StorageEntryTypeV14", [{
          Plain: compatType(specs, plain)
        }]);
      } else if (type.isMap) {
        const map3 = type.asMap;
        entryType = createMapEntry(specs, registry, sectionTypes, {
          hashers: [map3.hasher],
          isLinked: map3.linked.isTrue,
          isOptional: modifier.isOptional,
          keys: [map3.key],
          value: map3.value
        });
      } else if (type.isDoubleMap) {
        const dm = type.asDoubleMap;
        entryType = createMapEntry(specs, registry, sectionTypes, {
          hashers: [dm.hasher, dm.key2Hasher],
          isLinked: false,
          isOptional: modifier.isOptional,
          keys: [dm.key1, dm.key2],
          value: dm.value
        });
      } else {
        const nm = type.asNMap;
        entryType = createMapEntry(specs, registry, sectionTypes, {
          hashers: nm.hashers,
          isLinked: false,
          isOptional: modifier.isOptional,
          keys: nm.keyVec,
          value: nm.value
        });
      }
      return registry.createTypeUnsafe("StorageEntryMetadataV14", [{
        docs,
        fallback,
        modifier,
        name,
        type: entryType
      }]);
    }),
    prefix: prefix2
  }]);
}
function convertExtrinsic(registry, {
  signedExtensions,
  version
}) {
  return registry.createTypeUnsafe("ExtrinsicMetadataV14", [{
    signedExtensions: signedExtensions.map((identifier) => ({
      identifier,
      type: 0
    })),
    type: 0,
    version
  }]);
}
function createPallet(specs, registry, mod2, {
  calls,
  constants,
  errors,
  events: events2,
  storage
}) {
  const sectionTypes = getAliasTypes(registry, stringCamelCase(mod2.name));
  return registry.createTypeUnsafe("PalletMetadataV14", [{
    calls: calls && convertCalls(specs, registry, mod2.name, calls, sectionTypes),
    constants: convertConstants(specs, registry, constants, sectionTypes),
    errors: errors && convertErrors(specs, registry, mod2.name, errors, sectionTypes),
    events: events2 && convertEvents(specs, registry, mod2.name, events2, sectionTypes),
    index: mod2.index,
    name: mod2.name,
    storage: storage && convertStorage(specs, registry, storage, sectionTypes)
  }]);
}
function toV14(registry, v132, metaVersion) {
  const specs = [];
  compatTypes(specs, "Null", "u8", "u16", "u32", "u64");
  registerOriginCaller(registry, v132.modules, metaVersion);
  const extrinsic = convertExtrinsic(registry, v132.extrinsic);
  const pallets = v132.modules.map((mod2) => createPallet(specs, registry, mod2, {
    calls: mod2.calls.unwrapOr(null),
    constants: mod2.constants,
    errors: mod2.errors.length ? mod2.errors : null,
    events: mod2.events.unwrapOr(null),
    storage: mod2.storage.unwrapOr(null)
  }));
  return registry.createTypeUnsafe("MetadataV14", [{
    extrinsic,
    lookup: {
      types: specs.map((type, id2) => registry.createTypeUnsafe("PortableType", [{
        id: id2,
        type
      }]))
    },
    pallets
  }]);
}

// node_modules/@polkadot/types/metadata/v14/toLatest.js
function toLatest(registry, v142, _metaVersion) {
  return v142;
}

// node_modules/@polkadot/types/metadata/MagicNumber.js
var MAGIC_NUMBER = 1635018093;
var MagicNumber = class extends u323 {
  constructor(registry, value) {
    super(registry, value);
    if (!this.isEmpty && !this.eq(MAGIC_NUMBER)) {
      throw new Error(`MagicNumber mismatch: expected ${registry.createTypeUnsafe("u32", [MAGIC_NUMBER]).toHex()}, found ${this.toHex()}`);
    }
  }
};

// node_modules/@polkadot/types/metadata/MetadataVersioned.js
var KNOWN_VERSIONS = [14, 13, 12, 11, 10, 9];
var LATEST_VERSION = KNOWN_VERSIONS[0];
var _converted, _assertVersion, _getVersion, _metadata;
var _MetadataVersioned = class extends Struct {
  constructor(registry, value) {
    super(registry, {
      magicNumber: MagicNumber,
      metadata: "MetadataAll"
    }, value);
    __privateAdd(this, _converted, new Map());
    __privateAdd(this, _assertVersion, (version) => {
      if (this.version > version) {
        throw new Error(`Cannot convert metadata from version ${this.version} to ${version}`);
      }
      return this.version === version;
    });
    __privateAdd(this, _getVersion, (version, fromPrev) => {
      const asCurr = `asV${version}`;
      const asPrev = version === "latest" ? `asV${LATEST_VERSION}` : `asV${version - 1}`;
      if (version !== "latest" && __privateGet(this, _assertVersion).call(this, version)) {
        return __privateGet(this, _metadata).call(this)[asCurr];
      }
      if (!__privateGet(this, _converted).has(version)) {
        __privateGet(this, _converted).set(version, fromPrev(this.registry, this[asPrev], this.version));
      }
      return __privateGet(this, _converted).get(version);
    });
    __privateAdd(this, _metadata, () => {
      return this.getT("metadata");
    });
  }
  get asCallsOnly() {
    return new _MetadataVersioned(this.registry, {
      magicNumber: this.magicNumber,
      metadata: this.registry.createTypeUnsafe("MetadataAll", [toCallsOnly(this.registry, this.asLatest), LATEST_VERSION])
    });
  }
  get asV9() {
    __privateGet(this, _assertVersion).call(this, 9);
    return __privateGet(this, _metadata).call(this).asV9;
  }
  get asV10() {
    return __privateGet(this, _getVersion).call(this, 10, toV10);
  }
  get asV11() {
    return __privateGet(this, _getVersion).call(this, 11, toV11);
  }
  get asV12() {
    return __privateGet(this, _getVersion).call(this, 12, toV12);
  }
  get asV13() {
    return __privateGet(this, _getVersion).call(this, 13, toV13);
  }
  get asV14() {
    return __privateGet(this, _getVersion).call(this, 14, toV14);
  }
  get asLatest() {
    return __privateGet(this, _getVersion).call(this, "latest", toLatest);
  }
  get magicNumber() {
    return this.getT("magicNumber");
  }
  get version() {
    return __privateGet(this, _metadata).call(this).index;
  }
  getUniqTypes(throwError2) {
    return getUniqTypes(this.registry, this.asLatest, throwError2);
  }
  toJSON() {
    this.asLatest;
    return super.toJSON();
  }
};
var MetadataVersioned = _MetadataVersioned;
_converted = new WeakMap();
_assertVersion = new WeakMap();
_getVersion = new WeakMap();
_metadata = new WeakMap();

// node_modules/@polkadot/types/metadata/Metadata.js
var EMPTY_METADATA = new Uint8Array([109, 101, 116, 97, 9]);
var VERSION_IDX = EMPTY_METADATA.length - 1;
function decodeU8a7(registry, u8a) {
  if (u8a.length === 0) {
    return EMPTY_METADATA;
  } else if (u8a[VERSION_IDX] === 9) {
    try {
      return new MetadataVersioned(registry, u8a);
    } catch (error) {
      u8a[VERSION_IDX] = 10;
      return u8a;
    }
  }
  return u8a;
}
var Metadata = class extends MetadataVersioned {
  constructor(registry, value) {
    super(registry, isU8a(value) || isString(value) ? decodeU8a7(registry, u8aToU8a(value)) : value);
  }
};

// node_modules/@polkadot/types/metadata/decorate/util.js
function convert(fn) {
  return ({
    name
  }) => fn(name);
}
var objectNameToCamel = convert(stringCamelCase);
var objectNameToString = convert((n) => n.toString());

// node_modules/@polkadot/types/metadata/decorate/constants/index.js
function decorateConstants(registry, {
  pallets
}, _version) {
  const result = {};
  for (let i = 0; i < pallets.length; i++) {
    const {
      constants,
      name
    } = pallets[i];
    if (!constants.isEmpty) {
      lazyMethod(result, stringCamelCase(name), () => lazyMethods({}, constants, (constant) => {
        const codec = registry.createTypeUnsafe(registry.createLookupType(constant.type), [hexToU8a(constant.value.toHex())]);
        codec.meta = constant;
        return codec;
      }, objectNameToCamel));
    }
  }
  return result;
}

// node_modules/@polkadot/types/metadata/decorate/errors/index.js
function variantToMeta(lookup, variant) {
  return objectSpread({
    args: variant.fields.map(({
      type
    }) => lookup.getTypeDef(type).type)
  }, variant);
}
function decorateErrors(registry, {
  lookup,
  pallets
}, version) {
  const result = {};
  for (let i = 0; i < pallets.length; i++) {
    const {
      errors,
      index,
      name
    } = pallets[i];
    if (errors.isSome) {
      const sectionIndex = version >= 12 ? index.toNumber() : i;
      lazyMethod(result, stringCamelCase(name), () => lazyVariants(lookup, errors.unwrap(), objectNameToString, (variant) => ({
        is: (errorMod) => isCodec(errorMod) && isCodec(errorMod.index) && errorMod.index.eq(sectionIndex) && (isU8a(errorMod.error) ? errorMod.error[0] === variant.index.toNumber() : isCodec(errorMod.error) && errorMod.error.eq(variant.index)),
        meta: registry.createTypeUnsafe("ErrorMetadataLatest", [variantToMeta(lookup, variant)])
      })));
    }
  }
  return result;
}

// node_modules/@polkadot/types/metadata/decorate/events/index.js
function filterEventsSome({
  events: events2
}) {
  return events2.isSome;
}
function decorateEvents(registry, {
  lookup,
  pallets
}, version) {
  const result = {};
  const filtered = pallets.filter(filterEventsSome);
  for (let i = 0; i < filtered.length; i++) {
    const {
      events: events2,
      index,
      name
    } = filtered[i];
    const sectionIndex = version >= 12 ? index.toNumber() : i;
    lazyMethod(result, stringCamelCase(name), () => lazyVariants(lookup, events2.unwrap(), objectNameToString, (variant) => ({
      is: (eventRecord) => isCodec(eventRecord) && isU8a(eventRecord.index) && sectionIndex === eventRecord.index[0] && variant.index.eq(eventRecord.index[1]),
      meta: registry.createTypeUnsafe("EventMetadataLatest", [variantToMeta(lookup, variant)])
    })));
  }
  return result;
}

// node_modules/@polkadot/types/metadata/decorate/extrinsics/createUnchecked.js
function isTx(tx, callIndex) {
  return tx.callIndex[0] === callIndex[0] && tx.callIndex[1] === callIndex[1];
}
function createUnchecked(registry, section2, callIndex, callMetadata) {
  const expectedArgs = callMetadata.fields;
  const funcName = stringCamelCase(callMetadata.name);
  const extrinsicFn = (...args) => {
    if (expectedArgs.length !== args.length) {
      throw new Error(`Extrinsic ${section2}.${funcName} expects ${expectedArgs.length} arguments, got ${args.length}.`);
    }
    return registry.createTypeUnsafe("Call", [{
      args,
      callIndex
    }, callMetadata]);
  };
  extrinsicFn.is = (tx) => isTx(tx, callIndex);
  extrinsicFn.callIndex = callIndex;
  extrinsicFn.meta = callMetadata;
  extrinsicFn.method = funcName;
  extrinsicFn.section = section2;
  extrinsicFn.toJSON = () => callMetadata.toJSON();
  return extrinsicFn;
}

// node_modules/@polkadot/types/metadata/decorate/extrinsics/index.js
function filterCallsSome({
  calls
}) {
  return calls.isSome;
}
function createCallFunction(registry, lookup, variant, sectionName, sectionIndex) {
  const {
    fields,
    index
  } = variant;
  const args = new Array(fields.length);
  for (let a = 0; a < fields.length; a++) {
    const {
      name,
      type,
      typeName
    } = fields[a];
    args[a] = objectSpread({
      name: stringCamelCase(name.unwrapOr(`param${a}`)),
      type: getSiName(lookup, type)
    }, typeName.isSome ? {
      typeName: typeName.unwrap()
    } : null);
  }
  return createUnchecked(registry, sectionName, new Uint8Array([sectionIndex, index.toNumber()]), registry.createTypeUnsafe("FunctionMetadataLatest", [objectSpread({
    args
  }, variant)]));
}
function decorateExtrinsics(registry, {
  lookup,
  pallets
}, version) {
  const result = {};
  const filtered = pallets.filter(filterCallsSome);
  for (let i = 0; i < filtered.length; i++) {
    const {
      calls,
      index,
      name
    } = filtered[i];
    const sectionName = stringCamelCase(name);
    const sectionIndex = version >= 12 ? index.toNumber() : i;
    lazyMethod(result, sectionName, () => lazyVariants(lookup, calls.unwrap(), objectNameToCamel, (variant) => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));
  }
  return result;
}

// node_modules/@polkadot/types/metadata/decorate/storage/getHasher.js
var DEFAULT_FN = (data) => xxhashAsU8a(data, 128);
var HASHERS = {
  Blake2_128: (data) => blake2AsU8a(data, 128),
  Blake2_128Concat: (data) => u8aConcat(blake2AsU8a(data, 128), u8aToU8a(data)),
  Blake2_256: (data) => blake2AsU8a(data, 256),
  Identity: (data) => u8aToU8a(data),
  Twox128: (data) => xxhashAsU8a(data, 128),
  Twox256: (data) => xxhashAsU8a(data, 256),
  Twox64Concat: (data) => u8aConcat(xxhashAsU8a(data, 64), u8aToU8a(data))
};
function getHasher(hasher2) {
  return HASHERS[hasher2.type] || DEFAULT_FN;
}

// node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js
var NO_RAW_ARGS = {
  args: [],
  hashers: [],
  keys: []
};
function filterDefined(a) {
  return !isUndefined(a);
}
function assertArgs({
  method,
  section: section2
}, {
  args,
  keys: keys2
}) {
  if (!Array.isArray(args)) {
    throw new Error(`Call to ${stringCamelCase(section2 || "unknown")}.${stringCamelCase(method || "unknown")} needs ${keys2.length} arguments`);
  } else if (args.filter(filterDefined).length !== keys2.length) {
    throw new Error(`Call to ${stringCamelCase(section2 || "unknown")}.${stringCamelCase(method || "unknown")} needs ${keys2.length} arguments, found [${args.join(", ")}]`);
  }
}
function createKeyRawParts(registry, itemFn, {
  args,
  hashers,
  keys: keys2
}) {
  const extra = new Array(keys2.length);
  for (let i = 0; i < keys2.length; i++) {
    extra[i] = getHasher(hashers[i])(registry.createTypeUnsafe(registry.createLookupType(keys2[i]), [args[i]]).toU8a());
  }
  return [[xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128)], extra];
}
function createKeyInspect(registry, itemFn, args) {
  assertArgs(itemFn, args);
  const {
    meta
  } = itemFn;
  const [prefix2, extra] = createKeyRawParts(registry, itemFn, args);
  let types2 = [];
  if (meta.type.isMap) {
    const {
      hashers,
      key
    } = meta.type.asMap;
    types2 = hashers.length === 1 ? [`${hashers[0].type}(${getSiName(registry.lookup, key)})`] : registry.lookup.getSiType(key).def.asTuple.map((k, i) => `${hashers[i].type}(${getSiName(registry.lookup, k)})`);
  }
  const names = ["module", "method"].concat(...args.args.map((_, i) => types2[i]));
  return {
    inner: prefix2.concat(...extra).map((v, i) => ({
      name: names[i],
      outer: [v]
    }))
  };
}
function createKeyRaw(registry, itemFn, args) {
  const [prefix2, extra] = createKeyRawParts(registry, itemFn, args);
  return u8aConcat(...prefix2, ...extra);
}
function createKey(registry, itemFn, args) {
  assertArgs(itemFn, args);
  return compactAddLength(createKeyRaw(registry, itemFn, args));
}
function createStorageInspect(registry, itemFn, options) {
  const {
    meta: {
      type
    }
  } = itemFn;
  return (...args) => {
    if (type.isPlain) {
      return options.skipHashing ? {
        inner: [],
        name: "wellKnown",
        outer: [u8aToU8a(options.key)]
      } : createKeyInspect(registry, itemFn, NO_RAW_ARGS);
    }
    const {
      hashers,
      key
    } = type.asMap;
    return hashers.length === 1 ? createKeyInspect(registry, itemFn, {
      args,
      hashers,
      keys: [key]
    }) : createKeyInspect(registry, itemFn, {
      args,
      hashers,
      keys: registry.lookup.getSiType(key).def.asTuple
    });
  };
}
function createStorageFn(registry, itemFn, options) {
  const {
    meta: {
      type
    }
  } = itemFn;
  let cacheKey = null;
  return (...args) => {
    if (type.isPlain) {
      if (!cacheKey) {
        cacheKey = options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, NO_RAW_ARGS);
      }
      return cacheKey;
    }
    const {
      hashers,
      key
    } = type.asMap;
    return hashers.length === 1 ? createKey(registry, itemFn, {
      args,
      hashers,
      keys: [key]
    }) : createKey(registry, itemFn, {
      args,
      hashers,
      keys: registry.lookup.getSiType(key).def.asTuple
    });
  };
}
function createWithMeta(registry, itemFn, options) {
  const {
    meta,
    method,
    prefix: prefix2,
    section: section2
  } = itemFn;
  const storageFn = createStorageFn(registry, itemFn, options);
  storageFn.inspect = createStorageInspect(registry, itemFn, options);
  storageFn.meta = meta;
  storageFn.method = stringCamelCase(method);
  storageFn.prefix = prefix2;
  storageFn.section = section2;
  storageFn.toJSON = () => objectSpread({
    storage: {
      method,
      prefix: prefix2,
      section: section2
    }
  }, meta.toJSON());
  return storageFn;
}
function extendHeadMeta(registry, {
  meta: {
    docs,
    name,
    type
  },
  section: section2
}, {
  method
}, iterFn) {
  const meta = registry.createTypeUnsafe("StorageEntryMetadataLatest", [{
    docs,
    fallback: registry.createTypeUnsafe("Bytes", []),
    modifier: registry.createTypeUnsafe("StorageEntryModifierLatest", [1]),
    name,
    type: registry.createTypeUnsafe("StorageEntryTypeLatest", [type.asMap.key, 0])
  }]);
  iterFn.meta = meta;
  const fn = (...args) => registry.createTypeUnsafe("StorageKey", [iterFn(...args), {
    method,
    section: section2
  }]);
  fn.meta = meta;
  return fn;
}
function extendPrefixedMap(registry, itemFn, storageFn) {
  const {
    meta: {
      type
    },
    method,
    section: section2
  } = itemFn;
  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {
    if (args.length && (type.isPlain || args.length >= type.asMap.hashers.length)) {
      throw new Error(`Iteration of ${stringCamelCase(section2 || "unknown")}.${stringCamelCase(method || "unknown")} needs arguments to be at least one less than the full arguments, found [${args.join(", ")}]`);
    }
    if (args.length) {
      if (type.isMap) {
        const {
          hashers,
          key
        } = type.asMap;
        const keysVec = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;
        return new Raw(registry, createKeyRaw(registry, itemFn, {
          args,
          hashers: hashers.slice(0, args.length),
          keys: keysVec.slice(0, args.length)
        }));
      }
    }
    return new Raw(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));
  });
  return storageFn;
}
function createFunction(registry, itemFn, options) {
  const {
    meta: {
      type
    }
  } = itemFn;
  const storageFn = createWithMeta(registry, itemFn, options);
  if (type.isMap) {
    extendPrefixedMap(registry, itemFn, storageFn);
  }
  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];
  return storageFn;
}

// node_modules/@polkadot/types/metadata/decorate/storage/util.js
function findSiPrimitive(registry, _prim) {
  const prim = _prim.toLowerCase();
  return registry.lookup.types.find((t) => t.type.def.isPrimitive && t.type.def.asPrimitive.toString().toLowerCase() === prim || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);
}
function findSiType(registry, orig) {
  let portable = findSiPrimitive(registry, orig);
  if (!portable && orig === "Bytes") {
    const u83 = findSiPrimitive(registry, "u8");
    if (u83) {
      portable = registry.lookup.types.find((t) => t.type.def.isSequence && t.type.def.asSequence.type.eq(u83.id) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(orig));
    }
  }
  if (!portable) {
    console.warn(`Unable to map ${orig} to a lookup index`);
  }
  return portable;
}
function createRuntimeFunction({
  method,
  prefix: prefix2,
  section: section2
}, key, {
  docs,
  type
}) {
  return (registry) => {
    var _findSiType;
    return createFunction(registry, {
      meta: registry.createTypeUnsafe("StorageEntryMetadataLatest", [{
        docs: registry.createTypeUnsafe("Vec<Text>", [[docs]]),
        modifier: registry.createTypeUnsafe("StorageEntryModifierLatest", ["Required"]),
        name: registry.createTypeUnsafe("Text", [method]),
        toJSON: () => key,
        type: registry.createTypeUnsafe("StorageEntryTypeLatest", [{
          Plain: ((_findSiType = findSiType(registry, type)) == null ? void 0 : _findSiType.id) || 0
        }])
      }]),
      method,
      prefix: prefix2,
      section: section2
    }, {
      key,
      skipHashing: true
    });
  };
}

// node_modules/@polkadot/types/metadata/decorate/storage/substrate.js
var prefix = "Substrate";
var section = "substrate";
function createSubstrateFn(method, key, meta) {
  return createRuntimeFunction({
    method,
    prefix,
    section
  }, key, meta);
}
var substrate2 = {
  changesTrieConfig: createSubstrateFn("changesTrieConfig", ":changes_trie", {
    docs: "Changes trie configuration is stored under this key.",
    type: "u32"
  }),
  childStorageKeyPrefix: createSubstrateFn("childStorageKeyPrefix", ":child_storage:", {
    docs: "Prefix of child storage keys.",
    type: "u32"
  }),
  code: createSubstrateFn("code", ":code", {
    docs: "Wasm code of the runtime.",
    type: "Bytes"
  }),
  extrinsicIndex: createSubstrateFn("extrinsicIndex", ":extrinsic_index", {
    docs: "Current extrinsic index (u32) is stored under this key.",
    type: "u32"
  }),
  heapPages: createSubstrateFn("heapPages", ":heappages", {
    docs: "Number of wasm linear memory pages required for execution of the runtime.",
    type: "u64"
  })
};

// node_modules/@polkadot/types/metadata/decorate/storage/getStorage.js
function getStorage(registry) {
  const storage = {};
  const entries = Object.entries(substrate2);
  for (let e = 0; e < entries.length; e++) {
    storage[entries[e][0]] = entries[e][1](registry);
  }
  return {
    substrate: storage
  };
}

// node_modules/@polkadot/types/metadata/decorate/storage/index.js
var VERSION_NAME = "palletVersion";
var VERSION_KEY = ":__STORAGE_VERSION__:";
var VERSION_DOCS = {
  docs: "Returns the current pallet version from storage",
  type: "u16"
};
function decorateStorage(registry, {
  pallets
}, _metaVersion) {
  const result = getStorage(registry);
  for (let i = 0; i < pallets.length; i++) {
    const {
      name,
      storage
    } = pallets[i];
    if (storage.isSome) {
      const section2 = stringCamelCase(name);
      const {
        items,
        prefix: _prefix
      } = storage.unwrap();
      const prefix2 = _prefix.toString();
      lazyMethod(result, section2, () => lazyMethods({
        palletVersion: createRuntimeFunction({
          method: VERSION_NAME,
          prefix: prefix2,
          section: section2
        }, createKeyRaw(registry, {
          method: VERSION_KEY,
          prefix: name.toString()
        }, NO_RAW_ARGS), VERSION_DOCS)(registry)
      }, items, (meta) => createFunction(registry, {
        meta,
        method: meta.name.toString(),
        prefix: prefix2,
        section: section2
      }, {}), objectNameToCamel));
    }
  }
  return result;
}

// node_modules/@polkadot/types/metadata/decorate/index.js
function expandMetadata(registry, metadata) {
  if (!(metadata instanceof Metadata)) {
    throw new Error("You need to pass a valid Metadata instance to Decorated");
  }
  const latest2 = metadata.asLatest;
  const version = metadata.version;
  return {
    consts: decorateConstants(registry, latest2, version),
    errors: decorateErrors(registry, latest2, version),
    events: decorateEvents(registry, latest2, version),
    query: decorateStorage(registry, latest2, version),
    registry,
    tx: decorateExtrinsics(registry, latest2, version)
  };
}

// node_modules/@polkadot/types/metadata/PortableRegistry/PortableRegistry.js
var l9 = logger("PortableRegistry");
var TYPE_UNWRAP = {
  toNumber: () => -1
};
var PRIMITIVE_ALIAS = {
  Char: "u32",
  Str: "Text"
};
var PATHS_ALIAS = splitNamespace([
  "sp_core::crypto::AccountId32",
  "sp_runtime::generic::era::Era",
  "sp_runtime::multiaddress::MultiAddress",
  "frame_support::weights::weight_v2::Weight",
  "sp_weights::weight_v2::Weight",
  "account::AccountId20",
  "polkadot_runtime_common::claims::EthereumAddress",
  "*_democracy::vote::Vote",
  "*_conviction_voting::vote::Vote",
  "*_identity::types::Data",
  "sp_core::OpaqueMetadata",
  "sp_core::OpaquePeerId",
  "sp_core::offchain::OpaqueMultiaddr",
  "primitive_types::*",
  "sp_arithmetic::per_things::*",
  "ink_env::types::*",
  "ink_primitives::types::*"
]);
var PATHS_SET = splitNamespace(["pallet_identity::types::BitFlags"]);
var BITVEC_NS_LSB = ["bitvec::order::Lsb0", "BitOrderLsb0"];
var BITVEC_NS_MSB = ["bitvec::order::Msb0", "BitOrderMsb0"];
var BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];
var WRAPPERS = ["BoundedBTreeMap", "BoundedBTreeSet", "BoundedVec", "Box", "BTreeMap", "BTreeSet", "Cow", "Option", "Range", "RangeInclusive", "Result", "WeakBoundedVec", "WrapperKeepOpaque", "WrapperOpaque"];
var RESERVED = ["entries", "hash", "keys", "new", "size"];
var PATH_RM_INDEX_1 = ["generic", "misc", "pallet", "traits", "types"];
function sanitizeDocs(docs) {
  const result = new Array(docs.length);
  for (let i = 0; i < docs.length; i++) {
    result[i] = docs[i].toString();
  }
  return result;
}
function splitNamespace(values) {
  const result = new Array(values.length);
  for (let i = 0; i < values.length; i++) {
    result[i] = values[i].split("::");
  }
  return result;
}
function matchParts(first2, second) {
  return first2.length === second.length && first2.every((a, index) => {
    const b = second[index].toString();
    if (a === "*" || a === b) {
      return true;
    }
    if (a.includes("*") && a.includes("_") && b.includes("_")) {
      let suba = a.split("_");
      let subb = b.split("_");
      if (suba[0] === "*") {
        const indexOf = subb.indexOf(suba[1]);
        if (indexOf !== -1) {
          suba = suba.slice(1);
          subb = subb.slice(indexOf);
        }
      }
      if (suba.length === 2 && suba[1] === "*" && suba[0] === subb[0]) {
        return true;
      }
      return matchParts(suba, subb);
    }
    return false;
  });
}
function getAliasPath({
  def,
  path
}) {
  if (path.join("::") === "sp_weights::weight_v2::Weight" && def.isComposite && def.asComposite.fields.length !== 1) {
    return null;
  }
  return path.length && PATHS_ALIAS.some((a) => matchParts(a, path)) ? path[path.length - 1].toString() : null;
}
function extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {
  const count2 = path.length;
  if (count2 === 0 || WRAPPERS.includes(path[count2 - 1].toString())) {
    return null;
  }
  const camels = new Array(count2);
  const lowers = new Array(count2);
  for (let i = 0; i < count2; i++) {
    const c = stringPascalCase(isInternal ? path[i].replace("pallet_", "") : path[i]);
    const l16 = c.toLowerCase();
    camels[i] = c;
    lowers[i] = l16;
  }
  let name = "";
  for (let i = 0; i < count2; i++) {
    const l16 = lowers[i];
    if (i !== 1 || !PATH_RM_INDEX_1.includes(l16)) {
      if (l16 !== lowers[i + 1]) {
        name += camels[i];
      }
    }
  }
  if (camels[1] === "RawOrigin" && count2 === 2 && params.length === 2 && params[1].type.isSome) {
    const instanceType = portable[params[1].type.unwrap().toNumber()];
    if (instanceType.type.path.length === 2) {
      name = `${name}${instanceType.type.path[1].toString()}`;
    }
  }
  return {
    lookupIndex,
    name,
    params
  };
}
function extractName(portable, lookupIndex, {
  type: {
    params,
    path
  }
}) {
  return extractNameFlat(portable, lookupIndex, params, path);
}
function nextDupeMatches(name, startAt, names) {
  const result = [names[startAt]];
  for (let i = startAt + 1; i < names.length; i++) {
    const v = names[i];
    if (v.name === name) {
      result.push(v);
    }
  }
  return result;
}
function rewriteDupes(input, rewrite) {
  const count2 = input.length;
  for (let i = 0; i < count2; i++) {
    const a = input[i];
    for (let j = i + 1; j < count2; j++) {
      const b = input[j];
      if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {
        return false;
      }
    }
  }
  for (let i = 0; i < count2; i++) {
    const p = input[i];
    rewrite[p.lookupIndex] = p.name;
  }
  return true;
}
function removeDupeNames(lookup, portable, names) {
  const rewrite = {};
  return names.map((original, startAt) => {
    const {
      lookupIndex,
      name,
      params
    } = original;
    if (!name) {
      return null;
    } else if (rewrite[lookupIndex]) {
      return original;
    }
    const allSame = nextDupeMatches(name, startAt, names);
    if (allSame.length === 1) {
      return original;
    }
    const anyDiff = allSame.some((o) => params.length !== o.params.length || params.some((p, index) => !p.name.eq(o.params[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));
    if (!anyDiff) {
      return original;
    }
    const paramIdx = params.findIndex(({
      type
    }, index) => allSame.every(({
      params: params2
    }, aIndex) => params2[index].type.isSome && (aIndex === 0 || !params2[index].type.eq(type))));
    if (paramIdx === -1) {
      return original;
    }
    const adjusted = new Array(allSame.length);
    for (let i = 0; i < allSame.length; i++) {
      const {
        lookupIndex: lookupIndex2,
        name: name2,
        params: params2
      } = allSame[i];
      const {
        def,
        path
      } = lookup.getSiType(params2[paramIdx].type.unwrap());
      if (!def.isPrimitive && !path.length) {
        return null;
      }
      adjusted[i] = {
        lookupIndex: lookupIndex2,
        name: def.isPrimitive ? `${name2}${def.asPrimitive.toString()}` : `${name2}${path[path.length - 1].toString()}`
      };
    }
    if (rewriteDupes(adjusted, rewrite)) {
      return original;
    }
    for (let i = 0; i < allSame.length; i++) {
      const {
        lookupIndex: lookupIndex2,
        name: name2,
        params: params2
      } = allSame[i];
      const {
        def,
        path
      } = lookup.getSiType(params2[paramIdx].type.unwrap());
      const flat = extractNameFlat(portable, lookupIndex2, params2, path, true);
      if (def.isPrimitive || !flat) {
        return null;
      }
      adjusted[i] = {
        lookupIndex: lookupIndex2,
        name: `${name2}${flat.name}`
      };
    }
    if (rewriteDupes(adjusted, rewrite)) {
      return original;
    }
    return null;
  }).filter((n) => !!n).map(({
    lookupIndex,
    name,
    params
  }) => ({
    lookupIndex,
    name: rewrite[lookupIndex] || name,
    params
  }));
}
function registerTypes(lookup, lookups, names, params) {
  lookup.registry.register(lookups);
  if (params.SpRuntimeUncheckedExtrinsic) {
    const [addrParam, , sigParam] = params.SpRuntimeUncheckedExtrinsic;
    const siAddress = lookup.getSiType(addrParam.type.unwrap());
    const siSignature = lookup.getSiType(sigParam.type.unwrap());
    const nsSignature = siSignature.path.join("::");
    let nsAccountId = siAddress.path.join("::");
    const isMultiAddress = nsAccountId === "sp_runtime::multiaddress::MultiAddress";
    if (isMultiAddress) {
      const [idParam] = siAddress.params;
      nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join("::");
    }
    lookup.registry.register({
      AccountId: ["sp_core::crypto::AccountId32"].includes(nsAccountId) ? "AccountId32" : ["account::AccountId20", "primitive_types::H160"].includes(nsAccountId) ? "AccountId20" : "AccountId32",
      Address: isMultiAddress ? "MultiAddress" : "AccountId",
      ExtrinsicSignature: ["sp_runtime::MultiSignature"].includes(nsSignature) ? "MultiSignature" : names[sigParam.type.unwrap().toNumber()] || "MultiSignature"
    });
  }
  if (params.SpWeightsWeightV2Weight) {
    const weight = Object.entries(names).find(([, n]) => n === "SpWeightsWeightV2Weight");
    if (!weight) {
      throw new Error("Unable to extract weight type from SpWeightsWeightV2Weight");
    }
    const weightDef = lookup.getTypeDef(`Lookup${weight[0]}`);
    lookup.registry.register({
      Weight: Array.isArray(weightDef.sub) && weightDef.sub.length !== 1 ? "SpWeightsWeightV2Weight" : "WeightV1"
    });
  }
}
function extractAliases(params, isContract) {
  const hasParams = Object.keys(params).some((k) => !k.startsWith("Pallet"));
  const alias2 = {};
  if (params.SpRuntimeUncheckedExtrinsic) {
    const [, {
      type
    }] = params.SpRuntimeUncheckedExtrinsic;
    alias2[type.unwrap().toNumber()] = "Call";
  } else if (hasParams && !isContract) {
    l9.warn("Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic");
  }
  if (params.FrameSystemEventRecord) {
    const [{
      type
    }] = params.FrameSystemEventRecord;
    alias2[type.unwrap().toNumber()] = "Event";
  } else if (hasParams && !isContract) {
    l9.warn("Unable to determine runtime Event type, cannot inspect frame_system::EventRecord");
  }
  return alias2;
}
function extractTypeInfo(lookup, portable) {
  const nameInfo = [];
  const types2 = {};
  const porCount = portable.length;
  for (let i = 0; i < porCount; i++) {
    const type = portable[i];
    const lookupIndex = type.id.toNumber();
    const extracted = extractName(portable, lookupIndex, portable[i]);
    if (extracted) {
      nameInfo.push(extracted);
    }
    types2[lookupIndex] = type;
  }
  const lookups = {};
  const names = {};
  const params = {};
  const dedup = removeDupeNames(lookup, portable, nameInfo);
  const dedupCount = dedup.length;
  for (let i = 0; i < dedupCount; i++) {
    const {
      lookupIndex,
      name,
      params: p
    } = dedup[i];
    names[lookupIndex] = name;
    lookups[name] = lookup.registry.createLookupType(lookupIndex);
    params[name] = p;
  }
  return {
    lookups,
    names,
    params,
    types: types2
  };
}
var _alias = _classPrivateFieldKey("alias");
var _lookups = _classPrivateFieldKey("lookups");
var _names2 = _classPrivateFieldKey("names");
var _params = _classPrivateFieldKey("params");
var _typeDefs = _classPrivateFieldKey("typeDefs");
var _types = _classPrivateFieldKey("types");
var _createSiDef = _classPrivateFieldKey("createSiDef");
var _getLookupId = _classPrivateFieldKey("getLookupId");
var _extract = _classPrivateFieldKey("extract");
var _extractArray = _classPrivateFieldKey("extractArray");
var _extractBitSequence = _classPrivateFieldKey("extractBitSequence");
var _extractCompact = _classPrivateFieldKey("extractCompact");
var _extractComposite = _classPrivateFieldKey("extractComposite");
var _extractCompositeSet = _classPrivateFieldKey("extractCompositeSet");
var _extractFields = _classPrivateFieldKey("extractFields");
var _extractFieldsAlias = _classPrivateFieldKey("extractFieldsAlias");
var _extractHistoric = _classPrivateFieldKey("extractHistoric");
var _extractPrimitive = _classPrivateFieldKey("extractPrimitive");
var _extractAliasPath = _classPrivateFieldKey("extractAliasPath");
var _extractSequence = _classPrivateFieldKey("extractSequence");
var _extractTuple = _classPrivateFieldKey("extractTuple");
var _extractVariant = _classPrivateFieldKey("extractVariant");
var _extractVariantEnum = _classPrivateFieldKey("extractVariantEnum");
var PortableRegistry = class extends Struct {
  constructor(registry, value, isContract) {
    super(registry, {
      types: "Vec<PortableType>"
    }, value);
    Object.defineProperty(this, _extractVariantEnum, {
      value: _extractVariantEnum2
    });
    Object.defineProperty(this, _extractVariant, {
      value: _extractVariant2
    });
    Object.defineProperty(this, _extractTuple, {
      value: _extractTuple2
    });
    Object.defineProperty(this, _extractSequence, {
      value: _extractSequence2
    });
    Object.defineProperty(this, _extractAliasPath, {
      value: _extractAliasPath2
    });
    Object.defineProperty(this, _extractPrimitive, {
      value: _extractPrimitive2
    });
    Object.defineProperty(this, _extractHistoric, {
      value: _extractHistoric2
    });
    Object.defineProperty(this, _extractFieldsAlias, {
      value: _extractFieldsAlias2
    });
    Object.defineProperty(this, _extractFields, {
      value: _extractFields2
    });
    Object.defineProperty(this, _extractCompositeSet, {
      value: _extractCompositeSet2
    });
    Object.defineProperty(this, _extractComposite, {
      value: _extractComposite2
    });
    Object.defineProperty(this, _extractCompact, {
      value: _extractCompact2
    });
    Object.defineProperty(this, _extractBitSequence, {
      value: _extractBitSequence2
    });
    Object.defineProperty(this, _extractArray, {
      value: _extractArray2
    });
    Object.defineProperty(this, _extract, {
      value: _extract2
    });
    Object.defineProperty(this, _getLookupId, {
      value: _getLookupId2
    });
    Object.defineProperty(this, _createSiDef, {
      value: _createSiDef2
    });
    Object.defineProperty(this, _alias, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _lookups, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _names2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _params, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _typeDefs, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _types, {
      writable: true,
      value: void 0
    });
    const {
      lookups,
      names,
      params: _params2,
      types: types2
    } = extractTypeInfo(this, this.types);
    _classPrivateFieldBase(this, _alias)[_alias] = extractAliases(_params2, isContract);
    _classPrivateFieldBase(this, _lookups)[_lookups] = lookups;
    _classPrivateFieldBase(this, _names2)[_names2] = names;
    _classPrivateFieldBase(this, _params)[_params] = _params2;
    _classPrivateFieldBase(this, _types)[_types] = types2;
  }
  get names() {
    return Object.values(_classPrivateFieldBase(this, _names2)[_names2]).sort();
  }
  get types() {
    return this.getT("types");
  }
  register() {
    registerTypes(this, _classPrivateFieldBase(this, _lookups)[_lookups], _classPrivateFieldBase(this, _names2)[_names2], _classPrivateFieldBase(this, _params)[_params]);
  }
  getName(lookupId) {
    return _classPrivateFieldBase(this, _names2)[_names2][_classPrivateFieldBase(this, _getLookupId)[_getLookupId](lookupId)];
  }
  getSiType(lookupId) {
    const found = (_classPrivateFieldBase(this, _types)[_types] || this.types)[_classPrivateFieldBase(this, _getLookupId)[_getLookupId](lookupId)];
    if (!found) {
      throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);
    }
    return found.type;
  }
  getTypeDef(lookupId) {
    const lookupIndex = _classPrivateFieldBase(this, _getLookupId)[_getLookupId](lookupId);
    if (!_classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex]) {
      const lookupName = _classPrivateFieldBase(this, _names2)[_names2][lookupIndex];
      const empty3 = {
        info: TypeDefInfo.DoNotConstruct,
        lookupIndex,
        lookupName,
        type: this.registry.createLookupType(lookupIndex)
      };
      if (lookupName) {
        _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty3;
      }
      const extracted = _classPrivateFieldBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex);
      if (!lookupName) {
        _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty3;
      }
      Object.keys(extracted).forEach((k) => {
        if (k !== "lookupName" || extracted[k]) {
          _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];
        }
      });
      if (extracted.info === TypeDefInfo.Plain) {
        _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
        delete _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
      }
    }
    return _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex];
  }
  sanitizeField(name) {
    let nameField = null;
    let nameOrig = null;
    if (name.isSome) {
      nameField = stringCamelCase(name.unwrap());
      if (nameField.includes("#")) {
        nameOrig = nameField;
        nameField = nameOrig.replace(/#/g, "_");
      } else if (RESERVED.includes(nameField)) {
        nameOrig = nameField;
        nameField = `${nameField}_`;
      }
    }
    return [nameField, nameOrig];
  }
};
function _createSiDef2(lookupId) {
  const typeDef = this.getTypeDef(lookupId);
  const lookupIndex = lookupId.toNumber();
  return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {
    docs: typeDef.docs,
    info: TypeDefInfo.Si,
    lookupIndex,
    lookupName: _classPrivateFieldBase(this, _names2)[_names2][lookupIndex],
    type: this.registry.createLookupType(lookupId)
  } : typeDef;
}
function _getLookupId2(lookupId) {
  if (isString(lookupId)) {
    if (!this.registry.isLookupType(lookupId)) {
      throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);
    }
    return parseInt(lookupId.replace("Lookup", ""), 10);
  } else if (isNumber(lookupId)) {
    return lookupId;
  }
  return lookupId.toNumber();
}
function _extract2(type, lookupIndex) {
  const namespace = type.path.join("::");
  let typeDef;
  const aliasType = _classPrivateFieldBase(this, _alias)[_alias][lookupIndex] || getAliasPath(type);
  try {
    if (aliasType) {
      typeDef = _classPrivateFieldBase(this, _extractAliasPath)[_extractAliasPath](lookupIndex, aliasType);
    } else {
      switch (type.def.type) {
        case "Array":
          typeDef = _classPrivateFieldBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);
          break;
        case "BitSequence":
          typeDef = _classPrivateFieldBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);
          break;
        case "Compact":
          typeDef = _classPrivateFieldBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);
          break;
        case "Composite":
          typeDef = _classPrivateFieldBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);
          break;
        case "HistoricMetaCompat":
          typeDef = _classPrivateFieldBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);
          break;
        case "Primitive":
          typeDef = _classPrivateFieldBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);
          break;
        case "Sequence":
          typeDef = _classPrivateFieldBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);
          break;
        case "Tuple":
          typeDef = _classPrivateFieldBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);
          break;
        case "Variant":
          typeDef = _classPrivateFieldBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);
          break;
        default:
          assertUnreachable(type.def.type);
      }
    }
  } catch (error) {
    throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ""}: Error extracting ${stringify(type)}: ${error.message}`);
  }
  return objectSpread({
    docs: sanitizeDocs(type.docs),
    namespace
  }, typeDef);
}
function _extractArray2(_, {
  len,
  type
}) {
  const length = len.toNumber();
  if (length > 2048) {
    throw new Error("Only support for [Type; <length>], where length <= 2048");
  }
  return withTypeString(this.registry, {
    info: TypeDefInfo.VecFixed,
    length,
    sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type)
  });
}
function _extractBitSequence2(_, {
  bitOrderType,
  bitStoreType
}) {
  const a = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](bitOrderType);
  const b = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](bitStoreType);
  const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || "") ? [a, b] : [b, a];
  if (!BITVEC_NS.includes(bitOrder.namespace || "")) {
    throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || "<unknown>"}`);
  } else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== "u8") {
    throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);
  }
  return {
    info: TypeDefInfo.Plain,
    type: "BitVec"
  };
}
function _extractCompact2(_, {
  type
}) {
  return withTypeString(this.registry, {
    info: TypeDefInfo.Compact,
    sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type)
  });
}
function _extractComposite2(lookupIndex, {
  params,
  path
}, {
  fields
}) {
  if (path.length) {
    const pathFirst = path[0].toString();
    const pathLast = path[path.length - 1].toString();
    if (path.length === 1 && pathFirst === "BTreeMap") {
      if (params.length !== 2) {
        throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);
      }
      return withTypeString(this.registry, {
        info: TypeDefInfo.BTreeMap,
        sub: params.map(({
          type
        }) => _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type.unwrap()))
      });
    } else if (path.length === 1 && pathFirst === "BTreeSet") {
      if (params.length !== 1) {
        throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);
      }
      return withTypeString(this.registry, {
        info: TypeDefInfo.BTreeSet,
        sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())
      });
    } else if (["Range", "RangeInclusive"].includes(pathFirst)) {
      if (params.length !== 1) {
        throw new Error(`Range requires 1 parameter, found ${params.length}`);
      }
      return withTypeString(this.registry, {
        info: pathFirst === "Range" ? TypeDefInfo.Range : TypeDefInfo.RangeInclusive,
        sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
        type: pathFirst
      });
    } else if (["WrapperKeepOpaque", "WrapperOpaque"].includes(pathLast)) {
      if (params.length !== 1) {
        throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);
      }
      return withTypeString(this.registry, {
        info: pathLast === "WrapperKeepOpaque" ? TypeDefInfo.WrapperKeepOpaque : TypeDefInfo.WrapperOpaque,
        sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
        type: pathLast
      });
    }
  }
  return PATHS_SET.some((p) => matchParts(p, path)) ? _classPrivateFieldBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldBase(this, _extractFields)[_extractFields](lookupIndex, fields);
}
function _extractCompositeSet2(_, params, fields) {
  if (params.length !== 1 || fields.length !== 1) {
    throw new Error("Set handling expects param/field as single entries");
  }
  return withTypeString(this.registry, {
    info: TypeDefInfo.Set,
    length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),
    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({
      index,
      name
    }) => ({
      index: index.toNumber(),
      info: TypeDefInfo.Plain,
      name: name.toString(),
      type: "Null"
    }))
  });
}
function _extractFields2(lookupIndex, fields) {
  let isStruct = true;
  let isTuple = true;
  for (let f = 0; f < fields.length; f++) {
    const {
      name
    } = fields[f];
    isStruct = isStruct && name.isSome;
    isTuple = isTuple && name.isNone;
  }
  if (!isTuple && !isStruct) {
    throw new Error("Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)");
  }
  if (fields.length === 0) {
    return {
      info: TypeDefInfo.Null,
      type: "Null"
    };
  } else if (isTuple && fields.length === 1) {
    const typeDef = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](fields[0].type);
    return objectSpread({}, typeDef, lookupIndex === -1 ? null : {
      lookupIndex,
      lookupName: _classPrivateFieldBase(this, _names2)[_names2][lookupIndex],
      lookupNameRoot: typeDef.lookupName
    }, fields[0].typeName.isSome ? {
      typeName: sanitize(fields[0].typeName.unwrap())
    } : null);
  }
  const [sub, alias2] = _classPrivateFieldBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);
  return withTypeString(this.registry, objectSpread({
    info: isTuple ? TypeDefInfo.Tuple : TypeDefInfo.Struct,
    sub
  }, alias2.size ? {
    alias: alias2
  } : null, lookupIndex === -1 ? null : {
    lookupIndex,
    lookupName: _classPrivateFieldBase(this, _names2)[_names2][lookupIndex]
  }));
}
function _extractFieldsAlias2(fields) {
  const alias2 = new Map();
  const sub = new Array(fields.length);
  for (let i = 0; i < fields.length; i++) {
    const {
      docs,
      name,
      type,
      typeName
    } = fields[i];
    const typeDef = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type);
    if (name.isNone) {
      sub[i] = typeDef;
    } else {
      const [nameField, nameOrig] = this.sanitizeField(name);
      if (nameField && nameOrig) {
        alias2.set(nameField, nameOrig);
      }
      sub[i] = objectSpread({
        docs: sanitizeDocs(docs),
        name: nameField
      }, typeDef, typeName.isSome ? {
        typeName: sanitize(typeName.unwrap())
      } : null);
    }
  }
  return [sub, alias2];
}
function _extractHistoric2(_, type) {
  return objectSpread({
    displayName: type.toString(),
    isFromSi: true
  }, getTypeDef(type));
}
function _extractPrimitive2(_, type) {
  const typeStr = type.def.asPrimitive.type.toString();
  return {
    info: TypeDefInfo.Plain,
    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
  };
}
function _extractAliasPath2(_, type) {
  return {
    info: TypeDefInfo.Plain,
    type
  };
}
function _extractSequence2(lookupIndex, {
  type
}) {
  const sub = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type);
  if (sub.type === "u8") {
    return {
      info: TypeDefInfo.Plain,
      type: "Bytes"
    };
  }
  return withTypeString(this.registry, {
    info: TypeDefInfo.Vec,
    lookupIndex,
    lookupName: _classPrivateFieldBase(this, _names2)[_names2][lookupIndex],
    sub
  });
}
function _extractTuple2(lookupIndex, ids) {
  if (ids.length === 0) {
    return {
      info: TypeDefInfo.Null,
      type: "Null"
    };
  } else if (ids.length === 1) {
    return this.getTypeDef(ids[0]);
  }
  const sub = ids.map((t) => _classPrivateFieldBase(this, _createSiDef)[_createSiDef](t));
  return withTypeString(this.registry, {
    info: TypeDefInfo.Tuple,
    lookupIndex,
    lookupName: _classPrivateFieldBase(this, _names2)[_names2][lookupIndex],
    sub
  });
}
function _extractVariant2(lookupIndex, {
  params,
  path
}, {
  variants
}) {
  if (path.length) {
    const specialVariant = path[0].toString();
    if (specialVariant === "Option") {
      if (params.length !== 1) {
        throw new Error(`Option requires 1 parameter, found ${params.length}`);
      }
      return withTypeString(this.registry, {
        info: TypeDefInfo.Option,
        sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())
      });
    } else if (specialVariant === "Result") {
      if (params.length !== 2) {
        throw new Error(`Result requires 2 parameters, found ${params.length}`);
      }
      return withTypeString(this.registry, {
        info: TypeDefInfo.Result,
        sub: params.map(({
          type
        }, index) => objectSpread({
          name: ["Ok", "Error"][index]
        }, _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type.unwrap())))
      });
    }
  }
  if (variants.length === 0) {
    return {
      info: TypeDefInfo.Null,
      type: "Null"
    };
  }
  return _classPrivateFieldBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);
}
function _extractVariantEnum2(lookupIndex, variants) {
  const sub = [];
  variants.slice().sort((a, b) => a.index.cmp(b.index)).forEach(({
    fields,
    index: bnIndex,
    name
  }) => {
    const index = bnIndex.toNumber();
    while (sub.length !== index) {
      sub.push({
        index: sub.length,
        info: TypeDefInfo.Null,
        name: `__Unused${sub.length}`,
        type: "Null"
      });
    }
    sub.push(objectSpread(_classPrivateFieldBase(this, _extractFields)[_extractFields](-1, fields), {
      index,
      name: name.toString()
    }));
  });
  return withTypeString(this.registry, {
    info: TypeDefInfo.Enum,
    lookupIndex,
    lookupName: _classPrivateFieldBase(this, _names2)[_names2][lookupIndex],
    sub
  });
}

// node_modules/@polkadot/types/metadata/PortableRegistry/toV1.js
function convertType(key) {
  return (registry, {
    type
  }) => registry.createType("Si1TypeDef", {
    [key]: {
      type: type.toNumber()
    }
  });
}
var convertCompact = convertType("Compact");
var convertSequence = convertType("Sequence");

// node_modules/@polkadot/types/create/registry.js
var DEFAULT_FIRST_CALL_IDX = new Uint8Array(2);
var l10 = logger("registry");
function sortDecimalStrings(a, b) {
  return parseInt(a, 10) - parseInt(b, 10);
}
function valueToString(v) {
  return v.toString();
}
function getFieldArgs(lookup, fields) {
  const args = new Array(fields.length);
  for (let i = 0; i < fields.length; i++) {
    args[i] = lookup.getTypeDef(fields[i].type).type;
  }
  return args;
}
function clearRecord(record) {
  const keys2 = Object.keys(record);
  for (let i = 0; i < keys2.length; i++) {
    delete record[keys2[i]];
  }
}
function getVariantStringIdx({
  index
}) {
  return index.toString();
}
function injectErrors(_, {
  lookup,
  pallets
}, version, result) {
  clearRecord(result);
  for (let i = 0; i < pallets.length; i++) {
    const {
      errors,
      index,
      name
    } = pallets[i];
    if (errors.isSome) {
      const sectionName = stringCamelCase(name);
      lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, errors.unwrap(), getVariantStringIdx, ({
        docs,
        fields,
        index: index2,
        name: name2
      }) => ({
        args: getFieldArgs(lookup, fields),
        docs: docs.map(valueToString),
        fields,
        index: index2.toNumber(),
        method: name2.toString(),
        name: name2.toString(),
        section: sectionName
      })));
    }
  }
}
function injectEvents(registry, {
  lookup,
  pallets
}, version, result) {
  const filtered = pallets.filter(filterEventsSome);
  clearRecord(result);
  for (let i = 0; i < filtered.length; i++) {
    const {
      events: events2,
      index,
      name
    } = filtered[i];
    lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, events2.unwrap(), getVariantStringIdx, (variant) => {
      const meta = registry.createType("EventMetadataLatest", objectSpread({}, variant, {
        args: getFieldArgs(lookup, variant.fields)
      }));
      return class extends GenericEventData {
        constructor(registry2, value) {
          super(registry2, value, meta, stringCamelCase(name), variant.name.toString());
        }
      };
    }));
  }
}
function injectExtrinsics(registry, {
  lookup,
  pallets
}, version, result, mapping2) {
  const filtered = pallets.filter(filterCallsSome);
  clearRecord(result);
  clearRecord(mapping2);
  for (let i = 0; i < filtered.length; i++) {
    const {
      calls,
      index,
      name
    } = filtered[i];
    const sectionIndex = version >= 12 ? index.toNumber() : i;
    const sectionName = stringCamelCase(name);
    const allCalls = calls.unwrap();
    lazyMethod(result, sectionIndex, () => lazyVariants(lookup, allCalls, getVariantStringIdx, (variant) => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));
    const {
      path
    } = registry.lookup.getSiType(allCalls.type);
    const palletIdx = path.findIndex((v) => v.eq("pallet"));
    if (palletIdx !== -1) {
      const name2 = stringCamelCase(path.slice(0, palletIdx).map((p, i2) => i2 === 0 ? p.replace(/^(frame|pallet)_/, "") : p).join(" "));
      if (!mapping2[name2]) {
        mapping2[name2] = [sectionName];
      } else {
        mapping2[name2].push(sectionName);
      }
    }
  }
}
function extractProperties(registry, metadata) {
  const original = registry.getChainProperties();
  const constants = decorateConstants(registry, metadata.asLatest, metadata.version);
  const ss58Format = constants.system && (constants.system.sS58Prefix || constants.system.ss58Prefix);
  if (!ss58Format) {
    return original;
  }
  const {
    tokenDecimals,
    tokenSymbol
  } = original || {};
  return registry.createTypeUnsafe("ChainProperties", [{
    ss58Format,
    tokenDecimals,
    tokenSymbol
  }]);
}
var _classes, _definitions, _firstCallIndex, _lookup, _metadata2, _metadataVersion, _metadataCalls, _metadataErrors, _metadataEvents, _moduleMap, _unknownTypes, _chainProperties, _hasher, _knownDefaults, _knownDefinitions, _knownTypes, _signedExtensions, _userExtensions;
var TypeRegistry = class {
  constructor(createdAtHash) {
    __privateAdd(this, _classes, new Map());
    __privateAdd(this, _definitions, new Map());
    __privateAdd(this, _firstCallIndex, null);
    __privateAdd(this, _lookup, void 0);
    __privateAdd(this, _metadata2, void 0);
    __privateAdd(this, _metadataVersion, 0);
    __privateAdd(this, _metadataCalls, {});
    __privateAdd(this, _metadataErrors, {});
    __privateAdd(this, _metadataEvents, {});
    __privateAdd(this, _moduleMap, {});
    __privateAdd(this, _unknownTypes, new Map());
    __privateAdd(this, _chainProperties, void 0);
    __privateAdd(this, _hasher, blake2AsU8a);
    __privateAdd(this, _knownDefaults, void 0);
    __privateAdd(this, _knownDefinitions, void 0);
    __privateAdd(this, _knownTypes, {});
    __privateAdd(this, _signedExtensions, fallbackExtensions);
    __privateAdd(this, _userExtensions, void 0);
    __privateSet(this, _knownDefaults, objectSpread({
      Json,
      Metadata,
      PortableRegistry,
      Raw
    }, index_types_exports));
    __privateSet(this, _knownDefinitions, definitions_exports);
    const allKnown = Object.values(__privateGet(this, _knownDefinitions));
    for (let i = 0; i < allKnown.length; i++) {
      this.register(allKnown[i].types);
    }
    if (createdAtHash) {
      this.createdAtHash = this.createType("Hash", createdAtHash);
    }
  }
  get chainDecimals() {
    var _this$chainProperties;
    if ((_this$chainProperties = __privateGet(this, _chainProperties)) != null && _this$chainProperties.tokenDecimals.isSome) {
      const allDecimals = __privateGet(this, _chainProperties).tokenDecimals.unwrap();
      if (allDecimals.length) {
        return allDecimals.map((b) => b.toNumber());
      }
    }
    return [12];
  }
  get chainSS58() {
    var _this$chainProperties2;
    return (_this$chainProperties2 = __privateGet(this, _chainProperties)) != null && _this$chainProperties2.ss58Format.isSome ? __privateGet(this, _chainProperties).ss58Format.unwrap().toNumber() : void 0;
  }
  get chainTokens() {
    var _this$chainProperties3;
    if ((_this$chainProperties3 = __privateGet(this, _chainProperties)) != null && _this$chainProperties3.tokenSymbol.isSome) {
      const allTokens = __privateGet(this, _chainProperties).tokenSymbol.unwrap();
      if (allTokens.length) {
        return allTokens.map(valueToString);
      }
    }
    return [formatBalance.getDefaults().unit];
  }
  get firstCallIndex() {
    return __privateGet(this, _firstCallIndex) || DEFAULT_FIRST_CALL_IDX;
  }
  isLookupType(value) {
    return /Lookup\d+$/.test(value);
  }
  createLookupType(lookupId) {
    return `Lookup${lookupId.toString()}`;
  }
  get knownTypes() {
    return __privateGet(this, _knownTypes);
  }
  get lookup() {
    return assertReturn(__privateGet(this, _lookup), "Lookup has not been set on this registry");
  }
  get metadata() {
    return assertReturn(__privateGet(this, _metadata2), "Metadata has not been set on this registry");
  }
  get unknownTypes() {
    return [...__privateGet(this, _unknownTypes).keys()];
  }
  get signedExtensions() {
    return __privateGet(this, _signedExtensions);
  }
  clearCache() {
    __privateSet(this, _classes, new Map());
  }
  createClass(type) {
    return createClassUnsafe(this, type);
  }
  createClassUnsafe(type) {
    return createClassUnsafe(this, type);
  }
  createType(type, ...params) {
    return createTypeUnsafe(this, type, params);
  }
  createTypeUnsafe(type, params, options) {
    return createTypeUnsafe(this, type, params, options);
  }
  findMetaCall(callIndex) {
    const [section2, method] = [callIndex[0], callIndex[1]];
    return assertReturn(__privateGet(this, _metadataCalls)[`${section2}`] && __privateGet(this, _metadataCalls)[`${section2}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section2}, ${method}]/[${callIndex.toString()}]`);
  }
  findMetaError(errorIndex) {
    const [section2, method] = isU8a(errorIndex) ? [errorIndex[0], errorIndex[1]] : [errorIndex.index.toNumber(), isU8a(errorIndex.error) ? errorIndex.error[0] : errorIndex.error.toNumber()];
    return assertReturn(__privateGet(this, _metadataErrors)[`${section2}`] && __privateGet(this, _metadataErrors)[`${section2}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section2}, ${method}]/[${errorIndex.toString()}]`);
  }
  findMetaEvent(eventIndex) {
    const [section2, method] = [eventIndex[0], eventIndex[1]];
    return assertReturn(__privateGet(this, _metadataEvents)[`${section2}`] && __privateGet(this, _metadataEvents)[`${section2}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section2}, ${method}]/[${eventIndex.toString()}]`);
  }
  get(name, withUnknown, knownTypeDef) {
    return this.getUnsafe(name, withUnknown, knownTypeDef);
  }
  getUnsafe(name, withUnknown, knownTypeDef) {
    let Type2 = __privateGet(this, _classes).get(name) || __privateGet(this, _knownDefaults)[name];
    if (!Type2) {
      const definition = __privateGet(this, _definitions).get(name);
      let BaseType;
      if (definition) {
        BaseType = createClassUnsafe(this, definition);
      } else if (knownTypeDef) {
        BaseType = constructTypeClass(this, knownTypeDef);
      } else if (withUnknown) {
        l10.warn(`Unable to resolve type ${name}, it will fail on construction`);
        __privateGet(this, _unknownTypes).set(name, true);
        BaseType = DoNotConstruct.with(name);
      }
      if (BaseType) {
        Type2 = class extends BaseType {
        };
        __privateGet(this, _classes).set(name, Type2);
        if (knownTypeDef && isNumber(knownTypeDef.lookupIndex)) {
          __privateGet(this, _classes).set(this.createLookupType(knownTypeDef.lookupIndex), Type2);
        }
      }
    }
    return Type2;
  }
  getChainProperties() {
    return __privateGet(this, _chainProperties);
  }
  getClassName(Type2) {
    const names = [];
    for (const [name, Clazz] of Object.entries(__privateGet(this, _knownDefaults))) {
      if (Type2 === Clazz) {
        names.push(name);
      }
    }
    for (const [name, Clazz] of __privateGet(this, _classes).entries()) {
      if (Type2 === Clazz) {
        names.push(name);
      }
    }
    names.sort().reverse();
    return names.length ? names[0] : void 0;
  }
  getDefinition(typeName) {
    return __privateGet(this, _definitions).get(typeName);
  }
  getModuleInstances(specName, moduleName) {
    var _this$knownTypes, _this$knownTypes$type, _this$knownTypes$type2, _this$knownTypes$type3, _this$knownTypes$type4;
    return ((_this$knownTypes = __privateGet(this, _knownTypes)) == null ? void 0 : (_this$knownTypes$type = _this$knownTypes.typesBundle) == null ? void 0 : (_this$knownTypes$type2 = _this$knownTypes$type.spec) == null ? void 0 : (_this$knownTypes$type3 = _this$knownTypes$type2[specName.toString()]) == null ? void 0 : (_this$knownTypes$type4 = _this$knownTypes$type3.instances) == null ? void 0 : _this$knownTypes$type4[moduleName]) || __privateGet(this, _moduleMap)[moduleName];
  }
  getOrThrow(name, msg) {
    const Clazz = this.get(name);
    if (!Clazz) {
      throw new Error(msg || `type ${name} not found`);
    }
    return Clazz;
  }
  getOrUnknown(name) {
    return this.get(name, true);
  }
  getSignedExtensionExtra() {
    return expandExtensionTypes(__privateGet(this, _signedExtensions), "payload", __privateGet(this, _userExtensions));
  }
  getSignedExtensionTypes() {
    return expandExtensionTypes(__privateGet(this, _signedExtensions), "extrinsic", __privateGet(this, _userExtensions));
  }
  hasClass(name) {
    return __privateGet(this, _classes).has(name) || !!__privateGet(this, _knownDefaults)[name];
  }
  hasDef(name) {
    return __privateGet(this, _definitions).has(name);
  }
  hasType(name) {
    return !__privateGet(this, _unknownTypes).get(name) && (this.hasClass(name) || this.hasDef(name));
  }
  hash(data) {
    return this.createType("CodecHash", __privateGet(this, _hasher).call(this, data));
  }
  register(arg1, arg2) {
    if (isFunction(arg1)) {
      __privateGet(this, _classes).set(arg1.name, arg1);
    } else if (isString(arg1)) {
      if (!isFunction(arg2)) {
        throw new Error(`Expected class definition passed to '${arg1}' registration`);
      } else if (arg1 === arg2.toString()) {
        throw new Error(`Unable to register circular ${arg1} === ${arg1}`);
      }
      __privateGet(this, _classes).set(arg1, arg2);
    } else {
      this._registerObject(arg1);
    }
  }
  _registerObject(obj) {
    const entries = Object.entries(obj);
    for (let e = 0; e < entries.length; e++) {
      const [name, type] = entries[e];
      if (isFunction(type)) {
        __privateGet(this, _classes).set(name, type);
      } else {
        const def = isString(type) ? type : stringify(type);
        if (name === def) {
          throw new Error(`Unable to register circular ${name} === ${def}`);
        }
        if (__privateGet(this, _classes).has(name)) {
          __privateGet(this, _classes).delete(name);
        }
        __privateGet(this, _definitions).set(name, def);
      }
    }
  }
  setChainProperties(properties) {
    if (properties) {
      __privateSet(this, _chainProperties, properties);
    }
  }
  setHasher(hasher2) {
    __privateSet(this, _hasher, hasher2 || blake2AsU8a);
  }
  setKnownTypes(knownTypes2) {
    __privateSet(this, _knownTypes, knownTypes2);
  }
  setLookup(lookup) {
    __privateSet(this, _lookup, lookup);
    lookup.register();
  }
  setMetadata(metadata, signedExtensions, userExtensions) {
    __privateSet(this, _metadata2, metadata.asLatest);
    __privateSet(this, _metadataVersion, metadata.version);
    __privateSet(this, _firstCallIndex, null);
    this.setLookup(__privateGet(this, _metadata2).lookup);
    injectExtrinsics(this, __privateGet(this, _metadata2), __privateGet(this, _metadataVersion), __privateGet(this, _metadataCalls), __privateGet(this, _moduleMap));
    injectErrors(this, __privateGet(this, _metadata2), __privateGet(this, _metadataVersion), __privateGet(this, _metadataErrors));
    injectEvents(this, __privateGet(this, _metadata2), __privateGet(this, _metadataVersion), __privateGet(this, _metadataEvents));
    const [defSection] = Object.keys(__privateGet(this, _metadataCalls)).sort(sortDecimalStrings);
    if (defSection) {
      const [defMethod] = Object.keys(__privateGet(this, _metadataCalls)[defSection]).sort(sortDecimalStrings);
      if (defMethod) {
        __privateSet(this, _firstCallIndex, new Uint8Array([parseInt(defSection, 10), parseInt(defMethod, 10)]));
      }
    }
    this.setSignedExtensions(signedExtensions || (__privateGet(this, _metadata2).extrinsic.version.gt(BN_ZERO) ? __privateGet(this, _metadata2).extrinsic.signedExtensions.map(({
      identifier
    }) => identifier.toString()) : fallbackExtensions), userExtensions);
    this.setChainProperties(extractProperties(this, metadata));
  }
  setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions) {
    __privateSet(this, _signedExtensions, signedExtensions);
    __privateSet(this, _userExtensions, userExtensions);
    const unknown = findUnknownExtensions(__privateGet(this, _signedExtensions), __privateGet(this, _userExtensions));
    if (unknown.length) {
      l10.warn(`Unknown signed extensions ${unknown.join(", ")} found, treating them as no-effect`);
    }
  }
};
_classes = new WeakMap();
_definitions = new WeakMap();
_firstCallIndex = new WeakMap();
_lookup = new WeakMap();
_metadata2 = new WeakMap();
_metadataVersion = new WeakMap();
_metadataCalls = new WeakMap();
_metadataErrors = new WeakMap();
_metadataEvents = new WeakMap();
_moduleMap = new WeakMap();
_unknownTypes = new WeakMap();
_chainProperties = new WeakMap();
_hasher = new WeakMap();
_knownDefaults = new WeakMap();
_knownDefinitions = new WeakMap();
_knownTypes = new WeakMap();
_signedExtensions = new WeakMap();
_userExtensions = new WeakMap();

// node_modules/@polkadot/rpc-core/util/refCountDelay.js
function refCountDelay(delay2 = 1750) {
  return (source) => {
    let [state2, refCount2, connection, scheduler] = [0, 0, Subscription.EMPTY, Subscription.EMPTY];
    return new Observable((ob) => {
      source.subscribe(ob);
      if (refCount2++ === 0) {
        if (state2 === 1) {
          scheduler.unsubscribe();
        } else {
          connection = source.connect();
        }
        state2 = 3;
      }
      return () => {
        if (--refCount2 === 0) {
          if (state2 === 2) {
            state2 = 0;
            scheduler.unsubscribe();
          } else {
            state2 = 1;
            scheduler = asapScheduler.schedule(() => {
              state2 = 0;
              connection.unsubscribe();
            }, delay2);
          }
        }
      };
    });
  };
}

// node_modules/@polkadot/rpc-core/util/drr.js
function CMP(a, b) {
  return stringify({
    t: a
  }) === stringify({
    t: b
  });
}
function ERR(error) {
  throw error;
}
function NOOP() {
}
function drr({
  delay: delay2,
  skipChange = false,
  skipTimeout = false
} = {}) {
  return (source$) => source$.pipe(catchError(ERR), skipChange ? tap(NOOP) : distinctUntilChanged(CMP), publishReplay(1), skipTimeout ? refCount() : refCountDelay(delay2));
}

// node_modules/@polkadot/rpc-core/util/memo.js
function memo(instanceId, inner) {
  const options = {
    getInstanceId: () => instanceId
  };
  const cached = memoize((...params) => new Observable((observer) => {
    const subscription = inner(...params).subscribe(observer);
    return () => {
      cached.unmemoize(...params);
      subscription.unsubscribe();
    };
  }).pipe(drr()), options);
  return cached;
}

// node_modules/@polkadot/rpc-core/bundle.js
var l11 = logger("rpc-core");
var EMPTY_META = {
  fallback: void 0,
  modifier: {
    isOptional: true
  },
  type: {
    asMap: {
      linked: {
        isTrue: false
      }
    },
    isMap: false
  }
};
function logErrorMessage(method, {
  noErrorLog,
  params,
  type
}, error) {
  if (noErrorLog) {
    return;
  }
  const inputs = params.map(({
    isOptional,
    name,
    type: type2
  }) => `${name}${isOptional ? "?" : ""}: ${type2}`).join(", ");
  l11.error(`${method}(${inputs}): ${type}:: ${error.message}`);
}
function isTreatAsHex(key) {
  return ["0x3a636f6465"].includes(key.toHex());
}
var _instanceId, _registryDefault, _getBlockRegistry, _getBlockHash, _storageCache;
var RpcCore = class {
  constructor(instanceId, registry, provider, userRpc = {}) {
    __privateAdd(this, _instanceId, void 0);
    __privateAdd(this, _registryDefault, void 0);
    __privateAdd(this, _getBlockRegistry, void 0);
    __privateAdd(this, _getBlockHash, void 0);
    __privateAdd(this, _storageCache, new Map());
    __publicField(this, "mapping", new Map());
    __publicField(this, "sections", []);
    if (!provider || !isFunction(provider.send)) {
      throw new Error("Expected Provider to API create");
    }
    __privateSet(this, _instanceId, instanceId);
    __privateSet(this, _registryDefault, registry);
    this.provider = provider;
    const sectionNames = Object.keys(jsonrpc_default);
    this.sections.push(...sectionNames);
    this.addUserInterfaces(userRpc);
  }
  get isConnected() {
    return this.provider.isConnected;
  }
  connect() {
    return this.provider.connect();
  }
  disconnect() {
    return this.provider.disconnect();
  }
  setRegistrySwap(registrySwap) {
    __privateSet(this, _getBlockRegistry, memoize(registrySwap, {
      getInstanceId: () => __privateGet(this, _instanceId)
    }));
  }
  setResolveBlockHash(resolveBlockHash) {
    __privateSet(this, _getBlockHash, memoize(resolveBlockHash, {
      getInstanceId: () => __privateGet(this, _instanceId)
    }));
  }
  addUserInterfaces(userRpc) {
    this.sections.push(...Object.keys(userRpc).filter((k) => !this.sections.includes(k)));
    for (let s = 0; s < this.sections.length; s++) {
      const section2 = this.sections[s];
      const defs = objectSpread({}, jsonrpc_default[section2], userRpc[section2]);
      const methods = Object.keys(defs);
      for (let m = 0; m < methods.length; m++) {
        const method = methods[m];
        const def = defs[method];
        const jsonrpc2 = def.endpoint || `${section2}_${method}`;
        if (!this.mapping.has(jsonrpc2)) {
          const isSubscription2 = !!def.pubsub;
          if (!this[section2]) {
            this[section2] = {};
          }
          this.mapping.set(jsonrpc2, objectSpread({}, def, {
            isSubscription: isSubscription2,
            jsonrpc: jsonrpc2,
            method,
            section: section2
          }));
          lazyMethod(this[section2], method, () => isSubscription2 ? this._createMethodSubscribe(section2, method, def) : this._createMethodSend(section2, method, def));
        }
      }
    }
  }
  _memomize(creator, def) {
    const memoOpts = {
      getInstanceId: () => __privateGet(this, _instanceId)
    };
    const memoized = memoize(creator(true), memoOpts);
    memoized.raw = memoize(creator(false), memoOpts);
    memoized.meta = def;
    return memoized;
  }
  _formatResult(isScale, registry, blockHash, method, def, params, result) {
    return isScale ? this._formatOutput(registry, blockHash, method, def, params, result) : result;
  }
  _createMethodSend(section2, method, def) {
    const rpcName = def.endpoint || `${section2}_${method}`;
    const hashIndex = def.params.findIndex(({
      isHistoric
    }) => isHistoric);
    let memoized = null;
    const callWithRegistry = async (isScale, values) => {
      var _this$getBlockHash;
      const blockId = hashIndex === -1 ? null : values[hashIndex];
      const blockHash = blockId && def.params[hashIndex].type === "BlockNumber" ? await ((_this$getBlockHash = __privateGet(this, _getBlockHash)) == null ? void 0 : _this$getBlockHash.call(this, blockId)) : blockId;
      const {
        registry
      } = isScale && blockHash && __privateGet(this, _getBlockRegistry) ? await __privateGet(this, _getBlockRegistry).call(this, u8aToU8a(blockHash)) : {
        registry: __privateGet(this, _registryDefault)
      };
      const params = this._formatInputs(registry, null, def, values);
      const result = await this.provider.send(rpcName, params.map((p) => p.toJSON()), !!blockHash);
      return this._formatResult(isScale, registry, blockHash, method, def, params, result);
    };
    const creator = (isScale) => (...values) => {
      const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];
      return new Observable((observer) => {
        callWithRegistry(isScale, values).then((value) => {
          observer.next(value);
          observer.complete();
        }).catch((error) => {
          logErrorMessage(method, def, error);
          observer.error(error);
          observer.complete();
        });
        return () => {
          if (isScale) {
            var _memoized;
            (_memoized = memoized) == null ? void 0 : _memoized.unmemoize(...values);
          } else {
            var _memoized2;
            (_memoized2 = memoized) == null ? void 0 : _memoized2.raw.unmemoize(...values);
          }
        };
      }).pipe(publishReplay(1), isDelayed ? refCountDelay() : refCount());
    };
    memoized = this._memomize(creator, def);
    return memoized;
  }
  _createSubscriber({
    paramsJson,
    subName,
    subType,
    update
  }, errorHandler) {
    return new Promise((resolve, reject) => {
      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch((error) => {
        errorHandler(error);
        reject(error);
      });
    });
  }
  _createMethodSubscribe(section2, method, def) {
    const [updateType, subMethod, unsubMethod] = def.pubsub;
    const subName = `${section2}_${subMethod}`;
    const unsubName = `${section2}_${unsubMethod}`;
    const subType = `${section2}_${updateType}`;
    let memoized = null;
    const creator = (isScale) => (...values) => {
      return new Observable((observer) => {
        let subscriptionPromise = Promise.resolve(null);
        const registry = __privateGet(this, _registryDefault);
        const errorHandler = (error) => {
          logErrorMessage(method, def, error);
          observer.error(error);
        };
        try {
          const params = this._formatInputs(registry, null, def, values);
          const paramsJson = params.map((p) => p.toJSON());
          const update = (error, result) => {
            if (error) {
              logErrorMessage(method, def, error);
              return;
            }
            try {
              observer.next(this._formatResult(isScale, registry, null, method, def, params, result));
            } catch (error2) {
              observer.error(error2);
            }
          };
          subscriptionPromise = this._createSubscriber({
            paramsJson,
            subName,
            subType,
            update
          }, errorHandler);
        } catch (error) {
          errorHandler(error);
        }
        return () => {
          if (isScale) {
            var _memoized3;
            (_memoized3 = memoized) == null ? void 0 : _memoized3.unmemoize(...values);
          } else {
            var _memoized4;
            (_memoized4 = memoized) == null ? void 0 : _memoized4.raw.unmemoize(...values);
          }
          subscriptionPromise.then((subscriptionId) => isNull(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch((error) => logErrorMessage(method, def, error));
        };
      }).pipe(drr());
    };
    memoized = this._memomize(creator, def);
    return memoized;
  }
  _formatInputs(registry, blockHash, def, inputs) {
    const reqArgCount = def.params.filter(({
      isOptional
    }) => !isOptional).length;
    const optText = reqArgCount === def.params.length ? "" : ` (${def.params.length - reqArgCount} optional)`;
    if (inputs.length < reqArgCount || inputs.length > def.params.length) {
      throw new Error(`Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);
    }
    return inputs.map((input, index) => registry.createTypeUnsafe(def.params[index].type, [input], {
      blockHash
    }));
  }
  _formatOutput(registry, blockHash, method, rpc18, params, result) {
    if (rpc18.type === "StorageData") {
      const key = params[0];
      return this._formatStorageData(registry, blockHash, key, result);
    } else if (rpc18.type === "StorageChangeSet") {
      const keys2 = params[0];
      return keys2 ? this._formatStorageSet(registry, result.block, keys2, result.changes) : registry.createType("StorageChangeSet", result);
    } else if (rpc18.type === "Vec<StorageChangeSet>") {
      const mapped = result.map(({
        block,
        changes
      }) => [registry.createType("Hash", block), this._formatStorageSet(registry, block, params[0], changes)]);
      return method === "queryStorageAt" ? mapped[0][1] : mapped;
    }
    return registry.createTypeUnsafe(rpc18.type, [result], {
      blockHash
    });
  }
  _formatStorageData(registry, blockHash, key, value) {
    const isEmpty2 = isNull(value);
    const input = isEmpty2 ? null : isTreatAsHex(key) ? value : u8aToU8a(value);
    return this._newType(registry, blockHash, key, input, isEmpty2);
  }
  _formatStorageSet(registry, blockHash, keys2, changes) {
    const withCache = keys2.length !== 1;
    return keys2.reduce((results, key, index) => {
      results.push(this._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));
      return results;
    }, []);
  }
  _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {
    const hexKey = key.toHex();
    const found = changes.find(([key2]) => key2 === hexKey);
    const isNotFound = isUndefined(found);
    if (isNotFound && withCache) {
      const cached = __privateGet(this, _storageCache).get(hexKey);
      if (cached) {
        return cached;
      }
    }
    const value = isNotFound ? null : found[1];
    const isEmpty2 = isNull(value);
    const input = isEmpty2 || isTreatAsHex(key) ? value : u8aToU8a(value);
    const codec = this._newType(registry, blockHash, key, input, isEmpty2, entryIndex);
    __privateGet(this, _storageCache).set(hexKey, codec);
    return codec;
  }
  _newType(registry, blockHash, key, input, isEmpty2, entryIndex = -1) {
    const type = key.outputType || "Raw";
    const meta = key.meta || EMPTY_META;
    const entryNum = entryIndex === -1 ? "" : ` entry ${entryIndex}:`;
    try {
      return registry.createTypeUnsafe(type, [isEmpty2 ? meta.fallback ? type.includes("Linkage<") ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2)) : hexToU8a(meta.fallback.toHex()) : void 0 : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], {
        blockHash,
        isPedantic: true
      }) : input], {
        blockHash,
        isOptional: meta.modifier.isOptional,
        isPedantic: !meta.modifier.isOptional
      });
    } catch (error) {
      throw new Error(`Unable to decode storage ${key.section || "unknown"}.${key.method || "unknown"}:${entryNum}: ${error.message}`);
    }
  }
};
_instanceId = new WeakMap();
_registryDefault = new WeakMap();
_getBlockRegistry = new WeakMap();
_getBlockHash = new WeakMap();
_storageCache = new WeakMap();

// node_modules/@polkadot/api-derive/util/blockNumber.js
function unwrapBlockNumber(hdr) {
  return isCompact(hdr.number) ? hdr.number.unwrap() : hdr.number;
}

// node_modules/@polkadot/api-derive/util/cacheImpl.js
var mapCache = new Map();
var deriveNoopCache = {
  del: () => void 0,
  forEach: () => void 0,
  get: () => void 0,
  set: (_, value) => value
};

// node_modules/@polkadot/api-derive/util/cache.js
var CHACHE_EXPIRY = 7 * (24 * 60) * (60 * 1e3);
var deriveCache;
function wrapCache(keyStart, cache) {
  return {
    del: (partial) => cache.del(`${keyStart}${partial}`),
    forEach: cache.forEach,
    get: (partial) => {
      const key = `${keyStart}${partial}`;
      const cached = cache.get(key);
      if (cached) {
        cached.x = Date.now();
        cache.set(key, cached);
        return cached.v;
      }
      return void 0;
    },
    set: (partial, v) => {
      cache.set(`${keyStart}${partial}`, {
        v,
        x: Date.now()
      });
    }
  };
}
function clearCache(cache) {
  const now = Date.now();
  const all3 = [];
  cache.forEach((key, {
    x
  }) => {
    now - x > CHACHE_EXPIRY && all3.push(key);
  });
  all3.forEach((key) => cache.del(key));
}
function setDeriveCache(prefix2 = "", cache) {
  deriveCache = cache ? wrapCache(`derive:${prefix2}:`, cache) : deriveNoopCache;
  if (cache) {
    clearCache(cache);
  }
}
setDeriveCache();

// node_modules/@polkadot/api-derive/util/first.js
function firstObservable(obs) {
  return obs.pipe(map2(([a]) => a));
}
function firstMemo(fn) {
  return (instanceId, api) => memo(instanceId, (...args) => firstObservable(fn(api, ...args)));
}

// node_modules/@polkadot/api-derive/util/lazy.js
function lazyDeriveSection(result, section2, getKeys2, creator) {
  lazyMethod(result, section2, () => lazyMethods({}, getKeys2(section2), (method) => creator(section2, method)));
}

// node_modules/@polkadot/api-derive/accounts/accountId.js
function accountId(instanceId, api) {
  return memo(instanceId, (address) => {
    const decoded = isU8a(address) ? address : decodeAddress((address || "").toString());
    if (decoded.length > 8) {
      return of(api.registry.createType("AccountId", decoded));
    }
    const accountIndex = api.registry.createType("AccountIndex", decoded);
    return api.derive.accounts.indexToId(accountIndex.toString()).pipe(map2((a) => assertReturn(a, "Unable to retrieve accountId")));
  });
}

// node_modules/@polkadot/api-derive/accounts/flags.js
function parseFlags(address, [electionsMembers, councilMembers, technicalCommitteeMembers, societyMembers, sudoKey]) {
  const addrStr = address && address.toString();
  const isIncluded = (id2) => id2.toString() === addrStr;
  return {
    isCouncil: ((electionsMembers == null ? void 0 : electionsMembers.map((r) => Array.isArray(r) ? r[0] : r.who)) || councilMembers || []).some(isIncluded),
    isSociety: (societyMembers || []).some(isIncluded),
    isSudo: (sudoKey == null ? void 0 : sudoKey.toString()) === addrStr,
    isTechCommittee: (technicalCommitteeMembers || []).some(isIncluded)
  };
}
function _flags(instanceId, api) {
  return memo(instanceId, () => {
    var _ref, _api$query$council, _api$query$technicalC, _api$query$society, _api$query$sudo;
    const results = [void 0, [], [], [], void 0];
    const calls = [(_ref = api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections) == null ? void 0 : _ref.members, (_api$query$council = api.query.council) == null ? void 0 : _api$query$council.members, (_api$query$technicalC = api.query.technicalCommittee) == null ? void 0 : _api$query$technicalC.members, (_api$query$society = api.query.society) == null ? void 0 : _api$query$society.members, (_api$query$sudo = api.query.sudo) == null ? void 0 : _api$query$sudo.key];
    const filtered = calls.filter((c) => c);
    if (!filtered.length) {
      return of(results);
    }
    return api.queryMulti(filtered).pipe(map2((values) => {
      let resultIndex = -1;
      for (let i = 0; i < calls.length; i++) {
        if (isFunction(calls[i])) {
          results[i] = values[++resultIndex];
        }
      }
      return results;
    }));
  });
}
function flags(instanceId, api) {
  return memo(instanceId, (address) => api.derive.accounts._flags().pipe(map2((r) => parseFlags(address, r))));
}

// node_modules/@polkadot/api-derive/accounts/idAndIndex.js
function idAndIndex(instanceId, api) {
  return memo(instanceId, (address) => {
    try {
      const decoded = isU8a(address) ? address : decodeAddress((address || "").toString());
      if (decoded.length > 8) {
        const accountId2 = api.registry.createType("AccountId", decoded);
        return api.derive.accounts.idToIndex(accountId2).pipe(map2((accountIndex2) => [accountId2, accountIndex2]));
      }
      const accountIndex = api.registry.createType("AccountIndex", decoded);
      return api.derive.accounts.indexToId(accountIndex.toString()).pipe(map2((accountId2) => [accountId2, accountIndex]));
    } catch (error) {
      return of([void 0, void 0]);
    }
  });
}

// node_modules/@polkadot/api-derive/accounts/idToIndex.js
function idToIndex(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.accounts.indexes().pipe(map2((indexes3) => (indexes3 || {})[accountId2.toString()])));
}

// node_modules/@polkadot/api-derive/accounts/identity.js
var UNDEF_HEX = {
  toHex: () => void 0
};
function dataAsString(data) {
  return data.isRaw ? u8aToString(data.asRaw.toU8a(true)) : data.isNone ? void 0 : data.toHex();
}
function extractOther(additional) {
  return additional.reduce((other, [_key, _value]) => {
    const key = dataAsString(_key);
    const value = dataAsString(_value);
    if (key && value) {
      other[key] = value;
    }
    return other;
  }, {});
}
function extractIdentity(identityOfOpt, superOf) {
  if (!(identityOfOpt != null && identityOfOpt.isSome)) {
    return {
      judgements: []
    };
  }
  const {
    info: info6,
    judgements
  } = identityOfOpt.unwrap();
  const topDisplay = dataAsString(info6.display);
  return {
    display: superOf && dataAsString(superOf[1]) || topDisplay,
    displayParent: superOf && topDisplay,
    email: dataAsString(info6.email),
    image: dataAsString(info6.image),
    judgements,
    legal: dataAsString(info6.legal),
    other: extractOther(info6.additional),
    parent: superOf && superOf[0],
    pgp: info6.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),
    riot: dataAsString(info6.riot),
    twitter: dataAsString(info6.twitter),
    web: dataAsString(info6.web)
  };
}
function getParent(api, identityOfOpt, superOfOpt) {
  if (identityOfOpt != null && identityOfOpt.isSome) {
    return of([identityOfOpt, void 0]);
  } else if (superOfOpt != null && superOfOpt.isSome) {
    const superOf = superOfOpt.unwrap();
    return combineLatest([api.derive.accounts._identity(superOf[0]).pipe(map2(([info6]) => info6)), of(superOf)]);
  }
  return of([void 0, void 0]);
}
function _identity(instanceId, api) {
  return memo(instanceId, (accountId2) => {
    var _api$query$identity;
    return accountId2 && (_api$query$identity = api.query.identity) != null && _api$query$identity.identityOf ? combineLatest([api.query.identity.identityOf(accountId2), api.query.identity.superOf(accountId2)]) : of([void 0, void 0]);
  });
}
function identity2(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.accounts._identity(accountId2).pipe(switchMap(([identityOfOpt, superOfOpt]) => getParent(api, identityOfOpt, superOfOpt)), map2(([identityOfOpt, superOf]) => extractIdentity(identityOfOpt, superOf))));
}
var hasIdentity = firstMemo((api, accountId2) => api.derive.accounts.hasIdentityMulti([accountId2]));
function hasIdentityMulti(instanceId, api) {
  return memo(instanceId, (accountIds) => {
    var _api$query$identity2;
    return (_api$query$identity2 = api.query.identity) != null && _api$query$identity2.identityOf ? combineLatest([api.query.identity.identityOf.multi(accountIds), api.query.identity.superOf.multi(accountIds)]).pipe(map2(([identities, supers]) => identities.map((identityOfOpt, index) => {
      const superOfOpt = supers[index];
      const parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : void 0;
      let display;
      if (identityOfOpt && identityOfOpt.isSome) {
        const value = dataAsString(identityOfOpt.unwrap().info.display);
        if (value && !isHex(value)) {
          display = value;
        }
      }
      return {
        display,
        hasIdentity: !!(display || parentId),
        parentId
      };
    }))) : of(accountIds.map(() => ({
      hasIdentity: false
    })));
  });
}

// node_modules/@polkadot/api-derive/accounts/indexToId.js
function indexToId(instanceId, api) {
  return memo(instanceId, (accountIndex) => api.query.indices ? api.query.indices.accounts(accountIndex).pipe(map2((optResult) => optResult.unwrapOr([])[0])) : of(void 0));
}

// node_modules/@polkadot/api-derive/accounts/indexes.js
var indicesCache = null;
function queryAccounts(api) {
  return api.query.indices.accounts.entries().pipe(map2((entries) => entries.reduce((indexes3, [key, idOpt]) => {
    if (idOpt.isSome) {
      indexes3[idOpt.unwrap()[0].toString()] = api.registry.createType("AccountIndex", key.args[0]);
    }
    return indexes3;
  }, {})));
}
function indexes(instanceId, api) {
  return memo(instanceId, () => indicesCache ? of(indicesCache) : (api.query.indices ? queryAccounts(api).pipe(startWith({})) : of({})).pipe(map2((indices) => {
    indicesCache = indices;
    return indices;
  })));
}

// node_modules/@polkadot/api-derive/accounts/info.js
function retrieveNick(api, accountId2) {
  var _api$query$nicks;
  return (accountId2 && (_api$query$nicks = api.query.nicks) != null && _api$query$nicks.nameOf ? api.query.nicks.nameOf(accountId2) : of(void 0)).pipe(map2((nameOf) => nameOf != null && nameOf.isSome ? u8aToString(nameOf.unwrap()[0]).substring(0, api.consts.nicks.maxLength.toNumber()) : void 0));
}
function info(instanceId, api) {
  return memo(instanceId, (address) => api.derive.accounts.idAndIndex(address).pipe(switchMap(([accountId2, accountIndex]) => combineLatest([of({
    accountId: accountId2,
    accountIndex
  }), api.derive.accounts.identity(accountId2), retrieveNick(api, accountId2)])), map2(([{
    accountId: accountId2,
    accountIndex
  }, identity4, nickname]) => ({
    accountId: accountId2,
    accountIndex,
    identity: identity4,
    nickname
  }))));
}

// node_modules/@polkadot/api-derive/alliance/index.js
var alliance_exports = {};
__export(alliance_exports, {
  hasProposals: () => hasProposals2,
  members: () => members2,
  prime: () => prime2,
  proposal: () => proposal2,
  proposalCount: () => proposalCount2,
  proposalHashes: () => proposalHashes2,
  proposals: () => proposals2
});

// node_modules/@polkadot/api-derive/collective/helpers.js
function getInstance(api, section2) {
  const instances = api.registry.getModuleInstances(api.runtimeVersion.specName, section2);
  const name = instances && instances.length ? instances[0] : section2;
  return api.query[name];
}
function withSection(section2, fn) {
  return (instanceId, api) => memo(instanceId, fn(getInstance(api, section2), api, instanceId));
}
function callMethod(method, empty3) {
  return (section2) => withSection(section2, (query2) => () => isFunction(query2 == null ? void 0 : query2[method]) ? query2[method]() : of(empty3));
}

// node_modules/@polkadot/api-derive/collective/members.js
var members = callMethod("members", []);

// node_modules/@polkadot/api-derive/collective/prime.js
function prime(section2) {
  return withSection(section2, (query2) => () => isFunction(query2 == null ? void 0 : query2.prime) ? query2.prime().pipe(map2((o) => o.unwrapOr(null))) : of(null));
}

// node_modules/@polkadot/api-derive/collective/proposals.js
function parse(api, [hashes, proposals8, votes2]) {
  return proposals8.map((o, index) => ({
    hash: api.registry.createType("Hash", hashes[index]),
    proposal: o && o.isSome ? o.unwrap() : null,
    votes: votes2[index].unwrapOr(null)
  }));
}
function _proposalsFrom(api, query2, hashes) {
  return (isFunction(query2 == null ? void 0 : query2.proposals) && hashes.length ? combineLatest([
    of(hashes),
    query2.proposalOf.multi(hashes).pipe(catchError(() => of(hashes.map(() => null)))),
    query2.voting.multi(hashes)
  ]) : of([[], [], []])).pipe(map2((r) => parse(api, r)));
}
function hasProposals(section2) {
  return withSection(section2, (query2) => () => of(isFunction(query2 == null ? void 0 : query2.proposals)));
}
function proposals(section2) {
  return withSection(section2, (query2, api) => () => api.derive[section2].proposalHashes().pipe(switchMap((all3) => _proposalsFrom(api, query2, all3))));
}
function proposal(section2) {
  return withSection(section2, (query2, api) => (hash2) => isFunction(query2 == null ? void 0 : query2.proposals) ? firstObservable(_proposalsFrom(api, query2, [hash2])) : of(null));
}
var proposalCount = callMethod("proposalCount", null);
var proposalHashes = callMethod("proposals", []);

// node_modules/@polkadot/api-derive/alliance/index.js
var members2 = members("allianceMotion");
var hasProposals2 = hasProposals("allianceMotion");
var proposal2 = proposal("allianceMotion");
var proposalCount2 = proposalCount("allianceMotion");
var proposalHashes2 = proposalHashes("allianceMotion");
var proposals2 = proposals("allianceMotion");
var prime2 = prime("allianceMotion");

// node_modules/@polkadot/api-derive/bagsList/index.js
var bagsList_exports = {};
__export(bagsList_exports, {
  _getIds: () => _getIds,
  all: () => all,
  expand: () => expand2,
  get: () => get,
  getExpanded: () => getExpanded,
  listNodes: () => listNodes
});

// node_modules/@polkadot/api-derive/bagsList/util.js
function getQueryInterface(api) {
  return api.query.voterBagsList || api.query.bagsList || api.query.voterList;
}

// node_modules/@polkadot/api-derive/bagsList/get.js
function orderBags(ids, bags) {
  const sorted = ids.map((id2, index) => ({
    bag: bags[index].unwrapOr(null),
    id: id2,
    key: id2.toString()
  })).sort((a, b) => b.id.cmp(a.id));
  const max3 = sorted.length - 1;
  return sorted.map((entry, index) => objectSpread(entry, {
    bagLower: index === max3 ? BN_ZERO : sorted[index + 1].id,
    bagUpper: entry.id,
    index
  }));
}
function _getIds(instanceId, api) {
  const query2 = getQueryInterface(api);
  return memo(instanceId, (_ids) => {
    const ids = _ids.map((id2) => bnToBn(id2));
    return ids.length ? query2.listBags.multi(ids).pipe(map2((bags) => orderBags(ids, bags))) : of([]);
  });
}
function all(instanceId, api) {
  const query2 = getQueryInterface(api);
  return memo(instanceId, () => query2.listBags.keys().pipe(switchMap((keys2) => api.derive.bagsList._getIds(keys2.map(({
    args: [id2]
  }) => id2))), map2((list) => list.filter(({
    bag
  }) => bag))));
}
function get(instanceId, api) {
  return memo(instanceId, (id2) => api.derive.bagsList._getIds([bnToBn(id2)]).pipe(map2((bags) => bags[0])));
}

// node_modules/@polkadot/api-derive/bagsList/getExpanded.js
function expand2(instanceId, api) {
  return memo(instanceId, (bag) => api.derive.bagsList.listNodes(bag.bag).pipe(map2((nodes) => objectSpread({
    nodes
  }, bag))));
}
function getExpanded(instanceId, api) {
  return memo(instanceId, (id2) => api.derive.bagsList.get(id2).pipe(switchMap((bag) => api.derive.bagsList.expand(bag))));
}

// node_modules/@polkadot/api-derive/bagsList/listNodes.js
function traverseLinks(api, head) {
  const subject = new BehaviorSubject(head);
  const query2 = getQueryInterface(api);
  return subject.pipe(switchMap((account3) => query2.listNodes(account3)), tap((node) => {
    nextTick(() => {
      node.isSome && node.value.next.isSome ? subject.next(node.unwrap().next.unwrap()) : subject.complete();
    });
  }), toArray(), map2((all3) => all3.map((o) => o.unwrap())));
}
function listNodes(instanceId, api) {
  return memo(instanceId, (bag) => bag && bag.head.isSome ? traverseLinks(api, bag.head.unwrap()) : of([]));
}

// node_modules/@polkadot/api-derive/balances/index.js
var balances_exports = {};
__export(balances_exports, {
  account: () => account,
  all: () => all2,
  votingBalance: () => votingBalance,
  votingBalances: () => votingBalances
});

// node_modules/@polkadot/api-derive/balances/all.js
var VESTING_ID = "0x76657374696e6720";
function calcLocked(api, bestNumber2, locks2) {
  let lockedBalance = api.registry.createType("Balance");
  let lockedBreakdown = [];
  let vestingLocked = api.registry.createType("Balance");
  let allLocked = false;
  if (Array.isArray(locks2)) {
    lockedBreakdown = locks2.filter(({
      until
    }) => !until || bestNumber2 && until.gt(bestNumber2));
    allLocked = lockedBreakdown.some(({
      amount
    }) => amount && amount.isMax());
    vestingLocked = api.registry.createType("Balance", lockedBreakdown.filter(({
      id: id2
    }) => id2.eq(VESTING_ID)).reduce((result, {
      amount
    }) => result.iadd(amount), new import_bn.default(0)));
    const notAll = lockedBreakdown.filter(({
      amount
    }) => amount && !amount.isMax());
    if (notAll.length) {
      lockedBalance = api.registry.createType("Balance", bnMax(...notAll.map(({
        amount
      }) => amount)));
    }
  }
  return {
    allLocked,
    lockedBalance,
    lockedBreakdown,
    vestingLocked
  };
}
function calcShared(api, bestNumber2, data, locks2) {
  const {
    allLocked,
    lockedBalance,
    lockedBreakdown,
    vestingLocked
  } = calcLocked(api, bestNumber2, locks2);
  return objectSpread({}, data, {
    availableBalance: api.registry.createType("Balance", allLocked ? 0 : bnMax(new import_bn.default(0), data.freeBalance.sub(lockedBalance))),
    lockedBalance,
    lockedBreakdown,
    vestingLocked
  });
}
function calcVesting(bestNumber2, shared, _vesting) {
  const vesting = _vesting || [];
  const isVesting = !shared.vestingLocked.isZero();
  const vestedBalances = vesting.map(({
    locked,
    perBlock,
    startingBlock
  }) => bestNumber2.gt(startingBlock) ? bnMin(locked, perBlock.mul(bestNumber2.sub(startingBlock))) : BN_ZERO);
  const vestedBalance = vestedBalances.reduce((all3, value) => all3.iadd(value), new import_bn.default(0));
  const vestingTotal = vesting.reduce((all3, {
    locked
  }) => all3.iadd(locked), new import_bn.default(0));
  return {
    isVesting,
    vestedBalance,
    vestedClaimable: isVesting ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance)) : BN_ZERO,
    vesting: vesting.map(({
      locked,
      perBlock,
      startingBlock
    }, index) => ({
      endBlock: locked.div(perBlock).iadd(startingBlock),
      locked,
      perBlock,
      startingBlock,
      vested: vestedBalances[index]
    })).filter(({
      locked
    }) => !locked.isZero()),
    vestingTotal
  };
}
function calcBalances(api, [data, [vesting, allLocks, namedReserves], bestNumber2]) {
  const shared = calcShared(api, bestNumber2, data, allLocks[0]);
  return objectSpread(shared, calcVesting(bestNumber2, shared, vesting), {
    accountId: data.accountId,
    accountNonce: data.accountNonce,
    additional: allLocks.slice(1).map((l16, index) => calcShared(api, bestNumber2, data.additional[index], l16)),
    namedReserves
  });
}
function queryOld(api, accountId2) {
  return combineLatest([api.query.balances.locks(accountId2), api.query.balances.vesting(accountId2)]).pipe(map2(([locks2, optVesting]) => {
    let vestingNew = null;
    if (optVesting.isSome) {
      const {
        offset: locked,
        perBlock,
        startingBlock
      } = optVesting.unwrap();
      vestingNew = api.registry.createType("VestingInfo", {
        locked,
        perBlock,
        startingBlock
      });
    }
    return [vestingNew ? [vestingNew] : null, [locks2], []];
  }));
}
var isNonNullable = (nullable) => !!nullable;
function createCalls(calls) {
  return [calls.map((c) => !c), calls.filter(isNonNullable)];
}
function queryCurrent(api, accountId2, balanceInstances = ["balances"]) {
  var _api$query$vesting;
  const [lockEmpty, lockQueries] = createCalls(balanceInstances.map((m) => {
    var _m, _api$query;
    return ((_m = api.derive[m]) == null ? void 0 : _m.customLocks) || ((_api$query = api.query[m]) == null ? void 0 : _api$query.locks);
  }));
  const [reserveEmpty, reserveQueries] = createCalls(balanceInstances.map((m) => {
    var _api$query2;
    return (_api$query2 = api.query[m]) == null ? void 0 : _api$query2.reserves;
  }));
  return combineLatest([(_api$query$vesting = api.query.vesting) != null && _api$query$vesting.vesting ? api.query.vesting.vesting(accountId2) : of(api.registry.createType("Option<VestingInfo>")), lockQueries.length ? combineLatest(lockQueries.map((c) => c(accountId2))) : of([]), reserveQueries.length ? combineLatest(reserveQueries.map((c) => c(accountId2))) : of([])]).pipe(map2(([opt, locks2, reserves]) => {
    let offsetLock = -1;
    let offsetReserve = -1;
    const vesting = opt.unwrapOr(null);
    return [vesting ? Array.isArray(vesting) ? vesting : [vesting] : null, lockEmpty.map((e) => e ? api.registry.createType("Vec<BalanceLock>") : locks2[++offsetLock]), reserveEmpty.map((e) => e ? api.registry.createType("Vec<PalletBalancesReserveData>") : reserves[++offsetReserve])];
  }));
}
function all2(instanceId, api) {
  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, "balances");
  return memo(instanceId, (address) => {
    var _api$query$system, _api$query$balances;
    return combineLatest([api.derive.balances.account(address), isFunction((_api$query$system = api.query.system) == null ? void 0 : _api$query$system.account) || isFunction((_api$query$balances = api.query.balances) == null ? void 0 : _api$query$balances.account) ? queryCurrent(api, address, balanceInstances) : queryOld(api, address)]).pipe(switchMap(([account3, locks2]) => combineLatest([of(account3), of(locks2), api.derive.chain.bestNumber()])), map2((result) => calcBalances(api, result)));
  });
}

// node_modules/@polkadot/api-derive/balances/account.js
function zeroBalance(api) {
  return api.registry.createType("Balance");
}
function getBalance(api, [freeBalance, reservedBalance, frozenFee, frozenMisc]) {
  const votingBalance2 = api.registry.createType("Balance", freeBalance.toBn());
  return {
    freeBalance,
    frozenFee,
    frozenMisc,
    reservedBalance,
    votingBalance: votingBalance2
  };
}
function calcBalances2(api, [accountId2, [accountNonce, [primary, ...additional]]]) {
  return objectSpread({
    accountId: accountId2,
    accountNonce,
    additional: additional.map((b) => getBalance(api, b))
  }, getBalance(api, primary));
}
function queryBalancesFree(api, accountId2) {
  return combineLatest([api.query.balances.freeBalance(accountId2), api.query.balances.reservedBalance(accountId2), api.query.system.accountNonce(accountId2)]).pipe(map2(([freeBalance, reservedBalance, accountNonce]) => [accountNonce, [[freeBalance, reservedBalance, zeroBalance(api), zeroBalance(api)]]]));
}
function queryNonceOnly(api, accountId2) {
  const fill = (nonce) => [nonce, [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]]];
  return isFunction(api.query.system.account) ? api.query.system.account(accountId2).pipe(map2(({
    nonce
  }) => fill(nonce))) : isFunction(api.query.system.accountNonce) ? api.query.system.accountNonce(accountId2).pipe(map2((nonce) => fill(nonce))) : of(fill(api.registry.createType("Index")));
}
function queryBalancesAccount(api, accountId2, modules = ["balances"]) {
  const balances = modules.map((m) => {
    var _m, _api$query$m;
    return ((_m = api.derive[m]) == null ? void 0 : _m.customAccount) || ((_api$query$m = api.query[m]) == null ? void 0 : _api$query$m.account);
  }).filter((q) => isFunction(q));
  const extract = (nonce, data) => [nonce, data.map(({
    feeFrozen,
    free,
    miscFrozen,
    reserved
  }) => [free, reserved, feeFrozen, miscFrozen])];
  return balances.length ? isFunction(api.query.system.account) ? combineLatest([api.query.system.account(accountId2), ...balances.map((c) => c(accountId2))]).pipe(map2(([{
    nonce
  }, ...balances2]) => extract(nonce, balances2))) : combineLatest([api.query.system.accountNonce(accountId2), ...balances.map((c) => c(accountId2))]).pipe(map2(([nonce, ...balances2]) => extract(nonce, balances2))) : queryNonceOnly(api, accountId2);
}
function querySystemAccount(api, accountId2) {
  return api.query.system.account(accountId2).pipe(map2((infoOrTuple) => {
    const data = infoOrTuple.nonce ? infoOrTuple.data : infoOrTuple[1];
    const nonce = infoOrTuple.nonce || infoOrTuple[0];
    if (!data || data.isEmpty) {
      return [nonce, [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]]];
    }
    const {
      feeFrozen,
      free,
      miscFrozen,
      reserved
    } = data;
    return [nonce, [[free, reserved, feeFrozen, miscFrozen]]];
  }));
}
function account(instanceId, api) {
  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, "balances");
  const nonDefaultBalances = balanceInstances && (balanceInstances.length !== 1 || balanceInstances[0] !== "balances");
  return memo(instanceId, (address) => api.derive.accounts.accountId(address).pipe(switchMap((accountId2) => {
    var _api$query$system, _api$query$balances, _api$query$balances2;
    return accountId2 ? combineLatest([of(accountId2), nonDefaultBalances ? queryBalancesAccount(api, accountId2, balanceInstances) : isFunction((_api$query$system = api.query.system) == null ? void 0 : _api$query$system.account) ? querySystemAccount(api, accountId2) : isFunction((_api$query$balances = api.query.balances) == null ? void 0 : _api$query$balances.account) ? queryBalancesAccount(api, accountId2) : isFunction((_api$query$balances2 = api.query.balances) == null ? void 0 : _api$query$balances2.freeBalance) ? queryBalancesFree(api, accountId2) : queryNonceOnly(api, accountId2)]) : of([api.registry.createType("AccountId"), [api.registry.createType("Index"), [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]]]]);
  }), map2((result) => calcBalances2(api, result))));
}

// node_modules/@polkadot/api-derive/balances/votingBalances.js
function votingBalances(instanceId, api) {
  return memo(instanceId, (addresses) => !addresses || !addresses.length ? of([]) : combineLatest(addresses.map((accountId2) => api.derive.balances.account(accountId2))));
}

// node_modules/@polkadot/api-derive/balances/index.js
var votingBalance = all2;

// node_modules/@polkadot/api-derive/bounties/index.js
var bounties_exports = {};
__export(bounties_exports, {
  bounties: () => bounties
});

// node_modules/@polkadot/api-derive/bounties/helpers/filterBountyProposals.js
function filterBountiesProposals(api, allProposals) {
  const bountyTxBase = api.tx.bounties ? api.tx.bounties : api.tx.treasury;
  const bountyProposalCalls = [bountyTxBase.approveBounty, bountyTxBase.closeBounty, bountyTxBase.proposeCurator, bountyTxBase.unassignCurator];
  return allProposals.filter((proposal6) => bountyProposalCalls.find((bountyCall) => proposal6.proposal && bountyCall.is(proposal6.proposal)));
}

// node_modules/@polkadot/api-derive/bounties/bounties.js
function parseResult([maybeBounties, maybeDescriptions, ids, bountyProposals]) {
  const bounties2 = [];
  maybeBounties.forEach((bounty, index) => {
    if (bounty.isSome) {
      bounties2.push({
        bounty: bounty.unwrap(),
        description: maybeDescriptions[index].unwrapOrDefault().toUtf8(),
        index: ids[index],
        proposals: bountyProposals.filter((bountyProposal) => bountyProposal.proposal && ids[index].eq(bountyProposal.proposal.args[0]))
      });
    }
  });
  return bounties2;
}
function bounties(instanceId, api) {
  const bountyBase = api.query.bounties || api.query.treasury;
  return memo(instanceId, () => bountyBase.bounties ? combineLatest([bountyBase.bountyCount(), api.query.council ? api.query.council.proposalCount() : of(0)]).pipe(switchMap(() => combineLatest([bountyBase.bounties.keys(), api.derive.council ? api.derive.council.proposals() : of([])])), switchMap(([keys2, proposals8]) => {
    const ids = keys2.map(({
      args: [id2]
    }) => id2);
    return combineLatest([bountyBase.bounties.multi(ids), bountyBase.bountyDescriptions.multi(ids), of(ids), of(filterBountiesProposals(api, proposals8))]);
  }), map2(parseResult)) : of(parseResult([[], [], [], []])));
}

// node_modules/@polkadot/api-derive/chain/index.js
var chain_exports = {};
__export(chain_exports, {
  _getHeaderRange: () => _getHeaderRange,
  bestNumber: () => bestNumber,
  bestNumberFinalized: () => bestNumberFinalized,
  bestNumberLag: () => bestNumberLag,
  getBlock: () => getBlock,
  getBlockByNumber: () => getBlockByNumber,
  getHeader: () => getHeader,
  subscribeFinalizedHeads: () => subscribeFinalizedHeads,
  subscribeNewBlocks: () => subscribeNewBlocks,
  subscribeNewHeads: () => subscribeNewHeads
});

// node_modules/@polkadot/api-derive/chain/util.js
function createBlockNumberDerive(fn) {
  return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map2(unwrapBlockNumber)));
}
function getAuthorDetails(header, queryAt) {
  if (queryAt.authorMapping && queryAt.authorMapping.mappingWithDeposit) {
    const mapId = header.digest.logs[0] && (header.digest.logs[0].isConsensus && header.digest.logs[0].asConsensus[1] || header.digest.logs[0].isPreRuntime && header.digest.logs[0].asPreRuntime[1]);
    if (mapId) {
      return combineLatest([of(header), queryAt.session ? queryAt.session.validators() : of(null), queryAt.authorMapping.mappingWithDeposit(mapId).pipe(map2((opt) => opt.unwrapOr({
        account: null
      }).account))]);
    }
  }
  return combineLatest([of(header), queryAt.session ? queryAt.session.validators() : of(null), of(null)]);
}

// node_modules/@polkadot/api-derive/chain/bestNumber.js
var bestNumber = createBlockNumberDerive((api) => api.rpc.chain.subscribeNewHeads());

// node_modules/@polkadot/api-derive/chain/bestNumberFinalized.js
var bestNumberFinalized = createBlockNumberDerive((api) => api.rpc.chain.subscribeFinalizedHeads());

// node_modules/@polkadot/api-derive/chain/bestNumberLag.js
function bestNumberLag(instanceId, api) {
  return memo(instanceId, () => combineLatest([api.derive.chain.bestNumber(), api.derive.chain.bestNumberFinalized()]).pipe(map2(([bestNumber2, bestNumberFinalized2]) => api.registry.createType("BlockNumber", bestNumber2.sub(bestNumberFinalized2)))));
}

// node_modules/@polkadot/api-derive/type/util.js
function extractAuthor(digest, sessionValidators = []) {
  const [citem] = digest.logs.filter((e) => e.isConsensus);
  const [pitem] = digest.logs.filter((e) => e.isPreRuntime);
  const [sitem] = digest.logs.filter((e) => e.isSeal);
  let accountId2;
  try {
    if (pitem) {
      const [engine, data] = pitem.asPreRuntime;
      accountId2 = engine.extractAuthor(data, sessionValidators);
    }
    if (!accountId2 && citem) {
      const [engine, data] = citem.asConsensus;
      accountId2 = engine.extractAuthor(data, sessionValidators);
    }
    if (!accountId2 && sitem) {
      const [engine, data] = sitem.asSeal;
      accountId2 = engine.extractAuthor(data, sessionValidators);
    }
  } catch {
  }
  return accountId2;
}

// node_modules/@polkadot/api-derive/type/HeaderExtended.js
function createHeaderExtended(registry, header, validators2, author) {
  var _author;
  const HeaderBase = registry.createClass("Header");
  class Implementation extends HeaderBase {
    constructor(registry2, header2, validators3, author2) {
      super(registry2, header2);
      __privateAdd(this, _author, void 0);
      __privateSet(this, _author, author2 || extractAuthor(this.digest, validators3 || []));
      this.createdAtHash = header2 == null ? void 0 : header2.createdAtHash;
    }
    get author() {
      return __privateGet(this, _author);
    }
  }
  _author = new WeakMap();
  return new Implementation(registry, header, validators2, author);
}

// node_modules/@polkadot/api-derive/type/SignedBlockExtended.js
function mapExtrinsics(extrinsics, records) {
  return extrinsics.map((extrinsic, index) => {
    let dispatchError;
    let dispatchInfo;
    const events2 = records.filter(({
      phase
    }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index)).map(({
      event
    }) => {
      if (event.section === "system") {
        if (event.method === "ExtrinsicSuccess") {
          dispatchInfo = event.data[0];
        } else if (event.method === "ExtrinsicFailed") {
          dispatchError = event.data[0];
          dispatchInfo = event.data[1];
        }
      }
      return event;
    });
    return {
      dispatchError,
      dispatchInfo,
      events: events2,
      extrinsic
    };
  });
}
function createSignedBlockExtended(registry, block, events2, validators2, author) {
  var _author, _events, _extrinsics;
  const SignedBlockBase = registry.createClass("SignedBlock");
  class Implementation extends SignedBlockBase {
    constructor(registry2, block2, events3, validators3, author2) {
      super(registry2, block2);
      __privateAdd(this, _author, void 0);
      __privateAdd(this, _events, void 0);
      __privateAdd(this, _extrinsics, void 0);
      __privateSet(this, _author, author2 || extractAuthor(this.block.header.digest, validators3 || []));
      __privateSet(this, _events, events3 || []);
      __privateSet(this, _extrinsics, mapExtrinsics(this.block.extrinsics, __privateGet(this, _events)));
      this.createdAtHash = block2 == null ? void 0 : block2.createdAtHash;
    }
    get author() {
      return __privateGet(this, _author);
    }
    get events() {
      return __privateGet(this, _events);
    }
    get extrinsics() {
      return __privateGet(this, _extrinsics);
    }
  }
  _author = new WeakMap();
  _events = new WeakMap();
  _extrinsics = new WeakMap();
  return new Implementation(registry, block, events2, validators2, author);
}

// node_modules/@polkadot/api-derive/chain/getHeader.js
function getHeader(instanceId, api) {
  return memo(instanceId, (blockHash) => combineLatest([api.rpc.chain.getHeader(blockHash), api.queryAt(blockHash)]).pipe(switchMap(([header, queryAt]) => getAuthorDetails(header, queryAt)), map2(([header, validators2, author]) => createHeaderExtended((validators2 || header).registry, header, validators2, author))));
}

// node_modules/@polkadot/api-derive/chain/getBlock.js
function getBlock(instanceId, api) {
  return memo(instanceId, (blockHash) => combineLatest([api.rpc.chain.getBlock(blockHash), api.queryAt(blockHash)]).pipe(switchMap(([signedBlock, queryAt]) => combineLatest([of(signedBlock), queryAt.system.events(), getAuthorDetails(signedBlock.block.header, queryAt)])), map2(([signedBlock, events2, [, validators2, author]]) => createSignedBlockExtended(events2.registry, signedBlock, events2, validators2, author))));
}

// node_modules/@polkadot/api-derive/chain/getBlockByNumber.js
function getBlockByNumber(instanceId, api) {
  return memo(instanceId, (blockNumber) => api.rpc.chain.getBlockHash(blockNumber).pipe(switchMap((h) => api.derive.chain.getBlock(h))));
}

// node_modules/@polkadot/api-derive/chain/subscribeFinalizedHeads.js
function _getHeaderRange(instanceId, api) {
  return memo(instanceId, (startHash, endHash, prev = []) => api.rpc.chain.getHeader(startHash).pipe(switchMap((header) => header.parentHash.eq(endHash) ? of([header, ...prev]) : api.derive.chain._getHeaderRange(header.parentHash, endHash, [header, ...prev]))));
}
function subscribeFinalizedHeads(instanceId, api) {
  return memo(instanceId, () => {
    let prevHash = null;
    return api.rpc.chain.subscribeFinalizedHeads().pipe(switchMap((header) => {
      const endHash = prevHash;
      const startHash = header.parentHash;
      prevHash = header.createdAtHash = header.hash;
      return endHash === null || startHash.eq(endHash) ? of(header) : api.derive.chain._getHeaderRange(startHash, endHash, [header]).pipe(switchMap((headers) => from(headers)));
    }));
  });
}

// node_modules/@polkadot/api-derive/chain/subscribeNewBlocks.js
function subscribeNewBlocks(instanceId, api) {
  return memo(instanceId, () => api.derive.chain.subscribeNewHeads().pipe(switchMap((header) => api.derive.chain.getBlock(header.createdAtHash || header.hash))));
}

// node_modules/@polkadot/api-derive/chain/subscribeNewHeads.js
function subscribeNewHeads(instanceId, api) {
  return memo(instanceId, () => api.rpc.chain.subscribeNewHeads().pipe(switchMap((header) => combineLatest([of(header), api.queryAt(header.hash)])), switchMap(([header, queryAt]) => getAuthorDetails(header, queryAt)), map2(([header, validators2, author]) => {
    header.createdAtHash = header.hash;
    return createHeaderExtended(header.registry, header, validators2, author);
  })));
}

// node_modules/@polkadot/api-derive/contracts/index.js
var contracts_exports = {};
__export(contracts_exports, {
  fees: () => fees
});

// node_modules/@polkadot/api-derive/contracts/fees.js
function queryConstants(api) {
  return of([
    api.consts.contracts.callBaseFee || api.registry.createType("Balance"),
    api.consts.contracts.contractFee || api.registry.createType("Balance"),
    api.consts.contracts.creationFee || api.registry.createType("Balance"),
    api.consts.contracts.transactionBaseFee || api.registry.createType("Balance"),
    api.consts.contracts.transactionByteFee || api.registry.createType("Balance"),
    api.consts.contracts.transferFee || api.registry.createType("Balance"),
    api.consts.contracts.rentByteFee,
    api.consts.contracts.rentDepositOffset,
    api.consts.contracts.surchargeReward,
    api.consts.contracts.tombstoneDeposit
  ]);
}
function fees(instanceId, api) {
  return memo(instanceId, () => {
    return queryConstants(api).pipe(map2(([callBaseFee, contractFee, creationFee, transactionBaseFee, transactionByteFee, transferFee, rentByteFee, rentDepositOffset, surchargeReward, tombstoneDeposit]) => ({
      callBaseFee,
      contractFee,
      creationFee,
      rentByteFee,
      rentDepositOffset,
      surchargeReward,
      tombstoneDeposit,
      transactionBaseFee,
      transactionByteFee,
      transferFee
    })));
  });
}

// node_modules/@polkadot/api-derive/council/index.js
var council_exports = {};
__export(council_exports, {
  hasProposals: () => hasProposals3,
  members: () => members3,
  prime: () => prime3,
  proposal: () => proposal3,
  proposalCount: () => proposalCount3,
  proposalHashes: () => proposalHashes3,
  proposals: () => proposals3,
  votes: () => votes,
  votesOf: () => votesOf
});

// node_modules/@polkadot/api-derive/council/votes.js
function isVoter(value) {
  return !Array.isArray(value);
}
function retrieveStakeOf(elections) {
  return elections.stakeOf.entries().pipe(map2((entries) => entries.map(([{
    args: [accountId2]
  }, stake]) => [accountId2, stake])));
}
function retrieveVoteOf(elections) {
  return elections.votesOf.entries().pipe(map2((entries) => entries.map(([{
    args: [accountId2]
  }, votes2]) => [accountId2, votes2])));
}
function retrievePrev(api, elections) {
  return combineLatest([retrieveStakeOf(elections), retrieveVoteOf(elections)]).pipe(map2(([stakes, votes2]) => {
    const result = [];
    votes2.forEach(([voter, votes3]) => {
      result.push([voter, {
        stake: api.registry.createType("Balance"),
        votes: votes3
      }]);
    });
    stakes.forEach(([staker, stake]) => {
      const entry = result.find(([voter]) => voter.eq(staker));
      if (entry) {
        entry[1].stake = stake;
      } else {
        result.push([staker, {
          stake,
          votes: []
        }]);
      }
    });
    return result;
  }));
}
function retrieveCurrent(elections) {
  return elections.voting.entries().pipe(map2((entries) => entries.map(([{
    args: [accountId2]
  }, value]) => [accountId2, isVoter(value) ? {
    stake: value.stake,
    votes: value.votes
  } : {
    stake: value[0],
    votes: value[1]
  }])));
}
function votes(instanceId, api) {
  const elections = api.query.phragmenElection || api.query.electionsPhragmen || api.query.elections;
  return memo(instanceId, () => elections ? elections.stakeOf ? retrievePrev(api, elections) : retrieveCurrent(elections) : of([]));
}

// node_modules/@polkadot/api-derive/council/votesOf.js
function votesOf(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.council.votes().pipe(map2((votes2) => (votes2.find(([from2]) => from2.eq(accountId2)) || [null, {
    stake: api.registry.createType("Balance"),
    votes: []
  }])[1])));
}

// node_modules/@polkadot/api-derive/council/index.js
var members3 = members("council");
var hasProposals3 = hasProposals("council");
var proposal3 = proposal("council");
var proposalCount3 = proposalCount("council");
var proposalHashes3 = proposalHashes("council");
var proposals3 = proposals("council");
var prime3 = prime("council");

// node_modules/@polkadot/api-derive/crowdloan/index.js
var crowdloan_exports = {};
__export(crowdloan_exports, {
  childKey: () => childKey,
  contributions: () => contributions,
  ownContributions: () => ownContributions
});

// node_modules/@polkadot/api-derive/crowdloan/childKey.js
function createChildKey(info6) {
  return u8aToHex(u8aConcat(":child_storage:default:", blake2AsU8a(u8aConcat("crowdloan", (info6.fundIndex || info6.trieIndex).toU8a()))));
}
function childKey(instanceId, api) {
  return memo(instanceId, (paraId) => api.query.crowdloan.funds(paraId).pipe(map2((optInfo) => optInfo.isSome ? createChildKey(optInfo.unwrap()) : null)));
}

// node_modules/@polkadot/api-derive/crowdloan/util.js
function extractContributed(paraId, events2) {
  var _events$createdAtHash;
  const added = [];
  const removed = [];
  return events2.filter(({
    event: {
      data: [, eventParaId],
      method,
      section: section2
    }
  }) => section2 === "crowdloan" && ["Contributed", "Withdrew"].includes(method) && eventParaId.eq(paraId)).reduce((result, {
    event: {
      data: [accountId2],
      method
    }
  }) => {
    if (method === "Contributed") {
      result.added.push(accountId2.toHex());
    } else {
      result.removed.push(accountId2.toHex());
    }
    return result;
  }, {
    added,
    blockHash: ((_events$createdAtHash = events2.createdAtHash) == null ? void 0 : _events$createdAtHash.toHex()) || "-",
    removed
  });
}

// node_modules/@polkadot/api-derive/crowdloan/contributions.js
var PAGE_SIZE_K = 1e3;
function _getUpdates(api, paraId) {
  let added = [];
  let removed = [];
  return api.query.system.events().pipe(switchMap((events2) => {
    const changes = extractContributed(paraId, events2);
    if (changes.added.length || changes.removed.length) {
      var _events$createdAtHash;
      added = added.concat(...changes.added);
      removed = removed.concat(...changes.removed);
      return of({
        added,
        addedDelta: changes.added,
        blockHash: ((_events$createdAtHash = events2.createdAtHash) == null ? void 0 : _events$createdAtHash.toHex()) || "-",
        removed,
        removedDelta: changes.removed
      });
    }
    return EMPTY;
  }), startWith({
    added,
    addedDelta: [],
    blockHash: "-",
    removed,
    removedDelta: []
  }));
}
function _eventTriggerAll(api, paraId) {
  return api.query.system.events().pipe(switchMap((events2) => {
    var _events$createdAtHash2;
    const items = events2.filter(({
      event: {
        data: [eventParaId],
        method,
        section: section2
      }
    }) => section2 === "crowdloan" && ["AllRefunded", "Dissolved", "PartiallyRefunded"].includes(method) && eventParaId.eq(paraId));
    return items.length ? of(((_events$createdAtHash2 = events2.createdAtHash) == null ? void 0 : _events$createdAtHash2.toHex()) || "-") : EMPTY;
  }), startWith("-"));
}
function _getKeysPaged(api, childKey2) {
  const subject = new BehaviorSubject(void 0);
  return subject.pipe(switchMap((startKey) => api.rpc.childstate.getKeysPaged(childKey2, "0x", PAGE_SIZE_K, startKey)), tap((keys2) => {
    nextTick(() => {
      keys2.length === PAGE_SIZE_K ? subject.next(keys2[PAGE_SIZE_K - 1].toHex()) : subject.complete();
    });
  }), toArray(), map2((keyArr) => arrayFlatten(keyArr)));
}
function _getAll(api, paraId, childKey2) {
  return _eventTriggerAll(api, paraId).pipe(switchMap(() => isFunction(api.rpc.childstate.getKeysPaged) ? _getKeysPaged(api, childKey2) : api.rpc.childstate.getKeys(childKey2, "0x")), map2((keys2) => keys2.map((k) => k.toHex())));
}
function _contributions(api, paraId, childKey2) {
  return combineLatest([_getAll(api, paraId, childKey2), _getUpdates(api, paraId)]).pipe(map2(([keys2, {
    added,
    blockHash,
    removed
  }]) => {
    const contributorsMap = {};
    keys2.forEach((k) => {
      contributorsMap[k] = true;
    });
    added.forEach((k) => {
      contributorsMap[k] = true;
    });
    removed.forEach((k) => {
      delete contributorsMap[k];
    });
    return {
      blockHash,
      contributorsHex: Object.keys(contributorsMap)
    };
  }));
}
function contributions(instanceId, api) {
  return memo(instanceId, (paraId) => api.derive.crowdloan.childKey(paraId).pipe(switchMap((childKey2) => childKey2 ? _contributions(api, paraId, childKey2) : of({
    blockHash: "-",
    contributorsHex: []
  }))));
}

// node_modules/@polkadot/api-derive/crowdloan/ownContributions.js
function _getValues(api, childKey2, keys2) {
  return combineLatest(keys2.map((k) => api.rpc.childstate.getStorage(childKey2, k))).pipe(map2((values) => values.map((v) => api.registry.createType("Option<StorageData>", v)).map((o) => o.isSome ? api.registry.createType("Balance", o.unwrap()) : api.registry.createType("Balance")).reduce((all3, b, index) => objectSpread(all3, {
    [keys2[index]]: b
  }), {})));
}
function _watchOwnChanges(api, paraId, childkey, keys2) {
  return api.query.system.events().pipe(switchMap((events2) => {
    const changes = extractContributed(paraId, events2);
    const filtered = keys2.filter((k) => changes.added.includes(k) || changes.removed.includes(k));
    return filtered.length ? _getValues(api, childkey, filtered) : EMPTY;
  }), startWith({}));
}
function _contributions2(api, paraId, childKey2, keys2) {
  return combineLatest([_getValues(api, childKey2, keys2), _watchOwnChanges(api, paraId, childKey2, keys2)]).pipe(map2(([all3, latest2]) => objectSpread({}, all3, latest2)));
}
function ownContributions(instanceId, api) {
  return memo(instanceId, (paraId, keys2) => api.derive.crowdloan.childKey(paraId).pipe(switchMap((childKey2) => childKey2 && keys2.length ? _contributions2(api, paraId, childKey2, keys2) : of({}))));
}

// node_modules/@polkadot/api-derive/democracy/index.js
var democracy_exports = {};
__export(democracy_exports, {
  _referendumInfo: () => _referendumInfo,
  _referendumVotes: () => _referendumVotes,
  _referendumsVotes: () => _referendumsVotes,
  dispatchQueue: () => dispatchQueue,
  locks: () => locks,
  nextExternal: () => nextExternal,
  preimage: () => preimage,
  preimages: () => preimages,
  proposals: () => proposals4,
  referendumIds: () => referendumIds,
  referendums: () => referendums,
  referendumsActive: () => referendumsActive,
  referendumsFinished: () => referendumsFinished,
  referendumsInfo: () => referendumsInfo,
  sqrtElectorate: () => sqrtElectorate
});

// node_modules/@polkadot/api-derive/democracy/util.js
function isOldInfo(info6) {
  return !!info6.proposalHash;
}
function isCurrentStatus(status) {
  return !!status.tally;
}
function compareRationals(n1, d1, n2, d2) {
  while (true) {
    const q1 = n1.div(d1);
    const q2 = n2.div(d2);
    if (q1.lt(q2)) {
      return true;
    } else if (q2.lt(q1)) {
      return false;
    }
    const r1 = n1.mod(d1);
    const r2 = n2.mod(d2);
    if (r2.isZero()) {
      return false;
    } else if (r1.isZero()) {
      return true;
    }
    n1 = d2;
    n2 = d1;
    d1 = r2;
    d2 = r1;
  }
}
function calcPassingOther(threshold, sqrtElectorate2, {
  votedAye,
  votedNay,
  votedTotal
}) {
  const sqrtVoters = bnSqrt(votedTotal);
  return sqrtVoters.isZero() ? false : threshold.isSuperMajorityApprove ? compareRationals(votedNay, sqrtVoters, votedAye, sqrtElectorate2) : compareRationals(votedNay, sqrtElectorate2, votedAye, sqrtVoters);
}
function calcPassing(threshold, sqrtElectorate2, state2) {
  return threshold.isSimpleMajority ? state2.votedAye.gt(state2.votedNay) : calcPassingOther(threshold, sqrtElectorate2, state2);
}
function calcVotesPrev(votesFor) {
  return votesFor.reduce((state2, derived) => {
    const {
      balance,
      vote
    } = derived;
    const isDefault = vote.conviction.index === 0;
    const counted = balance.muln(isDefault ? 1 : vote.conviction.index).divn(isDefault ? 10 : 1);
    if (vote.isAye) {
      state2.allAye.push(derived);
      state2.voteCountAye++;
      state2.votedAye.iadd(counted);
    } else {
      state2.allNay.push(derived);
      state2.voteCountNay++;
      state2.votedNay.iadd(counted);
    }
    state2.voteCount++;
    state2.votedTotal.iadd(counted);
    return state2;
  }, {
    allAye: [],
    allNay: [],
    voteCount: 0,
    voteCountAye: 0,
    voteCountNay: 0,
    votedAye: new import_bn.default(0),
    votedNay: new import_bn.default(0),
    votedTotal: new import_bn.default(0)
  });
}
function calcVotesCurrent(tally, votes2) {
  const allAye = [];
  const allNay = [];
  votes2.forEach((derived) => {
    if (derived.vote.isAye) {
      allAye.push(derived);
    } else {
      allNay.push(derived);
    }
  });
  return {
    allAye,
    allNay,
    voteCount: allAye.length + allNay.length,
    voteCountAye: allAye.length,
    voteCountNay: allNay.length,
    votedAye: tally.ayes,
    votedNay: tally.nays,
    votedTotal: tally.turnout
  };
}
function calcVotes(sqrtElectorate2, referendum, votes2) {
  const state2 = isCurrentStatus(referendum.status) ? calcVotesCurrent(referendum.status.tally, votes2) : calcVotesPrev(votes2);
  return objectSpread({}, state2, {
    isPassing: calcPassing(referendum.status.threshold, sqrtElectorate2, state2),
    votes: votes2
  });
}
function getStatus(info6) {
  if (info6.isNone) {
    return null;
  }
  const unwrapped = info6.unwrap();
  return isOldInfo(unwrapped) ? unwrapped : unwrapped.isOngoing ? unwrapped.asOngoing : null;
}
function getImageHashBounded(hash2) {
  return hash2.isLegacy ? hash2.asLegacy.hash_.toHex() : hash2.isLookup ? hash2.asLookup.hash_.toHex() : hash2.isInline ? hash2.asInline.hash.toHex() : isString(hash2) ? isHex(hash2) ? hash2 : stringToHex(hash2) : isU8a(hash2) ? u8aToHex(hash2) : hash2.toHex();
}
function getImageHash(status) {
  return getImageHashBounded(status.proposal || status.proposalHash);
}

// node_modules/@polkadot/api-derive/democracy/dispatchQueue.js
var DEMOCRACY_ID = stringToHex("democrac");
function isMaybeHashedOrBounded(call) {
  return call instanceof Enum;
}
function isBounded(call) {
  return call.isInline || call.isLegacy || call.isLookup;
}
function queryQueue(api) {
  return api.query.democracy.dispatchQueue().pipe(switchMap((dispatches) => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash2]) => hash2))])), map2(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({
    at,
    image: images[dispatchIndex],
    imageHash: getImageHashBounded(imageHash),
    index
  }))));
}
function schedulerEntries(api) {
  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap((keys2) => {
    const blockNumbers = keys2.map(({
      args: [blockNumber]
    }) => blockNumber);
    return blockNumbers.length ? combineLatest([
      of(blockNumbers),
      api.query.scheduler.agenda.multi(blockNumbers).pipe(catchError(() => of(blockNumbers.map(() => []))))
    ]) : of([[], []]);
  }));
}
function queryScheduler(api) {
  return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {
    const result = [];
    blockNumbers.forEach((at, index) => {
      (agendas[index] || []).filter((o) => o.isSome).forEach((o) => {
        const scheduled2 = o.unwrap();
        if (scheduled2.maybeId.isSome) {
          const id2 = scheduled2.maybeId.unwrap().toHex();
          if (id2.startsWith(DEMOCRACY_ID)) {
            const imageHash = isMaybeHashedOrBounded(scheduled2.call) ? isBounded(scheduled2.call) ? getImageHashBounded(scheduled2.call) : scheduled2.call.isHash ? scheduled2.call.asHash.toHex() : scheduled2.call.asValue.args[0].toHex() : scheduled2.call.args[0].toHex();
            result.push({
              at,
              imageHash,
              index: api.registry.createType("(u64, ReferendumIndex)", id2)[1]
            });
          }
        }
      });
    });
    return combineLatest([of(result), result.length ? api.derive.democracy.preimages(result.map(({
      imageHash
    }) => imageHash)) : of([])]);
  }), map2(([infos, images]) => infos.map((info6, index) => objectSpread({
    image: images[index]
  }, info6))));
}
function dispatchQueue(instanceId, api) {
  return memo(instanceId, () => {
    var _api$query$scheduler;
    return isFunction((_api$query$scheduler = api.query.scheduler) == null ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : of([]);
  });
}

// node_modules/@polkadot/api-derive/democracy/locks.js
var LOCKUPS = [0, 1, 2, 4, 8, 16, 32];
function parseEnd(api, vote, {
  approved,
  end
}) {
  return [end, approved.isTrue && vote.isAye || approved.isFalse && vote.isNay ? end.add((api.consts.democracy.voteLockingPeriod || api.consts.democracy.enactmentPeriod).muln(LOCKUPS[vote.conviction.index])) : BN_ZERO];
}
function parseLock(api, [referendumId, accountVote], referendum) {
  const {
    balance,
    vote
  } = accountVote.asStandard;
  const [referendumEnd, unlockAt] = referendum.isFinished ? parseEnd(api, vote, referendum.asFinished) : [BN_ZERO, BN_ZERO];
  return {
    balance,
    isDelegated: false,
    isFinished: referendum.isFinished,
    referendumEnd,
    referendumId,
    unlockAt,
    vote
  };
}
function delegateLocks(api, {
  balance,
  conviction,
  target
}) {
  return api.derive.democracy.locks(target).pipe(map2((available) => available.map(({
    isFinished,
    referendumEnd,
    referendumId,
    unlockAt,
    vote
  }) => ({
    balance,
    isDelegated: true,
    isFinished,
    referendumEnd,
    referendumId,
    unlockAt: unlockAt.isZero() ? unlockAt : referendumEnd.add((api.consts.democracy.voteLockingPeriod || api.consts.democracy.enactmentPeriod).muln(LOCKUPS[conviction.index])),
    vote: api.registry.createType("Vote", {
      aye: vote.isAye,
      conviction
    })
  }))));
}
function directLocks(api, {
  votes: votes2
}) {
  if (!votes2.length) {
    return of([]);
  }
  return api.query.democracy.referendumInfoOf.multi(votes2.map(([referendumId]) => referendumId)).pipe(map2((referendums2) => votes2.map((vote, index) => [vote, referendums2[index].unwrapOr(null)]).filter((item) => !!item[1] && isUndefined(item[1].end) && item[0][1].isStandard).map(([directVote, referendum]) => parseLock(api, directVote, referendum))));
}
function locks(instanceId, api) {
  return memo(instanceId, (accountId2) => api.query.democracy.votingOf ? api.query.democracy.votingOf(accountId2).pipe(switchMap((voting) => voting.isDirect ? directLocks(api, voting.asDirect) : voting.isDelegating ? delegateLocks(api, voting.asDelegating) : of([]))) : of([]));
}

// node_modules/@polkadot/api-derive/democracy/nextExternal.js
function withImage(api, nextOpt) {
  if (nextOpt.isNone) {
    return of(null);
  }
  const [hash2, threshold] = nextOpt.unwrap();
  return api.derive.democracy.preimage(hash2).pipe(map2((image) => ({
    image,
    imageHash: getImageHashBounded(hash2),
    threshold
  })));
}
function nextExternal(instanceId, api) {
  return memo(instanceId, () => {
    var _api$query$democracy;
    return (_api$query$democracy = api.query.democracy) != null && _api$query$democracy.nextExternal ? api.query.democracy.nextExternal().pipe(switchMap((nextOpt) => withImage(api, nextOpt))) : of(null);
  });
}

// node_modules/@polkadot/api-derive/democracy/preimages.js
function isDemocracyPreimage(api, imageOpt) {
  return !!imageOpt && !api.query.democracy.dispatchQueue;
}
function constructProposal(api, [bytes3, proposer, balance, at]) {
  let proposal6;
  try {
    proposal6 = api.registry.createType("Call", bytes3.toU8a(true));
  } catch (error) {
    console.error(error);
  }
  return {
    at,
    balance,
    proposal: proposal6,
    proposer
  };
}
function parseDemocracy(api, imageOpt) {
  if (imageOpt.isNone) {
    return;
  }
  if (isDemocracyPreimage(api, imageOpt)) {
    const status = imageOpt.unwrap();
    if (status.isMissing) {
      return;
    }
    const {
      data,
      deposit,
      provider,
      since
    } = status.asAvailable;
    return constructProposal(api, [data, provider, deposit, since]);
  }
  return constructProposal(api, imageOpt.unwrap());
}
function parseImage(api, [proposalHash, status, bytes3]) {
  if (!status) {
    return void 0;
  }
  const [proposer, balance] = status.isUnrequested ? status.asUnrequested.deposit : status.asRequested.deposit.unwrapOrDefault();
  let proposal6;
  if (bytes3) {
    try {
      proposal6 = api.registry.createType("Call", bytes3.toU8a(true));
    } catch (error) {
      console.error(error);
    }
  }
  return {
    at: BN_ZERO,
    balance,
    proposal: proposal6,
    proposalHash,
    proposer
  };
}
function getDemocracyImages(api, hashes) {
  return api.query.democracy.preimages.multi(hashes).pipe(map2((images) => images.map((imageOpt) => parseDemocracy(api, imageOpt))));
}
function getImages(api, bounded) {
  const hashes = bounded.map((b) => getImageHashBounded(b));
  return api.query.preimage.statusFor.multi(hashes).pipe(switchMap((optStatus) => {
    const statuses = optStatus.map((o) => o.unwrapOr(null));
    const keys2 = statuses.map((s, i) => s ? s.isRequested ? [hashes[i], s.asRequested.len.unwrapOr(0)] : [hashes[i], s.asUnrequested.len] : null).filter((p) => !!p);
    return api.query.preimage.preimageFor.multi(keys2).pipe(map2((optBytes) => {
      let ptr = -1;
      return statuses.map((s, i) => s ? [hashes[i], s, optBytes[++ptr].unwrapOr(null)] : [hashes[i], null, null]).map((v) => parseImage(api, v));
    }));
  }));
}
function preimages(instanceId, api) {
  return memo(instanceId, (hashes) => hashes.length ? isFunction(api.query.democracy.preimages) ? getDemocracyImages(api, hashes) : isFunction(api.query.preimage.preimageFor) ? getImages(api, hashes) : of([]) : of([]));
}
var preimage = firstMemo((api, hash2) => api.derive.democracy.preimages([hash2]));

// node_modules/@polkadot/api-derive/democracy/proposals.js
function isNewDepositors(depositors) {
  return isFunction(depositors[1].mul);
}
function parse2([proposals8, images, optDepositors]) {
  return proposals8.filter(([, , proposer], index) => {
    var _optDepositors$index;
    return !!((_optDepositors$index = optDepositors[index]) != null && _optDepositors$index.isSome) && !proposer.isEmpty;
  }).map(([index, hash2, proposer], proposalIndex) => {
    const depositors = optDepositors[proposalIndex].unwrap();
    return objectSpread({
      image: images[proposalIndex],
      imageHash: getImageHashBounded(hash2),
      index,
      proposer
    }, isNewDepositors(depositors) ? {
      balance: depositors[1],
      seconds: depositors[0]
    } : {
      balance: depositors[0],
      seconds: depositors[1]
    });
  });
}
function proposals4(instanceId, api) {
  return memo(instanceId, () => {
    var _api$query$democracy, _api$query$democracy2;
    return isFunction((_api$query$democracy = api.query.democracy) == null ? void 0 : _api$query$democracy.publicProps) && isFunction((_api$query$democracy2 = api.query.democracy) == null ? void 0 : _api$query$democracy2.preimages) ? api.query.democracy.publicProps().pipe(switchMap((proposals8) => proposals8.length ? combineLatest([of(proposals8), api.derive.democracy.preimages(proposals8.map(([, hash2]) => hash2)), api.query.democracy.depositOf.multi(proposals8.map(([index]) => index))]) : of([[], [], []])), map2(parse2)) : of([]);
  });
}

// node_modules/@polkadot/api-derive/democracy/referendumIds.js
function referendumIds(instanceId, api) {
  return memo(instanceId, () => {
    var _api$query$democracy;
    return (_api$query$democracy = api.query.democracy) != null && _api$query$democracy.lowestUnbaked ? api.queryMulti([api.query.democracy.lowestUnbaked, api.query.democracy.referendumCount]).pipe(map2(([first2, total]) => total.gt(first2) ? [...Array(total.sub(first2).toNumber())].map((_, i) => first2.addn(i)) : [])) : of([]);
  });
}

// node_modules/@polkadot/api-derive/democracy/referendums.js
function referendums(instanceId, api) {
  return memo(instanceId, () => api.derive.democracy.referendumsActive().pipe(switchMap((referendums2) => referendums2.length ? combineLatest([of(referendums2), api.derive.democracy._referendumsVotes(referendums2)]) : of([[], []])), map2(([referendums2, votes2]) => referendums2.map((referendum, index) => objectSpread({}, referendum, votes2[index])))));
}

// node_modules/@polkadot/api-derive/democracy/referendumsActive.js
function referendumsActive(instanceId, api) {
  return memo(instanceId, () => api.derive.democracy.referendumIds().pipe(switchMap((ids) => ids.length ? api.derive.democracy.referendumsInfo(ids) : of([]))));
}

// node_modules/@polkadot/api-derive/democracy/referendumsFinished.js
function referendumsFinished(instanceId, api) {
  return memo(instanceId, () => api.derive.democracy.referendumIds().pipe(switchMap((ids) => api.query.democracy.referendumInfoOf.multi(ids)), map2((infos) => infos.map((o) => o.unwrapOr(null)).filter((info6) => !!info6 && info6.isFinished).map((info6) => info6.asFinished))));
}

// node_modules/@polkadot/api-derive/democracy/referendumsInfo.js
function votesPrev(api, referendumId) {
  return api.query.democracy.votersFor(referendumId).pipe(switchMap((votersFor) => combineLatest([of(votersFor), votersFor.length ? api.query.democracy.voteOf.multi(votersFor.map((accountId2) => [referendumId, accountId2])) : of([]), api.derive.balances.votingBalances(votersFor)])), map2(([votersFor, votes2, balances]) => votersFor.map((accountId2, index) => ({
    accountId: accountId2,
    balance: balances[index].votingBalance || api.registry.createType("Balance"),
    isDelegating: false,
    vote: votes2[index] || api.registry.createType("Vote")
  }))));
}
function extractVotes(mapped, referendumId) {
  return mapped.filter(([, voting]) => voting.isDirect).map(([accountId2, voting]) => [accountId2, voting.asDirect.votes.filter(([idx]) => idx.eq(referendumId))]).filter(([, directVotes]) => !!directVotes.length).reduce((result, [accountId2, votes2]) => votes2.reduce((result2, [, vote]) => {
    if (vote.isStandard) {
      result2.push(objectSpread({
        accountId: accountId2,
        isDelegating: false
      }, vote.asStandard));
    }
    return result2;
  }, result), []);
}
function votesCurr(api, referendumId) {
  return api.query.democracy.votingOf.entries().pipe(map2((allVoting) => {
    const mapped = allVoting.map(([{
      args: [accountId2]
    }, voting]) => [accountId2, voting]);
    const votes2 = extractVotes(mapped, referendumId);
    const delegations = mapped.filter(([, voting]) => voting.isDelegating).map(([accountId2, voting]) => [accountId2, voting.asDelegating]);
    delegations.forEach(([accountId2, {
      balance,
      conviction,
      target
    }]) => {
      const toDelegator = delegations.find(([accountId3]) => accountId3.eq(target));
      const to = votes2.find(({
        accountId: accountId3
      }) => accountId3.eq(toDelegator ? toDelegator[0] : target));
      if (to) {
        votes2.push({
          accountId: accountId2,
          balance,
          isDelegating: true,
          vote: api.registry.createType("Vote", {
            aye: to.vote.isAye,
            conviction
          })
        });
      }
    });
    return votes2;
  }));
}
function _referendumVotes(instanceId, api) {
  return memo(instanceId, (referendum) => combineLatest([api.derive.democracy.sqrtElectorate(), isFunction(api.query.democracy.votingOf) ? votesCurr(api, referendum.index) : votesPrev(api, referendum.index)]).pipe(map2(([sqrtElectorate2, votes2]) => calcVotes(sqrtElectorate2, referendum, votes2))));
}
function _referendumsVotes(instanceId, api) {
  return memo(instanceId, (referendums2) => referendums2.length ? combineLatest(referendums2.map((referendum) => api.derive.democracy._referendumVotes(referendum))) : of([]));
}
function _referendumInfo(instanceId, api) {
  return memo(instanceId, (index, info6) => {
    const status = getStatus(info6);
    return status ? api.derive.democracy.preimage(status.proposal || status.proposalHash).pipe(map2((image) => ({
      image,
      imageHash: getImageHash(status),
      index: api.registry.createType("ReferendumIndex", index),
      status
    }))) : of(null);
  });
}
function referendumsInfo(instanceId, api) {
  return memo(instanceId, (ids) => ids.length ? api.query.democracy.referendumInfoOf.multi(ids).pipe(switchMap((infos) => combineLatest(ids.map((id2, index) => api.derive.democracy._referendumInfo(id2, infos[index])))), map2((infos) => infos.filter((r) => !!r))) : of([]));
}

// node_modules/@polkadot/api-derive/democracy/sqrtElectorate.js
function sqrtElectorate(instanceId, api) {
  return memo(instanceId, () => api.query.balances.totalIssuance().pipe(map2(bnSqrt)));
}

// node_modules/@polkadot/api-derive/elections/index.js
var elections_exports = {};
__export(elections_exports, {
  info: () => info2
});

// node_modules/@polkadot/api-derive/elections/info.js
function isSeatHolder(value) {
  return !Array.isArray(value);
}
function isCandidateTuple(value) {
  return Array.isArray(value);
}
function getAccountTuple(value) {
  return isSeatHolder(value) ? [value.who, value.stake] : value;
}
function getCandidate(value) {
  return isCandidateTuple(value) ? value[0] : value;
}
function sortAccounts([, balanceA], [, balanceB]) {
  return balanceB.cmp(balanceA);
}
function getConstants(api, elections) {
  return elections ? {
    candidacyBond: api.consts[elections].candidacyBond,
    desiredRunnersUp: api.consts[elections].desiredRunnersUp,
    desiredSeats: api.consts[elections].desiredMembers,
    termDuration: api.consts[elections].termDuration,
    votingBond: api.consts[elections].votingBond
  } : {};
}
function getModules(api) {
  const [council] = api.registry.getModuleInstances(api.runtimeVersion.specName, "council") || ["council"];
  const elections = api.query.phragmenElection ? "phragmenElection" : api.query.electionsPhragmen ? "electionsPhragmen" : api.query.elections ? "elections" : null;
  return [council, elections];
}
function queryAll(api, council, elections) {
  return api.queryMulti([api.query[council].members, api.query[elections].candidates, api.query[elections].members, api.query[elections].runnersUp]);
}
function queryCouncil(api, council) {
  return combineLatest([api.query[council].members(), of([]), of([]), of([])]);
}
function info2(instanceId, api) {
  return memo(instanceId, () => {
    const [council, elections] = getModules(api);
    return (elections ? queryAll(api, council, elections) : queryCouncil(api, council)).pipe(map2(([councilMembers, candidates2, members7, runnersUp]) => objectSpread({}, getConstants(api, elections), {
      candidateCount: api.registry.createType("u32", candidates2.length),
      candidates: candidates2.map(getCandidate),
      members: members7.length ? members7.map(getAccountTuple).sort(sortAccounts) : councilMembers.map((a) => [a, api.registry.createType("Balance")]),
      runnersUp: runnersUp.map(getAccountTuple).sort(sortAccounts)
    })));
  });
}

// node_modules/@polkadot/api-derive/imOnline/index.js
var imOnline_exports = {};
__export(imOnline_exports, {
  receivedHeartbeats: () => receivedHeartbeats
});

// node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js
function mapResult([result, validators2, heartbeats, numBlocks]) {
  validators2.forEach((validator, index) => {
    const validatorId = validator.toString();
    const blockCount = numBlocks[index];
    const hasMessage = !heartbeats[index].isEmpty;
    const prev = result[validatorId];
    if (!prev || prev.hasMessage !== hasMessage || !prev.blockCount.eq(blockCount)) {
      result[validatorId] = {
        blockCount,
        hasMessage,
        isOnline: hasMessage || blockCount.gt(BN_ZERO)
      };
    }
  });
  return result;
}
function receivedHeartbeats(instanceId, api) {
  return memo(instanceId, () => {
    var _api$query$imOnline;
    return (_api$query$imOnline = api.query.imOnline) != null && _api$query$imOnline.receivedHeartbeats ? api.derive.staking.overview().pipe(switchMap(({
      currentIndex,
      validators: validators2
    }) => combineLatest([of({}), of(validators2), api.query.imOnline.receivedHeartbeats.multi(validators2.map((_address, index) => [currentIndex, index])), api.query.imOnline.authoredBlocks.multi(validators2.map((address) => [currentIndex, address]))])), map2(mapResult)) : of({});
  });
}

// node_modules/@polkadot/api-derive/membership/index.js
var membership_exports = {};
__export(membership_exports, {
  hasProposals: () => hasProposals4,
  members: () => members4,
  prime: () => prime4,
  proposal: () => proposal4,
  proposalCount: () => proposalCount4,
  proposalHashes: () => proposalHashes4,
  proposals: () => proposals5
});
var members4 = members("membership");
var hasProposals4 = hasProposals("membership");
var proposal4 = proposal("membership");
var proposalCount4 = proposalCount("membership");
var proposalHashes4 = proposalHashes("membership");
var proposals5 = proposals("membership");
var prime4 = prime("membership");

// node_modules/@polkadot/api-derive/parachains/index.js
var parachains_exports = {};
__export(parachains_exports, {
  info: () => info3,
  overview: () => overview
});

// node_modules/@polkadot/api-derive/parachains/util.js
function didUpdateToBool(didUpdate, id2) {
  return didUpdate.isSome ? didUpdate.unwrap().some((paraId) => paraId.eq(id2)) : false;
}

// node_modules/@polkadot/api-derive/parachains/info.js
function parseActive(id2, active) {
  const found = active.find(([paraId]) => paraId === id2);
  if (found && found[1].isSome) {
    const [collatorId, retriable] = found[1].unwrap();
    return objectSpread({
      collatorId
    }, retriable.isWithRetries ? {
      isRetriable: true,
      retries: retriable.asWithRetries.toNumber()
    } : {
      isRetriable: false,
      retries: 0
    });
  }
  return null;
}
function parseCollators(id2, collatorQueue) {
  return collatorQueue.map((queue2) => {
    const found = queue2.find(([paraId]) => paraId === id2);
    return found ? found[1] : null;
  });
}
function parse3(id2, [active, retryQueue, selectedThreads, didUpdate, info6, pendingSwap, heads, relayDispatchQueue]) {
  if (info6.isNone) {
    return null;
  }
  return {
    active: parseActive(id2, active),
    didUpdate: didUpdateToBool(didUpdate, id2),
    heads,
    id: id2,
    info: objectSpread({
      id: id2
    }, info6.unwrap()),
    pendingSwapId: pendingSwap.unwrapOr(null),
    relayDispatchQueue,
    retryCollators: parseCollators(id2, retryQueue),
    selectedCollators: parseCollators(id2, selectedThreads)
  };
}
function info3(instanceId, api) {
  return memo(instanceId, (id2) => api.query.registrar && api.query.parachains ? api.queryMulti([api.query.registrar.active, api.query.registrar.retryQueue, api.query.registrar.selectedThreads, api.query.parachains.didUpdate, [api.query.registrar.paras, id2], [api.query.registrar.pendingSwap, id2], [api.query.parachains.heads, id2], [api.query.parachains.relayDispatchQueue, id2]]).pipe(map2((result) => parse3(api.registry.createType("ParaId", id2), result))) : of(null));
}

// node_modules/@polkadot/api-derive/parachains/overview.js
function parse4([ids, didUpdate, infos, pendingSwaps, relayDispatchQueueSizes]) {
  return ids.map((id2, index) => ({
    didUpdate: didUpdateToBool(didUpdate, id2),
    id: id2,
    info: objectSpread({
      id: id2
    }, infos[index].unwrapOr(null)),
    pendingSwapId: pendingSwaps[index].unwrapOr(null),
    relayDispatchQueueSize: relayDispatchQueueSizes[index][0].toNumber()
  }));
}
function overview(instanceId, api) {
  return memo(instanceId, () => {
    var _api$query$registrar;
    return (_api$query$registrar = api.query.registrar) != null && _api$query$registrar.parachains && api.query.parachains ? api.query.registrar.parachains().pipe(switchMap((paraIds) => combineLatest([of(paraIds), api.query.parachains.didUpdate(), api.query.registrar.paras.multi(paraIds), api.query.registrar.pendingSwap.multi(paraIds), api.query.parachains.relayDispatchQueueSize.multi(paraIds)])), map2(parse4)) : of([]);
  });
}

// node_modules/@polkadot/api-derive/session/index.js
var session_exports = {};
__export(session_exports, {
  eraLength: () => eraLength,
  eraProgress: () => eraProgress,
  indexes: () => indexes2,
  info: () => info4,
  progress: () => progress,
  sessionProgress: () => sessionProgress
});

// node_modules/@polkadot/api-derive/session/indexes.js
function parse5([currentIndex, activeEra, activeEraStart, currentEra, validatorCount]) {
  return {
    activeEra,
    activeEraStart,
    currentEra,
    currentIndex,
    validatorCount
  };
}
function queryStaking(api) {
  return api.queryMulti([api.query.session.currentIndex, api.query.staking.activeEra, api.query.staking.currentEra, api.query.staking.validatorCount]).pipe(map2(([currentIndex, activeOpt, currentEra, validatorCount]) => {
    const {
      index,
      start
    } = activeOpt.unwrapOrDefault();
    return parse5([currentIndex, index, start, currentEra.unwrapOrDefault(), validatorCount]);
  }));
}
function querySession(api) {
  return api.query.session.currentIndex().pipe(map2((currentIndex) => parse5([currentIndex, api.registry.createType("EraIndex"), api.registry.createType("Option<Moment>"), api.registry.createType("EraIndex"), api.registry.createType("u32")])));
}
function empty2(api) {
  return of(parse5([api.registry.createType("SessionIndex", 1), api.registry.createType("EraIndex"), api.registry.createType("Option<Moment>"), api.registry.createType("EraIndex"), api.registry.createType("u32")]));
}
function indexes2(instanceId, api) {
  return memo(instanceId, () => api.query.session ? api.query.staking ? queryStaking(api) : querySession(api) : empty2(api));
}

// node_modules/@polkadot/api-derive/session/info.js
function info4(instanceId, api) {
  return memo(instanceId, () => api.derive.session.indexes().pipe(map2((indexes3) => {
    var _api$consts, _api$consts$babe, _api$consts2, _api$consts2$staking;
    const sessionLength = ((_api$consts = api.consts) == null ? void 0 : (_api$consts$babe = _api$consts.babe) == null ? void 0 : _api$consts$babe.epochDuration) || api.registry.createType("u64", 1);
    const sessionsPerEra = ((_api$consts2 = api.consts) == null ? void 0 : (_api$consts2$staking = _api$consts2.staking) == null ? void 0 : _api$consts2$staking.sessionsPerEra) || api.registry.createType("SessionIndex", 1);
    return objectSpread({
      eraLength: api.registry.createType("BlockNumber", sessionsPerEra.mul(sessionLength)),
      isEpoch: !!api.query.babe,
      sessionLength,
      sessionsPerEra
    }, indexes3);
  })));
}

// node_modules/@polkadot/api-derive/session/progress.js
function withProgressField(field) {
  return (instanceId, api) => memo(instanceId, () => api.derive.session.progress().pipe(map2((info6) => info6[field])));
}
function createDerive(api, info6, [currentSlot, epochIndex, epochOrGenesisStartSlot, activeEraStartSessionIndex]) {
  const epochStartSlot = epochIndex.mul(info6.sessionLength).iadd(epochOrGenesisStartSlot);
  const sessionProgress2 = currentSlot.sub(epochStartSlot);
  const eraProgress2 = info6.currentIndex.sub(activeEraStartSessionIndex).imul(info6.sessionLength).iadd(sessionProgress2);
  return objectSpread({
    eraProgress: api.registry.createType("BlockNumber", eraProgress2),
    sessionProgress: api.registry.createType("BlockNumber", sessionProgress2)
  }, info6);
}
function queryAura(api) {
  return api.derive.session.info().pipe(map2((info6) => objectSpread({
    eraProgress: api.registry.createType("BlockNumber"),
    sessionProgress: api.registry.createType("BlockNumber")
  }, info6)));
}
function queryBabe(api) {
  return api.derive.session.info().pipe(switchMap((info6) => {
    var _api$query$staking;
    return combineLatest([
      of(info6),
      (_api$query$staking = api.query.staking) != null && _api$query$staking.erasStartSessionIndex ? api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, [api.query.staking.erasStartSessionIndex, info6.activeEra]]) : api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot])
    ]);
  }), map2(([info6, [currentSlot, epochIndex, genesisSlot, optStartIndex]]) => [info6, [currentSlot, epochIndex, genesisSlot, optStartIndex && optStartIndex.isSome ? optStartIndex.unwrap() : api.registry.createType("SessionIndex", 1)]]));
}
function progress(instanceId, api) {
  return memo(instanceId, () => api.query.babe ? queryBabe(api).pipe(map2(([info6, slots]) => createDerive(api, info6, slots))) : queryAura(api));
}
var eraLength = withProgressField("eraLength");
var eraProgress = withProgressField("eraProgress");
var sessionProgress = withProgressField("sessionProgress");

// node_modules/@polkadot/api-derive/society/index.js
var society_exports = {};
__export(society_exports, {
  _members: () => _members,
  candidates: () => candidates,
  info: () => info5,
  member: () => member,
  members: () => members5
});

// node_modules/@polkadot/api-derive/society/candidates.js
function candidates(instanceId, api) {
  return memo(instanceId, () => api.query.society.candidates().pipe(switchMap((candidates2) => combineLatest([of(candidates2), api.query.society.suspendedCandidates.multi(candidates2.map(({
    who
  }) => who))])), map2(([candidates2, suspended]) => candidates2.map(({
    kind,
    value,
    who
  }, index) => ({
    accountId: who,
    isSuspended: suspended[index].isSome,
    kind,
    value
  })))));
}

// node_modules/@polkadot/api-derive/society/info.js
function info5(instanceId, api) {
  return memo(instanceId, () => api.queryMulti([api.query.society.bids, api.query.society.defender, api.query.society.founder, api.query.society.head, api.query.society.maxMembers, api.query.society.pot]).pipe(map2(([bids, defender, founder, head, maxMembers, pot]) => ({
    bids,
    defender: defender.unwrapOr(void 0),
    founder: founder.unwrapOr(void 0),
    hasDefender: defender.isSome && head.isSome && !head.eq(defender) || false,
    head: head.unwrapOr(void 0),
    maxMembers,
    pot
  }))));
}

// node_modules/@polkadot/api-derive/society/member.js
function member(instanceId, api) {
  return memo(instanceId, (accountId2) => api.derive.society._members([accountId2]).pipe(map2(([result]) => result)));
}

// node_modules/@polkadot/api-derive/society/members.js
function _members(instanceId, api) {
  return memo(instanceId, (accountIds) => combineLatest([of(accountIds), api.query.society.payouts.multi(accountIds), api.query.society.strikes.multi(accountIds), api.query.society.defenderVotes.multi(accountIds), api.query.society.suspendedMembers.multi(accountIds), api.query.society.vouching.multi(accountIds)]).pipe(map2(([accountIds2, payouts, strikes, defenderVotes, suspended, vouching]) => accountIds2.map((accountId2, index) => ({
    accountId: accountId2,
    isDefenderVoter: defenderVotes[index].isSome,
    isSuspended: suspended[index].isTrue,
    payouts: payouts[index],
    strikes: strikes[index],
    vote: defenderVotes[index].unwrapOr(void 0),
    vouching: vouching[index].unwrapOr(void 0)
  })))));
}
function members5(instanceId, api) {
  return memo(instanceId, () => api.query.society.members().pipe(switchMap((members7) => api.derive.society._members(members7))));
}

// node_modules/@polkadot/api-derive/staking/index.js
var staking_exports = {};
__export(staking_exports, {
  _eraExposure: () => _eraExposure,
  _eraPrefs: () => _eraPrefs,
  _eraSlashes: () => _eraSlashes,
  _erasExposure: () => _erasExposure,
  _erasPoints: () => _erasPoints,
  _erasPrefs: () => _erasPrefs,
  _erasRewards: () => _erasRewards,
  _erasSlashes: () => _erasSlashes,
  _ownExposures: () => _ownExposures,
  _ownSlashes: () => _ownSlashes,
  _stakerExposures: () => _stakerExposures,
  _stakerPoints: () => _stakerPoints,
  _stakerPrefs: () => _stakerPrefs,
  _stakerRewards: () => _stakerRewards,
  _stakerRewardsEras: () => _stakerRewardsEras,
  _stakerSlashes: () => _stakerSlashes,
  account: () => account2,
  accounts: () => accounts,
  currentPoints: () => currentPoints,
  electedInfo: () => electedInfo,
  eraExposure: () => eraExposure,
  eraPrefs: () => eraPrefs,
  eraSlashes: () => eraSlashes,
  erasExposure: () => erasExposure,
  erasHistoric: () => erasHistoric,
  erasPoints: () => erasPoints,
  erasPrefs: () => erasPrefs,
  erasRewards: () => erasRewards,
  erasSlashes: () => erasSlashes,
  keys: () => keys,
  keysMulti: () => keysMulti,
  nextElected: () => nextElected,
  overview: () => overview2,
  ownExposure: () => ownExposure,
  ownExposures: () => ownExposures,
  ownSlash: () => ownSlash,
  ownSlashes: () => ownSlashes,
  query: () => query,
  queryMulti: () => queryMulti,
  stakerExposure: () => stakerExposure,
  stakerExposures: () => stakerExposures,
  stakerPoints: () => stakerPoints,
  stakerPrefs: () => stakerPrefs,
  stakerRewards: () => stakerRewards,
  stakerRewardsMulti: () => stakerRewardsMulti,
  stakerRewardsMultiEras: () => stakerRewardsMultiEras,
  stakerSlashes: () => stakerSlashes,
  stashes: () => stashes,
  validators: () => validators,
  waitingInfo: () => waitingInfo
});

// node_modules/@polkadot/api-derive/staking/account.js
var QUERY_OPTS = {
  withDestination: true,
  withLedger: true,
  withNominations: true,
  withPrefs: true
};
function groupByEra(list) {
  return list.reduce((map3, {
    era,
    value
  }) => {
    const key = era.toString();
    map3[key] = (map3[key] || BN_ZERO).add(value.unwrap());
    return map3;
  }, {});
}
function calculateUnlocking(api, stakingLedger, sessionInfo) {
  const results = Object.entries(groupByEra(((stakingLedger == null ? void 0 : stakingLedger.unlocking) || []).filter(({
    era
  }) => era.unwrap().gt(sessionInfo.activeEra)))).map(([eraString, value]) => ({
    remainingEras: new import_bn.default(eraString).isub(sessionInfo.activeEra),
    value: api.registry.createType("Balance", value)
  }));
  return results.length ? results : void 0;
}
function redeemableSum(api, stakingLedger, sessionInfo) {
  return api.registry.createType("Balance", ((stakingLedger == null ? void 0 : stakingLedger.unlocking) || []).reduce((total, {
    era,
    value
  }) => {
    return era.unwrap().gt(sessionInfo.currentEra) ? total : total.iadd(value.unwrap());
  }, new import_bn.default(0)));
}
function parseResult2(api, sessionInfo, keys2, query2) {
  return objectSpread({}, keys2, query2, {
    redeemable: redeemableSum(api, query2.stakingLedger, sessionInfo),
    unlocking: calculateUnlocking(api, query2.stakingLedger, sessionInfo)
  });
}
function accounts(instanceId, api) {
  return memo(instanceId, (accountIds, opts = QUERY_OPTS) => api.derive.session.info().pipe(switchMap((sessionInfo) => combineLatest([api.derive.staking.keysMulti(accountIds), api.derive.staking.queryMulti(accountIds, opts)]).pipe(map2(([keys2, queries]) => queries.map((q, index) => parseResult2(api, sessionInfo, keys2[index], q)))))));
}
var account2 = firstMemo((api, accountId2, opts) => api.derive.staking.accounts([accountId2], opts));

// node_modules/@polkadot/api-derive/staking/currentPoints.js
function currentPoints(instanceId, api) {
  return memo(instanceId, () => api.derive.session.indexes().pipe(switchMap(({
    activeEra
  }) => api.query.staking.erasRewardPoints(activeEra))));
}

// node_modules/@polkadot/api-derive/staking/cache.js
function getEraCache(CACHE_KEY6, era, withActive) {
  const cacheKey = `${CACHE_KEY6}-${era.toString()}`;
  return [cacheKey, withActive ? void 0 : deriveCache.get(cacheKey)];
}
function getEraMultiCache(CACHE_KEY6, eras, withActive) {
  const cached = withActive ? [] : eras.map((e) => deriveCache.get(`${CACHE_KEY6}-${e.toString()}`)).filter((v) => !!v);
  return cached;
}
function setEraCache(cacheKey, withActive, value) {
  !withActive && deriveCache.set(cacheKey, value);
  return value;
}
function setEraMultiCache(CACHE_KEY6, withActive, values) {
  !withActive && values.forEach((v) => deriveCache.set(`${CACHE_KEY6}-${v.era.toString()}`, v));
  return values;
}
function filterCachedEras(eras, cached, query2) {
  return eras.map((e) => cached.find(({
    era
  }) => e.eq(era)) || query2.find(({
    era
  }) => e.eq(era)));
}

// node_modules/@polkadot/api-derive/staking/util.js
var ERA_CHUNK_SIZE = 14;
function chunkEras(eras, fn) {
  const chunked = arrayChunk(eras, ERA_CHUNK_SIZE);
  let index = 0;
  const subject = new BehaviorSubject(chunked[index]);
  return subject.pipe(switchMap(fn), tap(() => {
    nextTick(() => {
      index++;
      index === chunked.length ? subject.complete() : subject.next(chunked[index]);
    });
  }), toArray(), map2(arrayFlatten));
}
function filterEras(eras, list) {
  return eras.filter((e) => !list.some(({
    era
  }) => e.eq(era)));
}
function erasHistoricApply(fn) {
  return (instanceId, api) => memo(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((e) => api.derive.staking[fn](e, withActive))));
}
function erasHistoricApplyAccount(fn) {
  return (instanceId, api) => memo(instanceId, (accountId2, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((e) => api.derive.staking[fn](accountId2, e, withActive))));
}
function singleEra(fn) {
  return (instanceId, api) => memo(instanceId, (era) => api.derive.staking[fn](era, true));
}
function combineEras(fn) {
  return (instanceId, api) => memo(instanceId, (eras, withActive) => !eras.length ? of([]) : chunkEras(eras, (eras2) => combineLatest(eras2.map((e) => api.derive.staking[fn](e, withActive)))));
}

// node_modules/@polkadot/api-derive/staking/erasExposure.js
var CACHE_KEY = "eraExposure";
function mapStakers(era, stakers) {
  const nominators = {};
  const validators2 = {};
  stakers.forEach(([key, exposure]) => {
    const validatorId = key.args[1].toString();
    validators2[validatorId] = exposure;
    exposure.others.forEach(({
      who
    }, validatorIndex) => {
      const nominatorId = who.toString();
      nominators[nominatorId] = nominators[nominatorId] || [];
      nominators[nominatorId].push({
        validatorId,
        validatorIndex
      });
    });
  });
  return {
    era,
    nominators,
    validators: validators2
  };
}
function _eraExposure(instanceId, api) {
  return memo(instanceId, (era, withActive = false) => {
    const [cacheKey, cached] = getEraCache(CACHE_KEY, era, withActive);
    return cached ? of(cached) : api.query.staking.erasStakersClipped.entries(era).pipe(map2((r) => setEraCache(cacheKey, withActive, mapStakers(era, r))));
  });
}
var eraExposure = singleEra("_eraExposure");
var _erasExposure = combineEras("_eraExposure");
var erasExposure = erasHistoricApply("_erasExposure");

// node_modules/@polkadot/api-derive/staking/erasHistoric.js
function erasHistoric(instanceId, api) {
  return memo(instanceId, (withActive) => combineLatest([api.query.staking.activeEra(), api.consts.staking.historyDepth ? of(api.consts.staking.historyDepth) : api.query.staking.historyDepth()]).pipe(map2(([activeEraOpt, historyDepth]) => {
    const result = [];
    const max3 = historyDepth.toNumber();
    const activeEra = activeEraOpt.unwrapOrDefault().index;
    let lastEra = activeEra;
    while (lastEra.gte(BN_ZERO) && result.length < max3) {
      if (lastEra !== activeEra || withActive === true) {
        result.push(api.registry.createType("EraIndex", lastEra));
      }
      lastEra = lastEra.sub(BN_ONE);
    }
    return result.reverse();
  })));
}

// node_modules/@polkadot/api-derive/staking/erasPoints.js
var CACHE_KEY2 = "eraPoints";
function mapValidators({
  individual
}) {
  return [...individual.entries()].filter(([, points]) => points.gt(BN_ZERO)).reduce((result, [validatorId, points]) => {
    result[validatorId.toString()] = points;
    return result;
  }, {});
}
function mapPoints(eras, points) {
  return eras.map((era, index) => ({
    era,
    eraPoints: points[index].total,
    validators: mapValidators(points[index])
  }));
}
function _erasPoints(instanceId, api) {
  return memo(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return of([]);
    }
    const cached = getEraMultiCache(CACHE_KEY2, eras, withActive);
    const remaining = filterEras(eras, cached);
    return !remaining.length ? of(cached) : api.query.staking.erasRewardPoints.multi(remaining).pipe(map2((p) => filterCachedEras(eras, cached, setEraMultiCache(CACHE_KEY2, withActive, mapPoints(remaining, p)))));
  });
}
var erasPoints = erasHistoricApply("_erasPoints");

// node_modules/@polkadot/api-derive/staking/erasPrefs.js
var CACHE_KEY3 = "eraPrefs";
function mapPrefs(era, all3) {
  const validators2 = {};
  all3.forEach(([key, prefs]) => {
    validators2[key.args[1].toString()] = prefs;
  });
  return {
    era,
    validators: validators2
  };
}
function _eraPrefs(instanceId, api) {
  return memo(instanceId, (era, withActive) => {
    const [cacheKey, cached] = getEraCache(CACHE_KEY3, era, withActive);
    return cached ? of(cached) : api.query.staking.erasValidatorPrefs.entries(era).pipe(map2((r) => setEraCache(cacheKey, withActive, mapPrefs(era, r))));
  });
}
var eraPrefs = singleEra("_eraPrefs");
var _erasPrefs = combineEras("_eraPrefs");
var erasPrefs = erasHistoricApply("_erasPrefs");

// node_modules/@polkadot/api-derive/staking/erasRewards.js
var CACHE_KEY4 = "eraRewards";
function mapRewards(eras, optRewards) {
  return eras.map((era, index) => ({
    era,
    eraReward: optRewards[index].unwrapOrDefault()
  }));
}
function _erasRewards(instanceId, api) {
  return memo(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return of([]);
    }
    const cached = getEraMultiCache(CACHE_KEY4, eras, withActive);
    const remaining = filterEras(eras, cached);
    if (!remaining.length) {
      return of(cached);
    }
    return api.query.staking.erasValidatorReward.multi(remaining).pipe(map2((r) => filterCachedEras(eras, cached, setEraMultiCache(CACHE_KEY4, withActive, mapRewards(remaining, r)))));
  });
}
var erasRewards = erasHistoricApply("_erasRewards");

// node_modules/@polkadot/api-derive/staking/erasSlashes.js
var CACHE_KEY5 = "eraSlashes";
function mapSlashes(era, noms, vals) {
  const nominators = {};
  const validators2 = {};
  noms.forEach(([key, optBalance]) => {
    nominators[key.args[1].toString()] = optBalance.unwrap();
  });
  vals.forEach(([key, optRes]) => {
    validators2[key.args[1].toString()] = optRes.unwrapOrDefault()[1];
  });
  return {
    era,
    nominators,
    validators: validators2
  };
}
function _eraSlashes(instanceId, api) {
  return memo(instanceId, (era, withActive) => {
    const [cacheKey, cached] = getEraCache(CACHE_KEY5, era, withActive);
    return cached ? of(cached) : combineLatest([api.query.staking.nominatorSlashInEra.entries(era), api.query.staking.validatorSlashInEra.entries(era)]).pipe(map2(([n, v]) => setEraCache(cacheKey, withActive, mapSlashes(era, n, v))));
  });
}
var eraSlashes = singleEra("_eraSlashes");
var _erasSlashes = combineEras("_eraSlashes");
var erasSlashes = erasHistoricApply("_erasSlashes");

// node_modules/@polkadot/api-derive/staking/electedInfo.js
var DEFAULT_FLAGS = {
  withController: true,
  withExposure: true,
  withPrefs: true
};
function combineAccounts(nextElected2, validators2) {
  return arrayFlatten([nextElected2, validators2.filter((v) => !nextElected2.find((n) => n.eq(v)))]);
}
function electedInfo(instanceId, api) {
  return memo(instanceId, (flags2 = DEFAULT_FLAGS) => api.derive.staking.validators().pipe(switchMap(({
    nextElected: nextElected2,
    validators: validators2
  }) => api.derive.staking.queryMulti(combineAccounts(nextElected2, validators2), flags2).pipe(map2((info6) => ({
    info: info6,
    nextElected: nextElected2,
    validators: validators2
  }))))));
}

// node_modules/@polkadot/api-derive/staking/keys.js
function extractsIds(stashId, queuedKeys, nextKeys) {
  const sessionIds = (queuedKeys.find(([currentId]) => currentId.eq(stashId)) || [void 0, []])[1];
  const nextSessionIds = nextKeys.unwrapOr([]);
  return {
    nextSessionIds: Array.isArray(nextSessionIds) ? nextSessionIds : [...nextSessionIds.values()],
    sessionIds: Array.isArray(sessionIds) ? sessionIds : [...sessionIds.values()]
  };
}
var keys = firstMemo((api, stashId) => api.derive.staking.keysMulti([stashId]));
function keysMulti(instanceId, api) {
  return memo(instanceId, (stashIds) => stashIds.length ? api.query.session.queuedKeys().pipe(switchMap((queuedKeys) => {
    var _api$consts$session;
    return combineLatest([of(queuedKeys), (_api$consts$session = api.consts.session) != null && _api$consts$session.dedupKeyPrefix ? api.query.session.nextKeys.multi(stashIds.map((s) => [api.consts.session.dedupKeyPrefix, s])) : combineLatest(stashIds.map((s) => api.query.session.nextKeys(s)))]);
  }), map2(([queuedKeys, nextKeys]) => stashIds.map((stashId, index) => extractsIds(stashId, queuedKeys, nextKeys[index])))) : of([]));
}

// node_modules/@polkadot/api-derive/staking/overview.js
function overview2(instanceId, api) {
  return memo(instanceId, () => combineLatest([api.derive.session.indexes(), api.derive.staking.validators()]).pipe(map2(([indexes3, {
    nextElected: nextElected2,
    validators: validators2
  }]) => objectSpread({}, indexes3, {
    nextElected: nextElected2,
    validators: validators2
  }))));
}

// node_modules/@polkadot/api-derive/staking/ownExposure.js
function _ownExposures(instanceId, api) {
  return memo(instanceId, (accountId2, eras, _withActive) => eras.length ? combineLatest([combineLatest(eras.map((e) => api.query.staking.erasStakersClipped(e, accountId2))), combineLatest(eras.map((e) => api.query.staking.erasStakers(e, accountId2)))]).pipe(map2(([clp, exp]) => eras.map((era, index) => ({
    clipped: clp[index],
    era,
    exposure: exp[index]
  })))) : of([]));
}
var ownExposure = firstMemo((api, accountId2, era) => api.derive.staking._ownExposures(accountId2, [era], true));
var ownExposures = erasHistoricApplyAccount("_ownExposures");

// node_modules/@polkadot/api-derive/staking/ownSlashes.js
function _ownSlashes(instanceId, api) {
  return memo(instanceId, (accountId2, eras, _withActive) => eras.length ? combineLatest([combineLatest(eras.map((e) => api.query.staking.validatorSlashInEra(e, accountId2))), combineLatest(eras.map((e) => api.query.staking.nominatorSlashInEra(e, accountId2)))]).pipe(map2(([vals, noms]) => eras.map((era, index) => ({
    era,
    total: vals[index].isSome ? vals[index].unwrap()[1] : noms[index].unwrapOrDefault()
  })))) : of([]));
}
var ownSlash = firstMemo((api, accountId2, era) => api.derive.staking._ownSlashes(accountId2, [era], true));
var ownSlashes = erasHistoricApplyAccount("_ownSlashes");

// node_modules/@polkadot/api-derive/staking/query.js
function parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, stakingLedgerOpt) {
  return {
    accountId: stashId,
    controllerId: controllerIdOpt && controllerIdOpt.unwrapOr(null),
    exposure,
    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],
    rewardDestination,
    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
    stashId,
    validatorPrefs
  };
}
function getLedgers(api, optIds, {
  withLedger = false
}) {
  const ids = optIds.filter((o) => withLedger && !!o && o.isSome).map((o) => o.unwrap());
  const emptyLed = api.registry.createType("Option<StakingLedger>");
  return (ids.length ? combineLatest(ids.map((s) => api.query.staking.ledger(s))) : of([])).pipe(map2((optLedgers) => {
    let offset = -1;
    return optIds.map((o) => o && o.isSome ? optLedgers[++offset] || emptyLed : emptyLed);
  }));
}
function getStashInfo(api, stashIds, activeEra, {
  withController,
  withDestination,
  withExposure,
  withLedger,
  withNominations,
  withPrefs
}) {
  const emptyNoms = api.registry.createType("Option<Nominations>");
  const emptyRewa = api.registry.createType("RewardDestination");
  const emptyExpo = api.registry.createType("Exposure");
  const emptyPrefs = api.registry.createType("ValidatorPrefs");
  return combineLatest([withController || withLedger ? combineLatest(stashIds.map((s) => api.query.staking.bonded(s))) : of(stashIds.map(() => null)), withNominations ? combineLatest(stashIds.map((s) => api.query.staking.nominators(s))) : of(stashIds.map(() => emptyNoms)), withDestination ? combineLatest(stashIds.map((s) => api.query.staking.payee(s))) : of(stashIds.map(() => emptyRewa)), withPrefs ? combineLatest(stashIds.map((s) => api.query.staking.validators(s))) : of(stashIds.map(() => emptyPrefs)), withExposure ? combineLatest(stashIds.map((s) => api.query.staking.erasStakers(activeEra, s))) : of(stashIds.map(() => emptyExpo))]);
}
function getBatch(api, activeEra, stashIds, flags2) {
  return getStashInfo(api, stashIds, activeEra, flags2).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => getLedgers(api, controllerIdOpt, flags2).pipe(map2((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));
}
var query = firstMemo((api, accountId2, flags2) => api.derive.staking.queryMulti([accountId2], flags2));
function queryMulti(instanceId, api) {
  return memo(instanceId, (accountIds, flags2) => api.derive.session.indexes().pipe(switchMap(({
    activeEra
  }) => {
    const stashIds = accountIds.map((a) => api.registry.createType("AccountId", a));
    return stashIds.length ? getBatch(api, activeEra, stashIds, flags2) : of([]);
  })));
}

// node_modules/@polkadot/api-derive/staking/stakerExposure.js
function _stakerExposures(instanceId, api) {
  return memo(instanceId, (accountIds, eras, withActive = false) => {
    const stakerIds = accountIds.map((a) => api.registry.createType("AccountId", a).toString());
    return api.derive.staking._erasExposure(eras, withActive).pipe(map2((exposures) => stakerIds.map((stakerId) => exposures.map(({
      era,
      nominators: allNominators,
      validators: allValidators
    }) => {
      const isValidator = !!allValidators[stakerId];
      const validators2 = {};
      const nominating = allNominators[stakerId] || [];
      if (isValidator) {
        validators2[stakerId] = allValidators[stakerId];
      } else if (nominating) {
        nominating.forEach(({
          validatorId
        }) => {
          validators2[validatorId] = allValidators[validatorId];
        });
      }
      return {
        era,
        isEmpty: !Object.keys(validators2).length,
        isValidator,
        nominating,
        validators: validators2
      };
    }))));
  });
}
function stakerExposures(instanceId, api) {
  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking._stakerExposures(accountIds, eras, withActive))));
}
var stakerExposure = firstMemo((api, accountId2, withActive) => api.derive.staking.stakerExposures([accountId2], withActive));

// node_modules/@polkadot/api-derive/staking/stakerPoints.js
function _stakerPoints(instanceId, api) {
  return memo(instanceId, (accountId2, eras, withActive) => {
    const stakerId = api.registry.createType("AccountId", accountId2).toString();
    return api.derive.staking._erasPoints(eras, withActive).pipe(map2((points) => points.map(({
      era,
      eraPoints,
      validators: validators2
    }) => ({
      era,
      eraPoints,
      points: validators2[stakerId] || api.registry.createType("RewardPoint")
    }))));
  });
}
var stakerPoints = erasHistoricApplyAccount("_stakerPoints");

// node_modules/@polkadot/api-derive/staking/stakerPrefs.js
function _stakerPrefs(instanceId, api) {
  return memo(instanceId, (accountId2, eras, _withActive) => api.query.staking.erasValidatorPrefs.multi(eras.map((e) => [e, accountId2])).pipe(map2((all3) => all3.map((validatorPrefs, index) => ({
    era: eras[index],
    validatorPrefs
  })))));
}
var stakerPrefs = erasHistoricApplyAccount("_stakerPrefs");

// node_modules/@polkadot/api-derive/staking/stakerRewards.js
function parseRewards(api, stashId, [erasPoints2, erasPrefs2, erasRewards2], exposures) {
  return exposures.map(({
    era,
    isEmpty: isEmpty2,
    isValidator,
    nominating,
    validators: eraValidators
  }) => {
    const {
      eraPoints,
      validators: allValPoints
    } = erasPoints2.find((p) => p.era.eq(era)) || {
      eraPoints: BN_ZERO,
      validators: {}
    };
    const {
      eraReward
    } = erasRewards2.find((r) => r.era.eq(era)) || {
      eraReward: api.registry.createType("Balance")
    };
    const {
      validators: allValPrefs
    } = erasPrefs2.find((p) => p.era.eq(era)) || {
      validators: {}
    };
    const validators2 = {};
    const stakerId = stashId.toString();
    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {
      var _allValPrefs$validato, _exposure$total;
      const valPoints = allValPoints[validatorId] || BN_ZERO;
      const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) == null ? void 0 : _allValPrefs$validato.commission.unwrap()) || BN_ZERO;
      const expTotal = ((_exposure$total = exposure.total) == null ? void 0 : _exposure$total.unwrap()) || BN_ZERO;
      let avail = BN_ZERO;
      let value;
      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {
        avail = eraReward.mul(valPoints).div(eraPoints);
        const valCut = valComm.mul(avail).div(BN_BILLION);
        let staked;
        if (validatorId === stakerId) {
          staked = exposure.own.unwrap();
        } else {
          const stakerExp = exposure.others.find(({
            who
          }) => who.eq(stakerId));
          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;
        }
        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);
      }
      validators2[validatorId] = {
        total: api.registry.createType("Balance", avail),
        value: api.registry.createType("Balance", value)
      };
    });
    return {
      era,
      eraReward,
      isEmpty: isEmpty2,
      isValidator,
      nominating,
      validators: validators2
    };
  });
}
function allUniqValidators(rewards) {
  return rewards.reduce(([all3, perStash], rewards2) => {
    const uniq = [];
    perStash.push(uniq);
    rewards2.forEach(({
      validators: validators2
    }) => Object.keys(validators2).forEach((validatorId) => {
      if (!uniq.includes(validatorId)) {
        uniq.push(validatorId);
        if (!all3.includes(validatorId)) {
          all3.push(validatorId);
        }
      }
    }));
    return [all3, perStash];
  }, [[], []]);
}
function removeClaimed(validators2, queryValidators, reward) {
  const rm = [];
  Object.keys(reward.validators).forEach((validatorId) => {
    const index = validators2.indexOf(validatorId);
    if (index !== -1) {
      const valLedger = queryValidators[index].stakingLedger;
      if (valLedger != null && valLedger.claimedRewards.some((e) => reward.era.eq(e))) {
        rm.push(validatorId);
      }
    }
  });
  rm.forEach((validatorId) => {
    delete reward.validators[validatorId];
  });
}
function filterRewards(eras, valInfo, {
  rewards,
  stakingLedger
}) {
  const filter2 = eras.filter((e) => !stakingLedger.claimedRewards.some((s) => s.eq(e)));
  const validators2 = valInfo.map(([v]) => v);
  const queryValidators = valInfo.map(([, q]) => q);
  return rewards.filter(({
    isEmpty: isEmpty2
  }) => !isEmpty2).filter((reward) => {
    if (!filter2.some((e) => reward.era.eq(e))) {
      return false;
    }
    removeClaimed(validators2, queryValidators, reward);
    return true;
  }).filter(({
    validators: validators3
  }) => Object.keys(validators3).length !== 0).map((reward) => objectSpread({}, reward, {
    nominators: reward.nominating.filter((n) => reward.validators[n.validatorId])
  }));
}
function _stakerRewardsEras(instanceId, api) {
  return memo(instanceId, (eras, withActive = false) => combineLatest([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));
}
function _stakerRewards(instanceId, api) {
  return memo(instanceId, (accountIds, eras, withActive = false) => combineLatest([api.derive.staking.queryMulti(accountIds, {
    withLedger: true
  }), api.derive.staking._stakerExposures(accountIds, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe(switchMap(([queries, exposures, erasResult]) => {
    const allRewards = queries.map(({
      stakingLedger,
      stashId
    }, index) => !stashId || !stakingLedger ? [] : parseRewards(api, stashId, erasResult, exposures[index]));
    if (withActive) {
      return of(allRewards);
    }
    const [allValidators, stashValidators] = allUniqValidators(allRewards);
    return api.derive.staking.queryMulti(allValidators, {
      withLedger: true
    }).pipe(map2((queriedVals) => queries.map(({
      stakingLedger
    }, index) => filterRewards(eras, stashValidators[index].map((validatorId) => [validatorId, queriedVals.find((q) => q.accountId.eq(validatorId))]), {
      rewards: allRewards[index],
      stakingLedger
    }))));
  })));
}
var stakerRewards = firstMemo((api, accountId2, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking._stakerRewards([accountId2], eras, withActive))));
function stakerRewardsMultiEras(instanceId, api) {
  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : of([]));
}
function stakerRewardsMulti(instanceId, api) {
  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));
}

// node_modules/@polkadot/api-derive/staking/stakerSlashes.js
function _stakerSlashes(instanceId, api) {
  return memo(instanceId, (accountId2, eras, withActive) => {
    const stakerId = api.registry.createType("AccountId", accountId2).toString();
    return api.derive.staking._erasSlashes(eras, withActive).pipe(map2((slashes) => slashes.map(({
      era,
      nominators,
      validators: validators2
    }) => ({
      era,
      total: nominators[stakerId] || validators2[stakerId] || api.registry.createType("Balance")
    }))));
  });
}
var stakerSlashes = erasHistoricApplyAccount("_stakerSlashes");

// node_modules/@polkadot/api-derive/staking/stashes.js
function onBondedEvent(api) {
  let current = Date.now();
  return api.query.system.events().pipe(map2((events2) => {
    current = events2.filter(({
      event,
      phase
    }) => {
      try {
        return phase.isApplyExtrinsic && event.section === "staking" && event.method === "Bonded";
      } catch {
        return false;
      }
    }) ? Date.now() : current;
    return current;
  }), startWith(current), drr({
    skipTimeout: true
  }));
}
function stashes(instanceId, api) {
  return memo(instanceId, () => onBondedEvent(api).pipe(switchMap(() => api.query.staking.validators.keys()), map2((keys2) => keys2.map(({
    args: [v]
  }) => v).filter((a) => a))));
}

// node_modules/@polkadot/api-derive/staking/validators.js
function nextElected(instanceId, api) {
  return memo(instanceId, () => api.query.staking.erasStakers ? api.derive.session.indexes().pipe(switchMap(({
    currentEra
  }) => api.query.staking.erasStakers.keys(currentEra)), map2((keys2) => keys2.map(({
    args: [, accountId2]
  }) => accountId2))) : api.query.staking.currentElected());
}
function validators(instanceId, api) {
  return memo(instanceId, () => combineLatest([api.query.session ? api.query.session.validators() : of([]), api.query.staking ? api.derive.staking.nextElected() : of([])]).pipe(map2(([validators2, nextElected2]) => ({
    nextElected: nextElected2.length ? nextElected2 : validators2,
    validators: validators2
  }))));
}

// node_modules/@polkadot/api-derive/staking/waitingInfo.js
var DEFAULT_FLAGS2 = {
  withController: true,
  withPrefs: true
};
function waitingInfo(instanceId, api) {
  return memo(instanceId, (flags2 = DEFAULT_FLAGS2) => combineLatest([api.derive.staking.validators(), api.derive.staking.stashes()]).pipe(switchMap(([{
    nextElected: nextElected2
  }, stashes2]) => {
    const elected = nextElected2.map((a) => a.toString());
    const waiting = stashes2.filter((v) => !elected.includes(v.toString()));
    return api.derive.staking.queryMulti(waiting, flags2).pipe(map2((info6) => ({
      info: info6,
      waiting
    })));
  })));
}

// node_modules/@polkadot/api-derive/technicalCommittee/index.js
var technicalCommittee_exports = {};
__export(technicalCommittee_exports, {
  hasProposals: () => hasProposals5,
  members: () => members6,
  prime: () => prime5,
  proposal: () => proposal5,
  proposalCount: () => proposalCount5,
  proposalHashes: () => proposalHashes5,
  proposals: () => proposals6
});
var members6 = members("technicalCommittee");
var hasProposals5 = hasProposals("technicalCommittee");
var proposal5 = proposal("technicalCommittee");
var proposalCount5 = proposalCount("technicalCommittee");
var proposalHashes5 = proposalHashes("technicalCommittee");
var proposals6 = proposals("technicalCommittee");
var prime5 = prime("technicalCommittee");

// node_modules/@polkadot/api-derive/treasury/index.js
var treasury_exports = {};
__export(treasury_exports, {
  proposals: () => proposals7
});

// node_modules/@polkadot/api-derive/treasury/proposals.js
function parseResult3(api, {
  allIds,
  allProposals,
  approvalIds,
  councilProposals,
  proposalCount: proposalCount6
}) {
  const approvals = [];
  const proposals8 = [];
  const councilTreasury = councilProposals.filter(({
    proposal: proposal6
  }) => proposal6 && (api.tx.treasury.approveProposal.is(proposal6) || api.tx.treasury.rejectProposal.is(proposal6)));
  allIds.forEach((id2, index) => {
    if (allProposals[index].isSome) {
      const council = councilTreasury.filter(({
        proposal: proposal6
      }) => proposal6 && id2.eq(proposal6.args[0])).sort((a, b) => a.proposal && b.proposal ? a.proposal.method.localeCompare(b.proposal.method) : a.proposal ? -1 : 1);
      const isApproval = approvalIds.some((approvalId) => approvalId.eq(id2));
      const derived = {
        council,
        id: id2,
        proposal: allProposals[index].unwrap()
      };
      if (isApproval) {
        approvals.push(derived);
      } else {
        proposals8.push(derived);
      }
    }
  });
  return {
    approvals,
    proposalCount: proposalCount6,
    proposals: proposals8
  };
}
function retrieveProposals(api, proposalCount6, approvalIds) {
  const proposalIds = [];
  const count2 = proposalCount6.toNumber();
  for (let index = 0; index < count2; index++) {
    if (!approvalIds.some((id2) => id2.eqn(index))) {
      proposalIds.push(api.registry.createType("ProposalIndex", index));
    }
  }
  const allIds = [...proposalIds, ...approvalIds];
  return combineLatest([api.query.treasury.proposals.multi(allIds), api.derive.council ? api.derive.council.proposals() : of([])]).pipe(map2(([allProposals, councilProposals]) => parseResult3(api, {
    allIds,
    allProposals,
    approvalIds,
    councilProposals,
    proposalCount: proposalCount6
  })));
}
function proposals7(instanceId, api) {
  return memo(instanceId, () => api.query.treasury ? combineLatest([api.query.treasury.proposalCount(), api.query.treasury.approvals()]).pipe(switchMap(([proposalCount6, approvalIds]) => retrieveProposals(api, proposalCount6, approvalIds))) : of({
    approvals: [],
    proposalCount: api.registry.createType("ProposalIndex"),
    proposals: []
  }));
}

// node_modules/@polkadot/api-derive/tx/index.js
var tx_exports = {};
__export(tx_exports, {
  events: () => events,
  signingInfo: () => signingInfo
});

// node_modules/@polkadot/api-derive/tx/events.js
function events(instanceId, api) {
  return memo(instanceId, (blockHash) => combineLatest([api.rpc.chain.getBlock(blockHash), api.queryAt(blockHash).pipe(switchMap((queryAt) => queryAt.system.events()))]).pipe(map2(([block, events2]) => ({
    block,
    events: events2
  }))));
}

// node_modules/@polkadot/api-derive/tx/constants.js
var FALLBACK_MAX_HASH_COUNT = 250;
var FALLBACK_PERIOD = new import_bn.default(6 * 1e3);
var MAX_FINALITY_LAG = new import_bn.default(5);
var MORTAL_PERIOD = new import_bn.default(5 * 60 * 1e3);

// node_modules/@polkadot/api-derive/tx/signingInfo.js
function latestNonce(api, address) {
  return api.derive.balances.account(address).pipe(map2(({
    accountNonce
  }) => accountNonce));
}
function nextNonce(api, address) {
  var _api$rpc$system;
  return (_api$rpc$system = api.rpc.system) != null && _api$rpc$system.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);
}
function signingHeader(api) {
  return combineLatest([api.rpc.chain.getHeader().pipe(switchMap((header) => header.parentHash.isEmpty ? of(header) : api.rpc.chain.getHeader(header.parentHash))), api.rpc.chain.getFinalizedHead().pipe(switchMap((hash2) => api.rpc.chain.getHeader(hash2)))]).pipe(map2(([current, finalized]) => unwrapBlockNumber(current).sub(unwrapBlockNumber(finalized)).gt(MAX_FINALITY_LAG) ? current : finalized));
}
function signingInfo(_instanceId3, api) {
  return (address, nonce, era) => combineLatest([
    isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : of(api.registry.createType("Index", nonce)),
    isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : of(null)
  ]).pipe(map2(([nonce2, header]) => {
    var _api$consts$system, _api$consts$system$bl, _api$consts$babe, _api$consts$timestamp;
    return {
      header,
      mortalLength: Math.min(((_api$consts$system = api.consts.system) == null ? void 0 : (_api$consts$system$bl = _api$consts$system.blockHashCount) == null ? void 0 : _api$consts$system$bl.toNumber()) || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(((_api$consts$babe = api.consts.babe) == null ? void 0 : _api$consts$babe.expectedBlockTime) || ((_api$consts$timestamp = api.consts.timestamp) == null ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2)) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),
      nonce: nonce2
    };
  }));
}

// node_modules/@polkadot/api-derive/derive.js
var derive = {
  accounts: accounts_exports,
  alliance: alliance_exports,
  bagsList: bagsList_exports,
  balances: balances_exports,
  bounties: bounties_exports,
  chain: chain_exports,
  contracts: contracts_exports,
  council: council_exports,
  crowdloan: crowdloan_exports,
  democracy: democracy_exports,
  elections: elections_exports,
  imOnline: imOnline_exports,
  membership: membership_exports,
  parachains: parachains_exports,
  session: session_exports,
  society: society_exports,
  staking: staking_exports,
  technicalCommittee: technicalCommittee_exports,
  treasury: treasury_exports,
  tx: tx_exports
};

// node_modules/@polkadot/api-derive/bundle.js
var checks = {
  allianceMotion: {
    instances: ["allianceMotion"],
    methods: []
  },
  bagsList: {
    instances: ["voterBagsList", "voterList", "bagsList"],
    methods: [],
    withDetect: true
  },
  contracts: {
    instances: ["contracts"],
    methods: []
  },
  council: {
    instances: ["council"],
    methods: [],
    withDetect: true
  },
  crowdloan: {
    instances: ["crowdloan"],
    methods: []
  },
  democracy: {
    instances: ["democracy"],
    methods: []
  },
  elections: {
    instances: ["phragmenElection", "electionsPhragmen", "elections", "council"],
    methods: [],
    withDetect: true
  },
  imOnline: {
    instances: ["imOnline"],
    methods: []
  },
  membership: {
    instances: ["membership"],
    methods: []
  },
  parachains: {
    instances: ["parachains", "registrar"],
    methods: []
  },
  session: {
    instances: ["session"],
    methods: []
  },
  society: {
    instances: ["society"],
    methods: []
  },
  staking: {
    instances: ["staking"],
    methods: ["erasRewardPoints"]
  },
  technicalCommittee: {
    instances: ["technicalCommittee"],
    methods: [],
    withDetect: true
  },
  treasury: {
    instances: ["treasury"],
    methods: []
  }
};
function getModuleInstances(api, specName, moduleName) {
  return api.registry.getModuleInstances(specName, moduleName) || [];
}
function injectFunctions(instanceId, api, derives) {
  const result = {};
  const names = Object.keys(derives);
  const keys2 = Object.keys(api.query);
  const specName = api.runtimeVersion.specName;
  const filterKeys = (q) => keys2.includes(q);
  const filterInstances = (q) => getModuleInstances(api, specName, q).some(filterKeys);
  const filterMethods = (all3) => (m) => all3.some((q) => keys2.includes(q) && api.query[q][m]);
  const getKeys2 = (s) => Object.keys(derives[s]);
  const creator = (s, m) => derives[s][m](instanceId, api);
  const isIncluded = (c) => !checks[c] || checks[c].instances.some(filterKeys) && (!checks[c].methods.length || checks[c].methods.every(filterMethods(checks[c].instances))) || checks[c].withDetect && checks[c].instances.some(filterInstances);
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    isIncluded(name) && lazyDeriveSection(result, name, getKeys2, creator);
  }
  return result;
}
function getAvailableDerives(instanceId, api, custom = {}) {
  return __spreadValues(__spreadValues({}, injectFunctions(instanceId, api, derive)), injectFunctions(instanceId, api, custom));
}

// node_modules/@polkadot/api/util/decorate.js
function decorateDeriveSections(decorateMethod, derives) {
  const getKeys2 = (s) => Object.keys(derives[s]);
  const creator = (s, m) => decorateMethod(derives[s][m]);
  const result = {};
  const names = Object.keys(derives);
  for (let i = 0; i < names.length; i++) {
    lazyDeriveSection(result, names[i], getKeys2, creator);
  }
  return result;
}

// node_modules/@polkadot/api/util/logging.js
var l12 = logger("api/util");

// node_modules/@polkadot/api/util/filterEvents.js
function filterEvents(txHash, {
  block: {
    extrinsics,
    header
  }
}, allEvents, status) {
  for (const [txIndex, x] of extrinsics.entries()) {
    if (x.hash.eq(txHash)) {
      return {
        events: allEvents.filter(({
          phase
        }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eqn(txIndex)),
        txIndex
      };
    }
  }
  if (status.isInBlock) {
    const allHashes = extrinsics.map((x) => x.hash.toHex());
    l12.warn(`block ${header.hash.toHex()}: Unable to find extrinsic ${txHash.toHex()} inside ${allHashes.join(", ")}`);
  }
  return {};
}

// node_modules/@polkadot/api/util/isKeyringPair.js
function isKeyringPair(account3) {
  return isFunction(account3.sign);
}

// node_modules/@polkadot/api/submittable/Result.js
var recordIdentity = (record) => record;
function filterAndApply(events2, section2, methods, onFound) {
  return events2.filter(({
    event
  }) => section2 === event.section && methods.includes(event.method)).map((record) => onFound(record));
}
function getDispatchError({
  event: {
    data: [dispatchError]
  }
}) {
  return dispatchError;
}
function getDispatchInfo({
  event: {
    data,
    method
  }
}) {
  return method === "ExtrinsicSuccess" ? data[0] : data[1];
}
function extractError(events2 = []) {
  return filterAndApply(events2, "system", ["ExtrinsicFailed"], getDispatchError)[0];
}
function extractInfo(events2 = []) {
  return filterAndApply(events2, "system", ["ExtrinsicFailed", "ExtrinsicSuccess"], getDispatchInfo)[0];
}
var SubmittableResult = class {
  constructor({
    dispatchError,
    dispatchInfo,
    events: events2,
    internalError,
    status,
    txHash,
    txIndex
  }) {
    this.dispatchError = dispatchError || extractError(events2);
    this.dispatchInfo = dispatchInfo || extractInfo(events2);
    this.events = events2 || [];
    this.internalError = internalError;
    this.status = status;
    this.txHash = txHash;
    this.txIndex = txIndex;
  }
  get isCompleted() {
    return this.isError || this.status.isInBlock || this.status.isFinalized;
  }
  get isError() {
    return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;
  }
  get isFinalized() {
    return this.status.isFinalized;
  }
  get isInBlock() {
    return this.status.isInBlock;
  }
  get isWarning() {
    return this.status.isRetracted;
  }
  filterRecords(section2, method) {
    return filterAndApply(this.events, section2, Array.isArray(method) ? method : [method], recordIdentity);
  }
  findRecord(section2, method) {
    return this.filterRecords(section2, method)[0];
  }
  toHuman(isExtended) {
    var _this$dispatchError, _this$dispatchInfo, _this$internalError;
    return {
      dispatchError: (_this$dispatchError = this.dispatchError) == null ? void 0 : _this$dispatchError.toHuman(),
      dispatchInfo: (_this$dispatchInfo = this.dispatchInfo) == null ? void 0 : _this$dispatchInfo.toHuman(),
      events: this.events.map((e) => e.toHuman(isExtended)),
      internalError: (_this$internalError = this.internalError) == null ? void 0 : _this$internalError.message.toString(),
      status: this.status.toHuman(isExtended)
    };
  }
};

// node_modules/@polkadot/api/submittable/createClass.js
var identity3 = (input) => input;
function makeEraOptions(api, registry, partialOptions, {
  header,
  mortalLength,
  nonce
}) {
  if (!header) {
    if (partialOptions.era && !partialOptions.blockHash) {
      throw new Error("Expected blockHash to be passed alongside non-immortal era options");
    }
    if (isNumber(partialOptions.era)) {
      delete partialOptions.era;
      delete partialOptions.blockHash;
    }
    return makeSignOptions(api, partialOptions, {
      nonce
    });
  }
  return makeSignOptions(api, partialOptions, {
    blockHash: header.hash,
    era: registry.createTypeUnsafe("ExtrinsicEra", [{
      current: header.number,
      period: partialOptions.era || mortalLength
    }]),
    nonce
  });
}
function makeSignAndSendOptions(partialOptions, statusCb) {
  let options = {};
  if (isFunction(partialOptions)) {
    statusCb = partialOptions;
  } else {
    options = objectSpread({}, partialOptions);
  }
  return [options, statusCb];
}
function makeSignOptions(api, partialOptions, extras) {
  return objectSpread({
    blockHash: api.genesisHash,
    genesisHash: api.genesisHash
  }, partialOptions, extras, {
    runtimeVersion: api.runtimeVersion,
    signedExtensions: api.registry.signedExtensions,
    version: api.extrinsicType
  });
}
function optionsOrNonce(partialOptions = {}) {
  return isBn(partialOptions) || isNumber(partialOptions) ? {
    nonce: partialOptions
  } : partialOptions;
}
function createClass({
  api,
  apiType,
  blockHash,
  decorateMethod
}) {
  var _ignoreStatusCb, _transformResult, _observeSign, _observeStatus, _observeSend, _observeSubscribe, _signViaSigner, _updateSigner;
  const ExtrinsicBase2 = api.registry.createClass("Extrinsic");
  class Submittable extends ExtrinsicBase2 {
    constructor(registry, extrinsic) {
      super(registry, extrinsic, {
        version: api.extrinsicType
      });
      __privateAdd(this, _ignoreStatusCb, void 0);
      __privateAdd(this, _transformResult, identity3);
      __privateAdd(this, _observeSign, (account3, partialOptions) => {
        const address = isKeyringPair(account3) ? account3.address : account3.toString();
        const options = optionsOrNonce(partialOptions);
        return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe(first(), mergeMap(async (signingInfo2) => {
          const eraOptions = makeEraOptions(api, this.registry, options, signingInfo2);
          let updateId = -1;
          if (isKeyringPair(account3)) {
            this.sign(account3, eraOptions);
          } else {
            updateId = await __privateGet(this, _signViaSigner).call(this, address, eraOptions, signingInfo2.header);
          }
          return {
            options: eraOptions,
            updateId
          };
        }));
      });
      __privateAdd(this, _observeStatus, (txHash, status) => {
        if (!status.isFinalized && !status.isInBlock) {
          return of(__privateGet(this, _transformResult).call(this, new SubmittableResult({
            status,
            txHash
          })));
        }
        const blockHash2 = status.isInBlock ? status.asInBlock : status.asFinalized;
        return api.derive.tx.events(blockHash2).pipe(map2(({
          block,
          events: events2
        }) => __privateGet(this, _transformResult).call(this, new SubmittableResult(__spreadProps(__spreadValues({}, filterEvents(txHash, block, events2, status)), {
          status,
          txHash
        })))), catchError((internalError) => of(__privateGet(this, _transformResult).call(this, new SubmittableResult({
          internalError,
          status,
          txHash
        })))));
      });
      __privateAdd(this, _observeSend, (info6) => {
        return api.rpc.author.submitExtrinsic(this).pipe(tap((hash2) => {
          __privateGet(this, _updateSigner).call(this, hash2, info6);
        }));
      });
      __privateAdd(this, _observeSubscribe, (info6) => {
        const txHash = this.hash;
        return api.rpc.author.submitAndWatchExtrinsic(this).pipe(switchMap((status) => __privateGet(this, _observeStatus).call(this, txHash, status)), tap((status) => {
          __privateGet(this, _updateSigner).call(this, status, info6);
        }));
      });
      __privateAdd(this, _signViaSigner, async (address, options, header) => {
        const signer = options.signer || api.signer;
        if (!signer) {
          throw new Error("No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
        }
        const payload = this.registry.createTypeUnsafe("SignerPayload", [objectSpread({}, options, {
          address,
          blockNumber: header ? header.number : 0,
          method: this.method
        })]);
        let result;
        if (isFunction(signer.signPayload)) {
          result = await signer.signPayload(payload.toPayload());
        } else if (isFunction(signer.signRaw)) {
          result = await signer.signRaw(payload.toRaw());
        } else {
          throw new Error("Invalid signer interface, it should implement either signPayload or signRaw (or both)");
        }
        super.addSignature(address, result.signature, payload.toPayload());
        return result.id;
      });
      __privateAdd(this, _updateSigner, (status, info6) => {
        if (info6 && info6.updateId !== -1) {
          const {
            options,
            updateId
          } = info6;
          const signer = options.signer || api.signer;
          if (signer && isFunction(signer.update)) {
            signer.update(updateId, status);
          }
        }
      });
      __privateSet(this, _ignoreStatusCb, apiType === "rxjs");
    }
    get hasDryRun() {
      var _api$rpc$system;
      return isFunction((_api$rpc$system = api.rpc.system) == null ? void 0 : _api$rpc$system.dryRun);
    }
    get hasPaymentInfo() {
      var _api$call$transaction;
      return isFunction((_api$call$transaction = api.call.transactionPaymentApi) == null ? void 0 : _api$call$transaction.queryInfo);
    }
    dryRun(account3, optionsOrHash) {
      if (!this.hasDryRun) {
        throw new Error("The system.dryRun RPC call is not available in your environment");
      }
      if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {
        return decorateMethod(() => api.rpc.system.dryRun(this.toHex(), blockHash || optionsOrHash));
      }
      return decorateMethod(() => __privateGet(this, _observeSign).call(this, account3, optionsOrHash).pipe(switchMap(() => api.rpc.system.dryRun(this.toHex()))))();
    }
    paymentInfo(account3, optionsOrHash) {
      if (!this.hasPaymentInfo) {
        throw new Error("The transactionPaymentApi.queryInfo runtime call is not available in your environment");
      }
      if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {
        return decorateMethod(() => api.callAt(blockHash || optionsOrHash).pipe(switchMap((callAt) => {
          const u8a = this.toU8a();
          return callAt.transactionPaymentApi.queryInfo(u8a, u8a.length);
        })));
      }
      const [allOptions] = makeSignAndSendOptions(optionsOrHash);
      const address = isKeyringPair(account3) ? account3.address : account3.toString();
      return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe(first(), switchMap((signingInfo2) => {
        const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo2);
        const signOptions = makeSignOptions(api, eraOptions, {});
        const u8a = this.isSigned ? api.tx(this).signFake(address, signOptions).toU8a() : this.signFake(address, signOptions).toU8a();
        return api.call.transactionPaymentApi.queryInfo(u8a, u8a.length);
      })))();
    }
    send(statusCb) {
      const isSubscription2 = api.hasSubscriptions && (__privateGet(this, _ignoreStatusCb) || !!statusCb);
      return decorateMethod(isSubscription2 ? __privateGet(this, _observeSubscribe) : __privateGet(this, _observeSend))(statusCb);
    }
    signAsync(account3, partialOptions) {
      return decorateMethod(() => __privateGet(this, _observeSign).call(this, account3, partialOptions).pipe(mapTo(this)))();
    }
    signAndSend(account3, partialOptions, optionalStatusCb) {
      const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);
      const isSubscription2 = api.hasSubscriptions && (__privateGet(this, _ignoreStatusCb) || !!statusCb);
      return decorateMethod(() => __privateGet(this, _observeSign).call(this, account3, options).pipe(switchMap((info6) => isSubscription2 ? __privateGet(this, _observeSubscribe).call(this, info6) : __privateGet(this, _observeSend).call(this, info6))))(statusCb);
    }
    withResultTransform(transform) {
      __privateSet(this, _transformResult, transform);
      return this;
    }
  }
  _ignoreStatusCb = new WeakMap();
  _transformResult = new WeakMap();
  _observeSign = new WeakMap();
  _observeStatus = new WeakMap();
  _observeSend = new WeakMap();
  _observeSubscribe = new WeakMap();
  _signViaSigner = new WeakMap();
  _updateSigner = new WeakMap();
  return Submittable;
}

// node_modules/@polkadot/api/submittable/createSubmittable.js
function createSubmittable(apiType, api, decorateMethod, registry, blockHash) {
  const Submittable = createClass({
    api,
    apiType,
    blockHash,
    decorateMethod
  });
  return (extrinsic) => new Submittable(registry || api.registry, extrinsic);
}

// node_modules/@polkadot/api/base/find.js
function findCall(registry, callIndex) {
  return registry.findMetaCall(u8aToU8a(callIndex));
}
function findError(registry, errorIndex) {
  return registry.findMetaError(u8aToU8a(errorIndex));
}

// node_modules/@polkadot/types-known/detectOther.js
var detectOther_default16 = [packageInfo9];

// node_modules/@polkadot/types-known/detectPackage.js
detectPackage(packageInfo10, null, detectOther_default16);

// node_modules/@polkadot/types-known/chain/index.js
var typesChain = {};
var chain_default = typesChain;

// node_modules/@polkadot/types-known/spec/centrifuge-chain.js
var sharedTypes = {
  AnchorData: {
    anchoredBlock: "u64",
    docRoot: "H256",
    id: "H256"
  },
  DispatchErrorModule: "DispatchErrorModuleU8",
  PreCommitData: {
    expirationBlock: "u64",
    identity: "H256",
    signingRoot: "H256"
  },
  Fee: {
    key: "Hash",
    price: "Balance"
  },
  MultiAccountData: {
    deposit: "Balance",
    depositor: "AccountId",
    signatories: "Vec<AccountId>",
    threshold: "u16"
  },
  ChainId: "u8",
  DepositNonce: "u64",
  ResourceId: "[u8; 32]",
  "chainbridge::ChainId": "u8",
  RegistryId: "H160",
  TokenId: "U256",
  AssetId: {
    registryId: "RegistryId",
    tokenId: "TokenId"
  },
  AssetInfo: {
    metadata: "Bytes"
  },
  MintInfo: {
    anchorId: "Hash",
    proofs: "Vec<ProofMint>",
    staticHashes: "[Hash; 3]"
  },
  Proof: {
    leafHash: "H256",
    sortedHashes: "H256"
  },
  ProofMint: {
    hashes: "Vec<Hash>",
    property: "Bytes",
    salt: "[u8; 32]",
    value: "Bytes"
  },
  RegistryInfo: {
    fields: "Vec<Bytes>",
    ownerCanBurn: "bool"
  },
  ProxyType: {
    _enum: ["Any", "NonTransfer", "Governance", "Staking", "NonProxy"]
  }
};
var standaloneTypes = objectSpread({}, sharedTypes, {
  AccountInfo: "AccountInfoWithRefCount",
  Address: "LookupSource",
  LookupSource: "IndicesLookupSource",
  Multiplier: "Fixed64",
  RefCount: "RefCountTo259"
});
var versioned = [{
  minmax: [240, 243],
  types: objectSpread({}, standaloneTypes, {
    ProxyType: {
      _enum: ["Any", "NonTransfer", "Governance", "Staking", "Vesting"]
    }
  })
}, {
  minmax: [244, 999],
  types: objectSpread({}, standaloneTypes)
}, {
  minmax: [1e3, void 0],
  types: objectSpread({}, sharedTypes)
}];
var centrifuge_chain_default = versioned;

// node_modules/@polkadot/types-known/spec/kusama.js
var sharedTypes2 = {
  CompactAssignments: "CompactAssignmentsWith24",
  DispatchErrorModule: "DispatchErrorModuleU8",
  RawSolution: "RawSolutionWith24",
  Keys: "SessionKeys6",
  ProxyType: {
    _enum: ["Any", "NonTransfer", "Governance", "Staking", "IdentityJudgement", "CancelProxy", "Auction"]
  },
  Weight: "WeightV1"
};
var addrIndicesTypes = {
  AccountInfo: "AccountInfoWithRefCount",
  Address: "LookupSource",
  CompactAssignments: "CompactAssignmentsWith16",
  DispatchErrorModule: "DispatchErrorModuleU8",
  RawSolution: "RawSolutionWith16",
  Keys: "SessionKeys5",
  LookupSource: "IndicesLookupSource",
  ValidatorPrefs: "ValidatorPrefsWithCommission"
};
var addrAccountIdTypes = {
  AccountInfo: "AccountInfoWithRefCount",
  Address: "AccountId",
  CompactAssignments: "CompactAssignmentsWith16",
  DispatchErrorModule: "DispatchErrorModuleU8",
  RawSolution: "RawSolutionWith16",
  Keys: "SessionKeys5",
  LookupSource: "AccountId",
  ValidatorPrefs: "ValidatorPrefsWithCommission"
};
var versioned2 = [
  {
    minmax: [1019, 1031],
    types: objectSpread({}, addrIndicesTypes, {
      BalanceLock: "BalanceLockTo212",
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchError: "DispatchErrorTo198",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      IdentityInfo: "IdentityInfoTo198",
      Keys: "SessionKeys5",
      Multiplier: "Fixed64",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259",
      ReferendumInfo: "ReferendumInfoTo239",
      SlashingSpans: "SlashingSpansTo204",
      StakingLedger: "StakingLedgerTo223",
      Votes: "VotesTo230",
      Weight: "u32"
    })
  },
  {
    minmax: [1032, 1042],
    types: objectSpread({}, addrIndicesTypes, {
      BalanceLock: "BalanceLockTo212",
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      Keys: "SessionKeys5",
      Multiplier: "Fixed64",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259",
      ReferendumInfo: "ReferendumInfoTo239",
      SlashingSpans: "SlashingSpansTo204",
      StakingLedger: "StakingLedgerTo223",
      Votes: "VotesTo230",
      Weight: "u32"
    })
  },
  {
    minmax: [1043, 1045],
    types: objectSpread({}, addrIndicesTypes, {
      BalanceLock: "BalanceLockTo212",
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      Keys: "SessionKeys5",
      Multiplier: "Fixed64",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259",
      ReferendumInfo: "ReferendumInfoTo239",
      StakingLedger: "StakingLedgerTo223",
      Votes: "VotesTo230",
      Weight: "u32"
    })
  },
  {
    minmax: [1046, 1049],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes, {
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      Multiplier: "Fixed64",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259",
      ReferendumInfo: "ReferendumInfoTo239",
      StakingLedger: "StakingLedgerTo223",
      Weight: "u32"
    })
  },
  {
    minmax: [1050, 1054],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes, {
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      Multiplier: "Fixed64",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259",
      ReferendumInfo: "ReferendumInfoTo239",
      StakingLedger: "StakingLedgerTo240",
      Weight: "u32"
    })
  },
  {
    minmax: [1055, 1056],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes, {
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      Multiplier: "Fixed64",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259",
      StakingLedger: "StakingLedgerTo240",
      Weight: "u32"
    })
  },
  {
    minmax: [1057, 1061],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes, {
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [1062, 2012],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes, {
      CompactAssignments: "CompactAssignmentsTo257",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [2013, 2022],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes, {
      CompactAssignments: "CompactAssignmentsTo257",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [2023, 2024],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes, {
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [2025, 2027],
    types: objectSpread({}, sharedTypes2, addrAccountIdTypes)
  },
  {
    minmax: [2028, 2029],
    types: objectSpread({}, sharedTypes2, {
      AccountInfo: "AccountInfoWithDualRefCount",
      CompactAssignments: "CompactAssignmentsWith16",
      RawSolution: "RawSolutionWith16"
    })
  },
  {
    minmax: [2030, 9e3],
    types: objectSpread({}, sharedTypes2, {
      CompactAssignments: "CompactAssignmentsWith16",
      RawSolution: "RawSolutionWith16"
    })
  },
  {
    minmax: [9010, 9099],
    types: objectSpread({}, sharedTypes2, mapXcmTypes("V0"))
  },
  {
    minmax: [9100, 9105],
    types: objectSpread({}, sharedTypes2, mapXcmTypes("V1"))
  },
  {
    minmax: [9106, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
];
var kusama_default = versioned2;

// node_modules/@polkadot/types-known/spec/node.js
var versioned3 = [{
  minmax: [0, void 0],
  types: {
    Weight: "WeightV2"
  }
}];
var node_default = versioned3;

// node_modules/@polkadot/types-known/spec/node-template.js
var versioned4 = [{
  minmax: [0, void 0],
  types: {
    Weight: "WeightV2"
  }
}];
var node_template_default = versioned4;

// node_modules/@polkadot/types-known/spec/polkadot.js
var sharedTypes3 = {
  CompactAssignments: "CompactAssignmentsWith16",
  DispatchErrorModule: "DispatchErrorModuleU8",
  RawSolution: "RawSolutionWith16",
  Keys: "SessionKeys6",
  ProxyType: {
    _enum: {
      Any: 0,
      NonTransfer: 1,
      Governance: 2,
      Staking: 3,
      UnusedSudoBalances: 4,
      IdentityJudgement: 5,
      CancelProxy: 6,
      Auction: 7
    }
  },
  Weight: "WeightV1"
};
var addrAccountIdTypes2 = {
  AccountInfo: "AccountInfoWithRefCount",
  Address: "AccountId",
  DispatchErrorModule: "DispatchErrorModuleU8",
  Keys: "SessionKeys5",
  LookupSource: "AccountId",
  ValidatorPrefs: "ValidatorPrefsWithCommission"
};
var versioned5 = [
  {
    minmax: [0, 12],
    types: objectSpread({}, sharedTypes3, addrAccountIdTypes2, {
      CompactAssignments: "CompactAssignmentsTo257",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [13, 22],
    types: objectSpread({}, sharedTypes3, addrAccountIdTypes2, {
      CompactAssignments: "CompactAssignmentsTo257",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [23, 24],
    types: objectSpread({}, sharedTypes3, addrAccountIdTypes2, {
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [25, 27],
    types: objectSpread({}, sharedTypes3, addrAccountIdTypes2)
  },
  {
    minmax: [28, 29],
    types: objectSpread({}, sharedTypes3, {
      AccountInfo: "AccountInfoWithDualRefCount"
    })
  },
  {
    minmax: [30, 9109],
    types: objectSpread({}, sharedTypes3)
  },
  {
    minmax: [9110, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
];
var polkadot_default = versioned5;

// node_modules/@polkadot/types-known/spec/rococo.js
var sharedTypes4 = {
  DispatchErrorModule: "DispatchErrorModuleU8",
  FullIdentification: "()",
  Keys: "SessionKeys7B",
  Weight: "WeightV1"
};
var versioned6 = [
  {
    minmax: [0, 200],
    types: objectSpread({}, sharedTypes4, {
      AccountInfo: "AccountInfoWithDualRefCount",
      Address: "AccountId",
      LookupSource: "AccountId"
    })
  },
  {
    minmax: [201, 214],
    types: objectSpread({}, sharedTypes4, {
      AccountInfo: "AccountInfoWithDualRefCount"
    })
  },
  {
    minmax: [215, 228],
    types: objectSpread({}, sharedTypes4, {
      Keys: "SessionKeys6"
    })
  },
  {
    minmax: [229, 9099],
    types: objectSpread({}, sharedTypes4, mapXcmTypes("V0"))
  },
  {
    minmax: [9100, 9105],
    types: objectSpread({}, sharedTypes4, mapXcmTypes("V1"))
  },
  {
    minmax: [9106, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
];
var rococo_default = versioned6;

// node_modules/@polkadot/types-known/spec/shell.js
var versioned7 = [{
  minmax: [0, void 0],
  types: {}
}];
var shell_default = versioned7;

// node_modules/@polkadot/types-known/spec/statemint.js
var sharedTypes5 = {
  DispatchErrorModule: "DispatchErrorModuleU8",
  TAssetBalance: "u128",
  ProxyType: {
    _enum: ["Any", "NonTransfer", "CancelProxy", "Assets", "AssetOwner", "AssetManager", "Staking"]
  },
  Weight: "WeightV1"
};
var versioned8 = [
  {
    minmax: [0, 3],
    types: objectSpread({
      DispatchError: "DispatchErrorPre6First"
    }, sharedTypes5, mapXcmTypes("V0"))
  },
  {
    minmax: [4, 5],
    types: objectSpread({
      DispatchError: "DispatchErrorPre6First"
    }, sharedTypes5, mapXcmTypes("V1"))
  },
  {
    minmax: [500, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
];
var statemint_default = versioned8;

// node_modules/@polkadot/types-known/spec/westend.js
var sharedTypes6 = {
  CompactAssignments: "CompactAssignmentsWith16",
  DispatchErrorModule: "DispatchErrorModuleU8",
  RawSolution: "RawSolutionWith16",
  Keys: "SessionKeys6",
  ProxyType: {
    _enum: ["Any", "NonTransfer", "Staking", "SudoBalances", "IdentityJudgement", "CancelProxy"]
  },
  Weight: "WeightV1"
};
var addrAccountIdTypes3 = {
  AccountInfo: "AccountInfoWithRefCount",
  Address: "AccountId",
  CompactAssignments: "CompactAssignmentsWith16",
  DispatchErrorModule: "DispatchErrorModuleU8",
  LookupSource: "AccountId",
  Keys: "SessionKeys5",
  RawSolution: "RawSolutionWith16",
  ValidatorPrefs: "ValidatorPrefsWithCommission"
};
var versioned9 = [
  {
    minmax: [1, 2],
    types: objectSpread({}, sharedTypes6, addrAccountIdTypes3, {
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      Multiplier: "Fixed64",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259",
      Weight: "u32"
    })
  },
  {
    minmax: [3, 22],
    types: objectSpread({}, sharedTypes6, addrAccountIdTypes3, {
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      OpenTip: "OpenTipTo225",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [23, 42],
    types: objectSpread({}, sharedTypes6, addrAccountIdTypes3, {
      CompactAssignments: "CompactAssignmentsTo257",
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [43, 44],
    types: objectSpread({}, sharedTypes6, addrAccountIdTypes3, {
      DispatchInfo: "DispatchInfoTo244",
      Heartbeat: "HeartbeatTo244",
      RefCount: "RefCountTo259"
    })
  },
  {
    minmax: [45, 47],
    types: objectSpread({}, sharedTypes6, addrAccountIdTypes3)
  },
  {
    minmax: [48, 49],
    types: objectSpread({}, sharedTypes6, {
      AccountInfo: "AccountInfoWithDualRefCount"
    })
  },
  {
    minmax: [50, 9099],
    types: objectSpread({}, sharedTypes6, mapXcmTypes("V0"))
  },
  {
    minmax: [9100, 9105],
    types: objectSpread({}, sharedTypes6, mapXcmTypes("V1"))
  },
  {
    minmax: [9106, void 0],
    types: {
      Weight: "WeightV1"
    }
  }
];
var westend_default = versioned9;

// node_modules/@polkadot/types-known/spec/index.js
var typesSpec = {
  "centrifuge-chain": centrifuge_chain_default,
  kusama: kusama_default,
  node: node_default,
  "node-template": node_template_default,
  polkadot: polkadot_default,
  rococo: rococo_default,
  shell: shell_default,
  statemine: statemint_default,
  statemint: statemint_default,
  westend: westend_default,
  westmint: statemint_default
};
var spec_default = typesSpec;

// node_modules/@polkadot/types-known/upgrades/e2e/index.js
var e2e_exports = {};
__export(e2e_exports, {
  kusama: () => kusama_default2,
  polkadot: () => polkadot_default2,
  westend: () => westend_default2
});

// node_modules/@polkadot/types-known/upgrades/e2e/kusama.js
var upgrades = [[0, 1020, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [26669, 1021, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [38245, 1022, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [54248, 1023, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [59659, 1024, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [67651, 1025, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [82191, 1027, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [83238, 1028, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [101503, 1029, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [203466, 1030, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [295787, 1031, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [461692, 1032, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [504329, 1033, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [569327, 1038, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 1], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [587687, 1039, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [653183, 1040, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [693488, 1042, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [901442, 1045, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1375086, 1050, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1445458, 1051, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1472960, 1052, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1475648, 1053, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1491596, 1054, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1574408, 1055, [["0xdf6acb689907609b", 2], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 1], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2064961, 1058, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2201991, 1062, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2671528, 2005, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2704202, 2007, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2728002, 2008, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2832534, 2011, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2962294, 2012, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [324e4, 2013, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3274408, 2015, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3323565, 2019, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3534175, 2022, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3860281, 2023, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [4143129, 2024, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [4401242, 2025, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [4841367, 2026, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5961600, 2027, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6137912, 2028, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6561855, 2029, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7100891, 2030, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7468792, 9010, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7668600, 9030, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7812476, 9040, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [8010981, 9050, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [8073833, 9070, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [8555825, 9080, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [8945245, 9090, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9611377, 9100, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9625129, 9111, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9866422, 9122, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10403784, 9130, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10960765, 9150, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11006614, 9151, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11404482, 9160, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11601803, 9170, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [12008022, 9180, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [12405451, 9190, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [12665416, 9200, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [12909508, 9220, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [13109752, 9230, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [13555777, 9250, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [13727747, 9260, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [14248044, 9271, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0x17a6bc0d0062aeb3", 1]]], [14433840, 9280, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1], ["0x17a6bc0d0062aeb3", 1]]], [14645900, 9291, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1], ["0x17a6bc0d0062aeb3", 1]]], [15048375, 9300, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1], ["0x17a6bc0d0062aeb3", 1]]]];
var kusama_default2 = upgrades;

// node_modules/@polkadot/types-known/upgrades/e2e/polkadot.js
var upgrades2 = [[0, 0, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [29231, 1, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [188836, 5, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [199405, 6, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [214264, 7, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [244358, 8, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [303079, 9, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [314201, 10, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [342400, 11, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [443963, 12, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [528470, 13, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [687751, 14, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [746085, 15, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [787923, 16, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [799302, 17, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1205128, 18, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1603423, 23, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1733218, 24, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2005673, 25, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2436698, 26, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3613564, 27, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3899547, 28, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [4345767, 29, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [4876134, 30, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5661442, 9050, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6321619, 9080, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6713249, 9090, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7217907, 9100, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7229126, 9110, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7560558, 9122, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [8115869, 9140, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [8638103, 9151, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9280179, 9170, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9738717, 9180, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10156856, 9190, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10458576, 9200, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10655116, 9220, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10879371, 9230, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11328884, 9250, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11532856, 9260, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11933818, 9270, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [12217535, 9280, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1]]], [12245277, 9281, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1]]], [12532644, 9291, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0x17a6bc0d0062aeb3", 1], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1]]], [12876189, 9300, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0x17a6bc0d0062aeb3", 1], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1]]]];
var polkadot_default2 = upgrades2;

// node_modules/@polkadot/types-known/upgrades/e2e/westend.js
var upgrades3 = [[214356, 4, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 1], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [392764, 7, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [409740, 8, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [809976, 20, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [877581, 24, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [879238, 25, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [889472, 26, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [902937, 27, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [932751, 28, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [991142, 29, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1030162, 31, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1119657, 32, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1199282, 33, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1342534, 34, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1392263, 35, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1431703, 36, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1433369, 37, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [1490972, 41, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2087397, 43, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2316688, 44, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [2549864, 45, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3925782, 46, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [3925843, 47, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [4207800, 48, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [4627944, 49, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5124076, 50, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5478664, 900, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5482450, 9e3, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 4], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5584305, 9010, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5784566, 9030, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5879822, 9031, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5896856, 9032, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [5897316, 9033, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6117927, 9050, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6210274, 9070, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 2], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6379314, 9080, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 2], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [6979141, 9090, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7568453, 9100, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7766394, 9111, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7911691, 9120, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7968866, 9121, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [7982889, 9122, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [8514322, 9130, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9091726, 9140, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9091774, 9150, [["0xdf6acb689907609b", 3], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 1], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9406726, 9160, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [9921066, 9170, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10007115, 9180, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 5], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10480973, 9190, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10578091, 9200, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10678509, 9210, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [10811001, 9220, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11096116, 9230, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11409279, 9250, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11584820, 9251, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11716837, 9260, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11876919, 9261, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1]]], [11987927, 9270, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0x17a6bc0d0062aeb3", 1]]], [12077324, 9271, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0x17a6bc0d0062aeb3", 1]]], [12301871, 9280, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1], ["0x17a6bc0d0062aeb3", 1]]], [12604343, 9290, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 2], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1], ["0x17a6bc0d0062aeb3", 1]]], [12841034, 9300, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1], ["0x17a6bc0d0062aeb3", 1]]], [13128237, 9310, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 1], ["0xf3ff14d5ab527059", 1], ["0x17a6bc0d0062aeb3", 1]]], [13272363, 9320, [["0xdf6acb689907609b", 4], ["0x37e397fc7c91f5e4", 1], ["0x40fe3ad401f8959a", 6], ["0xd2bc9897eed08f15", 3], ["0xf78b278be53f454c", 2], ["0xaf2c0297a23e6d3d", 3], ["0x49eaaf1b548a0cb0", 1], ["0x91d5df18b0d2cf58", 1], ["0xed99c5acb25eedf5", 3], ["0xcbca25e39f142387", 2], ["0x687ad44ad37f03c2", 1], ["0xab3c0572291feb8b", 1], ["0xbc9d89904f5b923f", 1], ["0x37c8bb1350a9a2a8", 2], ["0xf3ff14d5ab527059", 2], ["0x17a6bc0d0062aeb3", 1]]]];
var westend_default2 = upgrades3;

// node_modules/@polkadot/types-known/upgrades/index.js
var NET_EXTRA = {
  westend: {
    genesisHash: ["0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"]
  }
};
function mapRaw([network, versions]) {
  const chain2 = selectableNetworks.find((n) => n.network === network) || NET_EXTRA[network];
  if (!chain2) {
    throw new Error(`Unable to find info for chain ${network}`);
  }
  return {
    genesisHash: hexToU8a(chain2.genesisHash[0]),
    network,
    versions: versions.map(([blockNumber, specVersion, apis]) => ({
      apis,
      blockNumber: new import_bn.default(blockNumber),
      specVersion: new import_bn.default(specVersion)
    }))
  };
}
var upgrades4 = Object.entries(e2e_exports).map(mapRaw);
var upgrades_default = upgrades4;

// node_modules/@polkadot/types-known/util.js
function withNames(chainName, specName, fn) {
  return fn(chainName.toString(), specName.toString());
}
function filterVersions(versions = [], specVersion) {
  return versions.filter(({
    minmax: [min2, max3]
  }) => (min2 === void 0 || min2 === null || specVersion >= min2) && (max3 === void 0 || max3 === null || specVersion <= max3)).reduce((result, {
    types: types2
  }) => objectSpread(result, types2), {});
}
function getSpecExtensions({
  knownTypes: knownTypes2
}, chainName, specName) {
  return withNames(chainName, specName, (c, s) => {
    var _knownTypes$typesBund, _knownTypes$typesBund2, _knownTypes$typesBund3, _knownTypes$typesBund4, _knownTypes$typesBund5, _knownTypes$typesBund6;
    return objectSpread({}, (_knownTypes$typesBund = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund2 = _knownTypes$typesBund.spec) == null ? void 0 : (_knownTypes$typesBund3 = _knownTypes$typesBund2[s]) == null ? void 0 : _knownTypes$typesBund3.signedExtensions, (_knownTypes$typesBund4 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund5 = _knownTypes$typesBund4.chain) == null ? void 0 : (_knownTypes$typesBund6 = _knownTypes$typesBund5[c]) == null ? void 0 : _knownTypes$typesBund6.signedExtensions);
  });
}
function getSpecTypes({
  knownTypes: knownTypes2
}, chainName, specName, specVersion) {
  const _specVersion = bnToBn(specVersion).toNumber();
  return withNames(chainName, specName, (c, s) => {
    var _knownTypes$typesBund7, _knownTypes$typesBund8, _knownTypes$typesBund9, _knownTypes$typesBund10, _knownTypes$typesBund11, _knownTypes$typesBund12, _knownTypes$typesSpec, _knownTypes$typesChai;
    return objectSpread({}, filterVersions(spec_default[s], _specVersion), filterVersions(chain_default[c], _specVersion), filterVersions((_knownTypes$typesBund7 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund8 = _knownTypes$typesBund7.spec) == null ? void 0 : (_knownTypes$typesBund9 = _knownTypes$typesBund8[s]) == null ? void 0 : _knownTypes$typesBund9.types, _specVersion), filterVersions((_knownTypes$typesBund10 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund11 = _knownTypes$typesBund10.chain) == null ? void 0 : (_knownTypes$typesBund12 = _knownTypes$typesBund11[c]) == null ? void 0 : _knownTypes$typesBund12.types, _specVersion), (_knownTypes$typesSpec = knownTypes2.typesSpec) == null ? void 0 : _knownTypes$typesSpec[s], (_knownTypes$typesChai = knownTypes2.typesChain) == null ? void 0 : _knownTypes$typesChai[c], knownTypes2.types);
  });
}
function getSpecHasher({
  knownTypes: knownTypes2
}, chainName, specName) {
  return withNames(chainName, specName, (c, s) => {
    var _knownTypes$typesBund13, _knownTypes$typesBund14, _knownTypes$typesBund15, _knownTypes$typesBund16, _knownTypes$typesBund17, _knownTypes$typesBund18;
    return knownTypes2.hasher || ((_knownTypes$typesBund13 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund14 = _knownTypes$typesBund13.chain) == null ? void 0 : (_knownTypes$typesBund15 = _knownTypes$typesBund14[c]) == null ? void 0 : _knownTypes$typesBund15.hasher) || ((_knownTypes$typesBund16 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund17 = _knownTypes$typesBund16.spec) == null ? void 0 : (_knownTypes$typesBund18 = _knownTypes$typesBund17[s]) == null ? void 0 : _knownTypes$typesBund18.hasher) || null;
  });
}
function getSpecRpc({
  knownTypes: knownTypes2
}, chainName, specName) {
  return withNames(chainName, specName, (c, s) => {
    var _knownTypes$typesBund19, _knownTypes$typesBund20, _knownTypes$typesBund21, _knownTypes$typesBund22, _knownTypes$typesBund23, _knownTypes$typesBund24;
    return objectSpread({}, (_knownTypes$typesBund19 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund20 = _knownTypes$typesBund19.spec) == null ? void 0 : (_knownTypes$typesBund21 = _knownTypes$typesBund20[s]) == null ? void 0 : _knownTypes$typesBund21.rpc, (_knownTypes$typesBund22 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund23 = _knownTypes$typesBund22.chain) == null ? void 0 : (_knownTypes$typesBund24 = _knownTypes$typesBund23[c]) == null ? void 0 : _knownTypes$typesBund24.rpc);
  });
}
function getSpecRuntime({
  knownTypes: knownTypes2
}, chainName, specName) {
  return withNames(chainName, specName, (c, s) => {
    var _knownTypes$typesBund25, _knownTypes$typesBund26, _knownTypes$typesBund27, _knownTypes$typesBund28, _knownTypes$typesBund29, _knownTypes$typesBund30;
    return objectSpread({}, (_knownTypes$typesBund25 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund26 = _knownTypes$typesBund25.spec) == null ? void 0 : (_knownTypes$typesBund27 = _knownTypes$typesBund26[s]) == null ? void 0 : _knownTypes$typesBund27.runtime, (_knownTypes$typesBund28 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund29 = _knownTypes$typesBund28.chain) == null ? void 0 : (_knownTypes$typesBund30 = _knownTypes$typesBund29[c]) == null ? void 0 : _knownTypes$typesBund30.runtime);
  });
}
function getSpecAlias({
  knownTypes: knownTypes2
}, chainName, specName) {
  return withNames(chainName, specName, (c, s) => {
    var _knownTypes$typesBund31, _knownTypes$typesBund32, _knownTypes$typesBund33, _knownTypes$typesBund34, _knownTypes$typesBund35, _knownTypes$typesBund36;
    return objectSpread({}, (_knownTypes$typesBund31 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund32 = _knownTypes$typesBund31.spec) == null ? void 0 : (_knownTypes$typesBund33 = _knownTypes$typesBund32[s]) == null ? void 0 : _knownTypes$typesBund33.alias, (_knownTypes$typesBund34 = knownTypes2.typesBundle) == null ? void 0 : (_knownTypes$typesBund35 = _knownTypes$typesBund34.chain) == null ? void 0 : (_knownTypes$typesBund36 = _knownTypes$typesBund35[c]) == null ? void 0 : _knownTypes$typesBund36.alias, knownTypes2.typesAlias);
  });
}
function getUpgradeVersion(genesisHash, blockNumber) {
  const known2 = upgrades_default.find((u) => genesisHash.eq(u.genesisHash));
  return known2 ? [known2.versions.reduce((last3, version) => {
    return blockNumber.gt(version.blockNumber) ? version : last3;
  }, void 0), known2.versions.find((version) => blockNumber.lte(version.blockNumber))] : [void 0, void 0];
}

// node_modules/@polkadot/api/util/augmentObject.js
var l13 = logger("api/augment");
function logLength(type, values, and = []) {
  return values.length ? ` ${values.length} ${type}${and.length ? " and" : ""}` : "";
}
function logValues(type, values) {
  return values.length ? `
	${type.padStart(7)}: ${values.sort().join(", ")}` : "";
}
function warn2(prefix2, type, [added, removed]) {
  if (added.length || removed.length) {
    l13.warn(`api.${prefix2}: Found${logLength("added", added, removed)}${logLength("removed", removed)} ${type}:${logValues("added", added)}${logValues("removed", removed)}`);
  }
}
function findSectionExcludes(a, b) {
  return a.filter((s) => !b.includes(s));
}
function findSectionIncludes(a, b) {
  return a.filter((s) => b.includes(s));
}
function extractSections(src, dst) {
  const srcSections = Object.keys(src);
  const dstSections = Object.keys(dst);
  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];
}
function findMethodExcludes(src, dst) {
  const srcSections = Object.keys(src);
  const dstSections = findSectionIncludes(Object.keys(dst), srcSections);
  const excludes = [];
  for (let s = 0; s < dstSections.length; s++) {
    const section2 = dstSections[s];
    const srcMethods = Object.keys(src[section2]);
    const dstMethods = Object.keys(dst[section2]);
    for (let d = 0; d < dstMethods.length; d++) {
      const method = dstMethods[d];
      if (!srcMethods.includes(method)) {
        excludes.push(`${section2}.${method}`);
      }
    }
  }
  return excludes;
}
function extractMethods(src, dst) {
  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];
}
function augmentObject(prefix2, src, dst, fromEmpty = false) {
  fromEmpty && objectClear(dst);
  if (prefix2 && Object.keys(dst).length) {
    warn2(prefix2, "modules", extractSections(src, dst));
    warn2(prefix2, "calls", extractMethods(src, dst));
  }
  const sections = Object.keys(src);
  for (let i = 0; i < sections.length; i++) {
    const section2 = sections[i];
    const methods = src[section2];
    if (!dst[section2]) {
      dst[section2] = {};
    }
    lazyMethods(dst[section2], Object.keys(methods), (m) => methods[m]);
  }
  return dst;
}

// node_modules/@polkadot/api/util/validate.js
function sig({
  lookup
}, {
  method,
  section: section2
}, args) {
  return `${section2}.${method}(${args.map((a) => lookup.getTypeDef(a).type).join(", ")})`;
}
function extractStorageArgs(registry, creator, _args2) {
  const args = _args2.filter((a) => !isUndefined(a));
  if (creator.meta.type.isPlain) {
    if (args.length !== 0) {
      throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);
    }
  } else {
    const {
      hashers,
      key
    } = creator.meta.type.asMap;
    const keys2 = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple.map((t) => t);
    if (args.length !== keys2.length) {
      throw new Error(`${sig(registry, creator, keys2)} is a map, requiring ${keys2.length} arguments, ${args.length} found`);
    }
  }
  return [creator, args];
}

// node_modules/@polkadot/api/base/Events.js
var import_eventemitter33 = __toModule(require_eventemitter3());
var _eventemitter3;
var Events = class {
  constructor() {
    __privateAdd(this, _eventemitter3, new import_eventemitter33.default());
  }
  emit(type, ...args) {
    return __privateGet(this, _eventemitter3).emit(type, ...args);
  }
  on(type, handler) {
    __privateGet(this, _eventemitter3).on(type, handler);
    return this;
  }
  off(type, handler) {
    __privateGet(this, _eventemitter3).removeListener(type, handler);
    return this;
  }
  once(type, handler) {
    __privateGet(this, _eventemitter3).once(type, handler);
    return this;
  }
};
_eventemitter3 = new WeakMap();

// node_modules/@polkadot/api/base/Decorate.js
var PAGE_SIZE_K2 = 1e3;
var PAGE_SIZE_V = 250;
var PAGE_SIZE_Q = 50;
var l14 = logger("api/init");
var instanceCounter = 0;
function getAtQueryFn(api, {
  method,
  section: section2
}) {
  return assertReturn(api.rx.query[section2] && api.rx.query[section2][method], () => `query.${section2}.${method} is not available in this version of the metadata`);
}
var _instanceId2, _registry, _runtimeLog, _storageGetQ, _storageSubQ;
var Decorate = class extends Events {
  constructor(options, type, decorateMethod) {
    var _options$source;
    super();
    __privateAdd(this, _instanceId2, void 0);
    __privateAdd(this, _registry, void 0);
    __privateAdd(this, _runtimeLog, {});
    __privateAdd(this, _storageGetQ, []);
    __privateAdd(this, _storageSubQ, []);
    __publicField(this, "__phantom", new import_bn.default(0));
    __publicField(this, "_call", {});
    __publicField(this, "_consts", {});
    __publicField(this, "_errors", {});
    __publicField(this, "_events", {});
    __publicField(this, "_extrinsicType", GenericExtrinsic.LATEST_EXTRINSIC_VERSION);
    __publicField(this, "_isReady", false);
    __publicField(this, "_query", {});
    __publicField(this, "_runtimeMap", {});
    __publicField(this, "_rx", {
      call: {},
      consts: {},
      query: {},
      tx: {}
    });
    __publicField(this, "_rxDecorateMethod", (method) => {
      return method;
    });
    __privateSet(this, _instanceId2, `${++instanceCounter}`);
    __privateSet(this, _registry, ((_options$source = options.source) == null ? void 0 : _options$source.registry) || options.registry || new TypeRegistry());
    this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map2((a) => a.rx.call));
    this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map2((a) => a.rx.query));
    this._rx.registry = __privateGet(this, _registry);
    const thisProvider = options.source ? options.source._rpcCore.provider.isClonable ? options.source._rpcCore.provider.clone() : options.source._rpcCore.provider : options.provider || new WsProvider();
    this._decorateMethod = decorateMethod;
    this._options = options;
    this._type = type;
    this._rpcCore = new RpcCore(__privateGet(this, _instanceId2), __privateGet(this, _registry), thisProvider, this._options.rpc);
    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);
    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;
  }
  get registry() {
    return __privateGet(this, _registry);
  }
  createType(type, ...params) {
    return __privateGet(this, _registry).createType(type, ...params);
  }
  registerTypes(types2) {
    types2 && __privateGet(this, _registry).register(types2);
  }
  get hasSubscriptions() {
    return this._rpcCore.provider.hasSubscriptions;
  }
  get supportMulti() {
    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;
  }
  _emptyDecorated(registry, blockHash) {
    return {
      call: {},
      consts: {},
      errors: {},
      events: {},
      query: {},
      registry,
      rx: {
        call: {},
        query: {}
      },
      tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)
    };
  }
  _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {
    if (!decoratedApi) {
      decoratedApi = this._emptyDecorated(registry.registry, blockHash);
    }
    if (fromEmpty || !registry.decoratedMeta) {
      registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);
    }
    const runtime26 = this._decorateCalls(registry, this._decorateMethod, blockHash);
    const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);
    const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);
    const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);
    augmentObject("consts", registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);
    augmentObject("errors", registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);
    augmentObject("events", registry.decoratedMeta.events, decoratedApi.events, fromEmpty);
    augmentObject("query", storage, decoratedApi.query, fromEmpty);
    augmentObject("query", storageRx, decoratedApi.rx.query, fromEmpty);
    augmentObject("call", runtime26, decoratedApi.call, fromEmpty);
    augmentObject("call", runtimeRx, decoratedApi.rx.call, fromEmpty);
    decoratedApi.findCall = (callIndex) => findCall(registry.registry, callIndex);
    decoratedApi.findError = (errorIndex) => findError(registry.registry, errorIndex);
    decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);
    decoratedApi.runtimeVersion = registry.runtimeVersion;
    return {
      createdAt: blockHash,
      decoratedApi,
      decoratedMeta: registry.decoratedMeta
    };
  }
  _injectMetadata(registry, fromEmpty = false) {
    if (fromEmpty || !registry.decoratedApi) {
      registry.decoratedApi = this._emptyDecorated(registry.registry);
    }
    const {
      decoratedApi,
      decoratedMeta
    } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);
    this._call = decoratedApi.call;
    this._consts = decoratedApi.consts;
    this._errors = decoratedApi.errors;
    this._events = decoratedApi.events;
    this._query = decoratedApi.query;
    this._rx.call = decoratedApi.rx.call;
    this._rx.query = decoratedApi.rx.query;
    const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);
    const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);
    if (fromEmpty || !this._extrinsics) {
      this._extrinsics = tx;
      this._rx.tx = rxtx;
    } else {
      augmentObject("tx", tx, this._extrinsics, false);
      augmentObject(null, rxtx, this._rx.tx, false);
    }
    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);
    this.emit("decorated");
  }
  injectMetadata(metadata, fromEmpty, registry) {
    this._injectMetadata({
      counter: 0,
      metadata,
      registry: registry || __privateGet(this, _registry),
      runtimeVersion: __privateGet(this, _registry).createType("RuntimeVersionPartial")
    }, fromEmpty);
  }
  _decorateFunctionMeta(input, output2) {
    output2.meta = input.meta;
    output2.method = input.method;
    output2.section = input.section;
    output2.toJSON = input.toJSON;
    if (input.callIndex) {
      output2.callIndex = input.callIndex;
    }
    return output2;
  }
  _filterRpc(methods, additional) {
    if (Object.keys(additional).length !== 0) {
      this._rpcCore.addUserInterfaces(additional);
      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);
      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);
    }
    const sectionMap = {};
    for (let i = 0; i < methods.length; i++) {
      const [section2] = methods[i].split("_");
      sectionMap[section2] = true;
    }
    const sections = Object.keys(sectionMap);
    for (let i = 0; i < sections.length; i++) {
      const nameA = stringUpperFirst(sections[i]);
      const nameB = `${nameA}Api`;
      this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;
      this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;
    }
    this._filterRpcMethods(methods);
  }
  _filterRpcMethods(exposed) {
    const hasResults = exposed.length !== 0;
    const allKnown = [...this._rpcCore.mapping.entries()];
    const allKeys = [];
    for (let i = 0; i < allKnown.length; i++) {
      const [, {
        alias: alias2,
        endpoint,
        method,
        pubsub,
        section: section2
      }] = allKnown[i];
      allKeys.push(`${section2}_${method}`);
      if (pubsub) {
        allKeys.push(`${section2}_${pubsub[1]}`);
        allKeys.push(`${section2}_${pubsub[2]}`);
      }
      if (alias2) {
        allKeys.push(...alias2);
      }
      if (endpoint) {
        allKeys.push(endpoint);
      }
    }
    const filterKey = (k) => !allKeys.includes(k);
    const unknown = exposed.filter(filterKey);
    if (unknown.length && !this._options.noInitWarn) {
      l14.warn(`RPC methods not decorated: ${unknown.join(", ")}`);
    }
    for (let i = 0; i < allKnown.length; i++) {
      const [k, {
        method,
        section: section2
      }] = allKnown[i];
      if (hasResults && !exposed.includes(k) && k !== "rpc_methods") {
        if (this._rpc[section2]) {
          delete this._rpc[section2][method];
          delete this._rx.rpc[section2][method];
        }
      }
    }
  }
  _rpcSubmitter(decorateMethod) {
    const method = (method2, ...params) => {
      return from(this._rpcCore.provider.send(method2, params));
    };
    return decorateMethod(method);
  }
  _decorateRpc(rpc18, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {
    const out = input;
    const decorateFn = (section2, method) => {
      const source = rpc18[section2][method];
      const fn = decorateMethod(source, {
        methodName: method
      });
      fn.meta = source.meta;
      fn.raw = decorateMethod(source.raw, {
        methodName: method
      });
      return fn;
    };
    for (let s = 0; s < rpc18.sections.length; s++) {
      const section2 = rpc18.sections[s];
      if (!Object.prototype.hasOwnProperty.call(out, section2)) {
        const methods = Object.keys(rpc18[section2]);
        const decorateInternal = (method) => decorateFn(section2, method);
        for (let m = 0; m < methods.length; m++) {
          const method = methods[m];
          if (this.hasSubscriptions || !(method.startsWith("subscribe") || method.startsWith("unsubscribe"))) {
            if (!Object.prototype.hasOwnProperty.call(out, section2)) {
              out[section2] = {};
            }
            lazyMethod(out[section2], method, decorateInternal);
          }
        }
      }
    }
    return out;
  }
  _addRuntimeDef(result, additional) {
    if (!additional) {
      return;
    }
    const entries = Object.entries(additional);
    for (let j = 0; j < entries.length; j++) {
      const [key, defs] = entries[j];
      if (result[key]) {
        for (let k = 0; k < defs.length; k++) {
          const def = defs[k];
          const prev = result[key].find(({
            version
          }) => def.version === version);
          if (prev) {
            objectSpread(prev.methods, def.methods);
          } else {
            result[key].push(def);
          }
        }
      } else {
        result[key] = defs;
      }
    }
  }
  _getRuntimeDefs(registry, specName, chain2 = "") {
    const result = {};
    const defValues = Object.values(definitions_exports);
    for (let i = 0; i < defValues.length; i++) {
      this._addRuntimeDef(result, defValues[i].runtime);
    }
    this._addRuntimeDef(result, getSpecRuntime(registry, chain2, specName));
    this._addRuntimeDef(result, this._options.runtime);
    return Object.entries(result);
  }
  _decorateCalls({
    registry,
    runtimeVersion: {
      apis,
      specName,
      specVersion
    }
  }, decorateMethod, blockHash) {
    const result = {};
    const named = {};
    const hashes = {};
    const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);
    const older = [];
    const implName = `${specName.toString()}/${specVersion.toString()}`;
    const hasLogged = __privateGet(this, _runtimeLog)[implName] || false;
    __privateGet(this, _runtimeLog)[implName] = true;
    for (let i = 0; i < sections.length; i++) {
      const [_section3, secs] = sections[i];
      const sectionHash = blake2AsHex(_section3, 64);
      const rtApi = apis.find(([a]) => a.eq(sectionHash));
      hashes[sectionHash] = true;
      if (rtApi) {
        const all3 = secs.map(({
          version
        }) => version).sort();
        const sec = secs.find(({
          version
        }) => rtApi[1].eq(version));
        if (sec) {
          const section2 = stringCamelCase(_section3);
          const methods = Object.entries(sec.methods);
          if (methods.length) {
            if (!named[section2]) {
              named[section2] = {};
            }
            for (let m = 0; m < methods.length; m++) {
              const [_method3, def] = methods[m];
              const method = stringCamelCase(_method3);
              named[section2][method] = objectSpread({
                method,
                name: `${_section3}_${_method3}`,
                section: section2,
                sectionHash
              }, def);
            }
          }
        } else {
          older.push(`${_section3}/${rtApi[1].toString()} (${all3.join("/")} known)`);
        }
      }
    }
    const notFound = apis.map(([a, v]) => [a.toHex(), v.toString()]).filter(([a]) => !hashes[a]).map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);
    if (!this._options.noInitWarn && !hasLogged) {
      if (older.length) {
        l14.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(", ")}`);
      }
      if (notFound.length) {
        l14.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(", ")}`);
      }
    }
    const stateCall = blockHash ? (name, bytes3) => this._rpcCore.state.call(name, bytes3, blockHash) : (name, bytes3) => this._rpcCore.state.call(name, bytes3);
    const lazySection = (section2) => lazyMethods({}, Object.keys(named[section2]), (method) => this._decorateCall(registry, named[section2][method], stateCall, decorateMethod));
    const modules = Object.keys(named);
    for (let i = 0; i < modules.length; i++) {
      lazyMethod(result, modules[i], lazySection);
    }
    return result;
  }
  _decorateCall(registry, def, stateCall, decorateMethod) {
    const decorated = decorateMethod((...args) => {
      if (args.length !== def.params.length) {
        throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);
      }
      const bytes3 = registry.createType("Raw", u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));
      return stateCall(def.name, bytes3).pipe(map2((r) => registry.createTypeUnsafe(def.type, [r])));
    });
    decorated.meta = def;
    return decorated;
  }
  _decorateMulti(decorateMethod) {
    return decorateMethod((keys2) => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys2.map((args) => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])));
  }
  _decorateMultiAt(atApi, decorateMethod, blockHash) {
    return decorateMethod((calls) => this._rpcCore.state.queryStorageAt(calls.map((args) => {
      if (Array.isArray(args)) {
        const {
          creator
        } = getAtQueryFn(atApi, args[0].creator);
        return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];
      }
      return [getAtQueryFn(atApi, args.creator).creator];
    }), blockHash));
  }
  _decorateExtrinsics({
    tx
  }, decorateMethod) {
    const result = createSubmittable(this._type, this._rx, decorateMethod);
    const lazySection = (section2) => lazyMethods({}, Object.keys(tx[section2]), (method) => method.startsWith("$") ? tx[section2][method] : this._decorateExtrinsicEntry(tx[section2][method], result));
    const sections = Object.keys(tx);
    for (let i = 0; i < sections.length; i++) {
      lazyMethod(result, sections[i], lazySection);
    }
    return result;
  }
  _decorateExtrinsicEntry(method, creator) {
    const decorated = (...params) => creator(method(...params));
    decorated.is = (other) => method.is(other);
    return this._decorateFunctionMeta(method, decorated);
  }
  _decorateStorage({
    query: query2,
    registry
  }, decorateMethod, blockHash) {
    const result = {};
    const lazySection = (section2) => lazyMethods({}, Object.keys(query2[section2]), (method) => blockHash ? this._decorateStorageEntryAt(registry, query2[section2][method], decorateMethod, blockHash) : this._decorateStorageEntry(query2[section2][method], decorateMethod));
    const sections = Object.keys(query2);
    for (let i = 0; i < sections.length; i++) {
      lazyMethod(result, sections[i], lazySection);
    }
    return result;
  }
  _decorateStorageEntry(creator, decorateMethod) {
    const getArgs = (args, registry) => extractStorageArgs(registry || __privateGet(this, _registry), creator, args);
    const getQueryAt = (blockHash) => from(this.at(blockHash)).pipe(map2((api) => getAtQueryFn(api, creator)));
    const decorated = this._decorateStorageCall(creator, decorateMethod);
    decorated.creator = creator;
    decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => q(...args))));
    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));
    decorated.is = (key) => key.section === creator.section && key.method === creator.method;
    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);
    decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));
    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));
    decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));
    if (creator.iterKey && creator.meta.type.isMap) {
      decorated.entries = decorateMethod(memo(__privateGet(this, _instanceId2), (...args) => this._retrieveMapEntries(creator, null, args)));
      decorated.entriesAt = decorateMethod(memo(__privateGet(this, _instanceId2), (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapEntries(q.creator, blockHash, args)))));
      decorated.entriesPaged = decorateMethod(memo(__privateGet(this, _instanceId2), (opts) => this._retrieveMapEntriesPaged(creator, void 0, opts)));
      decorated.keys = decorateMethod(memo(__privateGet(this, _instanceId2), (...args) => this._retrieveMapKeys(creator, null, args)));
      decorated.keysAt = decorateMethod(memo(__privateGet(this, _instanceId2), (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapKeys(q.creator, blockHash, args)))));
      decorated.keysPaged = decorateMethod(memo(__privateGet(this, _instanceId2), (opts) => this._retrieveMapKeysPaged(creator, void 0, opts)));
    }
    if (this.supportMulti && creator.meta.type.isMap) {
      decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a) => [creator, [a]])) : this._retrieveMulti(args.map((a) => [creator, a])));
    }
    return this._decorateFunctionMeta(creator, decorated);
  }
  _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {
    const getArgs = (args) => extractStorageArgs(registry, creator, args);
    const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));
    decorated.creator = creator;
    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));
    decorated.is = (key) => key.section === creator.section && key.method === creator.method;
    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);
    decorated.keyPrefix = (...keys2) => u8aToHex(creator.keyPrefix(...keys2));
    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));
    if (creator.iterKey && creator.meta.type.isMap) {
      decorated.entries = decorateMethod(memo(__privateGet(this, _instanceId2), (...args) => this._retrieveMapEntries(creator, blockHash, args)));
      decorated.entriesPaged = decorateMethod(memo(__privateGet(this, _instanceId2), (opts) => this._retrieveMapEntriesPaged(creator, blockHash, opts)));
      decorated.keys = decorateMethod(memo(__privateGet(this, _instanceId2), (...args) => this._retrieveMapKeys(creator, blockHash, args)));
      decorated.keysPaged = decorateMethod(memo(__privateGet(this, _instanceId2), (opts) => this._retrieveMapKeysPaged(creator, blockHash, opts)));
    }
    if (this.supportMulti && creator.meta.type.isMap) {
      decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a) => [creator, [a]]), blockHash) : this._retrieveMulti(args.map((a) => [creator, a]), blockHash));
    }
    return this._decorateFunctionMeta(creator, decorated);
  }
  _queueStorage(call, queue2) {
    const query2 = queue2 === __privateGet(this, _storageSubQ) ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
    let queueIdx = queue2.length - 1;
    let valueIdx = 0;
    let valueObs;
    if (queueIdx === -1 || !queue2[queueIdx] || queue2[queueIdx][1].length === PAGE_SIZE_Q) {
      queueIdx++;
      valueObs = from(new Promise((resolve) => {
        nextTick(() => {
          const calls = queue2[queueIdx][1];
          delete queue2[queueIdx];
          resolve(calls);
        });
      })).pipe(switchMap((calls) => query2(calls)));
      queue2.push([valueObs, [call]]);
    } else {
      valueObs = queue2[queueIdx][0];
      valueIdx = queue2[queueIdx][1].length;
      queue2[queueIdx][1].push(call);
    }
    return valueObs.pipe(map2((values) => values[valueIdx]));
  }
  _decorateStorageCall(creator, decorateMethod) {
    return decorateMethod((...args) => {
      const call = extractStorageArgs(__privateGet(this, _registry), creator, args);
      if (!this.hasSubscriptions) {
        return this._rpcCore.state.getStorage(call);
      }
      return this._queueStorage(call, __privateGet(this, _storageSubQ));
    }, {
      methodName: creator.method,
      overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(__privateGet(this, _registry), creator, args), __privateGet(this, _storageGetQ))
    });
  }
  _retrieveMulti(keys2, blockHash) {
    if (!keys2.length) {
      return of([]);
    }
    const query2 = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
    if (keys2.length <= PAGE_SIZE_V) {
      return blockHash ? query2(keys2, blockHash) : query2(keys2);
    }
    return combineLatest(arrayChunk(keys2, PAGE_SIZE_V).map((k) => blockHash ? query2(k, blockHash) : query2(k))).pipe(map2(arrayFlatten));
  }
  _retrieveMapKeys({
    iterKey,
    meta,
    method,
    section: section2
  }, at, args) {
    if (!iterKey || !meta.type.isMap) {
      throw new Error("keys can only be retrieved on maps");
    }
    const headKey = iterKey(...args).toHex();
    const startSubject = new BehaviorSubject(headKey);
    const query2 = at ? (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K2, startKey, at) : (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K2, startKey);
    const setMeta = (key) => key.setMeta(meta, section2, method);
    return startSubject.pipe(switchMap(query2), map2((keys2) => keys2.map(setMeta)), tap((keys2) => nextTick(() => {
      keys2.length === PAGE_SIZE_K2 ? startSubject.next(keys2[PAGE_SIZE_K2 - 1].toHex()) : startSubject.complete();
    })), toArray(), map2(arrayFlatten));
  }
  _retrieveMapKeysPaged({
    iterKey,
    meta,
    method,
    section: section2
  }, at, opts) {
    if (!iterKey || !meta.type.isMap) {
      throw new Error("keys can only be retrieved on maps");
    }
    const setMeta = (key) => key.setMeta(meta, section2, method);
    const query2 = at ? (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);
    return query2(iterKey(...opts.args).toHex()).pipe(map2((keys2) => keys2.map(setMeta)));
  }
  _retrieveMapEntries(entry, at, args) {
    const query2 = at ? (keys2) => this._rpcCore.state.queryStorageAt(keys2, at) : (keys2) => this._rpcCore.state.queryStorageAt(keys2);
    return this._retrieveMapKeys(entry, at, args).pipe(switchMap((keys2) => keys2.length ? combineLatest(arrayChunk(keys2, PAGE_SIZE_V).map(query2)).pipe(map2((valsArr) => arrayFlatten(valsArr).map((value, index) => [keys2[index], value]))) : of([])));
  }
  _retrieveMapEntriesPaged(entry, at, opts) {
    const query2 = at ? (keys2) => this._rpcCore.state.queryStorageAt(keys2, at) : (keys2) => this._rpcCore.state.queryStorageAt(keys2);
    return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap((keys2) => keys2.length ? query2(keys2).pipe(map2((valsArr) => valsArr.map((value, index) => [keys2[index], value]))) : of([])));
  }
  _decorateDeriveRx(decorateMethod) {
    var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;
    const specName = (_this$_runtimeVersion = this._runtimeVersion) == null ? void 0 : _this$_runtimeVersion.specName.toString();
    const available = getAvailableDerives(__privateGet(this, _instanceId2), this._rx, objectSpread({}, this._options.derives, (_this$_options$typesB = this._options.typesBundle) == null ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) == null ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName || ""]) == null ? void 0 : _this$_options$typesB3.derives));
    return decorateDeriveSections(decorateMethod, available);
  }
  _decorateDerive(decorateMethod) {
    return decorateDeriveSections(decorateMethod, this._rx.derive);
  }
};
_instanceId2 = new WeakMap();
_registry = new WeakMap();
_runtimeLog = new WeakMap();
_storageGetQ = new WeakMap();
_storageSubQ = new WeakMap();

// node_modules/@polkadot/api/base/Init.js
var KEEPALIVE_INTERVAL = 1e4;
var WITH_VERSION_SHORTCUT = false;
var l15 = logger("api/init");
function textToString(t) {
  return t.toString();
}
var _atLast = _classPrivateFieldKey("atLast");
var _healthTimer = _classPrivateFieldKey("healthTimer");
var _registries = _classPrivateFieldKey("registries");
var _updateSub = _classPrivateFieldKey("updateSub");
var _waitingRegistries = _classPrivateFieldKey("waitingRegistries");
var _onProviderConnect = _classPrivateFieldKey("onProviderConnect");
var _onProviderDisconnect = _classPrivateFieldKey("onProviderDisconnect");
var _onProviderError = _classPrivateFieldKey("onProviderError");
var Init = class extends Decorate {
  constructor(options, type, decorateMethod) {
    super(options, type, decorateMethod);
    Object.defineProperty(this, _onProviderError, {
      value: _onProviderError2
    });
    Object.defineProperty(this, _onProviderDisconnect, {
      value: _onProviderDisconnect2
    });
    Object.defineProperty(this, _onProviderConnect, {
      value: _onProviderConnect2
    });
    Object.defineProperty(this, _atLast, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _healthTimer, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _registries, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _updateSub, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _waitingRegistries, {
      writable: true,
      value: {}
    });
    this.registry.setKnownTypes(options);
    if (!options.source) {
      this.registerTypes(options.types);
    } else {
      _classPrivateFieldBase(this, _registries)[_registries] = _classPrivateFieldBase(options.source, _registries)[_registries];
    }
    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);
    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);
    if (this.supportMulti) {
      this._queryMulti = this._decorateMulti(this._decorateMethod);
      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);
    }
    this._rx.signer = options.signer;
    this._rpcCore.setRegistrySwap((blockHash) => this.getBlockRegistry(blockHash));
    this._rpcCore.setResolveBlockHash((blockNumber) => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));
    if (this.hasSubscriptions) {
      this._rpcCore.provider.on("disconnected", () => _classPrivateFieldBase(this, _onProviderDisconnect)[_onProviderDisconnect]());
      this._rpcCore.provider.on("error", (e) => _classPrivateFieldBase(this, _onProviderError)[_onProviderError](e));
      this._rpcCore.provider.on("connected", () => _classPrivateFieldBase(this, _onProviderConnect)[_onProviderConnect]());
    } else if (!this._options.noInitWarn) {
      l15.warn("Api will be available in a limited mode since the provider does not support subscriptions");
    }
    if (this._rpcCore.provider.isConnected) {
      _classPrivateFieldBase(this, _onProviderConnect)[_onProviderConnect]();
    }
  }
  _initRegistry(registry, chain2, version, metadata, chainProps) {
    registry.clearCache();
    registry.setChainProperties(chainProps || this.registry.getChainProperties());
    registry.setKnownTypes(this._options);
    registry.register(getSpecTypes(registry, chain2, version.specName, version.specVersion));
    registry.setHasher(getSpecHasher(registry, chain2, version.specName));
    if (registry.knownTypes.typesBundle) {
      registry.knownTypes.typesAlias = getSpecAlias(registry, chain2, version.specName);
    }
    registry.setMetadata(metadata, void 0, objectSpread({}, getSpecExtensions(registry, chain2, version.specName), this._options.signedExtensions));
  }
  _getDefaultRegistry() {
    return assertReturn(_classPrivateFieldBase(this, _registries)[_registries].find(({
      isDefault
    }) => isDefault), "Initialization error, cannot find the default registry");
  }
  async at(blockHash, knownVersion) {
    const u8aHash = u8aToU8a(blockHash);
    const u8aHex = u8aToHex(u8aHash);
    const registry = await this.getBlockRegistry(u8aHash, knownVersion);
    if (!_classPrivateFieldBase(this, _atLast)[_atLast] || _classPrivateFieldBase(this, _atLast)[_atLast][0] !== u8aHex) {
      _classPrivateFieldBase(this, _atLast)[_atLast] = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];
    }
    return _classPrivateFieldBase(this, _atLast)[_atLast][1];
  }
  async _createBlockRegistry(blockHash, header, version) {
    const registry = new TypeRegistry(blockHash);
    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));
    this._initRegistry(registry, this._runtimeChain, version, metadata);
    const result = {
      counter: 0,
      lastBlockHash: blockHash,
      metadata,
      registry,
      runtimeVersion: version
    };
    _classPrivateFieldBase(this, _registries)[_registries].push(result);
    return result;
  }
  _cacheBlockRegistryProgress(key, creator) {
    let waiting = _classPrivateFieldBase(this, _waitingRegistries)[_waitingRegistries][key];
    if (isUndefined(waiting)) {
      waiting = _classPrivateFieldBase(this, _waitingRegistries)[_waitingRegistries][key] = new Promise((resolve, reject) => {
        creator().then((registry) => {
          delete _classPrivateFieldBase(this, _waitingRegistries)[_waitingRegistries][key];
          resolve(registry);
        }).catch((error) => {
          delete _classPrivateFieldBase(this, _waitingRegistries)[_waitingRegistries][key];
          reject(error);
        });
      });
    }
    return waiting;
  }
  _getBlockRegistryViaVersion(blockHash, version) {
    if (version) {
      const existingViaVersion = _classPrivateFieldBase(this, _registries)[_registries].find(({
        runtimeVersion: {
          specName,
          specVersion
        }
      }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));
      if (existingViaVersion) {
        existingViaVersion.counter++;
        existingViaVersion.lastBlockHash = blockHash;
        return existingViaVersion;
      }
    }
    return null;
  }
  async _getBlockRegistryViaHash(blockHash) {
    if (!this._genesisHash || !this._runtimeVersion) {
      throw new Error("Cannot retrieve data on an uninitialized chain");
    }
    const header = this.registry.createType("HeaderPartial", this._genesisHash.eq(blockHash) ? {
      number: BN_ZERO,
      parentHash: this._genesisHash
    } : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));
    if (header.parentHash.isEmpty) {
      throw new Error("Unable to retrieve header and parent from supplied hash");
    }
    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);
    const version = this.registry.createType("RuntimeVersionPartial", WITH_VERSION_SHORTCUT && firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {
      apis: firstVersion.apis,
      specName: this._runtimeVersion.specName,
      specVersion: firstVersion.specVersion
    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));
    return this._getBlockRegistryViaVersion(blockHash, version) || await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version));
  }
  async getBlockRegistry(blockHash, knownVersion) {
    return _classPrivateFieldBase(this, _registries)[_registries].find(({
      lastBlockHash
    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) || this._getBlockRegistryViaVersion(blockHash, knownVersion) || await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash));
  }
  async _loadMeta() {
    var _this$_options$source;
    if (this._isReady) {
      return true;
    }
    this._unsubscribeUpdates();
    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) != null && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);
    return this._initFromMeta(this._runtimeMetadata);
  }
  async _metaFromSource(source) {
    this._extrinsicType = source.extrinsicVersion;
    this._runtimeChain = source.runtimeChain;
    this._runtimeVersion = source.runtimeVersion;
    const sections = Object.keys(source.rpc);
    const rpcs = [];
    for (let s = 0; s < sections.length; s++) {
      const section2 = sections[s];
      const methods = Object.keys(source.rpc[section2]);
      for (let m = 0; m < methods.length; m++) {
        rpcs.push(`${section2}_${methods[m]}`);
      }
    }
    this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));
    return [source.genesisHash, source.runtimeMetadata];
  }
  _subscribeUpdates() {
    if (_classPrivateFieldBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {
      return;
    }
    _classPrivateFieldBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap((version) => {
      var _this$_runtimeVersion;
      return (_this$_runtimeVersion = this._runtimeVersion) != null && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map2((metadata) => {
        l15.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);
        this._runtimeMetadata = metadata;
        this._runtimeVersion = version;
        this._rx.runtimeVersion = version;
        const thisRegistry = this._getDefaultRegistry();
        thisRegistry.metadata = metadata;
        thisRegistry.runtimeVersion = version;
        this._initRegistry(this.registry, this._runtimeChain, version, metadata);
        this._injectMetadata(thisRegistry, true);
        return true;
      }));
    })).subscribe();
  }
  async _metaFromChain(optMetadata) {
    const [genesisHash, runtimeVersion, chain2, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]);
    this._runtimeChain = chain2;
    this._runtimeVersion = runtimeVersion;
    this._rx.runtimeVersion = runtimeVersion;
    const metadataKey = `${genesisHash.toHex() || "0x"}-${runtimeVersion.specVersion.toString()}`;
    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata()));
    this._initRegistry(this.registry, chain2, runtimeVersion, metadata, chainProps);
    this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain2, runtimeVersion.specName));
    this._subscribeUpdates();
    if (!_classPrivateFieldBase(this, _registries)[_registries].length) {
      _classPrivateFieldBase(this, _registries)[_registries].push({
        counter: 0,
        isDefault: true,
        metadata,
        registry: this.registry,
        runtimeVersion
      });
    }
    metadata.getUniqTypes(this._options.throwOnUnknown || false);
    return [genesisHash, metadata];
  }
  _initFromMeta(metadata) {
    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();
    this._rx.extrinsicType = this._extrinsicType;
    this._rx.genesisHash = this._genesisHash;
    this._rx.runtimeVersion = this._runtimeVersion;
    this._injectMetadata(this._getDefaultRegistry(), true);
    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);
    this._derive = this._decorateDerive(this._decorateMethod);
    return true;
  }
  _subscribeHealth() {
    _classPrivateFieldBase(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(() => {
      firstValueFrom(this._rpcCore.system.health.raw()).catch(() => void 0);
    }, KEEPALIVE_INTERVAL) : null;
  }
  _unsubscribeHealth() {
    if (_classPrivateFieldBase(this, _healthTimer)[_healthTimer]) {
      clearInterval(_classPrivateFieldBase(this, _healthTimer)[_healthTimer]);
      _classPrivateFieldBase(this, _healthTimer)[_healthTimer] = null;
    }
  }
  _unsubscribeUpdates() {
    if (_classPrivateFieldBase(this, _updateSub)[_updateSub]) {
      _classPrivateFieldBase(this, _updateSub)[_updateSub].unsubscribe();
      _classPrivateFieldBase(this, _updateSub)[_updateSub] = null;
    }
  }
  _unsubscribe() {
    this._unsubscribeHealth();
    this._unsubscribeUpdates();
  }
};
async function _onProviderConnect2() {
  this._isConnected.next(true);
  this.emit("connected");
  try {
    const cryptoReady = this._options.initWasm === false ? true : await cryptoWaitReady();
    const hasMeta = await this._loadMeta();
    this._subscribeHealth();
    if (hasMeta && !this._isReady && cryptoReady) {
      this._isReady = true;
      this.emit("ready", this);
    }
  } catch (_error) {
    const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);
    l15.error(error);
    this.emit("error", error);
  }
}
function _onProviderDisconnect2() {
  this._isConnected.next(false);
  this._unsubscribeHealth();
  this.emit("disconnected");
}
function _onProviderError2(error) {
  this.emit("error", error);
}

// node_modules/@polkadot/api/base/Getters.js
function assertResult(value) {
  if (value === void 0) {
    throw new Error("Api interfaces needs to be initialized before using, wait for 'isReady'");
  }
  return value;
}
var Getters = class extends Init {
  get call() {
    return assertResult(this._call);
  }
  get consts() {
    return assertResult(this._consts);
  }
  get derive() {
    return assertResult(this._derive);
  }
  get errors() {
    return assertResult(this._errors);
  }
  get events() {
    return assertResult(this._events);
  }
  get extrinsicVersion() {
    return this._extrinsicType;
  }
  get genesisHash() {
    return assertResult(this._genesisHash);
  }
  get isConnected() {
    return this._isConnected.getValue();
  }
  get libraryInfo() {
    return `${packageInfo11.name} v${packageInfo11.version}`;
  }
  get query() {
    return assertResult(this._query);
  }
  get queryMulti() {
    return assertResult(this._queryMulti);
  }
  get rpc() {
    return assertResult(this._rpc);
  }
  get runtimeChain() {
    return assertResult(this._runtimeChain);
  }
  get runtimeMetadata() {
    return assertResult(this._runtimeMetadata);
  }
  get runtimeVersion() {
    return assertResult(this._runtimeVersion);
  }
  get rx() {
    return assertResult(this._rx);
  }
  get stats() {
    return this._rpcCore.provider.stats;
  }
  get type() {
    return this._type;
  }
  get tx() {
    return assertResult(this._extrinsics);
  }
  findCall(callIndex) {
    return findCall(this.registry, callIndex);
  }
  findError(errorIndex) {
    return findError(this.registry, errorIndex);
  }
};

// node_modules/@polkadot/api/base/index.js
var ApiBase = class extends Getters {
  constructor(options = {}, type, decorateMethod) {
    super(options, type, decorateMethod);
  }
  connect() {
    return this._rpcCore.connect();
  }
  disconnect() {
    this._unsubscribe();
    return this._rpcCore.disconnect();
  }
  setSigner(signer) {
    this._rx.signer = signer;
  }
  async sign(address, data, {
    signer
  } = {}) {
    if (isString(address)) {
      const _signer = signer || this._rx.signer;
      if (!_signer || !_signer.signRaw) {
        throw new Error("No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.");
      }
      return (await _signer.signRaw(objectSpread({
        type: "bytes"
      }, data, {
        address
      }))).signature;
    }
    return u8aToHex(address.sign(u8aToU8a(data.data)));
  }
};

// node_modules/@polkadot/api/promise/Combinator.js
var _allHasFired, _callback, _fired, _fns, _isActive, _results, _subscriptions3;
var Combinator = class {
  constructor(fns, callback) {
    __privateAdd(this, _allHasFired, false);
    __privateAdd(this, _callback, void 0);
    __privateAdd(this, _fired, []);
    __privateAdd(this, _fns, []);
    __privateAdd(this, _isActive, true);
    __privateAdd(this, _results, []);
    __privateAdd(this, _subscriptions3, []);
    __privateSet(this, _callback, callback);
    __privateSet(this, _subscriptions3, fns.map(async (input, index) => {
      const [fn, ...args] = Array.isArray(input) ? input : [input];
      __privateGet(this, _fired).push(false);
      __privateGet(this, _fns).push(fn);
      return fn(...args, this._createCallback(index));
    }));
  }
  _allHasFired() {
    __privateGet(this, _allHasFired) || __privateSet(this, _allHasFired, __privateGet(this, _fired).filter((hasFired) => !hasFired).length === 0);
    return __privateGet(this, _allHasFired);
  }
  _createCallback(index) {
    return (value) => {
      __privateGet(this, _fired)[index] = true;
      __privateGet(this, _results)[index] = value;
      this._triggerUpdate();
    };
  }
  _triggerUpdate() {
    if (!__privateGet(this, _isActive) || !isFunction(__privateGet(this, _callback)) || !this._allHasFired()) {
      return;
    }
    try {
      __privateGet(this, _callback).call(this, __privateGet(this, _results));
    } catch (error) {
    }
  }
  unsubscribe() {
    if (!__privateGet(this, _isActive)) {
      return;
    }
    __privateSet(this, _isActive, false);
    __privateGet(this, _subscriptions3).forEach(async (subscription) => {
      try {
        const unsubscribe = await subscription;
        if (isFunction(unsubscribe)) {
          unsubscribe();
        }
      } catch (error) {
      }
    });
  }
};
_allHasFired = new WeakMap();
_callback = new WeakMap();
_fired = new WeakMap();
_fns = new WeakMap();
_isActive = new WeakMap();
_results = new WeakMap();
_subscriptions3 = new WeakMap();

// node_modules/@polkadot/api/promise/decorateMethod.js
function promiseTracker(resolve, reject) {
  let isCompleted = false;
  return {
    reject: (error) => {
      if (!isCompleted) {
        isCompleted = true;
        reject(error);
      }
      return EMPTY;
    },
    resolve: (value) => {
      if (!isCompleted) {
        isCompleted = true;
        resolve(value);
      }
    }
  };
}
function extractArgs(args, needsCallback) {
  const actualArgs = args.slice();
  const callback = args.length && isFunction(args[args.length - 1]) ? actualArgs.pop() : void 0;
  if (needsCallback && !isFunction(callback)) {
    throw new Error("Expected a callback to be passed with subscriptions");
  }
  return [actualArgs, callback];
}
function decorateCall(method, args) {
  return new Promise((resolve, reject) => {
    const tracker = promiseTracker(resolve, reject);
    const subscription = method(...args).pipe(catchError((error) => tracker.reject(error))).subscribe((result) => {
      tracker.resolve(result);
      nextTick(() => subscription.unsubscribe());
    });
  });
}
function decorateSubscribe(method, args, resultCb) {
  return new Promise((resolve, reject) => {
    const tracker = promiseTracker(resolve, reject);
    const subscription = method(...args).pipe(catchError((error) => tracker.reject(error)), tap(() => tracker.resolve(() => subscription.unsubscribe()))).subscribe((result) => {
      nextTick(() => resultCb(result));
    });
  });
}
function toPromiseMethod(method, options) {
  const needsCallback = !!(options && options.methodName && options.methodName.includes("subscribe"));
  return function(...args) {
    const [actualArgs, resultCb] = extractArgs(args, needsCallback);
    return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall((options == null ? void 0 : options.overrideNoSub) || method, actualArgs);
  };
}

// node_modules/@polkadot/api/promise/Api.js
var _isReadyPromise2, _isReadyOrErrorPromise;
var _ApiPromise = class extends ApiBase {
  constructor(options) {
    super(options, "promise", toPromiseMethod);
    __privateAdd(this, _isReadyPromise2, void 0);
    __privateAdd(this, _isReadyOrErrorPromise, void 0);
    __privateSet(this, _isReadyPromise2, new Promise((resolve) => {
      super.once("ready", () => resolve(this));
    }));
    __privateSet(this, _isReadyOrErrorPromise, new Promise((resolve, reject) => {
      const tracker = promiseTracker(resolve, reject);
      super.once("ready", () => tracker.resolve(this));
      super.once("error", (error) => tracker.reject(error));
    }));
  }
  static create(options) {
    const instance = new _ApiPromise(options);
    if (options && options.throwOnConnect) {
      return instance.isReadyOrError;
    }
    instance.isReadyOrError.catch(() => {
    });
    return instance.isReady;
  }
  get isReady() {
    return __privateGet(this, _isReadyPromise2);
  }
  get isReadyOrError() {
    return __privateGet(this, _isReadyOrErrorPromise);
  }
  clone() {
    return new _ApiPromise(objectSpread({}, this._options, {
      source: this
    }));
  }
  async combineLatest(fns, callback) {
    const combinator = new Combinator(fns, callback);
    return () => {
      combinator.unsubscribe();
    };
  }
};
var ApiPromise = _ApiPromise;
_isReadyPromise2 = new WeakMap();
_isReadyOrErrorPromise = new WeakMap();

// node_modules/@polkadot/api/rx/decorateMethod.js
function toRxMethod(method) {
  return method;
}

// node_modules/@polkadot/api/rx/Api.js
var _isReadyRx;
var _ApiRx = class extends ApiBase {
  constructor(options) {
    super(options, "rxjs", toRxMethod);
    __privateAdd(this, _isReadyRx, void 0);
    __privateSet(this, _isReadyRx, from(new Promise((resolve) => {
      super.on("ready", () => resolve(this));
    })));
  }
  static create(options) {
    return new _ApiRx(options).isReady;
  }
  get isReady() {
    return __privateGet(this, _isReadyRx);
  }
  clone() {
    return new _ApiRx(objectSpread({}, this._options, {
      source: this
    }));
  }
};
var ApiRx = _ApiRx;
_isReadyRx = new WeakMap();
export {
  ApiPromise,
  ApiRx,
  HttpProvider,
  Keyring,
  ScProvider,
  SubmittableResult,
  WsProvider,
  packageInfo11 as packageInfo,
  toPromiseMethod,
  toRxMethod
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=@polkadot_api.js.map
